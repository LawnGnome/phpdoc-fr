 <chapter id="features.persistent-connections">
  <title>Connexions persistantes aux bases de donn&eacute;es</title>

  <simpara>
    Les connexions persistantes aux bases de donn&eacute;es SQL sont
    des connexions qui ne se referment pas &agrave; la fin du script.
    Lorsqu'une connexion persistante est demand&eacute;e, PHP s'assure
    qu'il n'y a pas une autre connexion identique (qui serait ouverte
    pr&eacute;c&eacute;demment, avec le m&ecirc;me nom d'h&ocirc;te, 
    d'utilisateur et de mot de passe), et si une telle connexion existe,
    elle est utilis&eacute;e. Sinon, elle est cr&eacute;&eacute;e. Une 
    connexion identique est une connexion qui a ouvert le m&ecirc;me 
    h&ocirc;te, avec le m&ecirc;me nom et m&ecirc;me mot de passe (si
    ils sont n&eacute;cessaires).
  </simpara>
  <simpara>
    Ceux qui ne sont pas habitu&eacute;s aux techniques des serveurs
    web et leur distribution de la charge de travail, se font parfois
    une fausse id&eacute;e de ces connexions persistantes. En particulier,
    cela ne permet par l'ouverture de plusieurs sessions avec le m&ecirc;me
    lien, cela ne permet pas la r&eacute;alisation de transactions efficaces,
    et cela ne fait pas le caf&eacute;. En fait, pour &ecirc;tre 
    extr&ecirc;mement clair sur le sujet, les connexions persistantes
    ne vous donnent aucune fonctionnalit&eacute; de plus que les 
    connexions non persistantes.
  </simpara>
  <simpara>
   Alors pourquoi?
  </simpara> 
  <simpara>
    Cela s'explique par la mani&egrave;re avec laquelle les serveurs web
    fonctionnent. Il y a trois mani&egrave;res d'utiliser PHP pour 
    g&eacute;n&eacute;rer des pages.
  </simpara>
  <simpara>
    La premi&egrave;re est d'utiliser PHP comme un CGI (Common Interface Gateway). 
    Lorsque PHP fonctionne de cette mani&egrave;re, une instance de 
    l'interpr&eacute;teur PHP est cr&eacute;&eacute;e puis d&eacute;truit
    pour chaque page demand&eacute;e. Etant donn&eacute; qu'il est 
    d&eacute;truit apr&egrave;s chaque requ&ecirc;te, toutes les 
    ressources acquises (comme une connexion &agrave; une base SQL), 
    sont purement et simplement d&eacute;truites.
  </simpara>

  <simpara>
    La deuxi&egrave;me m&eacute;thode, et de loin, la plus pris&eacute;e,
    est d'ex&eacute;cuter PHP sous la forme d'un module sur un serveur 
    multi-process, ce qui revient &agrave; dire : Apache. Un tel serveur
    a typiquement un processus parent qui coordonne un ensemble de processus fils,
    qui servent les fichiers. Lorsque les requ&ecirc;tes parviennent depuis 
    un client, elles sont transmises &agrave; un fils disponible. Cela signifie
    que si un client fait une deuxi&egrave;me requ&ecirc;te, il peut 
    &ecirc;tre servi par un processus client diff&eacute;rent du premier.
    Les connexions persistantes vous permettent alors de ne vous connecter
    &agrave; une base SQL que la premi&egrave;re fois. Lors des connexions
    ult&eacute;rieures, les processus fils pourront r&eacute;utiliser la 
    connexion ouverte pr&eacute;c&eacute;demment.
   </simpara>

  <simpara>
   La derni&egrave;re m&eacute;thode est d'utiliser PHP sous la forme d'un
   module. Pour un serveur multi-thread, actuellement, c'est purement 
   th&eacute;orique, car PHP ne fonctionne par encore sous cette forme.
   Le d&eacute;veloppement est en cours pour supporter ISAPI, WSAPI, et
   NSAPI (sous Windows), qui permettront d'utiliser PHP comme un module pour 
   des serveurs tels que Netscape FastTrack, Microsoft's Internet Information
   Server (IIS), et O'Reilly's WebSite Pro. Lorsque cela sera fait, le 
   comportement sera le m&ecirc;me que pour les serveur multi-process.
  </simpara>

  <simpara>
    Si les connexions persistantes n'ont aucune fonctionnalit&eacute; de plus, 
    &agrave; quoi servent-elles?
  </simpara>

  <simpara>
   La r&eacute;ponse est extr&ecirc;mement simple : efficacit&eacute;. Les 
   connexions persistantes sont un bon moyen d'acc&eacute;l&eacute;rer les
   acc&egrave;s &agrave; une base SQL si le traitement de connexion &agrave;
   la base est long. Ce temps d&eacute;pend de nombreux facteurs : le type 
   de base de donn&eacute;es, cette base est-elle sur le m&ecirc;me serveur
   ou pas, quelle est la charge du serveur de base de donn&eacute;es, etc...
   Si le temps de connexion est long, les connexions persistantes seront 
   bien utiles, car une fois ouverte par un processus fils, la connexion est 
   r&eacute;utilisable sans avoir &agrave; se reconnecter. Si vous avez 20 
   processus fils, il suffit d'avoir 20 connexions persistantes ouvertes, 
   une par fils.
  </simpara>
  <simpara>
   Notez que les connexions persistantes ont quelques inconv&eacute;nients
   si vous h&eacute;bergez une base de donn&eacute;es, dont le nombre maximal de
   connexion risque d'&ecirc;tre atteint par les connexions persistantes.
   Si votre base de donn&eacute;es accepte jusqu'&agrave; 16 connections simultan&eacute;es
   et que, 17 processus essaient de se connecte, le dernier restera
   sur la touche. Si il y a des erreurs dans les scripts qui ne permettent
   pas de fermer la connexion (par exemple, une boucle infinie), votre
   serveur sera rapidement engorg&eacute;. V&eacute;rifier la documentation de votre
   base de donn&eacute;es pour savoir comment elle traite les connexions 
   inactives ou abandonn&eacute;es.
   </simpara>
   <simpara>
    R&eacute;sumons nous : les connexions persistantes ont &eacute;t&eacute;
    d&eacute;finies pour avoir les m&ecirc;mes fonctionnalit&eacute;s que 
    les connexions non persistantes. Les deux types de connexions 
    sont parfaitement interchangeables, et n'affecteront pas le 
    comportement de votre script : uniquement son efficacit&eacute;.
  </simpara>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
