<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.8 $ -->
 <chapter id="features.persistent-connections">
  <title>Connexions persistantes aux bases de donn&eacute;es</title>
  <simpara>
    Les connexions persistantes aux bases de donn&eacute;es SQL sont
    des connexions qui ne se referment pas &agrave; la fin du script.
    Lorsqu'une connexion persistante est demand&eacute;e, PHP s'assure
    qu'il n'y a pas une autre connexion identique (qui serait ouverte
    pr&eacute;c&eacute;demment, avec le m&ecirc;me nom d'h&ocirc;te,
    d'utilisateur et le m&ecirc;me mot de passe), et si une telle connexion
    existe, elle est utilis&eacute;e. Sinon, elle est cr&eacute;&eacute;e.
    Une connexion identique est une connexion qui a ouvert le m&ecirc;me
    h&ocirc;te, avec le m&ecirc;me nom et le m&ecirc;me mot de passe (s'ils
    sont n&eacute;cessaires).
  </simpara>
  <simpara>
    Ceux qui ne sont pas rompus aux techniques des serveurs web et leur
    distribution de la charge de travail, se font parfois une fausse
    id&eacute;e de ces connexions persistantes. En particulier,
    les connexions persistantes ne permettent pas l'ouverture de plusieurs
    sessions avec le m&ecirc;me lien, ne permettent pas la r&eacute;alisation
    de transactions efficaces et ne font pas le caf&eacute;. En fait,
    pour &ecirc;tre extr&ecirc;mement clair sur le sujet, les
    connexions persistantes ne vous donnent aucune fonctionnalit&eacute;
    de plus que les connexions non persistantes.
  </simpara>
  <simpara>
   Alors pourquoi les connexions persistantes?
  </simpara>
  <simpara>
    Cela s'explique par la mani&egrave;re avec laquelle les serveurs web
    fonctionnent. Il y a trois mani&egrave;res d'utiliser PHP pour
    g&eacute;n&eacute;rer des pages.
  </simpara>
  <simpara>
    La premi&egrave;re est d'utiliser PHP comme un CGI (Common Interface Gateway).
    Lorsque PHP fonctionne de cette mani&egrave;re, une instance de
    l'interpr&eacute;teur PHP est cr&eacute;&eacute;e puis d&eacute;truite
    pour chaque page demand&eacute;e. Etant donn&eacute; que cet interpreteur est
    d&eacute;truit apr&egrave;s chaque requ&ecirc;te, toutes les
    ressources acquises (comme une connexion &agrave; une base SQL),
    sont purement et simplement d&eacute;truites.
  </simpara>
  <simpara>
    La deuxi&egrave;me m&eacute;thode, et de loin, la plus pris&eacute;e,
    est d'ex&eacute;cuter PHP sous la forme d'un module sur un serveur
    multi-processus, ce qui revient &agrave; dire : Apache. Un tel serveur
    a typiquement un processus parent qui coordonne un ensemble de processus fils,
    qui servent les fichiers. Lorsque les requ&ecirc;tes parviennent depuis
    un client, elles sont transmises &agrave; un fils disponible. Cela signifie
    que si un client fait une deuxi&egrave;me requ&ecirc;te, il peut
    &ecirc;tre servi par un processus client diff&eacute;rent du premier.
    Les connexions persistantes vous permettent alors de ne vous connecter
    &agrave; une base SQL que la premi&egrave;re fois. Lors des connexions
    ult&eacute;rieures, les processus fils pourront r&eacute;utiliser la
    connexion ouverte pr&eacute;c&eacute;demment.
   </simpara>
  <simpara>
   La derni&egrave;re m&eacute;thode est d'utiliser PHP sous la forme d'un
   module de serveur multi-threads. Actuellement, PHP 4 supporte
   ISAPI, WSAPI, et NSAPI (sous Windows), qui permettent tous d'utiliser
   PHP comme un module sur un serveur multi-threads tel que Netscape
   FastTrack (iPlanet), Microsoft's Internet Information Server (IIS), et
   O'Reilly's WebSite Pro. Le comportement est essentiellement le m&ecirc;me
   que pour les serveurs multi-processus d&eacute;crits pr&eacute;c&eacute;demment.
   Notez que SAPI n'est pas disponible avec PHP 3.
  </simpara>
  <simpara>
   Si les connexions persistantes n'ont aucune fonctionnalit&eacute; de plus,
   &agrave; quoi servent-elles?
  </simpara>
  <simpara>
   La r&eacute;ponse est extr&ecirc;mement simple : efficacit&eacute;. Les
   connexions persistantes sont un bon moyen d'acc&eacute;l&eacute;rer les
   acc&egrave;s &agrave; une base SQL si le traitement de connexion &agrave;
   la base est long. Ce temps d&eacute;pend de nombreux facteurs : le type
   de base de donn&eacute;es, cette base est-elle sur le m&ecirc;me serveur
   ou pas, quelle est la charge du serveur de base de donn&eacute;es, etc...
   Si le temps de connexion est long, les connexions persistantes seront
   bien utiles, car une fois ouverte par un processus fils, la connexion est
   r&eacute;utilisable sans avoir &agrave; se reconnecter. Si vous avez 20
   processus fils, il suffit d'avoir 20 connexions persistantes ouvertes,
   une par fils.
  </simpara>
  <simpara>
   Notez que les connexions persistantes ont quelques inconv&eacute;nients
   si vous h&eacute;bergez une base de donn&eacute;es, dont le nombre maximal de
   connexion risque d'&ecirc;tre atteint par les connexions persistantes.
   Si votre base de donn&eacute;es accepte jusqu'&agrave; 16 connexions
   simultan&eacute;es et que, 17 processus essaient de se connecter,
   le dernier restera sur la touche. S'il y a des erreurs dans les scripts qui ne permettent
   pas de fermer la connexion (par exemple, une boucle infinie), votre
   serveur sera rapidement engorg&eacute;. V&eacute;rifiez la documentation de votre
   base de donn&eacute;es pour savoir comment elle traite les connexions
   inactives ou abandonn&eacute;es.
   </simpara>
   <simpara>
    R&eacute;sumons-nous : les connexions persistantes ont &eacute;t&eacute;
    d&eacute;finies pour avoir les m&ecirc;mes fonctionnalit&eacute;s que
    les connexions non persistantes. Les deux types de connexions
    sont parfaitement interchangeables, et n'affecteront pas le
    comportement de votre script : uniquement son efficacit&eacute;.
  </simpara>
  <para>
   Voir aussi
   <function>fbsql_pconnect</function>,
   <function>ibase_pconnect</function>, 
   <function>ifx_pconnect</function>,
   <function>imap_popen</function>, 
   <function>ingres_pconnect</function>,
   <function>msql_pconnect</function>, 
   <function>mssql_pconnect</function>,
   <function>mysql_pconnect</function>, 
   <function>ociplogon</function>,
   <function>odbc_pconnect</function>, 
   <function>ora_plogon</function>,
   <function>pfsockopen</function>, 
   <function>pg_pconnect</function> et
   <function>sybase_pconnect</function>.
  </para> </chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
