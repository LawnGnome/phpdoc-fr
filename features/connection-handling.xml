<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.14 $ -->
 <chapter id="features.connection-handling">
  <title>Gestion des connexions</title>
  <note>
   <para>
     Les informations suivantes ne sont valables qu'&agrave;
     partir de la version 3.0.7.
   </para>
  </note>
  <para>
	Le statut des connexions est conserv&eacute; en interne par PHP. Il y a
	trois &eacute;tats possibles :
   <itemizedlist>
    <listitem><simpara>0 - NORMAL (normal)</simpara></listitem>
    <listitem><simpara>1 - ABORTED (annul&eacute;)</simpara></listitem>
    <listitem><simpara>2 - TIMEOUT (p&eacute;rim&eacute;)</simpara></listitem>
   </itemizedlist>
  </para>
  <simpara>
   Lorsqu'un script PHP est en cours d'ex&eacute;cution, son
   &eacute;tat est NORMAL. Si le client distant se d&eacute;connecte,
   le statut devient ABORTED. En g&eacute;n&eacute;ral, une telle
   d&eacute;connexion provient d'un arr&ecirc;t temporaire. Si la
   dur&eacute;e maximale d'ex&eacute;cution de PHP est 
   d&eacute;pass&eacute;e,
   (voir <function>set_time_limit</function>), le script prend le
   statut TIMEOUT.
  </simpara>
  <simpara>
   Vous pouvez en outre d&eacute;cider si vous voulez que la
   d&eacute;connexion d'un client provoque l'arr&ecirc;t de votre
   script. Il est parfois pratique que vos scripts continuent 
   &agrave; s'ex&eacute;cuter jusqu'&agrave; la fin, m&ecirc;me si le client n'est plus l&agrave; 
   pour recevoir les informations. Cependant, par d&eacute;faut, le script 
   s'arr&ecirc;tera d&egrave;s que le client se d&eacute;connecte.
   Ce comportement peut
   &ecirc;tre modifi&eacute; avec la directive <parameter>ignore_user_abort</parameter>
   dans le fichier &php.ini; ou bien avec la directive Apache
   <parameter>ignore_user_abort</parameter> du fichier Apache
   &httpd.conf;
   ou avec la fonction <function>ignore_user_abort</function>. Si vous
   ne demandez pas &agrave; PHP d'ignorer la d&eacute;connexion, et que
   l'utilisateur se d&eacute;connecte, le script sera termin&eacute;. La
   seule exception est si vous avez enregistr&eacute; une fonction
   de fermeture, avec <function>register_shutdown_function</function>.
   Avec une telle fonction, lorsque l'utilisateur interrompt sa
   requ&ecirc;te, &agrave; la prochaine ex&eacute;cution du script,
   PHP va s'apercevoir que le dernier script n'a pas &eacute;t&eacute;
   termin&eacute;, et il va d&eacute;clencher la fonction de fermeture.
   Cette fonction sera aussi appel&eacute;e &agrave; la fin du script,
   si celui-ci se termine normalement. Pour pouvoir avoir un comportement
   diff&eacute;rent suivant l'&eacute;tat du script lors de sa finalisation,
   vous pouvez ex&eacute;cutez des commandes sp&eacute;cifiques &agrave;
   la d&eacute;connexion gr&acirc;ce &agrave; la commande
   <function>connection_aborted</function>. Cette fonction retournera
   &true; si la connexion a &eacute;t&eacute; annul&eacute;e.
  </simpara>
  <simpara>
   Votre script peut aussi &ecirc;tre automatiquement interrompu 
   apr&egrave;s une certaine dur&eacute;e de temps.
   Par d&eacute;faut, le d&eacute;lai est de 30 secondes. Cette valeur
   peut &ecirc;tre chang&eacute;e en utilisant la directive PHP
   <parameter>max_execution_time</parameter> dans le fichier
   &php.ini; ou avec la directive
   <parameter>php3_max_execution_time</parameter>, dans le fichier
   Apache <filename>.conf</filename> ou encore avec la fonction
   <function>set_time_limit</function>.
   Lorsque le d&eacute;lai expire, le script est termin&eacute;,
   et comme pour la d&eacute;connexion du client, une fonction de
   finalisation sera appel&eacute;e. Dans cette fonction, vous
   pouvez savoir si c'est le d&eacute;lai d'expiration qui a
   caus&eacute; la fin du script, en appelant la fonction
   <function>connection_timeout</function>. Cette fonction
   retournera vrai si le d&eacute;lai d'expiration a
   &eacute;t&eacute; d&eacute;pass&eacute;.
  </simpara>
  <simpara>
   Une chose &agrave; noter est que les deux cas ABORTED et TIMEOUT
   peuvent &ecirc;tre appel&eacute;s en m&ecirc;me temps. Ceci est
   possible si vous demandez &agrave; PHP d'ignorer les
   d&eacute;connexions des utilisateurs. PHP va quand
   m&ecirc;me noter le fait que l'utilisateur s'est d&eacute;connect&eacute;,
   mais le script va continuer. Puis, lorsqu'il atteint la limite de
   temps, le script va expirer. A ce moment-l&agrave;, les deux
   fonctions <function>connection_timeout</function> et
   <function>connection_aborted</function> vont retourner &true;.
   Vous pouvez aussi v&eacute;rifier les deux &eacute;tats en un
   seul appel avec la fonction <function>connection_status</function>.
   Cette fonction va retourner un champs de bits, avec les &eacute;tats.
   Si les deux &eacute;tats sont actifs, l'&eacute;tat retourn&eacute;
   prendra la valeur 3.
  </simpara>
 </chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
