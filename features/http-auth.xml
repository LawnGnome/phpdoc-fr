 <chapter id="features.http-auth">
  <title>Authentification HTTP avec PHP</title>
  <simpara>
     Les fonctions d'authentification HTTP de PHP ne sont disponibles
     que si PHP est ex&eacute;cut&eacute; comme module Apache, et non
     pas sous la forme d'un CGI. Sous cette forme, il est possible
     d'utiliser la fonction <function>header</function> pour demander
     une authentification ("Authentication Required" ) au client,
     g&eacute;n&eacute;rant ainsi l'apparition d'une fen&ecirc;tre
     de demande d'utilisateur et de mot de passe. Une fois que les
     champs ont &eacute;t&eacute; remplis, l'URL sera de nouveau
     appel&eacute;e, avec les variables <varname>$PHP_AUTH_USER</varname>,
     <varname>$PHP_AUTH_PW</varname> et  <varname>$PHP_AUTH_TYPE</varname>
     contenant respectivement le nom d'utilisateur, le mot de passe et
     le type d'authentification. Actuellement, seule l'authentification
     simple ("Basic") est support&eacute;e. Reportez vous &agrave; la fonction
     <function>header</function> pour plus d'informations.
   </simpara>
  <para>
   Voici un exemple de script qui force l'authentification du client
   pour acc&eacute;der &agrave; une page :
   <example>
    <title>Exemple d'authentication HTTP</title>
    <programlisting role="php">
&lt;?php
  if(!isset($PHP_AUTH_USER)) {
    Header(&quot;WWW-Authenticate: Basic realm=\&quot;My Realm\&quot;&quot;);
    Header(&quot;HTTP/1.0 401 Unauthorized&quot;);
    echo &quot;Texte &agrave; envoyer si le client appuie sur le bouton d'annulation\n&quot;;
    exit;
  } else {
    echo &quot;Bonjour $PHP_AUTH_USER.&lt;P&gt;&quot;
    echo &quot;Vous avez entr&eacute; le mot de passe $PHP_AUTH_PW.&lt;P&gt;&quot;
  }
?&gt;
    </programlisting>
   </example>
   </para>
  <para>
     Au lieu d'afficher simplement les variables globales <varname>$PHP_AUTH_USER</varname>
     et <varname>$PHP_AUTH_PW</varname>, vous pr&eacute;f&eacute;rerez s&ucirc;rement
     v&eacute;rifier la validit&eacute; du nom d'utilisateur et du mot de passe.
     Par exemple, en envoyant ces informations &agrave; une base de donn&eacute;es,
     ou en recherchant dans un fichier dbm.
  </para>
  <para>
    M&eacute;fiez vous des navigateurs bugg&eacute;s, tels que Internet Explorer.
    Ils semblent tr&egrave;s suceptibles concernant l'ordre des ent&ecirc;tes.
    Envoyer l'ent&ecirc;te d'authentification (<emphasis>WWW-Authenticate</emphasis>)
    avant le code de <errorcode>HTTP/1.0 401</errorcode> semble lui convenir
    jusqu'&agrave; pr&eacute;sent.
  </para>
  <simpara>
    Pour &eacute;viter que quelqu'un &eacute;crive un script qui
    r&eacute;v&egrave;le les mots de passe d'une page, &agrave; la
    quelle on a acc&eacute;d&eacute; par une authentification traditionnelle,
    les variables globales PHP_AUTH ne seront pas assign&eacute;es si
    l'authentification externe a &eacute;t&eacute; activ&eacute;e pour
    cette page. Dans ce cas, la variable <varname>$REMOTE_USER</varname> peut &ecirc;tre
    utilis&eacute;e pour identifier l'utilisateur &agrave; l'ext&eacute;rieur.
  </simpara>
  <simpara>
    Notez cependant que les manipulations ci-dessus n'emp&ecirc;chent
    pas quiconque qui poss&egrave;de une page non authentifi&eacute;e
    de voler les mots de passes des pages prot&eacute;g&eacute;es,
    sur le m&ecirc;me serveur.
  </simpara>
  <simpara>
   Netscape et Internet Explorer effaceront le cache d'authentification client
   si ils recoivent une r&eacute;ponse 401. Cela permet de d&eacute;connecter
   un utilisateur, pour le forcer &agrave; r&eacute;-entrer son nom de compte
   et son mot de passe. Certains programmeurs l'utilisent pour donner un
   d&eacute;lai d'&eacute;xpiration, ou alors, fournissent un bouton de d&eacute;connexion.
  </simpara>
  <example>
   <title>
    Authentification HTTP avec nom d'utilisateur/mot de passe forc&eacute;
   </title>
   <programlisting role="php">
&lt;?php
  function  authenticate() {
    Header( &quot;WWW-authenticate:  basic  realm='Test  Authentication  System'&quot;);
    Header( &quot;HTTP/1.0  401  Unauthorized&quot;);
    echo  &quot;Vous devez entrer un nom d'utilisateur valide et un mot de passe correct pour acc&eacute;der &agrave; cette ressource\n&quot;;
    exit;
  }
  if(!isset($PHP_AUTH_USER)  ||  ($SeenBefore ==  1  &&  !strcmp($OldAuth,  $PHP_AUTH_USER))  )  {
    authenticate();
  }
  else  {
    echo  &quot;Bienvenue  $PHP_AUTH_USER&lt;BR&gt;&quot;;
    echo  &quot;Old:  $OldAuth&quot;;
    echo  &quot;&lt;FORM  ACTION=\&quot;$PHP_SELF\&quot;  METHOD=POST&gt;\n&quot;;
    echo  &quot;&lt;INPUT  TYPE=HIDDEN  NAME=\&quot;SeenBefore\&quot;  VALUE=\&quot;1\&quot;&gt;\n&quot;;
    echo  &quot;&lt;INPUT  TYPE=HIDDEN  NAME=\&quot;OldAuth\&quot;  VALUE=\&quot;$PHP_AUTH_USER\&quot;&gt;\n&quot;;
    echo  &quot;&lt;INPUT  TYPE=Submit  VALUE=\&quot;Re  Authenticate\&quot;&gt;\n&quot;
    echo  &quot;&lt;/FORM&gt;\n&quot;;
}
?&gt;
   </programlisting>
  </example>
  <simpara>
   Ce comportement n'est pas n&eacute;cessaire par le standard
   d'authentification HTTP Basic. Les tests avec Lynx ont montr&eacute;
   qu'il n'affectait pas les informations de session lors de la
   r&eacute;ception d'un message de type 401, ce qui fait que passer ces
   informations entre le serveur et le client, et donnera l'acc&egrave;s
   &agrave; la ressource. Cependant, l'utilisateur peut utiliser la
   touche '_' pour d&eacute;truire les anciennes autentifications.
  </simpara>
  <simpara>
   Notez aussi que tout ceci ne fonctionne pas sous Microsoft IIS et que les
   limitations de PHP en version CGI sont dues aux limitations de IIS.
  </simpara>
 </chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
