<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.22 $ -->
<!-- EN-Revision: 1.1 Maintainer: nobody Status: partial -->
 <chapter id="features.file-upload">
  <title>Gestion des chargements de fichier</title>
  <sect1 id="features.file-upload.post-method">
   <title>Chargements de fichiers par méthode POST </title>
   <simpara>
    &php; est capable de recevoir des fichiers émis par
    un navigateur conforme à la norme RFC-1867
    (c'est-à-dire Netscape Navigator 3 ou supérieur, Microsoft
    Internet Explorer 3 avec un patch de Microsoft, ou supérieur
    sans le patch). Cette fonctionnalité permet de charger des
    fichiers textes ou binaires. Avec l'authentification et les fonctions
    de manipulation des fichiers, vous avez un contrôle total
    sur le chargement et la gestion des fichiers chargés.
   </simpara>
   <note>
    <title>Notes de configuration</title>
    <para>
     Voir aussi les directives 
     <link linkend="ini.file-uploads">file_uploads</link>, 
     <link linkend="ini.upload-max-filesize">upload_max_filesize</link>,
     <link linkend="ini.upload-tmp-dir">upload_tmp_dir</link> et
     <link linkend="ini.post-max-size">post_max_size</link>, dans &php.ini;
    </para>
   </note>
   <para>
    Notez bien que &php; supporte aussi le chargement par la
    méthode PUT comme dans le navigateur <productname>Netscape Composer</productname>
    et les clients <productname>Amaya</productname> du W3C. Reportez-vous au chapitre sur le
    <link linkend="features.file-upload.put-method">support de la
    méthode PUT</link>.
   </para>
   <para>
    Un écran de chargement de fichiers peut être constitué
    en créant un formulaire de la manière suivante :
    <example>
     <title>Formulaire de chargement de fichier</title>
     <programlisting role="html">
 <![CDATA[
<form enctype="multipart/form-data" action="_URL_" method="POST">
 <input type="hidden" name="MAX_FILE_SIZE" value="1000" />
 Envoyez ce fichier : <input name="userfile" type="file" />
 <input type="submit" value="Send File" />
</form>
]]>
     </programlisting>
    </example>
      Le paramètre _URL_ doit pointer sur un fichier &php;.
      L'option MAX_FILE_SIZE cachée doit précéder
      le nom du fichier à charger, et représente la taille
      maximale du  fichier à charger. La valeur est donnée
      en octets. Dans ce script, les valeurs suivantes doivent être
      définies pour assurer un chargement correct.
   </para>
    <warning>
     <para>
      Le champ MAX_FILE_SIZE est là à titre de conseil au navigateur.
      Il est très facile de contourner cette restriction. Ne comptez pas
      sur le respect de cette configuration par le navigateur! La configuration
      de &php; sur la taille maximale à respecter (<link linkend="ini.upload-max-filesize">upload_max_filesize</link>)
      ne peut être contournée, elle.
     </para>
    </warning>
   <para>
    Les variables définies après un téléchargement 
    de fichiers diffèrent beaucoup de version en version. La variable 
    <link linkend="reserved.variables.files"><varname>$_FILES</varname></link>
    existe depuis &php; 4.1.0. Le tableau <varname>$HTTP_POST_FILES</varname>
    existe depuis &php; 4.0.0. Ces tableaux contiennent toutes les données
    sur les fichiers téléchargés. L'utilisation de la 
    variable <varname>$_FILES</varname> est recommandée. Si la directive &php; 
    <link linkend="ini.register-globals">register_globals</link> vaut
    <emphasis>on</emphasis>, les variables reliées existeront aussi.
    <link linkend="ini.register-globals">register_globals</link> 
    vaut par défaut <emphasis>off</emphasis> depuis &php; 
    <ulink url="&url.php.release4.2.0;">4.2.0</ulink>.
   </para>
   <para>
    Le contenu du tableau <link linkend="reserved.variables.files"><varname>$_FILES</varname></link>
    est détaillé dans notre exemple ci-dessous. Notez que l'un suppose que le nom
    de la variable du fichier téléchargé est <emphasis>userfile</emphasis>, tel que
    défini dans le formulaire ci-dessus.
    <variablelist>
     <varlistentry>
      <term><varname>$_FILES['userfile']['name']</varname></term>
      <listitem>
       <para>
        Le nom original du fichier, tel que sur la machine du client web.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>$_FILES['userfile']['type']</varname></term>
      <listitem>
       <para>
        Le type MIME du fichier, si le navigateur a fourni cette information.
        Par exemple, cela pourra être <literal>"image/gif"</literal>.
        </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>$_FILES['userfile']['size']</varname></term>
      <listitem>
       <para>
        La taille, en octets, du fichier téléchargé.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>$_FILES['userfile']['tmp_name']</varname></term>
      <listitem>
       <para>
        Le nom temporaire du fichier qui sera chargé sur la machine serveur.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>$_FILES['userfile']['error']</varname></term>
      <listitem>
       <para>
        Le code d'erreur 
        <link linkend="features.file-upload.errors"><literal>error code</literal></link>
        associé au téléchargement de fichier. <literal>error code</literal>
        a été introduit en &php; 4.2.0
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
   <note>
    <para>
     Dans les versions de &php; antérieure à la version 4.1.0, la variable
     <varname>$_FILES</varname> s'appelait <varname>$HTTP_POST_FILES</varname> et 
     ce n'était pas une variable 
     <link linkend="language.variables.superglobals">auto-globale</link> 
     comme l'est <varname>$_FILES</varname>. &php; 3 ne supporte pas
     <varname>$HTTP_POST_FILES</varname>.
    </para>
   </note>
   <para>
    Lorsque <link linkend="ini.register-globals">register_globals</link>
    vaut <emphasis>on</emphasis> dans le &php.ini;, des variables supplémentaires
    sont rendues disponibles. Par exemple 
    <varname>$userfile_name</varname> vaut 
    <varname>$_FILES['userfile']['name']</varname>,
    <varname>$userfile_type</varname> vaut 
    <varname>$_FILES['userfile']['type']</varname>, etc...  Gardez à l'esprit
    que depuis &php; 4.2.0, <link linkend="ini.register-globals">register_globals</link> 
    vaut <emphasis>off</emphasis> par défaut. Il n'est pas prudent de
    supposer que cette directive vaut <emphasis>on</emphasis>.
   </para>
   <para>
    Le fichier téléchargé sera stocké temporairement dans le dossier
    temporaire du système, à moins qu'un autre dossier soit fourni avec
    la directive <link linkend="ini.upload-tmp-dir">upload_tmp_dir</link> du
    &php.ini;. Le dossier par défaut du serveur peut être changé
    dans l'environnement via la variable <envar>TMPDIR</envar>.
    Modifier la valeur de cette variable avec la fonction <function>putenv</function>
    dans un script &php; sera sans effet. Cette variable d'environnement
    peut aussi être utilisée pour s'assurer que d'autres opérations
    fonctionnent aussi sur les fichiers téléchargés.
    <example>
     <title>Validation de téléchargement de fichiers</title>
     <para>
      Les exemples ci-dessous sont valables avec les versions de &php;
      plus récentes que la 4.0.2. Voyez les fonctions
      <function>is_uploaded_file</function> et
      <function>move_uploaded_file</function>.
     </para>
     <programlisting role="php">
<![CDATA[
<?php 
// En PHP < 4.1.0, $HTTP_POST_FILES doit être utilisé 
//    à la place de $_FILES.
// En PHP plus ancien que 4.0.3, utilisez copy() et is_uploaded_file() 
//    à la place de move_uploaded_file

$uploaddir = '/var/www/uploads/';

print "<pre>";
if (move_uploaded_file($_FILES['userfile']['tmp_name'], $uploaddir . $_FILES['userfile']['name'])) {
    print "Le fichier est valide, et a été téléchargé 
           avec succès. Voici plus d'informations :\n";
    print_r($_FILES);
} else {
    echo "Attaque par upload potentielle. Voici plus d'informations :\n";
    print_r($_FILES);
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Le script &php; qui reçoit le fichier chargé doit pouvoir
    gérer le fichier de manière appropriée. Vous
    pouvez utiliser la variable <varname>$file_size</varname> pour recaler
    tous les fichiers qui sont trop gros ou trop petits. Vous pouvez utiliser
    la variable <varname>$file_type</varname> pour recaler les fichiers qui
    n'ont pas le bon type. Quelques soient les actions, ce script doit pouvoir
    supprimer le fichier du dossier temporaire, ou le déplacer ailleurs.
    Depuis &php; 4.2.0, vous pouvez utiliser l'information dans 
    <varname>$_FILES['userfile']['error']</varname> et adapter votre politique
    en fonction des <link linkend="features.file-upload.errors">code d'erreur</link>.
    Quelque soit votre politique, vous devriez soit effacer le fichier du
    dossier temporaire, soit le déplacer.
   </simpara>
   <simpara>
    Le fichier sera automatiquement effacé du fichier temporaire
    à la fin du script, s'il n'a pas été
    déplacé ou renommé.
   </simpara>
  </sect1>

  <sect1 id="features.file-upload.errors">
   <title>Explication sur les messages d'erreurs de chargement de fichiers</title>
   <simpara>
    Depuis &php; 4.2.0, &php; retourne un code d'erreur approprié dans le
    tableau de fichiers. Ce code d'erreur est accessible à l'index
    <emphasis>error</emphasis> du tableau, qui est créé durant
    le téléchargement, par &php;. En d'autres termes, le message d'erreur
    est accessible dans la variable <varname>$_FILES['userfile']['error']</varname>.
   </simpara>
   <para>
    <variablelist>
     <varlistentry>
      <term><varname>UPLOAD_ERR_OK</varname></term>
      <listitem>
       <para>
        Valeur : 0. Aucune erreur, le téléchargement est correct.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>UPLOAD_ERR_INI_SIZE</varname></term>
      <listitem>
       <para>
        Valeur : 1. Le fichier téléchargé excède la taille de
        <link linkend="ini.upload-max-filesize">upload_max_filesize</link>,
        configuré dans le &php.ini;.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>UPLOAD_ERR_FORM_SIZE</varname></term>
      <listitem>
       <para>
        Valeur : 2. Le fichier téléchargé excède la taille de
        <emphasis>MAX_FILE_SIZE</emphasis>, qui a été spécifiée dans
        le formulaire HTML.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>UPLOAD_ERR_PARTIAL</varname></term>
      <listitem>
       <para>
        Valeur : 3. Le fichier n'a été que partiellement téléchargé.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>UPLOAD_ERR_NO_FILE</varname></term>
      <listitem>
       <para>
        Valeur : 4. Aucun fichier n'a été téléchargé.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
   <note>
    <para>
     Ces constantes sont apparues en &php; 4.3.0.
    </para>
   </note>
  </sect1>
  <sect1 id="features.file-upload.common-pitfalls">
   <title>Erreurs classiques</title>
   <simpara>
    La variable MAX_FILE_SIZE ne peut pas spécifier une taille
    de fichier plus grande que la taille qui a été
    fixée par upload_max_filesize, dans le fichier <filename>php3.ini</filename>,
    ou par php3_upload_max_filesize dans les directives Apache. La valeur
    par défaut est 2 méga-octets.
   </simpara>
   <simpara>
    Ne pas valider les fichiers que vous manipulez peut donner l'accès
    aux utilisateurs à des fichiers sensibles dans d'autres dossiers!
   </simpara>
   <simpara>
    Attention : il semble que <productname>CERN httpd</productname> supprime tout 
    ce qui est après le premier caractère dans l'en-tête MIME. 
    Tant que c'est le cas, <productname>CERN httpd</productname> ne pourra pas 
    effectuer de chargements de fichiers.
   </simpara>
  </sect1>
  <sect1 id="features.file-upload.multiple">
   <title>Télécharger plusieurs fichiers simultanément</title>
   <simpara>
    Le téléchargement de plusieurs fichiers  est possible
    en utilisant des noms différents dans l'attribut
    <literal>name</literal> de la balise <literal>input</literal>.
   </simpara>
   <simpara>
    Il est aussi possible de télécharger plusieurs fichiers simultanément
    et d'obtenir les informations sous forme de tableau. Pour cela, vous
    devez utiliser la syntaxe de tableau dans les noms de balises
    HTML, comme vous l'avez fait avec les sélections multiples 
    et les boîtes à cocher.
   </simpara>
   <note>
    <para>
     Le support des téléchargement multiples a été ajouté
     en &php; 3.0.10.
    </para>
   </note>
   <para>
    <example>
     <title>Télécharger plusieurs fichiers simultanément</title>
     <programlisting role="html">
<![CDATA[
<form action="file-upload.php" method="post" enctype="multipart/form-data">
 Envoyez plusieurs fichiers : <br />
 <input name="userfile[]" type="file" /><br />
 <input name="userfile[]" type="file" /><br />
 <input type="submit" value="Send files" />
</form>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Lorsque le formulaire ci-dessus a été envoyé, les 
    tableaux <varname>$_FILES['userfile']</varname>,
    <varname>$_FILES['userfile']['name']</varname>, et
    <varname>$_FILES['userfile']['size']</varname> seront initialisés
    (tout comme <varname>$HTTP_POST_FILES</varname> pour les versions
    de &php; antérieure à la 4.1.0). Lorsque
    <literal>register_globals</literal> est activé, les variables
    globales concernant les fichiers téléchargés sont aussi
    initialisées. Chacune d'entre elle contiendra un tableau
    numériquement indexé, avec les valeurs décrivant les fichiers
    téléchargés.
   </simpara>
   <simpara>
    Par exemple, supposons que les fichiers 
    <filename>/home/test/review.html</filename> et
    <filename>/home/test/xwp.out</filename> ont été téléchargé. Dans ce cas,
    <varname>$_FILES['userfile']['name'][0]</varname>
    contient <filename>review.html</filename> et
    <varname>$_FILES['userfile']['name'][1]</varname> contient
    <filename>xwp.out</filename>. Similairement, 
    <varname>$_FILES['userfile']['size'][0]</varname> va contenir
    la taille du fichier <filename>review.html</filename>, etc...
   </simpara>
   <simpara>
    <varname>$_FILES['userfile']['name'][0]</varname>,
    <varname>$_FILES['userfile']['tmp_name'][0]</varname>,
    <varname>$_FILES['userfile']['size'][0]</varname> et
    <varname>$_FILES['userfile']['type'][0]</varname> sont aussi 
    créées.
   </simpara>
  </sect1>
  <sect1 id="features.file-upload.put-method">
   <title>Chargement par méthode PUT </title>
   <simpara>
    Le suppor de la méthode PUT a été modifié entre &php; 3 et &php; 4.
    En &php; 4, il faut utiliser le flux d'entrée standard pour recevoir
    le contenu du fichier.
   </simpara>
   <para>
    <example>
     <title>Sauver un fichier par méthode PUT en &php; 4</title>
     <programlisting role="php">
<![CDATA[
<?php
/* Les données via la méthode PUT arrivent dans stdin */
$putdata = fopen("php://stdin","r");

/* Ouvre un fichier pour écriture */
$fp = fopen("myputfile.ext","w");

/* Lit les données par bloc de 1ko 
   et les écrit dans le fichier */
while ($data = fread($putdata,1024)) {
    fwrite($fp,$data);
}

/* Ferme les flux */
fclose($fp);
fclose($putdata);
?>
]]>
     </programlisting>
    </example>
   </para>
   <note>
    <para>
     Toute la documentation ci-dessous s'applique à &php; 3 uniquement.
    </para>
   </note>
   <para>
     &php; supporte la méthode HTTP PUT utilisée par
     les navigateurs tels que Netscape Composer et W3C Amaya. Les
     requêtes de type PUT sont beaucoup plus simples que
     les chargements de fichiers, et elles ressemblent à :
    <example>
     <title>Méthode PUT pour les chargements de fichiers</title>
     <programlisting role="HTTP">
PUT /path/filename.html HTTP/1.1
     </programlisting>
    </example>
   </para>
   <para>
    Normalement, cela signifie que le client distant va sauver
    les données qui suivent dans le fichier: <filename>/path/filename.html</filename>
    de votre disque. Ce n'est évidemment pas très
    sécurisé de laisser Apache ou &php; écraser n'importe
    quel fichier de l'arborescence. Pour éviter ceci, il faut d'abord
    dire au serveur que vous voulez qu'un script &php; donné gère
    la requête. Avec Apache, il y a une directive pour cela :
    <emphasis>Script</emphasis>. Elle peut être placée
    n'importe où dans le fichier de configuration d'Apache.
    En général, les webmestres la place dans le bloc
    <literal>&lt;Directory&gt;</literal>, ou peut être dans le bloc 
    <literal>&lt;Virtualhost&gt;</literal>.
    La ligne suivante fera très bien l'affaire :
    <example>
     <title>Directive Apache pour le chargement par méthode PUT</title>
     <programlisting>
Script PUT /put.php3
     </programlisting>
    </example>
   </para>
   <simpara>
    Elle indique à Apache qu'il doit envoyer les requêtes
    de chargement par méthode PUT au script 
    <filename>put.php3</filename>. Bien entendu,
    cela présuppose que vous avez activé &php; pour qu'il
    prenne en charge les fichiers de type .php3, et que &php; est actif.
   </simpara>
   <simpara>
    Dans le fichier <filename>put.php3</filename>, vous pouvez mettre ceci :
   </simpara>
   <para>
    <example>
     <title>Reception d'un fichier par méthode PUT</title>
     <programlisting role="php">
 <![CDATA[
<?php
copy($PHP_UPLOADED_FILE_NAME, $DOCUMENT_ROOT . $REQUEST_URI);
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Ce script va copier le fichier chargé par le client distant
    à l'endroit désiré. Vous aurez probablement
    à effectuer quelques tests et l'identification de 
    l'utilisateur, avant d'effectuer cette copie. Le seul piège
    est que lorsque &php; reçoit un chargement par méthode PUT,
    il va enregistrer le fichier dans le dossier temporaire, tout comme
    avec la
    <link linkend="features.file-upload.post-method">méthode POST</link>.
    A la fin de la requête, le fichier sera effacé. Ce qui
    fait que ce script doit placer le fichier chargé quelque part.
    Le nom du fichier temporaire est placé dans la variable
    globale <varname>$PHP_PUT_FILENAME</varname>, et la destination prévue est
    placée dans <varname>$REQUEST_URI</varname> (ces noms peuvent
    changer d'une configuration d'Apache à l'autre). Cette destination
    est celle qui est demandée par le client, et vous n'avez pas
    à obéir aveuglément au client. Vous pourriez
    par exemple, déplacer le fichier dans un dossier de chargement.
  </simpara>
 </sect1>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
