<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.12 $ -->
 <chapter id="features.file-upload">
  <title>Gestion des chargements de fichier</title>
  <sect1 id="features.file-upload.post-method">
   <title>Chargements de fichiers par m&eacute;thode POST </title>
   <simpara>
     PHP est capable de recevoir des fichiers &eacute;mis par
     un navigateur conforme &agrave; la norme RFC-1867
     (c'est-&agrave;-dire Netscape Navigator 3 ou sup&eacute;rieur, Microsoft
     Internet Explorer 3 avec un patch de Microsoft, ou sup&eacute;rieur
     sans le patch). Cette fonctionnalit&eacute; permet de charger des
     fichiers textes ou binaires. Avec l'authentification et les fonctions
     de manipulation des fichiers, vous avez un contr&ocirc;le total
     sur le chargement et la gestion des fichiers charg&eacute;s.
   </simpara>
   <para>
     Notez bien que PHP supporte aussi le chargement par la
     m&eacute;thode PUT comme dans le navigateur Netscape Composer
     et les clients Amaya du W3C. Reportez-vous au chapitre sur le
     <link linkend="features.file-upload.put-method">support de la
     m&eacute;thode PUT</link>.
   </para>
   <para>
     Un &eacute;cran de chargement de fichiers peut &ecirc;tre constitu&eacute;
     en cr&eacute;ant un formulaire de la mani&egrave;re suivante :
     <example>
     <title>Formulaire de chargement de fichier</title>
     <programlisting role="html">
&lt;FORM ENCTYPE=&quot;multipart/form-data&quot; ACTION=&quot;_URL_&quot; METHOD=&quot;POST&quot;&gt;
&lt;INPUT TYPE=&quot;hidden&quot; name=&quot;MAX_FILE_SIZE&quot; value=&quot;1000&quot;&gt;
Envoyez ce fichier : &lt;INPUT NAME=&quot;userfile&quot; TYPE=&quot;file&quot;&gt;
&lt;INPUT TYPE=&quot;submit&quot; VALUE=&quot;Send File&quot;&gt;
&lt;/FORM&gt;
     </programlisting>
     </example>
      Le param&egrave;tre _URL_ doit pointer sur un fichier PHP.
      L'option MAX_FILE_SIZE cach&eacute;e doit pr&eacute;c&eacute;der
      le nom du fichier &agrave; charger, et repr&eacute;sente la taille
      maximale du  fichier &agrave; charger. La valeur est donn&eacute;e
      en octets. Dans ce script, les valeurs suivantes doivent &ecirc;tre
      d&eacute;finies pour assurer un chargement correct :
   </para>
  <para>
    En PHP 3, les variables suivantes seront d&eacute;finies dans
    le script de destination, en cas de t&eacute;l&eacute;chargement r&eacute;ussi, et en
    supposant que <link linkend="ini.register-globals">register_globals</link>
    est activ&eacute; dans le fichier <filename>php.ini</filename>. Si <link
    linkend="ini.track-vars">track_vars</link> est activ&eacute;, elles seront aussi
    disponibles dans le dossier <varname>$HTTP_POST_VARS</varname>.
    Notez que les noms des variables suivantes supposent que nom du
    fichier t&eacute;l&eacute;charg&eacute; est 'userfile', comme
    pr&eacute;sent&eacute; dans l'exemple ci-dessus.
    <itemizedlist>
     <listitem>
      <simpara>
       <varname>$userfile</varname> - Le nom temporaire du fichier qui
       sera charg&eacute; sur la machine serveur.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       <varname>$userfile_name</varname> - Le nom du fichier original
       sur le syst&egrave;me de l'envoyeur.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       <varname>$userfile_size</varname> - La taille du fichier envoy&eacute;
       en octets.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       <varname>$userfile_type</varname> - Le type MIME du fichier, si
       le navigateur a fourni cette information. Par exemple,
       <literal>"image/gif"</literal>.
      </simpara>
     </listitem>
    </itemizedlist>
    Notez que &quot;$userfile&quot; prend la valeur qui est pass&eacute;e dans
    le champs INPUT de type TYPE=file. Dans l'exemple ci-dessus,
    nous avons choisi de l'appeler "userfile".
   </para>
   <para>
    En PHP 4, le comportement est l&eacute;g&egrave;rement diff&eacute;rent, car c'est la
    variable d'environnement <varname>$HTTP_POST_FILES</varname>, qui
    contiendra les informations sur les fichiers t&eacute;l&eacute;charg&eacute;s.
    Ces informations sont disponibles dans si l'option
    <link linkend="ini.track-vars">track_vars</link> est activ&eacute;e, mais
    <link linkend="ini.track-vars">track_vars</link> est toujours
    activ&eacute;e dans les versions de PHP sup&eacute;rieures &agrave; la version
    4.0.2.
   </para>
   <para>
    Le contenu du tableau <varname>$HTTP_POST_FILES</varname> d&eacute;crit
    ci-dessous. Notez que l'on suppose ici que le nom du fichier
    t&eacute;l&eacute;charg&eacute; est '<literal>userfile</literal>',
    comme pr&eacute;sent&eacute; dans l'exemple ci-dessus :
    <variablelist>
     <varlistentry>
      <term><varname>$HTTP_POST_FILES['userfile']['name']</varname></term>
      <listitem>
       <para>
        Le nom du fichier original sur la machine source.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>$HTTP_POST_FILES['userfile']['type']</varname></term>
      <listitem>
       <para>
         Le type MIME du fichier, si le navigateur a fourni cette information.
         Par exemple, <literal>"image/gif"</literal>.
        </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>$HTTP_POST_FILES['userfile']['size']</varname></term>
      <listitem>
       <para>
        La taille du fichier envoy&eacute;, en octets.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>$HTTP_POST_FILES['userfile']['tmp_name']</varname></term>
      <listitem>
       <para>
         Le nom temporaire du fichier qui sera charg&eacute; sur la machine serveur.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
   <para>
    Les fichiers seront enregistr&eacute;s par d&eacute;faut dans le dossier
    des fichiers temporaires, &agrave; moins qu'un autre dossier
    n'ait &eacute;t&eacute; fourni avec la directive de configuration
    <link linkend="ini.upload-tmp-dir">upload_tmp_dir</link> du fichier
    <filename>php.ini</filename>. Le dossier par d&eacute;faut du serveur
    peut &ecirc;tre modifi&eacute; gr&acirc;ce &agrave; la variable d'environnement
    <envar>TMPDIR</envar>, de l'utilisateur qui ex&eacute;cute PHP.
    Sa modification avec <function>putenv</function> depuis un script PHP
    ne fonctionnera pas. Cette variable d'environnement peut aussi &ecirc;tre
    utilis&eacute;e pour s'assurer que d'autres op&eacute;rations fonctionnent avec
    les fichiers t&eacute;l&eacute;charg&eacute;s.
    <example>
     <title>Validation de fichiers t&eacute;l&eacute;charg&eacute;s</title>
     <para>
      Les exemples suivants fonctionnent sur les versions
      de PHP 3 sup&eacute;rieures &agrave; la version 3.0.16, et sup&eacute;rieures
      &agrave; la version 4.0.2 pour PHP 4. Reportez-vous &agrave;
      la section des fonctions pour &eacute;tudier
      <function>is_uploaded_file</function> et <function>move_uploaded_file</function>.
     </para>
     <programlisting role="php">
&lt?;php
if (is_uploaded_file($userfile)) {
    copy($userfile, "/dossier/des/fichiers/telecharges/");
} else {
    echo "Attaque potentielle par fichier t&eacute;l&eacute;charg&eacute; : fichier '$userfile'.";
}
/* ...ou... */
move_uploaded_file($userfile, "/dossier/des/fichiers/telecharges");
?&gt;
     </programlisting>
     <para>
      Pour les versions plus anciennes de PHP, vous devrez faire quelque
      chose comme ceci :
     </para>
     <programlisting role="php">
&lt?;php
/* Test du fichier t&eacute;l&eacute;charg&eacute;. */
function is_uploaded_file($filename) {
    if (!$tmp_file = get_cfg_var('upload_tmp_dir')) {
        $tmp_file = dirname(tempnam('', ''));
    }
    $tmp_file .= '/' . basename($filename);
    /* L'utilisateur peut avoir un slash final dans <filename>php.ini</filename>... */
    return (ereg_replace('/+', '/', $tmp_file) == $filename);
}
if (is_uploaded_file($userfile)) {
    copy($userfile, "/place/to/put/uploaded/file");
} else {
    echo "Attaque potentielle par fichier t&eacute;l&eacute;charg&eacute; : fichier '$userfile'.";
}
?&gt;
     </programlisting>
    </example>
   </para>
      <note>
       <para>
        Cela ne fonctionnera <emphasis>PAS</emphasis> avec les versions de
        PHP 4 sup&eacute;rieure &agrave; 4.0.2. Cela repose sur des fonctionnalit&eacute;s
        internes &agrave; PHP qui ont &eacute;volu&eacute; apr&egrave;s cette version.
       </para>
      </note>
   <simpara>
    Le script PHP qui re&ccedil;oit le fichier charg&eacute; doit pouvoir
    g&eacute;rer le fichier de mani&egrave;re appropri&eacute;e. Vous
    pouvez utiliser la variable <varname>$file_size</varname> pour recaler
    tous les fichiers qui sont trop gros ou trop petits. Vous pouvez utiliser
    la variable <varname>$file_type</varname> pour recaler les fichiers qui
    n'ont pas le bon type. Quelques soient les actions, ce script doit pouvoir
    supprimer le fichier du dossier temporaire, ou le d&eacute;placer ailleurs.
   </simpara>
   <simpara>
    Le fichier sera automatiquement effac&eacute; du fichier temporaire
    &agrave; la fin du script, s'il n'a pas &eacute;t&eacute;
    d&eacute;plac&eacute; ou renomm&eacute;.
   </simpara>
  </sect1>
  <sect1 id="features.file-upload.common-pitfalls">
   <title>Erreurs classiques</title>
   <simpara>
    La variable MAX_FILE_SIZE ne peut pas sp&eacute;cifier une taille
    de fichier plus grande que la taille qui a &eacute;t&eacute;
    fix&eacute;e par upload_max_filesize, dans le fichier <filename>php3.ini</filename>,
    ou par php3_upload_max_filesize dans les directives Apache. La valeur
    par d&eacute;faut est 2 m&eacute;gaoctets.
   </simpara>
   <simpara>
    Ne pas valider les fichiers que vous manipulez peut donner l'acc&egrave;s
    aux utilisateurs &agrave; des fichiers sensibles dans d'autres dossiers!
   </simpara>
   <simpara>
    Attention : il semble que CERN httpd supprime tout ce qui est apr&egrave;s
    le premier caract&egrave;re dans l'en-t&ecirc;te MIME. Tant que c'est le cas,
    CERN httpd ne pourra pas effectuer de chargement.
   </simpara>
  </sect1>
  <sect1 id="feature-fileupload.multiple">
   <title>Chargement multiples de fichiers</title>
   <simpara>
    Il est possible de charger plusieurs fichiers en m&ecirc;me temps, et de
    recevoir les informations ad&eacute;quates organis&eacute;es sous
    forme de tableau. Pour ce faire, il faut utiliser la m&ecirc;me
    syntaxe d'envoi dans le code HTML que pour les s&eacute;lections ou
    bo&icirc;tes &agrave; cocher multiples.
   </simpara>
   <note>
    <para>
     Le support du chargement multiple de fichier a &eacute;t&eacute;
     ajout&eacute; dans la version  3.0.10.
    </para>
   </note>
   <para>
    <example>
     <title>Chargement multiple de fichier </title>
     <programlisting role="html">
&lt;form action=&quot;file-upload.html&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
  Send these files:&lt;br&gt;
  &lt;input name=&quot;userfile[]&quot; type=&quot;file&quot;&gt;&lt;br&gt;
  &lt;input name=&quot;userfile[]&quot; type=&quot;file&quot;&gt;&lt;br&gt;
  &lt;input type=&quot;submit&quot; value=&quot;Send files&quot;&gt;
&lt;/form&gt;
     </programlisting>
    </example>
   </para>
   <simpara>
   Lorsque le formulaire ci-dessus a &eacute;t&eacute;F envoy&eacute;, les tableaux
   <computeroutput>$userfile</computeroutput>,
   <computeroutput>$userfile_name</computeroutput>, et
   <computeroutput>$userfile_size</computeroutput> seront initialis&eacute;s
   (ainsi que $HTTP_POST_VARS). Chaque tableau sera de type
   num&eacute;rique, et contiendra les valeurs appropri&eacute;es
   pour le chargement des fichiers.
   </simpara>
   <simpara>
    Par exemple, supposons que les noms de fichier
    <filename>/home/test/review.html</filename> et
    <filename>/home/test/xwp.out</filename> soient envoy&eacute;s.
    Dans ce cas, <computeroutput>$userfile_name[0]</computeroutput>
    va contenir <computeroutput>review.html</computeroutput>,
    et <computeroutput>$userfile_name[1]</computeroutput> contiendra
    <computeroutput>xwp.out</computeroutput>. Similairement,
    <computeroutput>$userfile_size[0]</computeroutput> contiendra
    la taille de <filename>review.html</filename>, etc...
   </simpara>
   <simpara>
    <computeroutput>$userfile['name'][0]</computeroutput>,
    <computeroutput>$userfile['tmp_name'][0]</computeroutput>,
    <computeroutput>$userfile['size'][0]</computeroutput>, et
    <computeroutput>$userfile['type'][0]</computeroutput>
    sont aussi affect&eacute;s.
   </simpara>
  </sect1>
  <sect1 id="features.file-upload.put-method">
   <title>Chargement par m&eacute;thode PUT </title>
   <para>
     PHP supporte la m&eacute;thode HTTP PUT utilis&eacute;e par
     les navigateurs tels que Netscape Composer et W3C Amaya. Les
     requ&ecirc;tes de type PUT sont beaucoup plus simples que
     les chargements de fichiers, et elles ressemblent &agrave; :
    <informalexample>
     <programlisting role="HTTP">
PUT /path/filename.html HTTP/1.1
     </programlisting>
    </informalexample>
   </para>
   <para>
    Normalement, cela signifie que le client distant va sauver
    les donn&eacute;es qui suivent dans le fichier: <filename>/path/filename.html</filename>
    de votre disque. Ce n'est &eacute;videmment pas tr&egrave;s
    s&eacute;curis&eacute; de laisser Apache ou PHP &eacute;craser n'importe
    quel fichier de l'arborescence. Pour &eacute;viter ceci, il faut d'abord
    dire au serveur que vous voulez qu'un script PHP donn&eacute; g&egrave;re
    la requ&ecirc;te. Avec Apache, il y a une directive pour cela :
    <emphasis>Script</emphasis>. Elle peut &ecirc;tre plac&eacute;e
    n'importe o&ugrave; dans le fichier de configuration d'Apache.
    En g&eacute;n&eacute;ral, les webmestres la place dans le bloc
    &lt;Directory&gt;, ou peut &ecirc;tre dans le bloc &lt;Virtualhost&gt;.
    La ligne suivante fera tr&egrave;s bien l'affaire :
    <informalexample>
     <programlisting>
Script PUT /put.php3
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Elle indique &agrave; Apache qu'il doit envoyer les requ&ecirc;tes
    de chargement par m&eacute;thode PUT au script put.php3. Bien entendu,
    cela pr&eacute;suppose que vous avez activ&eacute; PHP pour qu'il
    prenne en charge les fichiers de type .php3, et que PHP est actif.
   </simpara>
   <simpara>
    Dans le fichier put.php3 file vous pouvez mettre ceci :
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
&lt;?php
 copy($PHP_UPLOADED_FILE_NAME,$DOCUMENT_ROOT.$REQUEST_URI);
?&gt;
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Ce script va copier le fichier charg&eacute; par le client distant
    &agrave; l'endroit d&eacute;sir&eacute;. Vous aurez probablement
    &agrave; effectuer quelques tests et des authentifications
    d'utilisateur, avant d'effectuer cette copie. Le seul pi&egrave;ge
    est que lorsque PHP re&ccedil;oit un chargement par m&eacute;thode PUT,
    il va enregistrer le fichier dans le dossier temporaire, tout comme
    avec la
    <link linkend="features.file-upload.post-method">m&eacute;thode POST-method</link>.
    A la fin de la requ&ecirc;te, le fichier sera effac&eacute;. Ce qui
    fait que ce script doit placer le fichier charg&eacute; quelque part.
    Le nom du fichier temporaire est plac&eacute; dans la variable
    globale $PHP_PUT_FILENAME, et la destination pr&eacute;vue est
    plac&eacute;e dans <varname>$REQUEST_URI</varname> (ces noms peuvent
    changer d'une configuration d'Apache &agrave; l'autre). Cette destination
    est celle qui est demand&eacute;e par le client, et vous n'avez pas
    &agrave; ob&eacute;ir aveugl&eacute;ment au client. Vous pourriez
    par exemple, d&eacute;placer le fichier dans un dossier de chargement.
  </simpara>
 </sect1>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
