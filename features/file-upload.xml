<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.33 $ -->
<!-- EN-Revision: 1.81 Maintainer: dams Status: ready -->
 <chapter id="features.file-upload">
  <title>Gestion des chargements de fichier</title>
  
  <sect1 id="features.file-upload.post-method">
   <title>Chargements de fichiers par méthode POST </title>
   
   <simpara>
    Cette fonctionnalité permet aux personnes d'uploader à la fois du texte
    et des fichiers binaires. Avec les fonctions d'authentifications et de manipulation
    de fichiers de &php;, vous avez le contrôle total pour définir qui a le droit d'uploader
    mais aussi ce qui sera fait du fichier une fois qu'il sera uploader.
   </simpara>
   <simpara>
    &php; est capable de recevoir des fichiers émis par
    un navigateur conforme à la norme RFC-1867
    (c'est-à-dire <productname>Netscape Navigator 3</productname> ou supérieur, 
    <productname>Microsoft Internet Explorer 3</productname> avec un patch 
    de Microsoft, ou supérieur sans le patch).
   </simpara>
   
   <note>
    <title>Notes de configuration</title>
    <para>
     Voir aussi les directives 
     <link linkend="ini.file-uploads">file_uploads</link>, 
     <link linkend="ini.upload-max-filesize">upload_max_filesize</link>,
     <link linkend="ini.upload-tmp-dir">upload_tmp_dir</link>,
     <link linkend="ini.post-max-size">post_max_size</link> et
     <link linkend="ini.max-input-time">max_input_time</link> dans &php.ini;
    </para>
   </note>
   
   <para>
    &php; supporte aussi le chargement par la méthode PUT comme dans le navigateur 
    <productname>Netscape Composer</productname>
    et <productname>Amaya</productname> du W3C. Reportez-vous au chapitre sur le
    <link linkend="features.file-upload.put-method">support de la
    méthode PUT</link>.
   </para>
   
   <para>
    <example>
     <title>Formulaire de chargement de fichier</title>
     <para>
      Un écran d'upload de fichier peut être construit
      en créant un formulaire spécifique qui peut ressembler à ceci :
     </para>
     <programlisting role="html">
<![CDATA[
<!-- Le type d'encodage des données, enctype, DOIT être spécifié comme ce qui suit -->
<form enctype="multipart/form-data" action="_URL_" method="post">
  <!-- MAX_FILE_SIZE doit précéder le champs input de type file -->
  <input type="hidden" name="MAX_FILE_SIZE" value="30000" />
  <!-- Le nom de l'élément input détermine le nom dans le tableau $_FILES -->  
  Envoyez ce fichier : <input name="userfile" type="file" />
  <input type="submit" value="Envoyer le fichier" />
</form>
]]>
     </programlisting>
    <para>
     <varname>_URL_</varname> dans l'exemple précédent doit être remplacé et 
     pointé vers un fichier &php;.
    </para>
    <para>
     Le champs caché <literal>MAX_FILE_SIZE</literal> (mesuré en octets) doit précédé
     le champs input de type file et sa valeur représente la taille maximale acceptée du fichier.
     Ceci est concidéré comme un conseil pour le navigateur, bien
     que &php; l'utilise également.
     Il est très facile de contourner cette restriction. Ne comptez pas
    sur le respect de cette configuration par le navigateur! La configuration
     de &php; sur la taille maximale à respecter (<link 
     linkend="ini.upload-max-filesize">upload_max_filesize</link>)
     ne peut être contournée, elle. Vous devez ajouter la variable 
     <literal>MAX_FILE_SIZE</literal> à votre formulaire dans tous les cas car
     il prévient le chargement de gros fichiers qui demanderait un long délai 
     d'attente au client et ainsi fera échouer le script.
    </para>
    <para>
     Assurez-vous que votre formulaire d'upload de fichier contienne 
     <literal>enctype="multipart/form-data"</literal> sinon, le fichier uploadé ne fonctionnera pas.     
    </para>
   </example> 
  </para>
  
  <para>
   La variable globale <link linkend="reserved.variables.files">$_FILES</link> existe
   depuis &php; 4.1.0 (Utilisez <varname>$HTTP_POST_FILES</varname> si vous utilisez une
   version plus ancienne). Ce tableau devrait contenir toutes les informations du fichier uploadé.
  </para>
  
  <para>
   Le contenu du tableau <link linkend="reserved.variables.files">$_FILES</link>
   est détaillé dans notre exemple ci-dessous. Notez que l'on suppose que le nom
   de la variable du fichier téléchargé est <literal>userfile</literal>, tel que
   défini dans le formulaire ci-dessus, mais peut être n'importe quel nom.
   <variablelist>
    <varlistentry>
     <term><varname>$_FILES['userfile']['name']</varname></term>
     <listitem>
      <para>
       Le nom original du fichier, tel que sur la machine du client web.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><varname>$_FILES['userfile']['type']</varname></term>
     <listitem>
      <para>
       Le type MIME du fichier, si le navigateur a fourni cette information.
       Par exemple, cela pourra être <literal>"image/gif"</literal>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><varname>$_FILES['userfile']['size']</varname></term>
     <listitem>
      <para>
       La taille, en octets, du fichier téléchargé.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><varname>$_FILES['userfile']['tmp_name']</varname></term>
     <listitem>
      <para>
       Le nom temporaire du fichier qui sera chargé sur la machine serveur.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><varname>$_FILES['userfile']['error']</varname></term>
     <listitem>
      <para>
       Le code d'erreur 
       <link linkend="features.file-upload.errors"><literal>error code</literal></link>
       associé au téléchargement de fichier. Cet élément a été introduit en &php; 4.2.0
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
  <para>
   Le fichier téléchargé sera stocké temporairement dans le dossier
   temporaire du système, à moins qu'un autre dossier soit fourni avec
   la directive <link linkend="ini.upload-tmp-dir">upload_tmp_dir</link> du
   &php.ini;. Le dossier par défaut du serveur peut être changé
   dans l'environnement via la variable <envar>TMPDIR</envar>.
   Modifier la valeur de cette variable avec la fonction <function>putenv</function>
   dans un script &php; sera sans effet. Cette variable d'environnement
   peut aussi être utilisée pour s'assurer que d'autres opérations
   fonctionnent aussi sur les fichiers téléchargés.
   <example>
    <title>Validation de téléchargement de fichiers</title>
    <para>
     Voyez aussi les fonctions
     <function>is_uploaded_file</function> et
     <function>move_uploaded_file</function> pour plus d'informations.
     L'exemple suivant va télécharger un fichier venant d'un formulaire.
    </para>
    <programlisting role="php">
<![CDATA[
<?php 
// En PHP < 4.1.0, $HTTP_POST_FILES doit être utilisé 
//    à la place de $_FILES.

$uploaddir = '/var/www/uploads/';
$uploadfile = $uploaddir . basename($_FILES['userfile']['name']);

echo '<pre>';
if (move_uploaded_file($_FILES['userfile']['tmp_name'], $uploadfile)) {
    echo "Le fichier est valide, et a été téléchargé 
           avec succès. Voici plus d'informations :\n";
} else {
    echo "Attaque par upload potentielle. Voici plus d'informations :\n";
}

echo 'Voici quelques informations de déboguage :';
print_r($_FILES);

echo '</pre>';

?>
]]>
    </programlisting>
   </example>
  </para>
  <simpara>
   Le script &php; qui reçoit le fichier chargé doit pouvoir
   gérer le fichier de manière appropriée. Vous
   pouvez utiliser la variable <varname>$_FILES['userfile']['size']</varname> pour recaler
   tous les fichiers qui sont trop gros ou trop petits. Vous pouvez utiliser
    la variable <varname>$_FILES['userfile']['type']</varname> pour recaler 
    les fichiers qui n'ont pas le bon type. 
    Depuis &php; 4.2.0, vous pouvez utiliser l'information dans 
    <varname>$_FILES['userfile']['error']</varname> et adapter votre politique
    en fonction des <link linkend="features.file-upload.errors">code d'erreur</link>.
    Quelque soit votre politique, vous devriez soit effacer le fichier du
    dossier temporaire, soit le déplacer.
   </simpara>
   <simpara>
    Si aucun fichier n'est sélectionné dans le formulaire, &php; retournera
    &zero; dans <varname>$_FILES['userfile']['size']</varname>
    et rien du tout dans <varname>$_FILES['userfile']['tmp_name']</varname>.
   </simpara>
   <simpara>
    Le fichier sera automatiquement effacé du fichier temporaire
    à la fin du script, s'il n'a pas été
    déplacé ou renommé.
   </simpara>
  </sect1>

  <sect1 id="features.file-upload.errors">
   <title>Explication sur les messages d'erreurs de chargement de fichiers</title>
   <simpara>
    Depuis &php; 4.2.0, &php; retourne un code d'erreur approprié dans le
    tableau de fichiers. Ce code d'erreur est accessible à l'index
    <literal>['error']</literal> du tableau, qui est créé durant
    le téléchargement, par &php;. En d'autres termes, le message d'erreur
    est accessible dans la variable <varname>$_FILES['userfile']['error']</varname>.
   </simpara>
   <para>
    <variablelist>
     <varlistentry>
      <term><constant>UPLOAD_ERR_OK</constant></term>
      <listitem>
       <para>
        Valeur : 0. Aucune erreur, le téléchargement est correct.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><constant>UPLOAD_ERR_INI_SIZE</constant></term>
      <listitem>
       <para>
        Valeur : 1. Le fichier téléchargé excède la taille de
        <link linkend="ini.upload-max-filesize">upload_max_filesize</link>,
        configuré dans le &php.ini;.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><constant>UPLOAD_ERR_FORM_SIZE</constant></term>
      <listitem>
       <para>
        Valeur : 2. Le fichier téléchargé excède la taille de
        <emphasis>MAX_FILE_SIZE</emphasis>, qui a été spécifiée dans
        le formulaire HTML.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><constant>UPLOAD_ERR_PARTIAL</constant></term>
      <listitem>
       <para>
        Valeur : 3. Le fichier n'a été que partiellement téléchargé.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><constant>UPLOAD_ERR_NO_FILE</constant></term>
      <listitem>
       <para>
        Valeur : 4. Aucun fichier n'a été téléchargé.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
   <note>
    <para>
     Ces constantes sont apparues en &php; 4.3.0.
    </para>
   </note>
  </sect1>
  
  <sect1 id="features.file-upload.common-pitfalls">
   <title>Erreurs classiques</title>
   <simpara>
    La variable <literal>MAX_FILE_SIZE</literal> ne peut pas spécifier une taille
    de fichier plus grande que la taille qui a été
    fixée par <link linkend="ini.upload-max-filesize">upload_max_filesize</link>, 
    dans le &php.ini;. La valeur par défaut est 2 mega-octets.
   </simpara>
   <simpara>
    Si une limite de mémoire est activé, une plus grande valeur de <link
    linkend="ini.memory-limit">memory_limit</link> peut être nécessaire. Assurez-vous
    d'avoir défini une valeur pour <link linkend="ini.memory-limit">memory_limit</link>
    assez grande.
   </simpara>
   <simpara>
    Si <link linkend="ini.max-execution-time">max_execution_time</link> a pour valeur
    une valeur trop petite, le temps d'exécution du script peut excéder cette valeur.
    Assurez-vous d'avoir défini une valeur pour <literal>max_execution_time</literal>
    assez grande.
   </simpara>
   <note>
    <simpara>
     <link linkend="ini.max-execution-time">max_execution_time</link> affecte uniquement
     le temps d'exécution du script. Le temps passé sur l'activité qui apparaît
     en dehors de l'exécution du script comme les appels systèmes avec la fonction 
     <function>system</function>, la fonction <function>sleep</function>, les requêtes
     sur les bases de données, le temps mis pour effectuer le téléchargement du fichier, etc.
     n'est pas inclus lors du calcul du temps maximal de l'exécution du script.
    </simpara>
   </note>
   <warning>
    <simpara>
     <link linkend="ini.max-input-time">max_input_time</link> définie le temps maximal, 
     en secondes, au script pour recevoir les données ; cela inclue le téléchargement du fichier.
     Pour de multiples fichiers, ou de gros fichiers, ou pour les utilisateurs sur de faible connexions,
     la valeur par défaut de <literal>60 secondes</literal> peut être dépassée.
    </simpara>
   </warning>
   <simpara>
    Ne pas valider les fichiers que vous manipulez peut donner l'accès
    aux utilisateurs à des fichiers sensibles dans d'autres dossiers!
   </simpara>
   <simpara>
    Attention : il semble que <productname>CERN httpd</productname> supprime tout 
    ce qui est après le premier caractère dans l'en-tête MIME. 
    Tant que c'est le cas, <productname>CERN httpd</productname> ne pourra pas 
    effectuer de chargements de fichiers.
   </simpara>
   <simpara>
    Du fait de la grande diversité des systèmes, nous ne pouvons garantir que les fichiers
    avec des noms exotiques (comme, par exemple, contenant des espaces) seront
    traités correctement.
   </simpara>
   <simpara>
    Le développeur ne doit pas mixer les champs <literal>input</literal> normaux et les champs 
    <literal>input</literal> de téléchargement dans une même variable (en utilisant un nom 
    d'<literal>input</literal> comme <literal>foo[]</literal>).
   </simpara>
  </sect1>
  
  <sect1 id="features.file-upload.multiple">
   <title>Télécharger plusieurs fichiers simultanément</title>
   <simpara>
    Le téléchargement de plusieurs fichiers  est possible
    en utilisant des noms différents dans l'attribut
    <literal>name</literal> de la balise <literal>input</literal>.
   </simpara>
   <simpara>
    Il est aussi possible de télécharger plusieurs fichiers simultanément
    et d'obtenir les informations sous forme de tableau. Pour cela, vous
    devez utiliser la syntaxe de tableau dans les noms de balises
    HTML, comme vous l'avez fait avec les sélections multiples 
    et les boîtes à cocher.
   </simpara>
   <note>
    <para>
     Le support des téléchargement multiples a été ajouté
     en &php; 3.0.10.
    </para>
   </note>
   <para>
    <example>
     <title>Télécharger plusieurs fichiers simultanément</title>
     <programlisting role="html">
<![CDATA[
<form action="file-upload.php" method="post" enctype="multipart/form-data">
  Envoyez plusieurs fichiers : <br />
  <input name="userfile[]" type="file" /><br />
  <input name="userfile[]" type="file" /><br />
  <input type="submit" value="Envoyer les fichiers" />
</form>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Lorsque le formulaire ci-dessus a été envoyé, les 
    tableaux <varname>$_FILES['userfile']</varname>,
    <varname>$_FILES['userfile']['name']</varname>, et
    <varname>$_FILES['userfile']['size']</varname> seront initialisés
    (tout comme <varname>$HTTP_POST_FILES</varname> pour les versions
    de &php; antérieure à la 4.1.0). Lorsque
    <link linkend="ini.register-globals">register_globals</link> est activé, les variables
    globales concernant les fichiers téléchargés sont aussi
    initialisées. Chacune d'entre elle contiendra un tableau
    numériquement indexé, avec les valeurs décrivant les fichiers
    téléchargés.
   </simpara>
   <simpara>
    Par exemple, supposons que les fichiers 
    <filename>/home/test/review.html</filename> et
    <filename>/home/test/xwp.out</filename> ont été téléchargés. Dans ce cas,
    <varname>$_FILES['userfile']['name'][0]</varname>
    contient <filename>review.html</filename> et
    <varname>$_FILES['userfile']['name'][1]</varname> contient
    <filename>xwp.out</filename>. Similairement, 
    <varname>$_FILES['userfile']['size'][0]</varname> va contenir
    la taille du fichier <filename>review.html</filename>, etc.
   </simpara>
   <simpara>
    <varname>$_FILES['userfile']['name'][0]</varname>,
    <varname>$_FILES['userfile']['tmp_name'][0]</varname>,
    <varname>$_FILES['userfile']['size'][0]</varname> et
    <varname>$_FILES['userfile']['type'][0]</varname> sont aussi 
    créées.
   </simpara>
  </sect1>
  
  <sect1 id="features.file-upload.put-method">
   <title>Chargement par méthode PUT </title>
   <simpara>
    Le support de la méthode PUT a été modifié entre &php; 3 et &php; 4.
    En &php; 4, il faut utiliser le flux d'entrée standard pour recevoir
    le contenu du fichier.
   </simpara>
   <para>
    <example>
     <title>Sauver un fichier par méthode PUT en &php; 4</title>
     <programlisting role="php">
<![CDATA[
<?php
/* Les données via la méthode PUT arrivent dans le flux stdin */
$putdata = fopen("php://stdin", "r");

/* Ouvre un fichier pour écriture */
$fp = fopen("myputfile.ext", "w");

/* Lit les données par bloc de 1ko 
   et les écrit dans le fichier */
while ($data = fread($putdata, 1024)) {
    fwrite($fp, $data);
}

/* Ferme les flux */
fclose($fp);
fclose($putdata);
?>
]]>
     </programlisting>
    </example>
   </para>
   <note>
    <para>
     Toute la documentation ci-dessous s'applique à &php; 3 uniquement.
    </para>
   </note>
   <para>
    &php; supporte la méthode HTTP PUT utilisée par
    les navigateurs tels que <productname>Netscape Composer</productname>
    et <productname>Amaya</productname> du W3C. Les
    requêtes de type PUT sont beaucoup plus simples que
    les chargements de fichiers, et elles ressemblent à :
    <example>
     <title>Méthode PUT pour les chargements de fichiers</title>
     <programlisting role="HTTP">
<![CDATA[
PUT /path/filename.html HTTP/1.1
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Normalement, cela signifie que le client distant va sauver
    les données qui suivent dans le fichier : <filename>/path/filename.html</filename>
    de votre disque. Ce n'est évidemment pas très
    sécurisé de laisser Apache ou &php; écraser n'importe
    quel fichier de l'arborescence. Pour éviter ceci, il faut d'abord
    dire au serveur que vous voulez qu'un script &php; donné gère
    la requête. Avec Apache, il y a une directive pour cela :
    <emphasis>Script</emphasis>. Elle peut être placée
    n'importe où dans le fichier de configuration d'Apache.
    En général, les webmestres la place dans le bloc
    <literal>&lt;Directory&gt;</literal>, ou peut être dans le bloc 
    <literal>&lt;Virtualhost&gt;</literal>.
    La ligne suivante fera très bien l'affaire :
    <example>
     <title>Directive Apache pour le chargement par méthode PUT</title>
     <programlisting>
 <![CDATA[
Script PUT /put.php
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Elle indique à Apache qu'il doit envoyer les requêtes
    de chargement par méthode PUT au script 
    <filename>put.php</filename>. Bien entendu,
    cela présuppose que vous avez activé &php; pour qu'il
    prenne en charge les fichiers de type <filename>.php</filename>,
    et que &php; est actif.
   </simpara>
   <simpara>
    Dans le fichier <filename>put.php</filename>, vous pouvez mettre ceci :
   </simpara>
   <para>
    <example>
     <title>Réception d'un fichier par méthode PUT</title>
     <programlisting role="php">
<![CDATA[
<?php
copy($PHP_UPLOADED_FILE_NAME, $DOCUMENT_ROOT . $REQUEST_URI);
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Ce script va copier le fichier chargé par le client distant
    à l'endroit désiré. Vous aurez probablement
    à effectuer quelques tests et l'identification de 
    l'utilisateur, avant d'effectuer cette copie. Le seul piège
    est que lorsque &php; reçoit un chargement par méthode PUT,
    il va enregistrer le fichier dans le dossier temporaire, tout comme
    avec la
    <link linkend="features.file-upload.post-method">méthode POST</link>.
    A la fin de la requête, le fichier sera effacé. Ce qui
    fait que ce script doit placer le fichier chargé quelque part.
    Le nom du fichier temporaire est placé dans la variable
    globale <varname>$PHP_PUT_FILENAME</varname>, et la destination prévue est
    placée dans <varname>$REQUEST_URI</varname> (ces noms peuvent
    changer d'une configuration d'Apache à l'autre). Cette destination
    est celle qui est demandée par le client, et vous n'avez pas
    à obéir aveuglément au client. Vous pourriez
    par exemple, déplacer le fichier dans un dossier de chargement.
  </simpara>
 </sect1>
 
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
