<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.18 $ -->
 <chapter id="features.file-upload">
  <title>Gestion des chargements de fichier</title>
  <sect1 id="features.file-upload.post-method">
   <title>Chargements de fichiers par m&eacute;thode POST </title>
   <simpara>
     PHP est capable de recevoir des fichiers &eacute;mis par
     un navigateur conforme &agrave; la norme RFC-1867
     (c'est-&agrave;-dire Netscape Navigator 3 ou sup&eacute;rieur, Microsoft
     Internet Explorer 3 avec un patch de Microsoft, ou sup&eacute;rieur
     sans le patch). Cette fonctionnalit&eacute; permet de charger des
     fichiers textes ou binaires. Avec l'authentification et les fonctions
     de manipulation des fichiers, vous avez un contr&ocirc;le total
     sur le chargement et la gestion des fichiers charg&eacute;s.
   </simpara>
   <note>
    <title>Notes de configuration</title>
    <para>
     Voir aussi les directives 
     <link linkend="ini.file-uploads">file_uploads</link>, 
     <link linkend="ini.upload-max-filesize">upload_max_filesize</link>,
     <link linkend="ini.upload-tmp-dir">upload_tmp_dir</link> et
     <link linkend="ini.post-max-size">post_max_size</link>, dans &php.ini;
    </para>
   </note>
   <para>
     Notez bien que PHP supporte aussi le chargement par la
     m&eacute;thode PUT comme dans le navigateur Netscape Composer
     et les clients Amaya du W3C. Reportez-vous au chapitre sur le
     <link linkend="features.file-upload.put-method">support de la
     m&eacute;thode PUT</link>.
   </para>
   <para>
    Un &eacute;cran de chargement de fichiers peut &ecirc;tre constitu&eacute;
    en cr&eacute;ant un formulaire de la mani&egrave;re suivante :
    <example>
     <title>Formulaire de chargement de fichier</title>
     <programlisting role="html">
 <![CDATA[
<FORM ENCTYPE="multipart/form-data" ACTION="_URL_" METHOD="POST">
<INPUT TYPE="hidden" name="MAX_FILE_SIZE" value="1000">
Envoyez ce fichier : <INPUT NAME="userfile" TYPE="file">
<INPUT TYPE="submit" VALUE="Send File">
</FORM>
]]>
     </programlisting>
    </example>
      Le param&egrave;tre _URL_ doit pointer sur un fichier PHP.
      L'option MAX_FILE_SIZE cach&eacute;e doit pr&eacute;c&eacute;der
      le nom du fichier &agrave; charger, et repr&eacute;sente la taille
      maximale du  fichier &agrave; charger. La valeur est donn&eacute;e
      en octets. Dans ce script, les valeurs suivantes doivent &ecirc;tre
      d&eacute;finies pour assurer un chargement correct.
   </para>
    <warning>
     <para>
      Le champ MAX_FILE_SIZE est l&agrave; &agrave; titre de conseil au navigateur.
      Il est tr&egrave;s facile de contourner cette restriction. Ne comptez pas
      sur le respect de cette configuration par le navigateur! La configuration
      de &php; sur la taille maximale &agrave; respecter (<link linkend="ini.upload-max-filesize">upload_max_filesize</link>)
      ne peut &ecirc;tre contourn&eacute;e, elle.
     </para>
    </warning>
   <para>
    Les variables d&eacute;finies apr&egrave;s un t&eacute;l&eacute;chargement de fichiers diff&egrave;rent
    beaucoup de version en version. La variable 
    <link linkend="reserved.variables.files">$_FILES</link>
    existe depuis PHP 4.1.0. Le tableau <varname>$HTTP_POST_FILES</varname>
    existe depuis PHP 4.0.0. Ces tableaux contiennent toutes les donn&eacute;es
    sur les fichiers t&eacute;l&eacute;charg&eacute;s. L'utilisation de la variable <varname>$_FILES</varname>
    est recommand&eacute;e. Si la directive &php; 
    <link linkend="ini.register-globals">register_globals</link> vaut
    <emphasis>on</emphasis>, les variables reli&eacute;es existeront aussi.
    <link linkend="ini.register-globals">register_globals</link> 
    vaut par d&eacute;faut <emphasis>off</emphasis> depuis &php; 
    <ulink url="&url.php.release4.2.0;">4.2.0</ulink>.
   </para>
   <para>
    Le contenu du tableau <link linkend="reserved.variables.files">$_FILES</link>
    est d&eacute;taill&eacute; dans notre exmple ci-dessous. Notez que l'un suppose que le nom
    de la variable du fichier t&eacute;l&eacute;charg&eacute; est <emphasis>userfile</emphasis>, tel que
    d&eacute;fini dans le formulaire ci-dessus.
    <variablelist>
     <varlistentry>
      <term><varname>$_FILES['userfile']['name']</varname></term>
      <listitem>
       <para>
        Le nom original du fichier, tel que sur la machine du client web.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>$_FILES['userfile']['type']</varname></term>
      <listitem>
       <para>
        Le type MIME du fichier, si le navigateur a fourni cette information.
        Par exemple, cela pourra &ecirc;tre <literal>"image/gif"</literal>.
        </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>$_FILES['userfile']['size']</varname></term>
      <listitem>
       <para>
        La taille, en octets, du fichier t&eacute;l&eacute;charg&eacute;.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>$_FILES['userfile']['tmp_name']</varname></term>
      <listitem>
       <para>
        Le nom temporaire du fichier qui sera charg&eacute; sur la machine serveur.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>$_FILES['userfile']['error']</varname></term>
      <listitem>
       <para>
        Le code d'erreur <link linkend="features.file-upload.errors">error code</link>
        associa&eacute; au t&eacute;l&eacute;chargement de fichier. <emphasis>['error']</emphasis>
        a &eacute;t&eacute; introduit en PHP 4.2.0
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
   <note>
    <para>
     Dans les versions de &php; ant&eacute;rieure &agrave; la version 4.1.0, la variable
     <varname>$_FILES</varname> s'appelait <varname>$HTTP_POST_FILES</varname> et 
     ce n'&eacute;tait pas une variable 
     <link linkend="language.variables.superglobals">autoglobale</link> 
     comme l'est <varname>$_FILES</varname>. PHP 3 ne supporte pas
     <varname>$HTTP_POST_FILES</varname>.
    </para>
   </note>
   <para>
    Lorsque <link linkend="ini.register-globals">register_globals</link>
    vaut <emphasis>on</emphasis> dans le &php.ini;, des variables suppl&eacute;mentaires
    sont rendues disponibles. Par exemple 
    <varname>$userfile_name</varname> vaut 
    <varname>$_FILES['userfile']['name']</varname>,
    <varname>$userfile_type</varname> vaut 
    <varname>$_FILES['userfile']['type']</varname>, etc...  Gardez &agrave; l'esprit
    que depuis &php; 4.2.0, <link linkend="ini.register-globals">register_globals</link> 
    vaut <emphasis>off</emphasis> par d&eacute;faut. Il n'est pas prudent de
    supposer que cette directive vaut <emphasis>on</emphasis>.
   </para>
   <para>
    Le fichier t&eacute;l&eacute;charg&eacute; sera stock&eacute; temporairement dans le dossier
    temporaire du syst&egrave;me, &agrave; moins qu'un autre dossier soit fourni avec
    la directive <link linkend="ini.upload-tmp-dir">upload_tmp_dir</link> du
    &php.ini;. Le dossier par d&eacute;faut du serveur peut &ecirc;tre chang&eacute;
    dans l'environnement via la variable <envar>TMPDIR</envar>.
    Modifier la valeur de cette variable avec la fonction <function>putenv</function>
    dans un script &php; sera sans effet. Cette variable d'environnement
    peut aussi &ecirc;tre utilis&eacute;e pour s'assurer que d'autres op&eacute;rations
    fonctionnent aussi sur les fichiers t&eacute;l&eacute;charg&eacute;s.
    <example>
     <title>Validation de t&eacute;l&eacute;chargement de fichiers</title>
     <para>
      Les exemples ci-dessous sont valables avec les versions de &php;
      plus r&eacute;centes que la 4.0.2. Voyez les fonctions
      <function>is_uploaded_file</function> et
      <function>move_uploaded_file</function>.
     </para>
     <programlisting role="php">
<![CDATA[
<?php 
// En PHP < 4.1.0, $HTTP_POST_FILES doit &ecirc;tre utilis&eacute; 
//    &agrave; la place de $_FILES.
// En PHP plus ancien que 4.0.3, utilisez copy() et is_uploaded_file() 
//    &agrave; la place de move_uploaded_file

$uploaddir = '/var/www/uploads/';

print "<pre>";
if (move_uploaded_file($_FILES['userfile']['tmp_name'], $uploaddir . $_FILES['userfile']['name'])) {
    print "Le fichier est valide, et a &eacute;t&eacute; t&eacute;l&eacute;charg&eacute; 
           avec succ&egrave;s. Voici plus d'informations :\n";
    print_r($_FILES);
} else {
    echo "Attaque par upload potentielle. Voici plus d'informations :\n";
    print_r($_FILES);
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Le script PHP qui re&ccedil;oit le fichier charg&eacute; doit pouvoir
    g&eacute;rer le fichier de mani&egrave;re appropri&eacute;e. Vous
    pouvez utiliser la variable <varname>$file_size</varname> pour recaler
    tous les fichiers qui sont trop gros ou trop petits. Vous pouvez utiliser
    la variable <varname>$file_type</varname> pour recaler les fichiers qui
    n'ont pas le bon type. Quelques soient les actions, ce script doit pouvoir
    supprimer le fichier du dossier temporaire, ou le d&eacute;placer ailleurs.
    Depuis &php; 4.2.0, vous pouvez utiliser l'information dans 
    <varname>$_FILES['userfile']['error']</varname> et adapter votre politique
    en fonction des <link linkend="features.file-upload.errors">code d'erreur</link>.
    Quelque soit votre politique, vous devriez soit effacer le fichier du
    dossier temporaire, soit le d&eacute;placer.
   </simpara>
   <simpara>
    Le fichier sera automatiquement effac&eacute; du fichier temporaire
    &agrave; la fin du script, s'il n'a pas &eacute;t&eacute;
    d&eacute;plac&eacute; ou renomm&eacute;.
   </simpara>
  </sect1>

  <sect1 id="features.file-upload.errors">
   <title>Explication sur les messages d'erreurs de chargement de fichiers</title>
   <simpara>
    Depuis PHP 4.2.0, &php; retourne un code d'erreur appropri&eacute; dans le
    tableau de fichiers. Ce code d'erreur est accessible &agrave; l'index
    <emphasis>error</emphasis> du tableau, qui est cr&eacute;&eacute; durant
    le t&eacute;l&eacute;chargement, par &php;. En d'autres termes, le message d'erreur
    est accessible dans la variable <varname>$_FILES['userfile']['error']</varname>.
   </simpara>
   <para>
    <variablelist>
     <varlistentry>
      <term><varname>UPLOAD_ERR_OK</varname></term>
      <listitem>
       <para>
        Valeur : 0. Aucune erreur, le t&eacute;l&eacute;chargement est correct.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>UPLOAD_ERR_INI_SIZE</varname></term>
      <listitem>
       <para>
        Valeur : 1. Le fichier t&eacute;l&eacute;charg&eacute; exc&egrave;de la taille de
        <link linkend="ini.upload-max-filesize">upload_max_filesize</link>,
        configur&eacute; dans le &php.ini;.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>UPLOAD_ERR_FORM_SIZE</varname></term>
      <listitem>
       <para>
        Valeur : 2. Le fichier t&eacute;l&eacute;charg&eacute; exc&egrave;de la taille de
        <emphasis>MAX_FILE_SIZE</emphasis>, qui a &eacute;t&eacute; sp&eacute;cifi&eacute;e dans
        le formulaire HTML.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>UPLOAD_ERR_PARTIAL</varname></term>
      <listitem>
       <para>
        Valeur : 3. Le fichier n'a &eacute;t&eacute; que partiellement t&eacute;l&eacute;charg&eacute;.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>UPLOAD_ERR_NO_FILE</varname></term>
      <listitem>
       <para>
        Valeur : 4. Aucun fichier n'a &eacute;t&eacute; t&eacute;l&eacute;charg&eacute;.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
   <note>
    <para>
     Ces constantes sont apparues en PHP 4.3.0.
    </para>
   </note>
  </sect1>
  <sect1 id="features.file-upload.common-pitfalls">
   <title>Erreurs classiques</title>
   <simpara>
    La variable MAX_FILE_SIZE ne peut pas sp&eacute;cifier une taille
    de fichier plus grande que la taille qui a &eacute;t&eacute;
    fix&eacute;e par upload_max_filesize, dans le fichier <filename>php3.ini</filename>,
    ou par php3_upload_max_filesize dans les directives Apache. La valeur
    par d&eacute;faut est 2 m&eacute;gaoctets.
   </simpara>
   <simpara>
    Ne pas valider les fichiers que vous manipulez peut donner l'acc&egrave;s
    aux utilisateurs &agrave; des fichiers sensibles dans d'autres dossiers!
   </simpara>
   <simpara>
    Attention : il semble que CERN httpd supprime tout ce qui est apr&egrave;s
    le premier caract&egrave;re dans l'en-t&ecirc;te MIME. Tant que c'est le cas,
    CERN httpd ne pourra pas effectuer de chargement.
   </simpara>
  </sect1>
  <sect1 id="features.file-upload.multiple">
   <title>T&eacute;l&eacute;charger plusieurs fichiers simultan&eacute;ment</title>
   <simpara>
    Le t&eacute;l&eacute;chargement de plusieurs fichiers  est possible
    en utilisant des noms diff&eacute;rents dans l'attribut
    <literal>name</literal> de la balise <literal>input</literal>.
   </simpara>
   <simpara>
    Il est aussi possible de t&eacute;l&eacute;charger plusieurs fichiers simultan&eacute;ment
    et d'obtenir les informations sous forme de tableau. Pour cela, vous
    devez utiliser la syntaxe de tableau dans les noms de balises
    HTML, comme vous l'avez fait avec les s&eacute;lections multiples 
    et les bo&icirc;tes &agrave; cocher.
   </simpara>
   <note>
    <para>
     Le support des t&eacute;l&eacute;chargement multiples a &eacute;t&eacute; ajout&eacute;
     en &php; 3.0.10.
    </para>
   </note>
   <para>
    <example>
     <title>T&eacute;l&eacute;charger plusieurs fichiers simultan&eacute;ment</title>
     <programlisting role="html">
<![CDATA[
<FORM ACTION="file-upload.php" METHOD="post" ENCTYPE="multipart/form-data">
  Envoyez plusieurs fichiers : <BR>
  <INPUT NAME="userfile[]" TYPE="file"><BR>
  <INPUT NAME="userfile[]" TYPE="file"><BR>
  <INPUT TYPE="submit" VALUE="Send files">
</FORM>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Lorsque le formulaire ci-dessus a &eacute;t&eacute; envoy&eacute;, les 
    tableaux <varname>$_FILES['userfile']</varname>,
    <varname>$_FILES['userfile']['name']</varname>, et
    <varname>$_FILES['userfile']['size']</varname> seront initialis&eacute;s
    (tout comme <varname>$HTTP_POST_FILES</varname> pour les versions
    de &php; ant&eacute;rieure &agrave; la 4.1.0). Lorsque
    <literal>register_globals</literal> est activ&eacute;, les variables
    globales concernant les fichiers t&eacute;l&eacute;charg&eacute;s sont aussi
    initialis&eacute;es. Chacune d'entre elle contiendra un tableau
    num&eacute;riquement index&eacute;, avec les valeurs d&eacute;crivant les fichiers
    t&eacute;l&eacute;charg&eacute;s.
   </simpara>
   <simpara>
    Par exemple, supposons que les fichiers 
    <filename>/home/test/review.html</filename> et
    <filename>/home/test/xwp.out</filename> ont &eacute;t&eacute; t&eacute;l&eacute;charg&eacute;. Dans ce cas,
    <varname>$_FILES['userfile']['name'][0]</varname>
    contient <filename>review.html</filename> et
    <varname>$_FILES['userfile']['name'][1]</varname> contient
    <filename>xwp.out</filename>. Similairement, 
    <varname>$_FILES['userfile']['size'][0]</varname> va contenir
    la taille du fichier <filename>review.html</filename>, etc...
   </simpara>
   <simpara>
    <varname>$_FILES['userfile']['name'][0]</varname>,
    <varname>$_FILES['userfile']['tmp_name'][0]</varname>,
    <varname>$_FILES['userfile']['size'][0]</varname> et
    <varname>$_FILES['userfile']['type'][0]</varname> sont aussi 
    cr&eacute;&eacute;es.
   </simpara>
  </sect1>
  <sect1 id="features.file-upload.put-method">
   <title>Chargement par m&eacute;thode PUT </title>
   <simpara>
    Le suppor de la m&eacute;thode PUT a &eacute;t&eacute; modifi&eacute; entre PHP 3 et PHP 4.
    En PHP 4, il faut utiliser le flux d'entr&eacute;e standard pour recevoir
    le contenu du fichier.
   </simpara>
   <para>
    <example>
     <title>Sauver un fichier par m&eacute;thode PUT en PHP 4</title>
     <programlisting role="php">
<![CDATA[
<?php
/* Les donn&eacute;es via la m&eacute;thode PUT arrivent dans stdin */
$putdata = fopen("php://stdin","r");

/* Ouvre un fichier pour &eacute;criture */
$fp = fopen("myputfile.ext","w");

/* Lit les donn&eacute;es par bloc de 1ko 
   et les &eacute;crit dans le fichier */
while ($data = fread($putdata,1024))
  fwrite($fp,$data);

/* Ferme les flux */
fclose($fp);
fclose($putdata);
?>
]]>
     </programlisting>
    </example>
   </para>
   <note>
    <para>
     Toute la documentation ci-dessous s'applique &agrave; &php; 3 uniquement.
    </para>
   </note>
   <para>
     PHP supporte la m&eacute;thode HTTP PUT utilis&eacute;e par
     les navigateurs tels que Netscape Composer et W3C Amaya. Les
     requ&ecirc;tes de type PUT sont beaucoup plus simples que
     les chargements de fichiers, et elles ressemblent &agrave; :
    <informalexample>
     <programlisting role="HTTP">
PUT /path/filename.html HTTP/1.1
     </programlisting>
    </informalexample>
   </para>
   <para>
    Normalement, cela signifie que le client distant va sauver
    les donn&eacute;es qui suivent dans le fichier: <filename>/path/filename.html</filename>
    de votre disque. Ce n'est &eacute;videmment pas tr&egrave;s
    s&eacute;curis&eacute; de laisser Apache ou PHP &eacute;craser n'importe
    quel fichier de l'arborescence. Pour &eacute;viter ceci, il faut d'abord
    dire au serveur que vous voulez qu'un script PHP donn&eacute; g&egrave;re
    la requ&ecirc;te. Avec Apache, il y a une directive pour cela :
    <emphasis>Script</emphasis>. Elle peut &ecirc;tre plac&eacute;e
    n'importe o&ugrave; dans le fichier de configuration d'Apache.
    En g&eacute;n&eacute;ral, les webmestres la place dans le bloc
    &lt;Directory&gt;, ou peut &ecirc;tre dans le bloc &lt;Virtualhost&gt;.
    La ligne suivante fera tr&egrave;s bien l'affaire :
    <informalexample>
     <programlisting>
Script PUT /put.php3
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Elle indique &agrave; Apache qu'il doit envoyer les requ&ecirc;tes
    de chargement par m&eacute;thode PUT au script 
    <filename>put.php3</filename>. Bien entendu,
    cela pr&eacute;suppose que vous avez activ&eacute; PHP pour qu'il
    prenne en charge les fichiers de type .php3, et que PHP est actif.
   </simpara>
   <simpara>
    Dans le fichier <filename>put.php3</filename>, vous pouvez mettre ceci :
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
 <![CDATA[
<?php
 copy($PHP_UPLOADED_FILE_NAME,$DOCUMENT_ROOT.$REQUEST_URI);
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Ce script va copier le fichier charg&eacute; par le client distant
    &agrave; l'endroit d&eacute;sir&eacute;. Vous aurez probablement
    &agrave; effectuer quelques tests et des authentifications
    d'utilisateur, avant d'effectuer cette copie. Le seul pi&egrave;ge
    est que lorsque PHP re&ccedil;oit un chargement par m&eacute;thode PUT,
    il va enregistrer le fichier dans le dossier temporaire, tout comme
    avec la
    <link linkend="features.file-upload.post-method">m&eacute;thode POST</link>.
    A la fin de la requ&ecirc;te, le fichier sera effac&eacute;. Ce qui
    fait que ce script doit placer le fichier charg&eacute; quelque part.
    Le nom du fichier temporaire est plac&eacute; dans la variable
    globale <varname>$PHP_PUT_FILENAME</varname>, et la destination pr&eacute;vue est
    plac&eacute;e dans <varname>$REQUEST_URI</varname> (ces noms peuvent
    changer d'une configuration d'Apache &agrave; l'autre). Cette destination
    est celle qui est demand&eacute;e par le client, et vous n'avez pas
    &agrave; ob&eacute;ir aveugl&eacute;ment au client. Vous pourriez
    par exemple, d&eacute;placer le fichier dans un dossier de chargement.
  </simpara>
 </sect1>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
