<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.16 $ -->
 <chapter id="functions">
  <title>Les fonctions</title>
  <sect1 id="functions.user-defined">
   <title>Les fonctions</title>
   <para>
    Une fonction peut &ecirc;tre d&eacute;finie en utilisant la syntaxe suivante :
    <example>
    <title>D&eacute;finition d'une fonction</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo ($arg_1, $arg_2, ..., $arg_n) {
    echo "Exemple de fonction.\n";
    return $retval;
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Tout code &php;, correct syntaxiquement, peut appara&icirc;tre
    dans une fonction et dans une d&eacute;finition de
    <link linkend="keyword.class">classe</link>.
   </simpara>
   <simpara>
    En &php; 3, les fonctions doivent &ecirc;tre d&eacute;finies avant
    qu'elles ne soient utilis&eacute;es. Ce n'est plus le cas en &php; 4.
   </simpara>
   <para>
    Lorsqu'une fonction est d&eacute;finie de mani&egrave;re conditionnelle, comme dans
    les exemples ci-dessous, leur d&eacute;finition doit <emphasis>pr&eacute;c&eacute;der</emphasis>
    leur utilisation.
    <example>
     <title>Fonctions conditionnelles</title>
     <programlisting role="php">
<![CDATA[
<?php

$makefoo = true;

/* Impossible d'appeler foo() ici,
   car cette fonction n'existe pas.
   Mais nous pouvons utiliser bar() */

bar();

if ($makefoo) {
  function foo ()
  {
    echo "Je n'existe pas tant que le programme n'est pas pass&eacute; ici.\n";
  }
}

/* Maitenant, nous pouvons appeler foo()
   car $makefoo est maintenant vrai */

if ($makefoo) foo();

function bar() {
{
  echo "J'existe d&egrave;s de d&eacute;but du programme.\n";
}

?>
]]>
     </programlisting>
    </example>
    <example>
     <title>Fonctions dans une autre fonctions</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo() 
{
  function bar() 
  {
    echo "Je n'existe pas tant que foo() n'est pas appel&eacute;.\n";
  }
}

/* Impossible d'appeler bar() ici
   car il n'existe pas. */

foo();

/* Maintenant, nous pouvons appeler bar(),
   car l'utilisation de foo() l'a rendu
   accessible. */

bar();

?>  
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    &php; ne supporte pas le surchargement de fonction, ni la destruction ou la
    red&eacute;finition de fonctions d&eacute;j&agrave; d&eacute;clar&eacute;es.
   </simpara>
   <simpara>
    &php; 3 ne supporte pas un nombre variable d'arguments (voir
    <link linkend="functions.arguments.default">valeurs par d&eacute;fault d'arguments</link>
    pour plus d'informations).
    &php; 4 supporte les deux : voir <link linkend="functions.variable-arg-list">
    liste variable d'arguments de fonction</link> et les fonctions
    de r&eacute;f&eacute;rences que sont <function>func_num_args</function>,
    <function>func_get_arg</function>, et
    <function>func_get_args</function> pour plus d'informations.
   </simpara>
  </sect1>
  <sect1 id="functions.arguments">
   <title>Les arguments de fonction</title>
   <simpara>
     Des informations peuvent &ecirc;tre pass&eacute;es &agrave;
     une fonction en utilisant un tableau d'arguments, dont chaque
     &eacute;l&eacute;ment est s&eacute;par&eacute; par une virgule.
     Un &eacute;l&eacute;ment peut &ecirc;tre une variable ou une constante.
   </simpara>
   <para>
     &php; supporte le passage d'arguments <link linkend="functions.arguments.default">
     par valeur</link> (m&eacute;thode par d&eacute;faut),
     <link linkend="functions.arguments.by-reference">par r&eacute;f&eacute;rence</link>.
     Les listes variables d'arguments sont support&eacute;es par &php; 4
     et les versions plus r&eacute;centes. Voir
     <link linkend="functions.variable-arg-list">liste variable d'arguments de fonction</link>
     et les fonctions utiles que sont <function>func_num_args</function>,
     <function>func_get_arg</function>, et <function>func_get_args</function>.
     Fonctionnellement, on peut arriver au m&ecirc;me r&eacute;sultat en passant
     un tableau comme argument :
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
function takes_array($input) {
    echo "$input[0] + $input[1] = ", $input[0]+$input[1];
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <sect2 id="functions.arguments.by-reference">
    <title>Passage d'arguments par r&eacute;f&eacute;rence</title>
    <simpara>
       Par d&eacute;faut, les arguments sont pass&eacute;s
       &agrave; la fonction par valeur (donc vous pouvez
       changer la valeur d'un argument dans la fonction, cela ne
       change pas sa valeur &agrave; l'ext&eacute;rieur de la
       fonction). Si vous voulez que vos fonctions puissent
       changer la valeur des arguments, vous devez passer ces
       arguments par r&eacute;f&eacute;rence.
    </simpara>
    <para>
       Si vous voulez qu'un argument soit toujours pass&eacute;
       par r&eacute;f&eacute;rence, vous pouvez ajouter un '&amp;'
       devant l'argument dans la d&eacute;claration de la fonction :
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
function add_some_extra(&$string) {
    $string .= ', et un peu plus.';
}
$str = 'Ceci est une cha&icirc;ne';
add_some_extra($str);
echo $str;    // affiche 'Ceci est une cha&icirc;ne, et un peu plus.'
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
      Si vous souhaitez passer une variable par
      r&eacute;f&eacute;rence &agrave; une fonction mais de
      mani&egrave;re ponctuelle, vous pouvez ajouter un '&amp;'
      devant l'argument dans l'appel de la fonction:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
function foo ($bar) {
    $bar .= ', et un peu plus.';
}
$str = Ceci est une cha&icirc;ne';
foo ($str);
echo $str;    // affiche 'Ceci est une cha&icirc;ne'
foo (&$str);
echo $str;    // affiche 'Ceci est une cha&icirc;ne, et un peu plus.'
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </sect2>
   <sect2 id="functions.arguments.default">
    <title>Valeur par d&eacute;faut des arguments</title>
    <para>
       Vous pouvez d&eacute;finir comme en C++ des valeurs par
       d&eacute;faut pour les arguments de type scalaire :
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
function servir_apero ($type = "ricard") {
    return "Servir un verre de $type.\n";
}
echo servir_apero();
echo servir_apero("whisky");
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     La fonction ci-dessus affichera :
     <screen>
Servir un verre de ricard.
Servir un verre de whisky.
     </screen>
    </para>
    <simpara>
     La valeur par d&eacute;faut d'un argument doit
     obligatoirement &ecirc;tre une constante, et ne peut &ecirc;tre
     ni une variable, ni un membre de classe.
    </simpara>
    <para>
     Il est &agrave; noter que si vous utilisez des arguments avec
     valeur par d&eacute;faut avec d'autres sans valeur par d&eacute;faut,
     les premiers doivent &ecirc;tre plac&eacute;s &agrave; la suite de tous les param&egrave;tres sans
     valeur par d&eacute;faut. Sinon, cela ne fonctionnera pas.
     Consid&eacute;rons le code suivant :
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
function faireunyaourt ($type = "acidophilus", $flavour) {
    return "Pr&eacute;parer un bol de $type $flavour.\n";
}
echo faireunyaourt ("framboise");   // ne fonctionne pas comme voulu
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     L'affiche du code ci-dessus est le suivant :
     <screen>
Warning: Missing argument 2 in call to faireunyaourt() in
/usr/local/etc/httpd/htdocs/PHP 3test/functest.html on line 41
Pr&eacute;parer un bol de framboise.
     </screen>
    </para>
    <para>
     Maintenant comparons l'exemple pr&eacute;c&eacute;dent avec
     l'exemple suivant :
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
function faireunyaourt ($flavour, $type = "acidophilus") {
    return "Pr&eacute;parer un bol de $type $flavour.\n";
}
echo faireunyaourt ("framboise");   // fonctionne comme voulu
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     L'affichage de cet exemple est le suivant :
     <screen>
Pr&eacute;parer un bol de acidophilus framboise.
     </screen>
    </para>
   </sect2>
   <sect2 id="functions.variable-arg-list">
    <title>Nombre d'arguments variable</title>
    <simpara>
     &php; 4 supporte les fonctions &agrave; nombre d'arguments variable.
     C'est tr&egrave;s simple &agrave; utiliser, avec les fonctions
     <function>func_num_args</function>, <function>func_get_arg</function>,
     et <function>func_get_args</function>.
    </simpara>
    <simpara>
     Aucune syntaxe particuli&egrave;re n'est n&eacute;cessaire, et
     la liste d'argument doit toujours &ecirc;tre fournie
     explicitement avec la d&eacute;finition de la fonction, et se
     comportera normalement.
    </simpara>
   </sect2>
  </sect1>
  <sect1 id="functions.returning-values">
   <title>Les valeurs de retour</title>
   <para>
     Les valeurs sont renvoy&eacute;es en utilisant une
     instruction de retour optionnelle. Tous les types de variables
     peuvent &ecirc;tre renvoy&eacute;s, tableaux et objets compris.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
function carre ($num) {
    return $num * $num;
}
echo carre (4);   // affiche '16'.
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
     Vous ne pouvez pas renvoyer plusieurs valeurs en m&ecirc;me
     temps, mais vous pouvez obtenir le m&ecirc;me r&eacute;sultat
     en renvoyant un tableau.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
function petit_nombre() {
    return array (0, 1, 2);
}
list ($zero, $one, $two) = petit_nombre();
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Pour retourner une r&eacute;f&eacute;rence d'une fonction, utilisez
    l'op&eacute;rateur &amp; aussi bien dans la d&eacute;claration de la fonction que dans
    l'assignation de la valeur de retour.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
function &retourne_reference() {
    return $uneref;
}
$newref =& retourne_reference();
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>
<!--
  <sect1 id="functions.old-syntax">
   <title><literal>old_function</literal></title>
   <simpara>
    L'instruction <literal>old_function</literal> vous permet de
    d&eacute;clarer une fonction en utilisant une syntaxe du type
    PHP/FI2 (au d&eacute;tail pr&egrave;s que vous devez remplacer
    l'instruction 'function' par 'old_function'.)
   </simpara>
   <simpara>
    C'est une fonctionnalit&eacute; obsol&egrave;te et elle ne devrait
    &ecirc;tre utilis&eacute;e que dans le cadre de conversion de
    PHP/FI2 vers &php; 3
   </simpara>
   <warning>
    <para>
     Les fonctions d&eacute;clar&eacute;es comme <literal>old_function</literal>
     ne peuvent pas &ecirc;tre appel&eacute;es &agrave; partir du code
     interne du &php;. Cela signifie, par exemple, que vous ne
     pouvez pas les utiliser avec des fonctions comme <function>usort</function>,
     <function>array_walk</function>, et <function>register_shutdown_function</function>.
     Vous pouvez contourner ce probl&egrave;me en &eacute;crivant une fonction
     d'encapsulation qui appellera la fonction <literal>old_function</literal>.
    </para>
   </warning>
  </sect1>
-->
  <sect1 id="functions.variable-functions">
   <title>Fonctions-variable</title>
   <para>
    &php; supporte le concept de fonctions variables. Cela signifie
    que si le nom d'une variable est suivi de parenth&egrave;ses,
    &php; recherchera une fonction de m&ecirc;me nom,
    et essaiera de l'ex&eacute;cuter. Cela peut servir, entre autre,
    pour faire des fonctions call-back, des tables de fonctions...
   </para>
   <para>
    Les fonctions-variables ne peuvent pas fonctionner avec les
    &eacute;l&eacute;ments de langage comme les <function>echo</function>,
    <function>unset</function>, <function>isset</function>
    et <function>empty</function>. C'est une des diff&eacute;rences majeures
    entre les fonctions &php; et les &eacute;l&eacute;ments de langage.
   </para>
   <para>
    <example>
     <title>Exemple de fonction variable</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo() {
    echo "dans foo()<br>\n";
}
function bar( $arg = '' ) {
    echo "Dans bar(); l'argument &eacute;tait '$arg'.<br>\n";
}
$func = 'foo';
$func();
$func = 'bar';
$func( 'test' );
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Voir aussi
    <function>call_user_func</function>,
    <link linkend="language.variables.variable">les variables variables</link> et 
    <function>function_exists</function>.
   </para>
  </sect1>
  <sect1 id="functions.internal">
   <title>Fonctions internes</title>
   
   <para>
    &php; dispose de nombreuses fonctions et structures standards. Il y a aussi
    des fonctiosn qui requi&egrave;rent des extensions sp&eacute;cifiques de &php;, sans
    lesquelles vous obtiendrez l'erreur fatale <literal>undefined function</literal>.
    Par exemple, pour utiliser les fonctions <link linkend="ref.image">d'images</link>,
    telles que <function>imagecreatetruecolor</function>, vous aurez besoin du
    support de GD dans &php;. Ou bien, pour utiliser 
    <function>mysql_connect</function>, vous aurez besoin de l'extension
    <link linkend="ref.mysql">MySQL</link>. Il y a des fonctiosn de base qui sont
    inclues dans toutes les versiosn de &php;, telles que les fonctions de
    <link linkend="ref.strings">cha&icirc;nes de caract&egrave;res</link> et les fonctions
    de <link linkend="ref.variables">variables</link>. Utilisez 
    <function>phpinfo</function> ou
    <function>get_loaded_extensions</function> pour savoir quelles sont les
    extensions qui sont compil&eacute;es avec votre &php;. Notez aussi que de nombreuses
    extensions sont activ&eacute;es par d&eacute;faut, et que le manuel &php; est
    compartiment&eacute; par extension. Voyez les chapitres de 
    <link linkend="configuration">configuration</link>,  
    <link linkend="installation">installation</link> ainsi que les
    d&eacute;tails particuliers &agrave; chaque extension, pour savoir les mettre en place.
   </para>
   <para>
    Lire et comprendre le prototype d'une fonction est d&eacute;crit dans l'annexe
    <link linkend="about.prototypes">Comment lire la d&eacute;finition d'une 
    fonction (prototype)</link>.
    Il est important de comprendre ce qu'une fonction retourne, ou si une fonction
    travaille directement sur la valeur des param&egrave;tres fournis. Par exemple, 
    <function>str_replace</function> va retourne une cha&icirc;ne modifi&eacute;e, tandis que
    <function>usort</function> travaille directement sur la variable pass&eacute;e en 
    param&egrave;tre. Chaque page du manuel a des informations sp&eacute;cifiques sur chaque
    fonction, comme le nombre de param&egrave;tres, les &eacute;volutions de sp&eacute;cifications,
    les valeurs retourn&eacute;es en cas de succ&egrave;s ou d'&eacute;chec, et la disponibilit&eacute; en fonction
    des versions. Bien conna&icirc;tre ces diff&eacute;rences, parfois subtiles, est cruxial
    pour bien coder en &php;.
   </para>
   <para>
    Voir aussi
    <function>function_exists</function>, 
    <link linkend="funcref">l'index des fonctions</link>,
    <function>get_extension_funcs</function> et 
    <function>dl</function>.
   </para>
  </sect1>
 </chapter>
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
indent-tabs-mode:nil
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
