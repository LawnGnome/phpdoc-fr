<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.21 $ -->
<!-- EN-Revision: 1.29 Maintainer: dams Status: ready -->
 <chapter id="language.expressions">
   <title>Les expressions</title>
   <simpara>
    Les expressions sont la partie la plus importante du &php;. En &php;, presque tout
    ce que vous écrivez est une expression. La manière la plus simple
    de définir une expression est : "tout ce qui a une valeur".
   </simpara>
   <simpara>
    Les formes les plus simples d'expressions sont les constantes et les variables.
    Lorsque vous écrivez "<varname>$a</varname> = 5", vous assignez la valeur '5' à la
    variable <varname>$a</varname>. Bien évidemment, '5' vaut 5 ou, en d'autres termes, '5'
    est une expression avec pour valeur 5 (dans ce cas, '5' est un entier constant).
   </simpara>
   <simpara>
    Après cette assignation, vous pouvez considérer que <varname>$a</varname>
    a pour valeur 5 et donc, écrire <varname>$b</varname> = <varname>$a</varname>,
    revient à écrire <varname>$b</varname> = 5.
    En d'autres termes, <varname>$a</varname> est une expression avec une valeur de 5.
    Si tout fonctionne correctement, c'est exactement ce qui arrive.
   </simpara>
   <para>
    Un exemple plus complexe concerne les fonctions. Par exemple, 
    considérons la fonction suivante :
    <example>
     <title>Affectation d'expressions</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo () {
    return 5;
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    En supposant que vous êtes familiers avec le concept de fonction,
    (si ce n'est pas le cas, jetez un oeil au chapitre concernant les 
    <link linkend="language.functions">fonctions</link>),
    vous serez d'accord que <literal>$c = foo()</literal> est équivalent 
    à <literal>$c = 5</literal>, et
    vous aurez tout à fait raison. Les fonctions sont des expressions qui
    ont la valeur de leur "valeur de retour". Si <literal>foo()</literal> renvoie 5,
    la valeur de l'expression '<literal>foo()</literal>' est 5. Habituellement, 
    les fonctions ne font pas que
    renvoyer une valeur constante mais réalisent des traitements.
   </simpara>
   <simpara>
    Bien sûr, les valeurs en &php; n'ont pas à être des
    valeurs numériques, comme c'est souvent le cas. &php; supporte 3
    types de variables scalaires : les valeurs entières <type>integer</type>, les nombres
    à virgule flottante <type>float</type>, les chaînes de caractères <type>string</type>
    et les booléens <type>boolean</type>.
    (une variable scalaire est une variable que vous ne pouvez pas scinder en
    morceaux, au contraire des tableaux par exemple). &php; supporte aussi deux
    types composés : les tableaux et les objets. Chacun de ces types
    de variables peut être affecté ou renvoyé par une
    fonction.
   </simpara>
   <simpara>
    Les utilisateurs de &php;/FI 2 ne verront aucun changement. Malgré tout,
    &php; va plus loin dans la gestion des expressions, comme le font d'autres
    langages. &php; est un langage orienté expression, dans le sens où
    presque tout est une expression. Considérons l'exemple dont nous avons
    déjà parlé, '<varname>$a</varname> = 5'. Il est facile de voir qu'il y a
    deux valeurs qui entrent en jeu ici, la valeur numérique constante '5'
    et la valeur de la variable <varname>$a</varname> qui est mise à jour à la valeur 5.
    Mais, la vérité est qu'il y a une autre valeur qui entre en jeu ici
    et c'est la valeur de l'assignation elle-même. L'assignation elle-même
    est assignée à une valeur, dans ce cas-là 5. En pratique,
    cela signifie que '<varname>$a</varname> = 5' est une expression qui a pour valeur 5. Donc,
    écrire '<varname>$b</varname> = (<varname>$a</varname> = 5)' revient à écrire '<varname>$a</varname> = 5; <varname>$b</varname> = 5;'
    (un point virgule marque la fin d'une instruction). Comme les assignations sont
    analysées de droite à gauche, vous pouvez aussi bien écrire
    '<varname>$b</varname> = <varname>$a</varname> = 5'.
   </simpara>
   <simpara>
    Un autre bon exemple du langage orienté expression est la
    pre-incrémentation et la post-incrémentation, (ainsi que
    la décrémentation). Les utilisateurs de &php;/FI 2
    et ceux de nombreux autres langages sont habitués à
    la notation "<literal>variable++</literal>" et "<literal>variable--</literal>".
    Ce sont les <link linkend="language.operators.increment">opérateurs
    d'incrémentation et de décrémentation</link>. En &php;/FI 2,
    l'instruction '<varname>$a</varname>++' n'a aucune valeur (c'est-à-dire que ce n'est pas
    une expression) et vous ne pouvez donc pas l'utiliser. &php; ajoute les
    possibilités d'incrémentation et de décrémentation
    comme c'est le cas dans le langage C. En &php;, comme en C, il y a deux types
    d'opérateurs d'incrémentation (pre-incrémentation et
    post-incrémentation). Les deux types d'opérateur
    d'incrémentation jouent le même rôle (c'est-à-dire qu'ils
    incrémentent la variable). La différence vient de la valeur de
    l'opérateur d'incrémentation. L'opérateur de
    pre-incrémentation, qui s'écrit '++<varname>$variable</varname>', évalue
    la valeur incrémentée (&php; incrémente la variable
    avant de lire la valeur de cette variable, d'où le nom de
    pre-incrémentation). L'opérateur de post-incrémentation,
    qui s'écrit '<varname>$variable</varname>++', évalue la valeur de la variable
    avant de l'incrémenter (&php; incrémente la variable après
    avoir lu sa valeur, d'où le nom de post-incrémentation).
   </simpara>
   <simpara>
    Un type d'expression très commun est l'expression de comparaison. Ces expressions
    sont évaluées à 0 ou 1, autrement dit &false; ou &true; (respectivement). &php; supporte
    les opérateurs de comparaison &gt; (plus grand que), =&gt;  (plus grand ou égal),
    == (égal à), &lt; (plus petit que), &lt;= (plus petit ou égal). Ces expressions sont
    utilisées de manière courante dans les instructions conditionnelles, comme l'instruction
    <literal>if</literal>.
   </simpara>
   <simpara>
    Pour le dernier exemple d'expression, nous allons parler des combinaisons
    d'opérateurs/assignation. Vous savez que si vous voulez incrémenter la variable
    <varname>$a</varname> d'une unité, vous devez simplement écrire '<varname>$a</varname>++'. Mais si vous voulez ajouter
    la valeur '3' à votre variable ? Vous pouvez écrire plusieurs fois '<varname>$a</varname>++', mais ce
    n'est pas la meilleure des méthodes. Un pratique plus courante est d'écrire
    '<varname>$a</varname> = <varname>$a</varname> + 3'. L'expression '<varname>$a</varname> + 3' correspond à la valeur <varname>$a</varname> plus 3, et est
    de nouveau assignée à la variable <varname>$a</varname>. Donc, le résultat est
    l'incrémentation de 3 unités. En &php;, comme dans de nombreux autres
    langages comme le C, vous pouvez écrire cela de manière plus concise,
    manière qui avec le temps se révélera plus claire et plus rapide
    à comprendre. Ajouter 3 à la valeur de la variable <varname>$a</varname>
    peut s'écrire '<varname>$a</varname> += 3'. Cela signifie précisément : "on prend la valeur
    de la variable <varname>$a</varname>, on ajoute la valeur 3 et on assigne cette valeur à
    la variable <varname>$a</varname>". Et pour être plus concis et plus clair, cette expression est
    plus rapide. La valeur de l'expression '<varname>$a</varname> += 3', comme l'assignation d'une valeur
    quelconque, est la valeur assignée. Il est à noter que ce n'est pas 3 mais la
    combinaison de la valeur de la variable <varname>$a</varname> plus la valeur 3. (c'est la valeur qui
    est assignée à la variable <varname>$a</varname>). N'importe quel opérateur binaire
    peut utiliser ce type d'assignation, par exemple '<varname>$a</varname> -= 5' (soustraction de 5 de
    la valeur de la variable <varname>$a</varname>), '<varname>$b</varname> *= 7' (multiplication de la valeur de la variable <varname>$b</varname> par 7).
   </simpara>
   <para>
    Il y a une autre expression qui peut paraître complexe si vous ne l'avez pas
    vue dans d'autres langages, l'opérateur conditionnel ternaire :
    <example>
     <title>L'opérateur conditionnel ternaire</title>
     <programlisting role="php">
<![CDATA[
<?php
  $first ? $second : $third
?>
]]>
    </programlisting>
   </example>
    Si la valeur de la première sous-expression est vraie
    (différente de 0), alors la deuxième sous-expression est
    évaluée et constitue le résultat de l'expression
    conditionnelle. Sinon, c'est la troisième sous-expression qui est
    évaluée et qui constitue le résultat de l'expression.
   </para>
   <para>
    Les exemples suivants devraient vous permettre de mieux comprendre 
    la pre-incrémentation, la post-incrémentation
    et le concept des expressions en général :
    <example>
     <title>Pré et post-incrémentation : exemples</title>
     <programlisting role="php">
<![CDATA[
<?php
function double($i) {
    return $i*2;
}

$b = $a = 5;        /* Assigne la valeur 5 aux variables $a et $b  */
$c = $a++;          /* Post-incrémentation de la variable $a et assignation de
                       la valeur à la variable $c */
$e = $d = ++$b;     /* Pre-incrémentation, et assignation de la valeur aux
                       variables $d et $e  */
/* à ce niveau, les variables $d et $e sont égales à 6 */
$f = double($d++);  /* assignation du double de la valeur de $d à la variable $f ($f vaut 12),
                       puis incrémentation de la valeur de $d  */
$g = double(++$e);  /* assigne deux fois la valeur de $e après
                       incrémentation, 2*7 = 14 to $g */
$h = $g += 10;      /* Tout d'abord, $g est incrémentée de 10, et donc $g vaut 24.
                       Ensuite, la valeur de $g, (24) est assignée à la variable $h,
                       qui vaut donc elle aussi 24. */
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Au début de ce chapitre, nous avons dit que nous allions décrire les
    différents types d'instructions, et donc, comme promis, nous allons voir que
    les expressions peuvent être des instructions. Mais, attention, toutes les
    expressions ne sont pas des instructions. Dans ce cas-là, une instruction
    est de la forme '<literal>expr ;</literal>', c'est-à-dire, une expression 
    suivie par un point-virgule.
    L'expression <literal>'$b = $a = 5;', '$a = 5'</literal> est valide, 
    mais ce n'est pas une instruction en elle-même. 
    <literal>'$b = $a = 5'</literal> est une instruction valide.
   </simpara>
   <simpara>
    La dernière chose qui mérite d'être mentionnée est
    la véritable valeur des expressions. Lorsque vous faites des tests
    sur une variable, dans une boucle conditionnelle par exemple, cela ne vous
    intéresse pas de savoir quelle est la valeur exacte de l'expression.
    Mais vous voulez seulement savoir si le résultat signifie &true; ou &false;
    (&php; n'a pas de type booléen). La véritable valeur d'une
    expression en &php; est calculée de la même manière qu'en Perl.
    Toute valeur numérique différente de 0 est considérée
    comme étant &true;. Une chaîne de caractères vide et la chaîne
    de caractère 0 sont considérées comme &false;. Toutes les autres
    valeurs sont vraies. Avec les types de variables non-scalaires (les tableaux et les objets),
    s'ils ne contiennent aucun élément, renvoient &false;, sinon,
    ils renvoient &true;.
   </simpara>
   <simpara>
    &php; propose une implémentation complète et détaillée des
    expressions. &php; documente toutes ses expressions dans le manuel que vous êtes
    en train de lire. Les exemples qui vont suivre devraient vous donner une bonne
    idée de ce qu'est une expression et comment construire vos propres expressions.
    Dans tout ce qui va suivre, nous écrirons <literal>expr</literal> pour
    indiquer toute expression &php; valide.
   </simpara>
  </chapter>
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
indent-tabs-mode:nil
 sgml-parent-document:nil
 sgml-default-dtd-file:"../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
