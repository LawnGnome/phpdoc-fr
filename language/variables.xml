<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.34 $ -->
 <chapter id="language.variables">
  <title>Les variables</title>
  <sect1 id="language.variables.basics">
   <title>Essentiel</title>
   <simpara>
    En &php;, les variables sont repr&eacute;sent&eacute;es par un signe
    dollar "$" suivi du nom de la variable. Le nom est sensible &agrave;
    la casse (ie : $x != $X).
   </simpara>
   <para>
    Les noms de variables suivent les m&ecirc;mes r&egrave;gles de nommage que
    les autres entit&eacute;s &php;. Un nom de variable valide doit commencer par
    une lettre ou un soulign&eacute; (_), suivi de lettres, chiffres ou
    soulign&eacute;s. Exprim&eacute; sous la forme d'une expression
    r&eacute;guli&egrave;re, cela donne :
    '[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*'
   </para>
   <note>
    <simpara>
     Dans nos propos, une lettre peut &ecirc;tre une des lettres minuscules
     (a &agrave; z) ou majuscules (A &agrave; Z), et les caract&egrave;res
     ASCII de 127 &agrave; 255 (0x7f-0xff).
    </simpara>
   </note>
    <para>
    <example>
     <programlisting role="php">
<![CDATA[
<?php
  $var = "Jean";
  $Var = "Paul";
  echo "$var, $Var";         // affiche "Jean, Paul"
  $4site = 'pas encore';     // invalide : commence par un nombre
  $_4site = 'pas encore';    // valide : commence par un soulign&eacute;
  $ma&#239;s = 'jaune';      // valide; '&iuml;' est ASCII 239.
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    En &php; 3, les variables sont toujours assign&eacute;es par valeur.
    C'est-&agrave;-dire, lorsque vous assignez une expression &agrave;
    une variable, la valeur de l'expression est recopi&eacute;e dans
    la variable. Cela signifie, par exemple, qu'apr&egrave;s avoir
    assign&eacute; la valeur d'une variable &agrave; une autre,
    modifier l'une des variables n'aura pas d'effet sur l'autre. Pour plus
    de d&eacute;tails sur ce genre d'assignation, reportez-vous &agrave;
    <link linkend="language.expressions">Expressions</link>.
   </para>
   <para>
    &php; 4 permet aussi d'assigner les valeurs aux variables
    <emphasis>par r&eacute;f&eacute;rence</emphasis>. Cela
    signifie que la nouvelle variable ne fait que r&eacute;f&eacute;rencer
    (en d'autres terme, "devient un alias de", ou encore "pointe sur") la
    variable originale. Les modifications de la nouvelle variable
    affecteront l'ancienne, et vice versa. Cela signifie aussi
    qu'aucune copie n'est faite : l'assignation est donc beaucoup
    plus rapide. Cela se fera notamment sentir dans des boucles,
    ou lors d'assignation de grands objets (tableaux).
   </para>
   <para>
    Pour assigner par r&eacute;f&eacute;rence, ajoutez simplement
    un &amp; (ET commercial) au d&eacute;but de la variable qui
    est assign&eacute;e (la variable source). Dans l'exemple suivant,
    <literal>Mon nom est Pierre</literal> s'affichera deux
    fois :
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$foo = 'Pierre';              // Assigne la valeur 'Pierre' &agrave; $foo
$bar = &$foo;              // R&eacute;f&eacute;rence $foo avec $bar.
$bar = "Mon nom est Pierre";  // Modifie $bar...
echo $foo;                 // $foo est aussi modifi&eacute;e
echo $bar;
?>
]]>

     </programlisting>
    </informalexample>
   </para>
   <para>
    Une chose importante &agrave; noter est que seules les variables
    nomm&eacute;es peuvent &ecirc;tre assign&eacute;es par r&eacute;f&eacute;rence.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$foo = 25;
$bar = &$foo;      // assignation valide .
$bar = &(24 * 7);  // assignation invalide : r&eacute;f&eacute;rence une expression sans nom
function test() {
   return 25;
}
$bar = &test();    // assignation invalide.
?>
]]>

     </programlisting>
    </informalexample>
   </para>
  </sect1>
  <sect1 id="language.variables.predefined">
   <title>Variables pr&eacute;d&eacute;finies</title>
   <simpara>
    &php; fourni un grand nombre de variables pr&eacute;d&eacute;finies.
    Cependant, beaucoup de ces variables ne peuvent pas &ecirc;tre
    pr&eacute;sent&eacute;es ici, car elles d&eacute;pendent du serveur
    sur lequel elles tournent, de la version du serveur, et de la
    configuration du serveur, ou encore d'autres facteurs. Certaines
    de ces variables ne seront pas accessibles lorsque &php; fonctionne
    en ex&eacute;cutable.
   </simpara>
   <warning>
    <simpara>
     En &php; 4.2.0 et plus r&eacute;cent, le jeu de variables pr&eacute;d&eacute;finies qui sont
     disponibles dans l'environnement global a chang&eacute;. Les variables
     d'entr&eacute;es et de serveurs ne sont plus <emphasis>par d&eacute;faut</emphasis>
     plac&eacute;es dans le contexte d'ex&eacute;cution global. Elles sont plac&eacute;es dans 
     les <link linkend="language.variables.superglobals">tableaux superglobaux</link>.
    </simpara>
    <simpara>
     Vous pouvez toujours forcer l'ancien comportement de &php; en le configurant
     avec <link linkend="ini.register-globals">register_globals</link> &agrave;
     <literal>On</literal> votre fichier &php.ini;.
    </simpara>
    <simpara>
     Pour plus d'informations et d'explications sur ce changement, voyez 
     <ulink url="&url.php.release4.1.0;">l'annonce de &php; 4.1.0</ulink> 
     et and <ulink url="&url.php.release4.2.0;">l'annonce de &php; 4.2.0</ulink> 
     (en anglais).
    </simpara>
   </warning>
   <simpara>
    Depuis la version 4.1.0, &php; fournit un jeu de tableaux
    pr&eacute;d&eacute;finis, contenant les variables du serveur (si possible), les
    variables d'environnement et celle d'entr&eacute;es. Ces nouveaux tableaux
    sont un peut particuliers, car ils ont automatiquement globaux : 
    ils sont automatiquement disponibles dans tous les environnements
    d'ex&eacute;cution, sans avoir &agrave; utiliser le mot r&eacute;serv&eacute; <literal>global</literal>.
    Pour cette raison, ils sont dits 'auto-globaux' ou bien encore
    'superglobaux' (il n'y a pas de m&eacute;canisme &php; pour cr&eacute;er de telles
    variables. Les superglobales sont list&eacute;es ci-dessous. Cependant, pour
    conna&icirc;tre le d&eacute;tails de leur contenu, et une pr&eacute;sentation approfondie
    sur les variables pr&eacute;d&eacute;finies &php;, et leur nature, reportez vous
    &agrave; la section <link linkend="reserved.variables">variables pr&eacute;definies</link>.
   </simpara>

   <variablelist id="language.variables.superglobals">
    <title>Tableaux superglobaux de &php;</title>
    <varlistentry>
     <term><link linkend="reserved.variables.globals">$GLOBALS</link></term>
     <listitem>
      <simpara>
       Contient une r&eacute;f&eacute;rence sur chaque variable qui est actuellement disponible
       dans l'environnement d'ex&eacute;cution global. Les cl&eacute;s de ce tableau sont les
       noms des variables globales.
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.server">$_SERVER</link></term>
     <listitem>
      <simpara>
       Les variables fournies par le serveur web, ou bien directement
       li&eacute;es &agrave; l'environnement d'ex&eacute;cution du script courant. C'est
       la nouvelle version de l'ancienne variable <varname>$HTTP_SERVER_VARS</varname>,
       qui est maintenant obsol&egrave;te, mais toujours l&agrave;.
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.get">$_GET</link></term>
     <listitem>
      <simpara>
       Les variables fournies par le protocole HTTP en m&eacute;thode GET.
        C'est la nouvelle version de l'ancienne variable <varname>$HTTP_GET_VARS</varname>
       qui est maintenant obsol&egrave;te, mais toujours l&agrave;.
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.post">$_POST</link></term>
     <listitem>
      <simpara>
        Les variables fournies par le protocole HTTP en m&eacute;thode POST.
        C'est la nouvelle version de l'ancienne variable <varname>$HTTP_POST_VARS</varname>
       qui est maintenant obsol&egrave;te, mais toujours l&agrave;.
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.cookies">$_COOKIE</link></term>
     <listitem>
      <simpara>
        Les variables fournies par le protocole HTTP, dans les cookies.
        C'est la nouvelle version de l'ancienne variable <varname>$HTTP_COOKIE_VARS</varname>
       qui est maintenant obsol&egrave;te, mais toujours l&agrave;.
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.files">$_FILES</link></term>
     <listitem>
      <simpara>
        Les variables fournies par le protocole HTTP, suite &agrave; un t&eacute;l&eacute;chargement de fichier.
        C'est la nouvelle version de l'ancienne variable <varname>$HTTP_POST_FILES</varname>
       qui est maintenant obsol&egrave;te, mais toujours l&agrave;. Voir
       <link linkend="features.file-upload.post-method">T&eacute;l&eacute;chargement par m&eacute;thode POST</link>,
       pour plus d'informations.
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.environment">$_ENV</link></term>
     <listitem>
      <simpara>
        Les variables fournies par l'environnement.
        C'est la nouvelle version de l'ancienne variable <varname>$HTTP_ENV_VARS</varname>
       qui est maintenant obsol&egrave;te, mais toujours l&agrave;.
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.request">$_REQUEST</link></term>
     <listitem>
      <simpara>
        Les variables fournies au script par n'importe quel m&eacute;canisme d'entr&eacute;e
        et qui ne doit recevoir une confiance limit&eacute;e. Note : lorsque
        vous ex&eacute;cutez un script en ligne de commande, cette variable ne
        va <emphasis>pas</emphasis> inclure les variables <varname>argv</varname> 
        et <varname>argc</varname>. Elles seront pr&eacute;sentes dans la variable
        <varname>$_SERVER</varname>. La pr&eacute;sence et la valeur des entr&eacute;es
        de ce tableau sont r&eacute;gl&eacute;s par la directive 
        <link linkend="ini.variables-order">variables_order</link>. Ce tableau
        n'est l'&eacute;volution d'aucune variable d'avant &php; 4.1.0.
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.session">$_SESSION</link></term>
     <listitem>
      <simpara>
       Les variables qui sont actuellement enregistr&eacute;es dans la session attach&eacute;e
       au script. which are currently registered to a script's
       session.C'est la nouvelle version de l'ancienne variable <varname>$HTTP_SESSION_VARS</varname>.
       Voir le chapitre <link linkend="ref.session">Sessions handling functions</link>
       pour plus d'informations.
      </simpara>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect1>
  <sect1 id="language.variables.scope">
   <title>Port&eacute;e des variables</title>
   <simpara>
	La port&eacute;e d'une variable d&eacute;pend du contexte
	dans lequel la variable est d&eacute;finie. Pour la majorit&eacute; des
	variables, la port&eacute;e concerne la totalit&eacute; d'un script
	&php;. Mais, lorsque vous d&eacute;finissez une fonction, la
	port&eacute;e d'une variable d&eacute;finie dans cette fonction
	est locale &agrave; la fonction. Par exemple:
   </simpara>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$a = 1;
include "b.inc";
?>
]]>

    </programlisting>
   </informalexample>
   <simpara>
    Ici, la variable $a sera accessible dans le script inclus
    <filename>b.inc</filename>. Cependant, dans les fonctions
    d&eacute;finies par l'utilisateur, une nouvelle d&eacute;finition
    de cette variable sera donn&eacute;e, limit&eacute;e &agrave; la
    fonction. Toute variable utilis&eacute;e dans une fonction est
    par d&eacute;finition, locale. Par exemple :
   </simpara>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$a = 1; /* port&eacute;e globale */
function test() {
    echo $a; /* port&eacute;e locale */
}
test();
?>
]]>

    </programlisting>
   </informalexample>
   <simpara>
	Le script n'affichera rien &agrave; l'&eacute;cran car
	la fonction <function>echo</function> utilise la variable locale $a,
	et celle-ci n'a pas &eacute;t&eacute; assign&eacute;e
	pr&eacute;alablement dans la fonction. Vous pouvez noter que
	ce concept diff&egrave;re un petit peu du langage C dans
	lequel une variable globale est automatiquement accessible dans
	les fonctions, &agrave; moins d'&ecirc;tre red&eacute;finie
	localement dans la fonction. Cela peut poser des probl&egrave;mes
	si vous red&eacute;finissez des variables globales localement.
	En &php;, une variable globale doit &ecirc;tre
	d&eacute;clar&eacute;e &agrave; l'int&eacute;rieur de chaque
	fonction afin de pouvoir &ecirc;tre utilis&eacute;e dans cette
	fonction. Par exemple:
   </simpara>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$a = 1;
$b = 2;
function somme() {
    global $a, $b;
    $b = $a + $b;
}
somme();
echo $b;
]]>
    </programlisting>
   </informalexample>
   <simpara>
	Le script ci-dessus va afficher la valeur <literal>3</literal>.
	En d&eacute;clarant globales les variables $a et $b locales
	de la fonction somme(), toutes les r&eacute;f&eacute;rences &agrave;
	ces variables concerneront les variables globales. Il n'y a
	aucune limite au nombre de variables globales qui peuvent
	&ecirc;tre manipul&eacute;es par une fonction.
   </simpara>
   <simpara>
	Une deuxi&egrave;me m&eacute;thode pour acc&eacute;der aux
	variables globales est d'utiliser le tableau associatif
	pr&eacute;d&eacute;fini $GLOBALS. Le pr&eacute;c&eacute;dent
	exemple peut &ecirc;tre r&eacute;&eacute;crit de la
	mani&egrave;re suivante:
   </simpara>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
  $a = 1;
  $b = 2;
  function somme() {
    $GLOBALS["b"] = $GLOBALS["a"] + $GLOBALS["b"];
  }
  somme();
  echo $b;
?>
]]>

    </programlisting>
   </informalexample>
   <simpara>
	Le tableau $GLOBALS est un tableau associatif avec le nom
	des variables globales comme clef et les valeurs des &eacute;l&eacute;ments
	du tableau comme valeur des variables.
   </simpara>
   <simpara>
	Une autre caract&eacute;ristique importante de la port&eacute;e des variables est
	la notion de variable <emphasis>static</emphasis>. Une variable statique a
	une port&eacute;e locale uniquement, mais elle ne perd pas sa valeur lorsque le
	script appelle la fonction. Prenons l'exemple suivant:
   </simpara>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
function test() {
    $a = 0;
    echo $a;
    $a++;
}
?>
]]>

    </programlisting>
   </informalexample>
   <simpara>
	Cette fonction est un peu inutile car &agrave; chaque fois
	qu'elle est appel&eacute;e, elle initialise $a &agrave; 0 et
	affiche "0". L'incr&eacute;mentation de la variable ($a++)
	ne sert pas &agrave; grand chose, car d&egrave;s que la
	fonction est termin&eacute;e la variable dispara&icirc;t.
	Pour faire une fonction de comptage utile, c'est-&agrave;-dire qui
	ne perdra pas la trace du compteur, la variable $a est
	d&eacute;clar&eacute;e comme une variable statique:
   </simpara>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
function test() {
    static $a = 0;
    echo $a;
    $a++;
}
?>
]]>

    </programlisting>
   </informalexample>
   <simpara>
    Maintenant, &agrave; chaque fois que la fonction Test() est
    appel&eacute;e, elle affichera une valeur de $a incr&eacute;ment&eacute;e
    de 1.
   </simpara>
   <simpara>
	Les variables statiques sont essentielles lorsque vous faites des
	appels r&eacute;cursifs &agrave; une fonction. Une fonction
	r&eacute;cursive est une fonction qui s'appelle elle-m&ecirc;me.
	Il faut faire attention lorsque vous &eacute;crivez une fonction
	r&eacute;cursive car il est facile de faire une boucle infinie.
	Vous devez v&eacute;rifier que vous avez bien une condition qui
	permet de terminer votre r&eacute;cursivit&eacute;. La fonction
	suivante compte r&eacute;cursivement jusqu'&agrave; 10:
   </simpara>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
function test() {
    static $count = 0;
    $count++;
    echo $count;
    if ($count < 10) {
        test();
    }
    $count--;
}
?>
]]>

    </programlisting>
   </informalexample>
  </sect1>
  <sect1 id="language.variables.variable">
   <title>Les variables dynamiques</title>
   <simpara>
	Il est pratique d'avoir parfois des noms de variables qui sont variables.
	C'est-&agrave;-dire un nom de variable qui est affect&eacute;e et utilis&eacute;e
	dynamiquement. Une variable classique est affect&eacute; avec
	l'instruction suivante:
   </simpara>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$a = "bonjour";
?>
]]>

    </programlisting>
   </informalexample>
   <simpara>
	Une variable dynamique prend la valeur d'une variable et l'utilise
	comme nom d'une autre variable. Dans l'exemple ci-dessous,
	<emphasis>bonjour</emphasis> peut &ecirc;tre utilis&eacute; comme le nom d'une
	variable en utilisant le "$$" pr&eacute;c&eacute;dent la variable.
	C'est-&agrave;-dire
   </simpara>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$$a = "monde";
?>
]]>

    </programlisting>
   </informalexample>
   <simpara>
	A ce niveau, deux variables ont &eacute;t&eacute; d&eacute;finies et
	stock&eacute;es dans l'arbre des symboles &php; : $a avec comme valeur
	"bonjour" et $bonjour avec comme valeur "monde". Alors, l'instruction
    </simpara>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
echo "$a ${$a}";
?>
]]>

    </programlisting>
   </informalexample>
   <simpara>
    produira le m&ecirc;me affichage que :
   </simpara>
   <informalexample>
    <programlisting  role="php">
<![CDATA[
<?php
echo "$a $bonjour";
?>
]]>

    </programlisting>
   </informalexample>
   <simpara>
    c'est-&agrave;-dire : <emphasis>bonjour monde</emphasis>.
   </simpara>
   <simpara>
	Afin de pouvoir utiliser les variables dynamiques avec les tableaux,
	vous avez &agrave; r&eacute;soudre un probl&egrave;me ambigu. Si vous
	&eacute;crivez $$a[1], le parseur a besoin de savoir si vous
	parler de la variable qui a pour nom $a[1] ou bien si vous voulez
	l'index [1] de la variable $$a. La syntaxe pour r&eacute;soudre
	cette ambigu&iuml;t&eacute; est la suivante: ${$a[1]} pour le premier
	cas, et ${$a}[1] pour le deuxi&egrave;me.
    </simpara>
  </sect1>
  <sect1 id="language.variables.external">
   <title>Variables externes &agrave; &php;</title>
   <sect2 id="language.variables.external.form">
    <title>Formulaires HTML (GET et POST)</title>
    <simpara>
	Lorsqu'un formulaire est envoy&eacute; &agrave; un script &php;,
	toutes les variables du formulaire seront automatiquement disponibles
	dans le script. Par exemple, consid&eacute;rons le formulaire suivant:
    </simpara>
    <para>
     <example>
      <title>Exemple avec un formulaire simple</title>
      <programlisting role="html">
<![CDATA[
<form action="foo.php" method="post">
    Nom: <input type="text" name="nom"><BR>
    <input type="submit">
</form>
]]>
      </programlisting>
     </example>
    </para>
    <simpara>
	Lorsque ce formulaire est envoy&eacute;, le &php; va cr&eacute;er la variable
	<computeroutput>$nom</computeroutput>, qui contiendra la valeur
	que vous avez entr&eacute;e dans le champs <emphasis>Nom:</emphasis>
	du formulaire.
    </simpara>
    <note>
     <para>
      La directive de configuration <link 
      linkend="ini.magic-quotes-gpc">magic_quotes_gpc</link> affecte les valeurs 
      issues des m&eacute;thodes GET et POST ainsi aue des Cookies. Si cette 
      directive est active, une valeur telle que <literal>It's "PHP!"</literal>
      sera automagiquement transform&eacute;e en <literal>It&#92;'s
      &#92;"PHP!&#92;"</literal>.
      L'&eacute;chappement est n&eacute;cessaire pour les insertions en base de
      donn&eacute;es. Voyez <function>addslashes</function>,
      <function>stripslashes</function> et  
      <link linkend="ini.magic-quotes-sybase">magic_quotes_sybase</link>.
     </para>
    </note>
    <simpara>
	Le &php; permet aussi l'utilisation des tableaux dans le contexte de
	formulaire, mais seulement des tableaux &agrave; une seule dimension. Comme
	cela, vous pouvez rassembler des variables ou utiliser cette
	fonctionnalit&eacute; pour r&eacute;cup&eacute;rer les valeurs d'un choix
	multiple :
    </simpara>
    <para>
     <example>
      <title>Variables complexes de formulaire</title>
      <programlisting role="html">
<![CDATA[
<form action="array.php" method="post">
    Name: <input type="text" name="personal[name]"><br>
    Email: <input type="text" name="personal[email]"><br>
    Beer: <br>
    <select multiple name="vin[]">
        <option value="medoc">M&eacute;doc
        <option value="chablis">Chablis
        <option value="riesling">Riesling
        </select>
    <input type="submit">
</form>
]]>
      </programlisting>
     </example>
    </para>
    <simpara>
	Si l'option "track_vars" est activ&eacute;e, soit par l'option de
	compilation
	<link linkend="ini.track-vars">track_vars</link>, soit par la directive de
	configuration <computeroutput>
<![CDATA[	
	<? php_track_vars ?>
]]>
</computeroutput>,
	les variables transmises par les m&eacute;thodes POST et GET
	pourront aussi &ecirc;tre trouv&eacute;es dans le tableau
	associatif global $HTTP_POST_VARS ou $HTTP_GET_VARS
	suivant la m&eacute;thode utlis&eacute;e.
    </simpara>
    <sect3 id="language.variables.external.form.submit">
     <title>Bouton "submit" sous forme d'image</title>
     <simpara>
      Lorsque vous envoyez le r&eacute;sultat d'un formulaire, vous
      pouvez utiliser une image au lieu du bouton "submit" standard
      en utilisant un tag :
     </simpara>
     <informalexample>
      <programlisting role="html">
<![CDATA[
  <input type=image src="image.gif" name="sub">
]]>
      </programlisting>
     </informalexample>
     <simpara>
       Lorsqu'un utilisateur clique sur l'image, le formulaire sera
       transmis au serveur avec deux variables de plus, sub_x et
       sub_y. Ces deux variables contiennent les coordonn&eacute;es
       de l'endroit o&ugrave; l'utilisateur &agrave; cliqu&eacute;. Les
       utilisateurs exp&eacute;riment&eacute;s remarqueront que les noms
       de variables sont transmis avec une virgule &agrave; la place du
       caract&egrave;re "_", mais &php; fait la conversion
       automatiquement.
     </simpara>
    </sect3>
   </sect2>
   <sect2 id="language.variables.external.cookies">
    <title>HTTP Cookies</title>
    <simpara>
	&php; supporte les cookies HTTP de mani&egrave;re totalement
	transparente, comme d&eacute;fini dans les
	<ulink url="&spec.cookies;">Netscape's Spec</ulink>. Les cookies
	sont un m&eacute;canisme permettant de stocker des donn&eacute;es
	sur la machine cliente &agrave; des fins d'authentification de
	l'utilisateur. Vous pouvez &eacute;tablir un cookie gr&acirc;ce &agrave;
	la fonction <function>setcookie</function>. Les cookies
	font partie int&eacute;grante du "header" HTTP, et donc
	la fonction <function>setcookie</function> doit &ecirc;tre
	appel&eacute;e avant que le moindre affichage ne soit envoy&eacute;
	au navigateur. C'est la m&ecirc;me restriction que pour la fonction
	<function>header</function>. Tout cookie envoy&eacute; depuis le
	client sur le serveur sera automatiquement stock&eacute; sous
	forme de variable, comme pour la m&eacute;thode POST ou GET.
     </simpara>
    <simpara>
	Si vous souhaitez assigner plusieurs valeurs &agrave; un seul
	cookie, il vous faut ajouter les caract&egrave;res
	<emphasis>[]</emphasis> au nom de votre cookie.
	Par exemple :
    </simpara>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
setcookie ("MonCookie[]", "test", time()+3600);
?>
]]>

     </programlisting>
    </informalexample>
    <simpara>
	Il est &agrave; noter qu'un cookie remplace le cookie
	pr&eacute;c&eacute;dent par un cookie de m&ecirc;me nom tant que
	le "path" ou le domaine sont identiques. Donc, pour une application
	de caddie, vous devez impl&eacute;menter un compteur et
	l'incr&eacute;menter au fur et &agrave; mesure. C'est-&agrave;-dire:
    </simpara>
    <example>
     <title>Exemple avec <function>setcookie</function></title>
     <programlisting role="php">
<![CDATA[
<?php
$compte++;
SetCookie ("Compte", $compte, time()+3600);
SetCookie ("Caddie[$compte]", $item, time()+3600);
?>
]]>

     </programlisting>
    </example>
   </sect2>
   <sect2 id="language.variables.external.dot-in-names">
    <title>Cas des points dans les noms de variables</title>
    <para>
     Typiquement, &php; ne modifie pas les noms des variables lorsqu'elles
     sont pass&eacute;es &agrave; un script. Cependant, il faut noter que
     les points (.) ne sont pas autoris&eacute;s dans les noms de variables
     &php;. Pour cette raison, jetez un oeil sur :
     <programlisting role="php">
<![CDATA[
<?php
  $varname.ext;  /* nom de variable invalide */
?>
]]>
     </programlisting>
     Dans ce cas, l'analyseur croit voir la variable nomm&eacute;e
     $varname, suivie par l'op&eacute;rateur de concat&eacute;nation,
     et suivi encore par la cha&icirc;ne non-guillemet&eacute;e (une
     cha&icirc;ne sans guillemets, et qui n'a pas de signification
     particuli&egrave;re). Visiblement, ce n'est pas ce qu'on attendait...
    </para>
    <para>
     Pour cette raison, il est important de noter que &php; remplacera
     automatiquement les points des noms de variables entrantes par
     des soulign&eacute;s (underscore).
    </para>
   </sect2>
   <sect2 id="language.variables.determining-type-of">
    <title>D&eacute;termination du type des variables</title>
    <para>
     Parceque &php; d&eacute;termine le type des variables et
     les convertit (g&eacute;n&eacute;ralement) comme il faut,
     ce n'est pas toujours le type de variable que vous souhaitez.
     &php; inclut des fonctions permettant de d&eacute;terminer le
     type d'une variable :
     <function>gettype</function>,
     <function>is_long</function>,
     <function>is_double</function>,
     <function>is_string</function>,
     <function>is_array</function> et
     <function>is_object</function>.
    </para>
   </sect2>
  </sect1>
 </chapter>
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
indent-tabs-mode:nil
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
