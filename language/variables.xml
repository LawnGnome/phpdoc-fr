<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.72 $ -->
<!-- EN-Revision: 1.90 Maintainer: dams Status: ready -->

 <chapter id="language.variables">
  <title>Les variables</title>

  <sect1 id="language.variables.basics">
   <title>Essentiel</title>

   <simpara>
    En &php;, les variables sont représentées par un signe
    dollar "$" suivi du nom de la variable. Le nom est sensible à
    la casse (i.e. <literal>$x != $X</literal>).
   </simpara>

   <para>
    Les noms de variables suivent les mêmes règles de nommage que
    les autres entités &php;. Un nom de variable valide doit commencer par
    une lettre ou un souligné (_), suivi de lettres, chiffres ou
    soulignés. Exprimé sous la forme d'une expression
    régulière, cela donne :
    '<literal>[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*</literal>'
   </para>

   <note>
    <simpara>
     Dans nos propos, une lettre peut être une des lettres minuscules
     (a à z) ou majuscules (A à Z) et les caractères
     ASCII de 127 à 255 (<literal>0x7f-0xff</literal>).
    </simpara>
   </note>

 
    <para>
     Pour obtenir des informations sur une variable, voyez les fonctions
     dédiées aux <link linkend="ref.var">variables</link>.
    </para>

    <para>
    <example>
     <title>Validité des noms de variables</title>
     <programlisting role="php">
<![CDATA[
<?php
$var = 'Jean';
$Var = 'Paul';
echo "$var, $Var";         // affiche "Jean, Paul"

$4site = 'pas encore';     // invalide : commence par un nombre
$_4site = 'pas encore';    // valide : commence par un souligné
$täyte = 'mansikka';    // valide : 'ä' est ASCII (étendu) 228.
?>
]]>
     </programlisting>
    </example>
   </para>

   <para>
    En &php; 3, les variables sont toujours assignées par valeur.
    C'est-à-dire, lorsque vous assignez une expression à
    une variable, la valeur de l'expression est recopiée dans
    la variable. Cela signifie, par exemple, qu'après avoir
    assigné la valeur d'une variable à une autre,
    modifier l'une des variables n'aura pas d'effet sur l'autre. Pour plus
    de détails sur ce genre d'assignation, reportez-vous aux
    <link linkend="language.expressions">expressions</link>.
   </para>
   <para>
    Depuis &php; 4, &php; permet aussi d'assigner les valeurs aux variables
    <link linkend="language.references">par référence</link>. Cela
    signifie que la nouvelle variable ne fait que référencer
    (en d'autres terme, "devient un alias de", ou encore "pointe sur") la
    variable originale. Les modifications de la nouvelle variable
    affecteront l'ancienne et vice versa.
   </para>
   <para>
    Pour assigner par référence, ajoutez simplement
    un &amp; (ET commercial) au début de la variable qui
    est assignée (la variable source). Dans l'exemple suivant,
    <literal>Mon nom est Pierre</literal> s'affichera deux
    fois :
    <example>
     <title>Assignation de référence</title>
     <programlisting role="php">
<![CDATA[
<?php
$foo = 'Pierre';              // Assigne la valeur 'Pierre' à $foo
$bar = &$foo;                 // Référence $foo avec $bar.
$bar = "Mon nom est $bar";  // Modifie $bar...
echo $foo;                    // $foo est aussi modifiée
echo $bar;
?>
]]>

     </programlisting>
    </example>
   </para>

   <para>
    Une chose importante à noter est que seules les variables
    nommées peuvent être assignées par référence.
    <example>
     <title>Assignation de référence et variables anonymes</title>
     <programlisting role="php">
<![CDATA[
<?php
$foo = 25;
$bar = &$foo;      // assignation valide
$bar = &(24 * 7);  // assignation invalide : référence une expression sans nom
function test() {
   return 25;
}
$bar = &test();    // assignation invalide.
?>
]]>

     </programlisting>
    </example>
   </para>

   <para>
    Il n'est pas nécessaire d'initialiser les variables en &php;, cepedant, celà reste
    une excellente pratique. Les variables non initialisées ont une valeur par défaut
    selon leurs types - &false;, zéro, chaîne vide ou un tableau vide.
   </para>
   <para>
    <example>
     <title>Valeurs par défaut des variables non initialisées</title>
     <programlisting role="php">
<![CDATA[
<?php
echo ($unset_bool ? "true" : "false"); // false
$unset_int += 25; // 0 + 25 => 25
echo $unset_string . "abc"; // "" . "abc" => "abc"
$unset_array[3] = "def"; // array() + array(3 => "def") => array(3 => "def")
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Utiliser la valeur par défaut d'une variable non initialisée est problèmatique
    lorsque vous incluez un fichier dans un autre qui utilise le même nom de variable.
    C'est également un <link linkend="security.globals">risque niveau sécurité</link>
    lorsque <link linkend="ini.register-globals">register_globals</link> est activé.
    Une erreur de niveau <link linkend="e-notice">E_NOTICE</link> sera émise
    lorsque vous travaillerez avec des variables non initialisées, cependant, aucune
    erreur ne sera lancée lorsque vous tenterez d'insérer un élément dans un tableau
    non initialisé. La structure de langage <function>isset</function>
    peut être utilisée pour détecter si une variable a déjà été initialisée.
   </para>
  </sect1>

  <sect1 id="language.variables.predefined">
   <title>Variables pré-définies</title>

   <simpara>
    &php; fourni un grand nombre de variables pré-définies.
    Cependant, beaucoup de ces variables ne peuvent pas être
    présentées ici, car elles dépendent du serveur
    sur lequel elles tournent, de la version du serveur et de la
    configuration du serveur ou encore d'autres facteurs. Certaines
    de ces variables ne seront pas accessibles lorsque &php; fonctionne
    en exécutable.
   </simpara>

   <warning>
    <simpara>
     Depuis la version &php; 4.2.0, la valeur par défaut de la directive &php;
     <link linkend="ini.register-globals">register_globals</link> est
     <emphasis>off</emphasis>. Ceci est une évolution majeure de &php;.
     Avoir la directive <option>register_globals</option> à
     <emphasis>off</emphasis> affecte les
     variables pré-définies du contexte globale. Par exemple, pour lire
     <varname>DOCUMENT_ROOT</varname> vous devez utiliser
     <varname>$_SERVER['DOCUMENT_ROOT']</varname> au lieu de
     <varname>$DOCUMENT_ROOT</varname> ou bien, il faut lire
     <varname>$_GET['id']</varname> dans l'URL
     <literal>http://www.example.com/test.php?id=3</literal> au lieu
     de <varname>$id</varname> ou encore <varname>$_ENV['HOME']</varname> au lieu de
     <varname>$HOME</varname>.
    </simpara>
    <simpara>
     Pour des informations liées à cette évolution, lisez la documentation de la
     directive <link linkend="ini.register-globals"><option>register_globals</option></link>,
     le chapitre sur la sécurité, à propos de l'<link linkend="security.globals">Utilisation des variables
     superglobales</link>, ainsi que les annonces de &php;
     <ulink url="&url.php.release4.1.0;">4.1.0</ulink>
     et <ulink url="&url.php.release4.2.0;">4.2.0</ulink>.
    </simpara>
    <simpara>
     L'utilisation des variables pré-définies de &php;, comme les
     <link linkend="language.variables.superglobals">tableaux superglobaux</link>,
     est recommandé.
    </simpara>
   </warning>

   <simpara>
    Depuis la version 4.1.0, &php; fournit un jeu de tableaux
    pré-définis, contenant les variables du serveur (si possible), les
    variables d'environnement et celle d'entrées. Ces nouveaux tableaux
    sont un peu particuliers, car ils sont automatiquement globaux :
    ils sont automatiquement disponibles dans tous les environnements
    d'exécution, sans avoir à utiliser le mot réservé <literal>global</literal>.
    Pour cette raison, ils sont dits 'auto-globaux' ou bien encore
    'superglobaux' (il n'y a pas de mécanisme &php; pour créer de telles
    variables. Les superglobales sont listées ci-dessous. Cependant, pour
    connaître le détails de leur contenu et une présentation approfondie
    sur les variables pré-définies &php; et leur nature, reportez-vous
    à la section <link linkend="reserved.variables">variables pré-définies</link>.
    De plus, vous noterez que les anciennes variables pré-définies
    (<varname>$HTTP_*_VARS</varname>) existent toujours.

     &avail.register-long-arrays;
   </simpara>

   <note>
    <title>Variables variables</title>
    <para>
     Les superglobales ne peuvent pas être utilisées comme
     <link linkend="language.variables.variable">variables dynamiques</link>
     dans les fonctions ou les méthodes des classes.
    </para>
   </note>

   <note>
    <para>
     Même si les superglobales et <literal>HTTP_*_VARS</literal> peuvent exister en même temps,
     ils ne sont pas identiques, donc, le changement d'une ne changera pas l'autre.
    </para>
   </note>

   <para>
    Si certaines variables de
    <link linkend="ini.variables-order"><option>variables_order</option></link>
    ne sont pas définies, leur tableau pré-défini &php; correspondant est laissé vide.
   </para>

   <variablelist id="language.variables.superglobals">
    <title>Tableaux superglobaux de &php;</title>
    <varlistentry>
     <term><link linkend="reserved.variables.globals">$GLOBALS</link></term>
     <listitem>
      <simpara>
       Contient une référence sur chaque variable qui est en fait disponible
       dans l'environnement d'exécution global. Les clés de ce tableau sont les
       noms des variables globales.
       <varname>$GLOBALS</varname> existe depuis &php; 3.
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.server">$_SERVER</link></term>
     <listitem>
      <simpara>
       Les variables fournies par le serveur web, ou bien directement
       liées à l'environnement d'exécution du script courant. C'est
       la nouvelle version de l'ancienne variable <varname>$HTTP_SERVER_VARS</varname>,
       qui est maintenant obsolète, mais toujours là.
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.get">$_GET</link></term>
     <listitem>
      <simpara>
       Les variables fournies au script via la chaîne de requête URL.
       C'est la nouvelle version de l'ancienne variable 
       <varname>$HTTP_GET_VARS</varname>
       qui est maintenant obsolète, mais toujours là.
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.post">$_POST</link></term>
     <listitem>
      <simpara>
       Les variables fournies par le protocole HTTP en méthode POST.
       C'est la nouvelle version de l'ancienne variable 
       <varname>$HTTP_POST_VARS</varname>
       qui est maintenant obsolète, mais toujours là.
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.cookies">$_COOKIE</link></term>
     <listitem>
      <simpara>
       Les variables fournies par le protocole HTTP, dans les cookies.
       C'est la nouvelle version de l'ancienne variable 
       <varname>$HTTP_COOKIE_VARS</varname>
       qui est maintenant obsolète, mais toujours là.
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.files">$_FILES</link></term>
     <listitem>
      <simpara>
       Les variables fournies par le protocole HTTP, suite à un téléchargement de fichier.
       C'est la nouvelle version de l'ancienne variable 
       <varname>$HTTP_POST_FILES</varname>
       qui est maintenant obsolète, mais toujours là. Voir
       <link linkend="features.file-upload.post-method">Téléchargement par méthode POST</link>,
       pour plus d'informations.
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.environment">$_ENV</link></term>
     <listitem>
      <simpara>
       Les variables fournies par l'environnement.
       C'est la nouvelle version de l'ancienne variable 
       <varname>$HTTP_ENV_VARS</varname>
       qui est maintenant obsolète, mais toujours là.
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.request">$_REQUEST</link></term>
     <listitem>
      <simpara>
       Les variables fournies au script par n'importe quel mécanisme d'entrée
       et qui ne doit recevoir une confiance limitée. Note : lorsque
       vous exécutez un script en ligne de commande, cette variable ne
       va <emphasis>pas</emphasis> inclure les variables <varname>argv</varname>
       et <varname>argc</varname>. Elles seront présentes dans la variable
       <varname>$_SERVER</varname>. La présence et la valeur des entrées
       de ce tableau sont réglés par la directive
       <link linkend="ini.variables-order">variables_order</link>. Ce tableau
       n'est l'évolution d'aucune variable d'avant &php; 4.1.0.
      </simpara>
      <caution>
       <simpara>
        Depuis &php; 4.3.0, les informations de la variable <varname>$_FILES</varname>
        ne sont plus intégrées dans la variable <varname>$_REQUEST</varname>.
       </simpara>
      </caution>
      <note>
       <simpara>
        En <link linkend="features.commandline">ligne de commande</link>, cette
        variable <emphasis>n'inclut pas</emphasis> les variables
        <varname>argv</varname> et <varname>argc</varname> : elles sont
        stockées dans le tableau <varname>$_SERVER</varname>.
       </simpara>
      </note>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.session">$_SESSION</link></term>
     <listitem>
      <simpara>
       Les variables qui sont en fait enregistrées dans la session attachée
       au script. C'est la nouvelle version de l'ancienne variable
       <varname>$HTTP_SESSION_VARS</varname>.
       Voir le chapitre sur la <link linkend="ref.session">gestion des sessions</link>
       pour plus d'informations.
      </simpara>
     </listitem>
    </varlistentry>
   </variablelist>

  </sect1>

  <sect1 id="language.variables.scope">
   <title>Portée des variables</title>

   <simpara>
    La portée d'une variable dépend du contexte
    dans lequel la variable est définie. Pour la majorité des
    variables, la portée concerne la totalité d'un script
    &php;. Mais lorsque vous définissez une fonction, la
    portée d'une variable définie dans cette fonction
    est locale à la fonction. Par exemple :
   </simpara>
   <example>
    <title>Les variables sont locales à la fonction</title>
    <programlisting role="php">
<![CDATA[
<?php
$a = 1;
include 'b.inc';
?>
]]>
    </programlisting>
   </example>
   <simpara>
    Ici, la variable <varname>$a</varname> sera accessible dans le script inclus
    <filename>b.inc</filename>. Cependant, dans les fonctions
    définies par l'utilisateur, une nouvelle définition
    de cette variable sera donnée, limitée à la
    fonction. Toute variable utilisée dans une fonction est
    par définition, locale. Par exemple :
   </simpara>

   <example>
    <title>Les variables sont locales à la fonction (2)</title>
    <programlisting role="php">
<![CDATA[
<?php
$a = 1; /* portée globale */

function test() {
    echo $a; /* portée locale */
}
test();
?>
]]>

    </programlisting>
   </example>
   <simpara>
    Le script n'affichera rien à l'écran car
    l'instruction <function>echo</function> utilise la variable locale <varname>$a</varname>,
    et celle-ci n'a pas été assignée
    préalablement dans la fonction. Vous pouvez noter que
    ce concept diffère un petit peu du langage C dans
    lequel une variable globale est automatiquement accessible dans
    les fonctions, à moins d'être redéfinie
    localement dans la fonction. Cela peut poser des problèmes
    si vous redéfinissez des variables globales localement.
    En &php;, une variable globale doit être
    déclarée à l'intérieur de chaque
    fonction afin de pouvoir être utilisée dans cette
    fonction.
   </simpara>

   <sect2 id="language.variables.scope.global">
    <title>Le mot clé <literal>global</literal></title>
    <simpara>
     Commençons par un exemple avec <literal>global</literal> :
    </simpara>
    <para>
     <example>
      <title>Exemple avec <literal>global</literal></title>
      <programlisting role="php">
<![CDATA[
<?php
$a = 1;
$b = 2;
function somme() {
    global $a, $b;
    $b = $a + $b;
}
somme();
echo $b;
]]>
     </programlisting>
    </example>
   </para>

   <simpara>
    Le script ci-dessus va afficher la valeur <literal>3</literal>.
    En déclarant globales les variables <varname>$a</varname> et
    <varname>$b</varname> locales
    de la fonction somme(), toutes les références à
    ces variables concerneront les variables globales. Il n'y a
    aucune limite au nombre de variables globales qui peuvent
    être manipulées par une fonction.
   </simpara>

   <simpara>
    Une deuxième méthode pour accéder aux
    variables globales est d'utiliser le tableau associatif
    pré-défini <varname>$GLOBALS</varname>. Le précédent
    exemple peut être réécrit de la
    manière suivante :
   </simpara>
   <para>
    <example>
     <title>Les variables globales et <varname>$GLOBALS</varname></title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 1;
$b = 2;
function somme() {
    $GLOBALS['b'] = $GLOBALS['a'] + $GLOBALS['b'];
}
somme();
echo $b;
?>
]]>

     </programlisting>
    </example>
   </para>

   <simpara>
    Le tableau <varname>$GLOBALS</varname> est un tableau associatif avec le nom
    des variables globales comme clé et les valeurs des éléments
    du tableau comme valeur des variables. Notez que <varname>$GLOBALS</varname>
    existe dans tous les contextes, car <varname>$GLOBALS</varname> est un
    <link linkend="language.variables.superglobals">superglobal</link>.
    Voici un exemple des super globaux :
   </simpara>

   <para>
    <example>
     <title>Les variables super globales</title>
     <programlisting role="php">
<![CDATA[
<?php
function test_global() {

    // La plupart des variables pré-définies ne sont pas des "superglobales" et
    // requiert le mot-clé 'global' pour être disponible dans une fonction.
    global $HTTP_POST_VARS;

    echo $HTTP_POST_VARS['name'];

    // Les superglobales sont accessibles dans tous les contextes
    // et ne requièrent pas 'global'.  Les superglobales sont disponibles
    // depuis &php; 4.1.0 et HTTP_POST_VARS est de plus en plus
    // déprécié.
    echo $_POST['name'];
}
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect2>

  <sect2 id="language.variables.scope.static">
   <title>Utilisation des variables <literal>static</literal></title>
   <simpara>
    Une autre caractéristique importante de la portée des variables est
    la notion de variable <literal>static</literal>. Une variable statique a
    une portée locale uniquement, mais elle ne perd pas sa valeur lorsque le
    script appelle la fonction. Prenons l'exemple suivant :
   </simpara>
   <para>
    <example>
     <title>Les variables statiques</title>
     <programlisting role="php">
<![CDATA[
<?php
function Test() 
{
    $a = 0;
    echo $a;
    $a++;
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Cette fonction est un peu inutile car à chaque fois
    qu'elle est appelée, elle initialise <varname>$a</varname> à 0 et
    affiche "0". L'incrémentation de la variable (<varname>$a</varname>++)
    ne sert pas à grand chose, car dès que la
    fonction est terminée, la variable disparaît.
    Pour faire une fonction de comptage utile, c'est-à-dire qui
    ne perdra pas la trace du compteur, la variable <varname>$a</varname> est
    déclarée comme une variable statique :
   </simpara>
   <para>
    <example>
     <title>Les variables statiques (2)</title>
     <programlisting role="php">
<![CDATA[
<?php
function Test() {
    static $a = 0;
    echo $a;
    $a++;
}
?>
]]>

     </programlisting>
    </example>
   </para>
   <simpara>
    Maintenant, à chaque fois que la fonction Test() est
    appelée, elle affichera une valeur de <varname>$a</varname> incrémentée
    de 1.
   </simpara>

   <simpara>
    Les variables statiques sont essentielles lorsque vous faîtes des
    appels récursifs à une fonction. Une fonction
    récursive est une fonction qui s'appelle elle-même.
    Il faut faire attention lorsque vous écrivez une fonction
    récursive car il est facile de faire une boucle infinie.
    Vous devez vérifier que vous avez bien une condition qui
    permet de terminer votre récursivité. La fonction
    suivante compte récursivement jusqu'à 10 :
   </simpara>
   <para>
    <example>
     <title>Les variables statiques et la récursivité</title>
     <programlisting role="php">
<![CDATA[
<?php
function Test() 
{
    static $count = 0;
    $count++;
    echo $count;
    if ($count < 10) {
        Test();
    }
    $count--;
}
?>
]]>
     </programlisting>
    </example>
   </para>

    <note>
     <para>
      Les variables statiques doivent être déclarées comme dans l'exemple ci-dessus.
      Tenter d'assigner des valeurs à ces variables qui sont le résultat d'expressions
      causera une erreur d'analyse.
     </para>
     <para>
      <example>
       <title>Déclaration de variables statiques</title>
       <programlisting role="php">
<![CDATA[
<?php
function foo(){
    static $int = 0;          // correct
    static $int = 1+2;        // faux  (car c'est une expression)
    static $int = sqrt(121);  // faux  (car c'est aussi une expression)

    $int++;
    echo $int;
}
?>
]]>
      </programlisting>
     </example>
    </para>
   </note>
  </sect2>

  <sect2 id="language.variables.scope.references">
   <title>
    Les références avec les variables <literal>global</literal> et <literal>static</literal>
   </title>
   <simpara>
    Le Zend Engine 1, sur qui repose &php; 4, implémente les
    options <literal><link linkend="language.variables.scope.static">static</link></literal>
    et <literal><link linkend="language.variables.scope.global">global</link></literal>
    pour les variables, en terme de références. Par exemple, une vraie
    variable globale est importée dans un contexte de fonction avec
    <literal>global</literal>.
    Cette commande crée en fait une référence sur la variable globale. Cela
    peut vous mener à des comportements inattendus, par exemple :
   </simpara>

   <example>
    <title>Les variables statiques et les références</title>
    <programlisting role="php">
<![CDATA[
<?php
function test_global_ref() {
    global $obj;
    $obj = &new stdclass;
}

function test_global_noref() {
    global $obj;
    $obj = new stdclass;
}

test_global_ref();
var_dump($obj);
test_global_noref();
var_dump($obj);
?>
]]>
    </programlisting>
   </example>
   &example.outputs;
   <screen>
NULL
object(stdClass)(0) {
}
   </screen>

   <simpara>
    Un comportement similaire s'applique à la commande <literal>static</literal>.
    Les références ne sont pas stockées dynamiquement :
   </simpara>

   <example>
    <title>Les variables statiques et les références (2)</title>
    <programlisting role="php">
<![CDATA[
<?php
function &get_instance_ref() {
    static $obj;

    echo 'Objet statique : ';
    var_dump($obj);
    if (!isset($obj)) {
        // Assigne une référence à une variable statique
        $obj = &new stdclass;
    }
    $obj->property++;
    return $obj;
}

function &get_instance_noref() {
    static $obj;

    echo 'Objet statique : ';
    var_dump($obj);
    if (!isset($obj)) {
        // Assigne une objet à une variable statique
        $obj = new stdclass;
    }
    $obj->property++;
    return $obj;
}

$obj1 = get_instance_ref();
$still_obj1 = get_instance_ref();
echo "\n";
$obj2 = get_instance_noref();
$still_obj2 = get_instance_noref();
?>
]]>
    </programlisting>
   </example>
   &example.outputs;
   <screen>
Objet statique : NULL
Objet statique : NULL

Objet statique : NULL
Objet statique : object(stdClass)(1) {
  ["property"]=>
  int(1)
}
   </screen>

    <simpara>
     Ces exemples illustrent les problèmes rencontrés lors de l'assignation
     de référence à des variables statiques, qui sont
     <emphasis>oubliées</emphasis> lorsque vous appelez
     <literal>&amp;get_instance_ref()</literal> une seconde fois.
    </simpara>
   </sect2>
  </sect1>

  <sect1 id="language.variables.variable">
   <title>Les variables dynamiques</title>

   <simpara>
    Il est pratique d'avoir parfois des noms de variables qui sont variables.
    C'est-à-dire un nom de variable qui est affecté et utilisé
    dynamiquement. Une variable classique est affectée avec
    l'instruction suivante :
   </simpara>

   <example>
    <title>Une variable classique</title>
    <programlisting role="php">
<![CDATA[
<?php
$a = 'bonjour';
?>
]]>
    </programlisting>
   </example>

   <simpara>
    Une variable dynamique prend la valeur d'une variable et l'utilise
    comme nom d'une autre variable. Dans l'exemple ci-dessous,
    <emphasis>bonjour</emphasis> peut être utilisé comme le nom d'une
    variable en utilisant le "$$" précédent la variable.
    C'est-à-dire :
   </simpara>

   <example>
    <title>Les variables variables</title>
    <programlisting role="php">
<![CDATA[
<?php
$$a = 'monde';
?>
]]>
    </programlisting>
   </example>

   <simpara>
    À ce niveau, deux variables ont été définies et
    stockées dans l'arbre des symboles &php; : <varname>$a</varname> avec comme valeur
    "bonjour" et <varname>$bonjour</varname> avec comme valeur "monde". Alors, l'instruction :
   </simpara>

   <example>
    <title>Equivalent de variables variables</title>
    <programlisting role="php">
<![CDATA[
<?php
echo "$a ${$a}";
?>
]]>
    </programlisting>
   </example>

   <simpara>
    produira le même affichage que :
   </simpara>

   <example>
    <title>Equivalent de variables variables</title>
    <programlisting  role="php">
<![CDATA[
<?php
echo "$a $bonjour";
?>
]]>
    </programlisting>
   </example>

   <simpara>
    c'est-à-dire : <emphasis>bonjour monde</emphasis>.
   </simpara>

   <simpara>
    Afin de pouvoir utiliser les variables dynamiques avec les tableaux,
    vous avez à résoudre un problème ambigü. Si vous
    écrivez <varname>$$a[1]</varname>, l'analyseur a besoin de savoir si vous
    parler de la variable qui a pour nom <varname>$a[1]</varname> ou bien si vous
    voulez l'index [1] de la variable <varname>$$a</varname>. La syntaxe pour résoudre
    cette ambigu&Ocirc;té est la suivante : <varname>${$a[1]}</varname> pour le premier
    cas et <varname>${$a}[1]</varname> pour le deuxième.
    </simpara>

    <warning>
     <simpara>
      Notez que les variables dynamiques ne peuvent pas être utilisées
      avec les
      <link linkend="language.variables.superglobals">tableaux Superglobaux</link> de &php;.
     </simpara>
    </warning>

  </sect1>

  <sect1 id="language.variables.external">
   <title>Variables externes à &php;</title>

   <sect2 id="language.variables.external.form">
    <title>Formulaires HTML (GET et POST)</title>

    <simpara>
     Lorsqu'un formulaire est envoyé à un script &php;,
     toutes les variables du formulaire seront automatiquement disponibles
     dans le script. Par exemple, considérons le formulaire suivant :
    </simpara>

    <para>
     <example>
      <title>Exemple avec un formulaire simple</title>
      <programlisting role="html">
<![CDATA[
<form action="foo.php" method="post">
    Nom  :  <input type="text" name="username" /><br />
    Email: <input type="text" name="email" /><br />
    <input type="submit" name="submit" value="Envoi!" />
</form>
]]>
      </programlisting>
     </example>
    </para>

    <para>
     Suivant votre configuration particulière et vos préférences,
     vous avez plusieurs méthodes pour accéder aux variables du formulaires.
     Voici quelques exemples :
    </para>

    <para>
     <example>
      <title>Accéder simplement à des variables de formulaires POST</title>
      <programlisting role="html">
<![CDATA[
<?php
// Disponibles depuis &php; 4.1.0

   echo $_POST['username'];
   echo $_REQUEST['username'];

   import_request_variables('p', 'p_');
   echo $p_username;

// Disponibles depuis &php; 3.

   echo $HTTP_POST_VARS['username'];

// Disponibles si la directive register_globals = on.  Depuis
// &php; 4.2.0 la valeur par défaut de cette directive est register_globals = off.
// Utiliser ou présumer cette méthode est découragé.

   echo $username;
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Utiliser un formulaire de type GET est similaire, hormis le fait que
     vous deviez utiliser les variables pré-définies de GET à la place.
     GET s'applique aussi à la <literal>QUERY_STRING</literal>
     (les informations disponibles après le '?' dans une URL).
     De ce fait, par exemple,
     <literal>http://www.example.com/test.php?id=3</literal>
     contient les données de GET, qui sont accessibles via <varname>$_GET['id']</varname>.
     Voyez aussi
     <link linkend="reserved.variables.request">$_REQUEST</link> et
     <function>import_request_variables</function>.
    </para>

    <note>
     <para>
      <link linkend="language.variables.superglobals">Les tableaux superglobaux</link>,
      comme <varname>$_POST</varname> et <varname>$_GET</varname> sont disponibles
      depuis &php; 4.1.0.
     </para>
    </note>

    <para>
     Comme nous l'avons déjà dis, avant &php; 4.2.0, la valeur par défaut de
     <link linkend="ini.register-globals">register_globals</link> était
     <emphasis>on</emphasis>. Dans &php; 3, elle était toujours à <literal>On</literal>.
     La communauté &php;
     n'encourage personne à utiliser cette directive et privilégie la valeur
     <emphasis>off</emphasis> et un code accordé.
    </para>

    <note>
     <para>
      La directive de configuration <link linkend="ini.magic-quotes-gpc">magic_quotes_gpc</link>
      affecte les valeurs de GET, POST et cookies. Si elle est activée,
      une valeur comme celle de (C'est "&php;!") sera magiquement transformée en (C\'est \"&php;!\").
      La protection des caractères est nécessaire pour l'insertion dans les bases de données.
      Voyez aussi les fonctions <function>addslashes</function>,
      <function>stripslashes</function> et
      <link linkend="ini.magic-quotes-sybase">magic_quotes_sybase</link>.
     </para>
    </note>

    <simpara>
     &php; comprend aussi les tableaux dans le contexte des formulaires.
     (voir aussi <link linkend="faq.html">la FAQ</link>).  Vous pouvez,
     par exemple, grouper des variables ensembles ou bien utiliser cette
     fonctionnalité pour lire des valeurs multiples d'un menu déroulant.
     Par exemple, voici un formulaire qui se poste lui-même des données,
     et les affiche :
    </simpara>

    <para>
     <example>
      <title>Variables de formulaires complexes</title>
      <programlisting role="php">
<![CDATA[
<?php
if ($_POST['action'] == 'submitted') {
    echo '<pre>';

    print_r($_POST);
    echo '<a href="'. $_SERVER['PHP_SELF'] .'">Essayez à nouveau</a>';

    echo '</pre>';
} else {
?>
<form action="<?php echo $_SERVER['PHP_SELF']; ?>" method="post">
    Nom   :  <input type="text" name="personal[name]" /><br />
    Email : <input type="text" name="personal[email]" /><br />
    Biere : <br />
    <select multiple name="vin[]">
        <option value="bordeaux">bordeaux</option>
        <option value="beaujolais">beaujolais</option>
        <option value="loire">loire</option>
    </select><br />
    <input type="hidden" name="action" value="submitted" />
    <input type="submit" name="submit" value="submit me!" />
</form>
<?php
}
?>
]]>
      </programlisting>
     </example>
    </para>

    <para>
     En &php; 3, la syntaxe des tableaux HTML est limitée aux tableaux
     uni-dimensionnels. En &php; 4, ces limitations ont été levées.
    </para>

    <sect3 id="language.variables.external.form.submit">
     <title>Nom de variables IMAGE de type <literal>SUBMIT</literal></title>

     <simpara>
      Lors de la soumission d'un formulaire, il est possible d'utiliser
      une image au lieu d'un bouton standard, comme ceci :
     </simpara>

     <example>
      <title>Utilisation d'une image pour soumettre un formulaire</title>
      <programlisting role="html">
<![CDATA[
<input type="image" src="image.gif" name="sub" />
]]>
      </programlisting>
     </example>

     <simpara>
      Lorsque l'utilisateur clique sur cette image, le formulaire
      associé est envoyé au serveur, avec deux données supplémentaires,
      <varname>sub_x</varname> et <varname>sub_y</varname>. Elles contiennent
      les coordonnées du clic de l'utilisateur dans l'image. Vous noterez
      que ces variables sont envoyées par le navigateur avec un point dans leur
      nom, mais &php; convertit ces points en soulignés.
     </simpara>
    </sect3>

   </sect2>

   <sect2 id="language.variables.external.cookies">
    <title>Cookies HTTP</title>

    <simpara>
     &php; supporte les cookies HTTP de manière totalement
     transparente, comme défini dans les
     <ulink url="&spec.cookies;">spécifications de Netscape</ulink>. Les cookies
     sont un mécanisme permettant de stocker des données
     sur la machine cliente à des fins d'identification de
     l'utilisateur. Vous pouvez établir un cookie grâce à
     la fonction <function>setcookie</function>. Les cookies
     font partie intégrante des en-têtes HTTP et donc
     la fonction <function>setcookie</function> doit être
     appelée avant que le moindre affichage ne soit envoyé
     au navigateur. C'est la même restriction que pour la fonction
     <function>header</function>. Les données contenus dans les cookies
     sont alors disponibles dans les tableaux de cookies appopriés, comme
     <varname>$_COOKIE</varname>, <varname>$HTTP_COOKIE_VARS</varname>
     mais aussi <varname>$_REQUEST</varname>. Lisez la page de la documentation
     sur la fonction <function>setcookie</function> pour plus de détails ainsi que des exemples.
    </simpara>

    <simpara>
     Si vous souhaitez assigner plusieurs valeurs à un seul
     cookie, il vous faut ajouter les caractères
     <emphasis>[]</emphasis> au nom de votre cookie.
     Par exemple :
    </simpara>

    <example>
      <title>Utilisation de tableaux avec les cookies</title>
     <programlisting role="php">
<![CDATA[
<?php
setcookie("MyCookie[foo]", 'Test 1', time()+3600);
setcookie("MyCookie[bar]", 'Test 2', time()+3600);
?>
]]>
     </programlisting>
    </example>

    <simpara>
     Cela va créer deux cookies distinctes bien que <varname>MyCookie</varname>
     est maintenant un simple tableau dans votre script. Si vous voulez définir
     seulement un cookie avec plusieurs valeurs, utilisez la fonction
     <function>serialize</function> ou <function>explode</function>
     sur la première valeur.
    </simpara>

    <simpara>
     Il est à noter qu'un cookie remplace le cookie
     précédent par un cookie de même nom tant que
     le "<literal>path</literal>" ou le domaine sont identiques.
     Donc, pour une application de panier, vous devez implémenter
     un compteur et l'incrémenter au fur et à mesure. C'est-à-dire :
    </simpara>

    <example>
     <title>Exemple avec <function>setcookie</function></title>
     <programlisting role="php">
<![CDATA[
<?php
if (isset($_COOKIE['compte'])) {
    $compte = $_COOKIE['compte'] + 1;
} else {
    $compte = 1;
}
setcookie('Panier', $compte, time()+3600);
setcookie("Panier[$compte]", $item, time()+3600);
?>
]]>
     </programlisting>
    </example>

   </sect2>

   <sect2 id="language.variables.external.dot-in-names">
    <title>Cas des points dans les noms de variables</title>

    <para>
     Typiquement, &php; ne modifie pas les noms des variables lorsqu'elles
     sont passées à un script. Cependant, il faut noter que
     les points (.) ne sont pas autorisés dans les noms de variables
     &php;. Pour cette raison, jetez un oeil sur :
     <programlisting role="php">
<![CDATA[
<?php
  $varname.ext;  /* nom de variable invalide */
?>
]]>
     </programlisting>
     Dans ce cas, l'analyseur croit voir la variable nommée
     <varname>$varname</varname>, suivie par l'opérateur de concaténation,
     et suivie encore par la chaîne sans guillemets
     (une chaîne sans guillemets et qui n'a pas de signification
     particulière). Visiblement, ce n'est pas ce qu'on attendait...
    </para>

    <para>
     Pour cette raison, il est important de noter que &php; remplacera
     automatiquement les points des noms de variables entrantes par
     des soulignés (<literal>underscore</literal>).
    </para>

   </sect2>

   <sect2 id="language.variables.determining-type-of">
    <title>Détermination du type des variables</title>

    <para>
     Parce que &php; détermine le type des variables et
     les convertit (généralement) comme il faut,
     ce n'est pas toujours le type de variable que vous souhaîtez.
     &php; inclut des fonctions permettant de déterminer le
     type d'une variable :
     <function>gettype</function>,
     <function>is_array</function>,
     <function>is_float</function>,
     <function>is_int</function>,
     <function>is_object</function> et
     <function>is_string</function>.
     Lisez également le chapître sur les
     <link linkend="language.types">types</link>.
    </para>
   </sect2>

  </sect1>

 </chapter>
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
indent-tabs-mode:nil
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
