<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.38 $ -->
 <chapter id="language.variables">
  <title>Les variables</title>
  <sect1 id="language.variables.basics">
   <title>Essentiel</title>
   <simpara>
    En &php;, les variables sont repr&eacute;sent&eacute;es par un signe
    dollar "$" suivi du nom de la variable. Le nom est sensible &agrave;
    la casse (ie : $x != $X).
   </simpara>
   <para>
    Les noms de variables suivent les m&ecirc;mes r&egrave;gles de nommage que
    les autres entit&eacute;s &php;. Un nom de variable valide doit commencer par
    une lettre ou un soulign&eacute; (_), suivi de lettres, chiffres ou
    soulign&eacute;s. Exprim&eacute; sous la forme d'une expression
    r&eacute;guli&egrave;re, cela donne :
    '[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*'
   </para>
   <note>
    <simpara>
     Dans nos propos, une lettre peut &ecirc;tre une des lettres minuscules
     (a &agrave; z) ou majuscules (A &agrave; Z), et les caract&egrave;res
     ASCII de 127 &agrave; 255 (0x7f-0xff).
    </simpara>
   </note>
    <para>
    <example>
     <title>Validit&eacute; des noms de variables</title>
     <programlisting role="php">
<![CDATA[
<?php
  $var = "Jean";
  $Var = "Paul";
  echo "$var, $Var";         // affiche "Jean, Paul"
  $4site = 'pas encore';     // invalide : commence par un nombre
  $_4site = 'pas encore';    // valide : commence par un soulign&eacute;
  $ma&#239;s = 'jaune';      // valide; '&iuml;' est ASCII 239.
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    En &php; 3, les variables sont toujours assign&eacute;es par valeur.
    C'est-&agrave;-dire, lorsque vous assignez une expression &agrave;
    une variable, la valeur de l'expression est recopi&eacute;e dans
    la variable. Cela signifie, par exemple, qu'apr&egrave;s avoir
    assign&eacute; la valeur d'une variable &agrave; une autre,
    modifier l'une des variables n'aura pas d'effet sur l'autre. Pour plus
    de d&eacute;tails sur ce genre d'assignation, reportez-vous &agrave;
    <link linkend="language.expressions">Expressions</link>.
   </para>
   <para>
    &php; 4 permet aussi d'assigner les valeurs aux variables
    <emphasis>par r&eacute;f&eacute;rence</emphasis>. Cela
    signifie que la nouvelle variable ne fait que r&eacute;f&eacute;rencer
    (en d'autres terme, "devient un alias de", ou encore "pointe sur") la
    variable originale. Les modifications de la nouvelle variable
    affecteront l'ancienne, et vice versa. Cela signifie aussi
    qu'aucune copie n'est faite : l'assignation est donc beaucoup
    plus rapide. Cela se fera notamment sentir dans des boucles,
    ou lors d'assignation de grands objets (tableaux).
   </para>
   <para>
    Pour assigner par r&eacute;f&eacute;rence, ajoutez simplement
    un &amp; (ET commercial) au d&eacute;but de la variable qui
    est assign&eacute;e (la variable source). Dans l'exemple suivant,
    <literal>Mon nom est Pierre</literal> s'affichera deux
    fois :
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$foo = 'Pierre';              // Assigne la valeur 'Pierre' &agrave; $foo
$bar = &$foo;              // R&eacute;f&eacute;rence $foo avec $bar.
$bar = "Mon nom est Pierre";  // Modifie $bar...
echo $foo;                 // $foo est aussi modifi&eacute;e
echo $bar;
?>
]]>

     </programlisting>
    </informalexample>
   </para>
   <para>
    Une chose importante &agrave; noter est que seules les variables
    nomm&eacute;es peuvent &ecirc;tre assign&eacute;es par r&eacute;f&eacute;rence.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$foo = 25;
$bar = &$foo;      // assignation valide .
$bar = &(24 * 7);  // assignation invalide : r&eacute;f&eacute;rence une expression sans nom
function test() {
   return 25;
}
$bar = &test();    // assignation invalide.
?>
]]>

     </programlisting>
    </informalexample>
   </para>
   <para>
    &php; suit les conventions de Perl pour la gestion des op&eacute;rateurs
    arithm&eacute;iques, et non pas celles du lanage C. Par exemple, en Perl 
    <literal>'Z'+1</literal> devient <literal>'AA'</literal>, tandis que
    en langage C <literal>'Z'+1</literal> devient <literal>'['</literal> 
    ({ ord('Z') == 90, ord('[') == 91 ).
    <example>
     <title>Op&eacute;rations arithm&eacute;tiques et caract&egrave;res</title>
     <programlisting role="php">
<![CDATA[
<?php
$i = 'W';
for($n=0; $n<6; $n++)
  echo ++$i . "\n";

/*
  Affiche ceci : 

X
Y
Z
AA
AB
AC

*/
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect1>
  <sect1 id="language.variables.predefined">
   <title>Variables pr&eacute;d&eacute;finies</title>
   <simpara>
    &php; fourni un grand nombre de variables pr&eacute;d&eacute;finies.
    Cependant, beaucoup de ces variables ne peuvent pas &ecirc;tre
    pr&eacute;sent&eacute;es ici, car elles d&eacute;pendent du serveur
    sur lequel elles tournent, de la version du serveur, et de la
    configuration du serveur, ou encore d'autres facteurs. Certaines
    de ces variables ne seront pas accessibles lorsque &php; fonctionne
    en ex&eacute;cutable.
   </simpara>
   <warning>
    <simpara>
     Depuis la version &php; 4.2.0, la valeur par d&eacute;faut de la directive &php;
     <link linkend="ini.register-globals">register_globals</link> est 
     <emphasis>off</emphasis>. Ceci est une &eacute;volution majeure de &php;.
     Avoir la directive register_globals &agrave; <emphasis>off</emphasis> affecte les
     variables pr&eacute;d&eacute;finies du contexte globale. Par exemple, pour lire 
     <varname>DOCUMENT_ROOT</varname> vous devez utiliser
     <varname>$_SERVER['DOCUMENT_ROOT']</varname> au lieu de 
     <varname>$DOCUMENT_ROOT</varname>, ou bien il faut lire <varname>$_GET['id']</varname> 
     dans l'URL <literal>http://www.example.com/test.php?id=3</literal> au lieu
     de <varname>$id</varname>, ou encore <varname>$_ENV['HOME']</varname> au lieu de
     <varname>$HOME</varname>.
    </simpara>
    <simpara>
     Pour des informations li&eacute;es &agrave; cette &eacute;volution, lisez la documentation de la 
     directive <link linkend="ini.register-globals">register_globals</link>, le chapitre
     sur la s&eacute;crit&eacute;, &agrave; propos de l'<link linkend="security.registerglobals">Utilisation des variables super-globales</link>, 
     ainsi que les annonces de &php; <ulink url="&url.php.release4.1.0;">4.1.0</ulink> 
     et <ulink url="&url.php.release4.2.0;">4.2.0</ulink>.
    </simpara>
    <simpara>
     L'utilisation des variables pr&eacute;d&eacute;finies de &php;, comme les
     <link linkend="language.variables.superglobals">tableaux superglobaux</link>, 
     est recommand&eacute;.
    </simpara>
   </warning>
   <simpara>
    Depuis la version 4.1.0, &php; fournit un jeu de tableaux
    pr&eacute;d&eacute;finis, contenant les variables du serveur (si possible), les
    variables d'environnement et celle d'entr&eacute;es. Ces nouveaux tableaux
    sont un peut particuliers, car ils ont automatiquement globaux : 
    ils sont automatiquement disponibles dans tous les environnements
    d'ex&eacute;cution, sans avoir &agrave; utiliser le mot r&eacute;serv&eacute; <literal>global</literal>.
    Pour cette raison, ils sont dits 'auto-globaux' ou bien encore
    'superglobaux' (il n'y a pas de m&eacute;canisme &php; pour cr&eacute;er de telles
    variables. Les superglobales sont list&eacute;es ci-dessous. Cependant, pour
    conna&icirc;tre le d&eacute;tails de leur contenu, et une pr&eacute;sentation approfondie
    sur les variables pr&eacute;d&eacute;finies &php;, et leur nature, reportez vous
    &agrave; la section <link linkend="reserved.variables">variables pr&eacute;definies</link>.
    De plus, vous noterez que les anciennes variables pr&eacute;d&eacute;finies
    (<varname>$HTTP_*_VARS</varname>) existent toujours.
   </simpara>
   
   <note>
    <title>Variables variables</title>
    <para>
     Les superglobales ne peuvent pas &ecirc;tre utilis&eacute;es comme 
     <link linkend="language.variables.variable">variable variables</link>.
    </para>
   </note>

   <para>
    Si certaines variables de <link linkend="ini.variables-order">variables_order</link> 
    ne sont pas d&eacute;finies, leur tableau pr&eacute;d&eacute;fini &php; correspondant est laiss&eacute; vide.
   </para>

   <variablelist id="language.variables.superglobals">
    <title>Tableaux superglobaux de &php;</title>
    <varlistentry>
     <term><link linkend="reserved.variables.globals">$GLOBALS</link></term>
     <listitem>
      <simpara>
       Contient une r&eacute;f&eacute;rence sur chaque variable qui est actuellement disponible
       dans l'environnement d'ex&eacute;cution global. Les cl&eacute;s de ce tableau sont les
       noms des variables globales.
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.server">$_SERVER</link></term>
     <listitem>
      <simpara>
       Les variables fournies par le serveur web, ou bien directement
       li&eacute;es &agrave; l'environnement d'ex&eacute;cution du script courant. C'est
       la nouvelle version de l'ancienne variable <varname>$HTTP_SERVER_VARS</varname>,
       qui est maintenant obsol&egrave;te, mais toujours l&agrave;.
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.get">$_GET</link></term>
     <listitem>
      <simpara>
       Les variables fournies par le protocole HTTP en m&eacute;thode GET.
        C'est la nouvelle version de l'ancienne variable <varname>$HTTP_GET_VARS</varname>
       qui est maintenant obsol&egrave;te, mais toujours l&agrave;.
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.post">$_POST</link></term>
     <listitem>
      <simpara>
        Les variables fournies par le protocole HTTP en m&eacute;thode POST.
        C'est la nouvelle version de l'ancienne variable <varname>$HTTP_POST_VARS</varname>
       qui est maintenant obsol&egrave;te, mais toujours l&agrave;.
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.cookies">$_COOKIE</link></term>
     <listitem>
      <simpara>
        Les variables fournies par le protocole HTTP, dans les cookies.
        C'est la nouvelle version de l'ancienne variable <varname>$HTTP_COOKIE_VARS</varname>
       qui est maintenant obsol&egrave;te, mais toujours l&agrave;.
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.files">$_FILES</link></term>
     <listitem>
      <simpara>
        Les variables fournies par le protocole HTTP, suite &agrave; un t&eacute;l&eacute;chargement de fichier.
        C'est la nouvelle version de l'ancienne variable <varname>$HTTP_POST_FILES</varname>
       qui est maintenant obsol&egrave;te, mais toujours l&agrave;. Voir
       <link linkend="features.file-upload.post-method">T&eacute;l&eacute;chargement par m&eacute;thode POST</link>,
       pour plus d'informations.
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.environment">$_ENV</link></term>
     <listitem>
      <simpara>
        Les variables fournies par l'environnement.
        C'est la nouvelle version de l'ancienne variable <varname>$HTTP_ENV_VARS</varname>
       qui est maintenant obsol&egrave;te, mais toujours l&agrave;.
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.request">$_REQUEST</link></term>
     <listitem>
      <simpara>
        Les variables fournies au script par n'importe quel m&eacute;canisme d'entr&eacute;e
        et qui ne doit recevoir une confiance limit&eacute;e. Note : lorsque
        vous ex&eacute;cutez un script en ligne de commande, cette variable ne
        va <emphasis>pas</emphasis> inclure les variables <varname>argv</varname> 
        et <varname>argc</varname>. Elles seront pr&eacute;sentes dans la variable
        <varname>$_SERVER</varname>. La pr&eacute;sence et la valeur des entr&eacute;es
        de ce tableau sont r&eacute;gl&eacute;s par la directive 
        <link linkend="ini.variables-order">variables_order</link>. Ce tableau
        n'est l'&eacute;volution d'aucune variable d'avant &php; 4.1.0.
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.session">$_SESSION</link></term>
     <listitem>
      <simpara>
       Les variables qui sont actuellement enregistr&eacute;es dans la session attach&eacute;e
       au script. which are currently registered to a script's
       session.C'est la nouvelle version de l'ancienne variable <varname>$HTTP_SESSION_VARS</varname>.
       Voir le chapitre <link linkend="ref.session">Sessions handling functions</link>
       pour plus d'informations.
      </simpara>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect1>
  <sect1 id="language.variables.scope">
   <title>Port&eacute;e des variables</title>
   <simpara>
	La port&eacute;e d'une variable d&eacute;pend du contexte
	dans lequel la variable est d&eacute;finie. Pour la majorit&eacute; des
	variables, la port&eacute;e concerne la totalit&eacute; d'un script
	&php;. Mais, lorsque vous d&eacute;finissez une fonction, la
	port&eacute;e d'une variable d&eacute;finie dans cette fonction
	est locale &agrave; la fonction. Par exemple:
   </simpara>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$a = 1;
include "b.inc";
?>
]]>

    </programlisting>
   </informalexample>
   <simpara>
    Ici, la variable $a sera accessible dans le script inclus
    <filename>b.inc</filename>. Cependant, dans les fonctions
    d&eacute;finies par l'utilisateur, une nouvelle d&eacute;finition
    de cette variable sera donn&eacute;e, limit&eacute;e &agrave; la
    fonction. Toute variable utilis&eacute;e dans une fonction est
    par d&eacute;finition, locale. Par exemple :
   </simpara>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$a = 1; /* port&eacute;e globale */
function test() {
    echo $a; /* port&eacute;e locale */
}
test();
?>
]]>

    </programlisting>
   </informalexample>
   <simpara>
	Le script n'affichera rien &agrave; l'&eacute;cran car
	la fonction <function>echo</function> utilise la variable locale $a,
	et celle-ci n'a pas &eacute;t&eacute; assign&eacute;e
	pr&eacute;alablement dans la fonction. Vous pouvez noter que
	ce concept diff&egrave;re un petit peu du langage C dans
	lequel une variable globale est automatiquement accessible dans
	les fonctions, &agrave; moins d'&ecirc;tre red&eacute;finie
	localement dans la fonction. Cela peut poser des probl&egrave;mes
	si vous red&eacute;finissez des variables globales localement.
	En &php;, une variable globale doit &ecirc;tre
	d&eacute;clar&eacute;e &agrave; l'int&eacute;rieur de chaque
	fonction afin de pouvoir &ecirc;tre utilis&eacute;e dans cette
	fonction. Par exemple:
   </simpara>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$a = 1;
$b = 2;
function somme() {
    global $a, $b;
    $b = $a + $b;
}
somme();
echo $b;
]]>
    </programlisting>
   </informalexample>
   <simpara>
	Le script ci-dessus va afficher la valeur <literal>3</literal>.
	En d&eacute;clarant globales les variables $a et $b locales
	de la fonction somme(), toutes les r&eacute;f&eacute;rences &agrave;
	ces variables concerneront les variables globales. Il n'y a
	aucune limite au nombre de variables globales qui peuvent
	&ecirc;tre manipul&eacute;es par une fonction.
   </simpara>
   <simpara>
	Une deuxi&egrave;me m&eacute;thode pour acc&eacute;der aux
	variables globales est d'utiliser le tableau associatif
	pr&eacute;d&eacute;fini $GLOBALS. Le pr&eacute;c&eacute;dent
	exemple peut &ecirc;tre r&eacute;&eacute;crit de la
	mani&egrave;re suivante:
   </simpara>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
  $a = 1;
  $b = 2;
  function somme() {
    $GLOBALS["b"] = $GLOBALS["a"] + $GLOBALS["b"];
  }
  somme();
  echo $b;
?>
]]>

    </programlisting>
   </informalexample>
   <simpara>
	Le tableau $GLOBALS est un tableau associatif avec le nom
	des variables globales comme clef et les valeurs des &eacute;l&eacute;ments
	du tableau comme valeur des variables. Notez que <varname>$GLOBALS</varname> 
	existe dans tous les contextes, car <varname>$GLOBALS</varname> est un
	<link linkend="language.variables.superglobals">superglobal</link>.
    Voici un exemple des super globaux : 
   </simpara>
   <para>
   
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
function test_global()
{
    // La plupart des variables pr&eacute;d&eacute;finies ne sont pas des "superglobales" et
    // requiert le mot cl&eacute; 'global' pour &ecirc;tre disponible dans une fonction.
    global $HTTP_POST_VARS;
    
    print $HTTP_POST_VARS['name'];
    
    // Les superglobales sont accessibles dans tous les contextes
    // et ne requi&egrave;rent pas 'global'.  Les superglobales sont disponibles
    // depuis &php; 4.1.0
    print $_POST['name'];
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
	Une autre caract&eacute;ristique importante de la port&eacute;e des variables est
	la notion de variable <emphasis>static</emphasis>. Une variable statique a
	une port&eacute;e locale uniquement, mais elle ne perd pas sa valeur lorsque le
	script appelle la fonction. Prenons l'exemple suivant:
   </simpara>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
function test() {
    $a = 0;
    echo $a;
    $a++;
}
?>
]]>

    </programlisting>
   </informalexample>
   <simpara>
	Cette fonction est un peu inutile car &agrave; chaque fois
	qu'elle est appel&eacute;e, elle initialise $a &agrave; 0 et
	affiche "0". L'incr&eacute;mentation de la variable ($a++)
	ne sert pas &agrave; grand chose, car d&egrave;s que la
	fonction est termin&eacute;e la variable dispara&icirc;t.
	Pour faire une fonction de comptage utile, c'est-&agrave;-dire qui
	ne perdra pas la trace du compteur, la variable $a est
	d&eacute;clar&eacute;e comme une variable statique:
   </simpara>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
function test() {
    static $a = 0;
    echo $a;
    $a++;
}
?>
]]>

    </programlisting>
   </informalexample>
   <simpara>
    Maintenant, &agrave; chaque fois que la fonction Test() est
    appel&eacute;e, elle affichera une valeur de $a incr&eacute;ment&eacute;e
    de 1.
   </simpara>
   <simpara>
	Les variables statiques sont essentielles lorsque vous faites des
	appels r&eacute;cursifs &agrave; une fonction. Une fonction
	r&eacute;cursive est une fonction qui s'appelle elle-m&ecirc;me.
	Il faut faire attention lorsque vous &eacute;crivez une fonction
	r&eacute;cursive car il est facile de faire une boucle infinie.
	Vous devez v&eacute;rifier que vous avez bien une condition qui
	permet de terminer votre r&eacute;cursivit&eacute;. La fonction
	suivante compte r&eacute;cursivement jusqu'&agrave; 10:
   </simpara>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
function test() {
    static $count = 0;
    $count++;
    echo $count;
    if ($count < 10) {
        test();
    }
    $count--;
}
?>
]]>

    </programlisting>
   </informalexample>
   <simpara>
    Le Zend Engine 1, sur qui repose <literal>&php;4</literal>, impl&eacute;mente les
    options <literal>static</literal> et <literal>global</literal> pour les variables,
    en terme de r&eacute;f&eacute;rences. Par exemple, une vrai variable globale
    est import&eacute;e dans un contexte de fonction avec <literal>global</literal>.
    Cette commande cr&eacute;e en fait une r&eacute;f&eacute;rence sur la variable globale. Ce
    peut vous mener &agrave; des comportement inattendus, comme par exemple : 
   </simpara>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
function test_global_ref() {
    global $obj;
    $obj = &new stdclass;
}

function test_global_noref() {
    global $obj;
    $obj = new stdclass;
}

test_global_ref();
var_dump($obj);
test_global_noref();
var_dump($obj);
?>
]]>
    </programlisting>
   </informalexample>

   <simpara>
    Ex&eacute;cuter cet exemple vous donnera  : 
   </simpara>

   <screen>
NULL
object(stdClass)(0) {
}
   </screen>

   <simpara>
    Un comportement similaire s'applique &agrave; la commande <literal>static</literal>.
    Les r&eacute;f&eacute;rences ne sont pas stock&eacute;es dynamiquement : 
   </simpara>
   
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
function &get_instance_ref() {
    static $obj;

    echo "Objet statique : ";
    var_dump($obj);
    if (!isset($obj)) {
        // Assigne une r&eacute;f&eacute;rence &agrave; une variable statique
        $obj = &new stdclass;
    }
    $obj->property++;
    return $obj;
}

function &get_instance_noref() {
    static $obj;

    echo "Objet statique : ";
    var_dump($obj);
    if (!isset($obj)) {
        // Assigne une objet &agrave; une variable statique
        $obj = new stdclass;
    }
    $obj->property++;
    return $obj;
}

$obj1 = get_instance_ref();
$still_obj1 = get_instance_ref();
echo "\n";
$obj2 = get_instance_noref();
$still_obj2 = get_instance_noref();
?>
]]>
    </programlisting>
   </informalexample>

   <simpara>
    Ex&eacute;cuter cet exemple vous donnera  : 
   </simpara>

   <screen>
Objet statique : NULL
Objet statique : NULL

Objet statique : NULL
Objet statique : object(stdClass)(1) {
  ["property"]=>
  int(1)
}
   </screen>

   <simpara>
    Ces exemples illustrent les probl&egrave;mes rencontr&eacute;s lors de l'assignation
    de r&eacute;f&eacute;rence &agrave; des variables statiuqes, qui sont 
    <emphasis>oubli&eacute;es</emphasis> lorsque vous appelez
    <literal>&amp;get_instance_ref()</literal> une seconde fois.
   </simpara>
  </sect1>
  <sect1 id="language.variables.variable">
   <title>Les variables dynamiques</title>
   <simpara>
	Il est pratique d'avoir parfois des noms de variables qui sont variables.
	C'est-&agrave;-dire un nom de variable qui est affect&eacute;e et utilis&eacute;e
	dynamiquement. Une variable classique est affect&eacute; avec
	l'instruction suivante:
   </simpara>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$a = "bonjour";
?>
]]>

    </programlisting>
   </informalexample>
   <simpara>
	Une variable dynamique prend la valeur d'une variable et l'utilise
	comme nom d'une autre variable. Dans l'exemple ci-dessous,
	<emphasis>bonjour</emphasis> peut &ecirc;tre utilis&eacute; comme le nom d'une
	variable en utilisant le "$$" pr&eacute;c&eacute;dent la variable.
	C'est-&agrave;-dire
   </simpara>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$$a = "monde";
?>
]]>

    </programlisting>
   </informalexample>
   <simpara>
	A ce niveau, deux variables ont &eacute;t&eacute; d&eacute;finies et
	stock&eacute;es dans l'arbre des symboles &php; : $a avec comme valeur
	"bonjour" et $bonjour avec comme valeur "monde". Alors, l'instruction
    </simpara>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
echo "$a ${$a}";
?>
]]>

    </programlisting>
   </informalexample>
   <simpara>
    produira le m&ecirc;me affichage que :
   </simpara>
   <informalexample>
    <programlisting  role="php">
<![CDATA[
<?php
echo "$a $bonjour";
?>
]]>

    </programlisting>
   </informalexample>
   <simpara>
    c'est-&agrave;-dire : <emphasis>bonjour monde</emphasis>.
   </simpara>
   <simpara>
	Afin de pouvoir utiliser les variables dynamiques avec les tableaux,
	vous avez &agrave; r&eacute;soudre un probl&egrave;me ambigu. Si vous
	&eacute;crivez $$a[1], le parseur a besoin de savoir si vous
	parler de la variable qui a pour nom $a[1] ou bien si vous voulez
	l'index [1] de la variable $$a. La syntaxe pour r&eacute;soudre
	cette ambigu&iuml;t&eacute; est la suivante: ${$a[1]} pour le premier
	cas, et ${$a}[1] pour le deuxi&egrave;me.
    </simpara>
  </sect1>
  <sect1 id="language.variables.external">
   <title>Variables externes &agrave; &php;</title>
   <sect2 id="language.variables.external.form">
    <title>Formulaires HTML (GET et POST)</title>
    <simpara>
	Lorsqu'un formulaire est envoy&eacute; &agrave; un script &php;,
	toutes les variables du formulaire seront automatiquement disponibles
	dans le script. Par exemple, consid&eacute;rons le formulaire suivant:
    </simpara>
    <para>
     <example>
      <title>Exemple avec un formulaire simple</title>
      <programlisting role="html">
<![CDATA[
<form action="foo.php" method="post">
    Name:  <input type="text" name="username"><br>
    Email: <input type="text" name="email"><br>
    <input type="submit" name="submit" value="Submit me!">
</form>
]]>
      </programlisting>
     </example>
    </para>
 
    <para>
     Suivant votre configuration particuli&egrave;er et vos pr&eacute;f&eacute;rences,
     vous avez plusieurs m&eacute;thodes pour acc&eacute;der aux variables du formulaires.
     Voici quelques exemples : 
    </para>
    
    <para>
     <example>
      <title>Acc&eacute;der simplement &agrave; des variables de formulaires POST</title>
      <programlisting role="html">
<![CDATA[
<?php 
// Disponibles depuis &php; 4.1.0

   print $_POST['username'];
   print $_REQUEST['username'];

   import_request_variables('p', 'p_');
   print $p_username;

// Disponibles depuis &php; 3.

   print $HTTP_POST_VARS['username'];

// Disponibles si la directive register_globals = on.  Depuis
// &php; 4.2.0 la valeur par d&eacute;faut de cette directive est register_globals = off.
// Utiliser ou pr&eacute;sumer cette m&eacute;thode est d&eacute;courag&eacute;.

   print $username;
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Utiliser un formulaire de type GET est similaire, hormis le fait que
     vpis devez utiliser les variables pr&eacute;d&eacute;finies du GET &agrave; la place. 
     GET s'applique aussi &agrave; la QUERY_STRING (les informations disponibles apr&egrave;s 
     le '?' dans une URL).  De ce fait, par exemple, 
     <literal>http://www.exemple.com/test.php?id=3</literal>
     contient les donn&eacute;es de GET, qui sont accessibles via <varname>$_GET['id']</varname>.
     Voyez aussi <link linkend="reserved.variables.request">$_REQUEST</link> et 
     <function>import_request_variables</function>.
    </para>

    <note>
     <para>
      <link linkend="language.variables.superglobals">Les tableaux superglobaux</link>, 
      comme <varname>$_POST</varname> et <varname>$_GET</varname>, sont disponibles
      depuis &php; 4.1.0
     </para>
    </note>

    <para>
     Comme nous l'avons d&eacute;j&agrave; dis, avant &php; 4.2.0 la valeur par d&eacute;faut de
     <link linkend="ini.register-globals">register_globals</link> &eacute;tait 
     <emphasis>on</emphasis>. Dans &php; 3 elle &eacute;tait toujours &agrave; on. La communaut&eacute; &php; 
     n'encourage personne &agrave; utiliser cette directive et privil&eacute;gie la valeur 
     <emphasis>off</emphasis> et un code accord&eacute;.
    </para>

    <note>
     <para>
      La directive de configuration <link linkend="ini.magic-quotes-gpc">magic_quotes_gpc</link>
      affecte les valeurs de GET, POST et cookies. Si elle est activ&eacute;e,
      une valeur comme celle de (C'est "&php;!") sera magiquement transform&eacute;e en (C\'est \"&php;!\").
      La protection des caract&egrave;res est n&eacute;cessaire pour l'insertion dans les bases de donn&eacute;es.
      Voyez aussi les fonctions <function>addslashes</function>, 
      <function>stripslashes</function> et
      <link linkend="ini.magic-quotes-sybase">magic_quotes_sybase</link>.
     </para>
    </note>
    
    <simpara>
     &php; comprend aussi les tableaux dans le contexte des formulaires.
     (voir aussi <link linkend="faq.html">related faq</link>).  Vous pouvez,
     par exemple, grouper des variables ensembles, ou bien utiliser cette
     fonctionnalit&eacute; pour lire des valeurs multiples d'un menu d&eacute;roulant.
     Par exemple, voici un formulaire qui se poste lui m&ecirc;me des donn&eacute;es,
     et les affiche : 
    </simpara>

    <para>
     <example>
      <title>Variables de formulaires complexes</title>
      <programlisting role="php">
<![CDATA[
<?php
if ($_POST['action'] == 'submitted') {
    print '<pre>';

    print_r($_POST);
    print '<a href="'. $_SERVER['PHP_SELF'] .'">Essayez &agrave; nouveau</a>';

    print '</pre>';
} else {
?>
<form action="<?php echo $_SERVER['PHP_SELF']; ?>" method="post">
    Name:  <input type="text" name="personal[name]"><br>
    Email: <input type="text" name="personal[email]"><br>
    Beer: <br>
    <select multiple name="vin[]">
        <option value="bordeaux">bordeaux</option>
        <option value="beaujolais">beaujolais</option>
        <option value="loire">loire</option>
    </select><br>
    <input type="hidden" name="action" value="submitted">
    <input type="submit" name="submit" value="submit me!">
</form>
<?php
}
?>
]]>
      </programlisting>
     </example>
    </para>

    <para>
     En &php; 3, la syntaxe des tableaux HTML est limit&eacute;e aux tableaux
     uni-dimensionnels. En &php; 4, ces limitations ont &eacute;t&eacute; lev&eacute;es.
    </para>

    <sect3 id="language.variables.external.form.submit">
     <title>Nom de variables IMAGE SUBMIT</title>

     <simpara>
      Lors de la soumission d'un formulaire, il est possible d'utiliser
      une image au lieu d'un bouton standard, comme ceci : 
     </simpara>

     <informalexample>
      <programlisting role="html">
<![CDATA[
<input type="image" src="image.gif" name="sub">
]]>
      </programlisting>
     </informalexample>

     <simpara>
      Lorque l'utilisateur clique sur cette image, le formulaire
      associ&eacute; est envoy&eacute; au serveur, avec deux donn&eacute;es suppl&eacute;mentaires,
      <varname>sub_x</varname> et <varname>sub_y</varname>. Elles contiennent
      les coordonn&eacute;es du clic de l'utilisateur dans l'image. Vous noterez
      que ces variables sont envoy&eacute;es par le navigateur avec un point dans leur
      nom, mais &php; convertit ces points en soulign&eacute;s.
     </simpara>
    </sect3>
   </sect2>
   <sect2 id="language.variables.external.cookies">
    <title>Cookies HTTP</title>
    <simpara>
	&php; supporte les cookies HTTP de mani&egrave;re totalement
	transparente, comme d&eacute;fini dans les
	<ulink url="&spec.cookies;">Netscape's Spec</ulink>. Les cookies
	sont un m&eacute;canisme permettant de stocker des donn&eacute;es
	sur la machine cliente &agrave; des fins d'authentification de
	l'utilisateur. Vous pouvez &eacute;tablir un cookie gr&acirc;ce &agrave;
	la fonction <function>setcookie</function>. Les cookies
	font partie int&eacute;grante du "header" HTTP, et donc
	la fonction <function>setcookie</function> doit &ecirc;tre
	appel&eacute;e avant que le moindre affichage ne soit envoy&eacute;
	au navigateur. C'est la m&ecirc;me restriction que pour la fonction
	<function>header</function>. Tout cookie envoy&eacute; depuis le
	client sur le serveur sera automatiquement stock&eacute; sous
	forme de variable, comme pour la m&eacute;thode POST ou GET.
     </simpara>
    <simpara>
	Si vous souhaitez assigner plusieurs valeurs &agrave; un seul
	cookie, il vous faut ajouter les caract&egrave;res
	<emphasis>[]</emphasis> au nom de votre cookie.
	Par exemple :
    </simpara>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
setcookie ("MonCookie[]", "test", time()+3600);
?>
]]>

     </programlisting>
    </informalexample>
    <simpara>
	Il est &agrave; noter qu'un cookie remplace le cookie
	pr&eacute;c&eacute;dent par un cookie de m&ecirc;me nom tant que
	le "path" ou le domaine sont identiques. Donc, pour une application
	de caddie, vous devez impl&eacute;menter un compteur et
	l'incr&eacute;menter au fur et &agrave; mesure. C'est-&agrave;-dire:
    </simpara>
    <example>
     <title>Exemple avec <function>setcookie</function></title>
     <programlisting role="php">
<![CDATA[
<?php
$compte++;
SetCookie ("Compte", $compte, time()+3600);
SetCookie ("Caddie[$compte]", $item, time()+3600);
?>
]]>

     </programlisting>
    </example>
   </sect2>
   <sect2 id="language.variables.external.dot-in-names">
    <title>Cas des points dans les noms de variables</title>
    <para>
     Typiquement, &php; ne modifie pas les noms des variables lorsqu'elles
     sont pass&eacute;es &agrave; un script. Cependant, il faut noter que
     les points (.) ne sont pas autoris&eacute;s dans les noms de variables
     &php;. Pour cette raison, jetez un oeil sur :
     <programlisting role="php">
<![CDATA[
<?php
  $varname.ext;  /* nom de variable invalide */
?>
]]>
     </programlisting>
     Dans ce cas, l'analyseur croit voir la variable nomm&eacute;e
     $varname, suivie par l'op&eacute;rateur de concat&eacute;nation,
     et suivi encore par la cha&icirc;ne non-guillemet&eacute;e (une
     cha&icirc;ne sans guillemets, et qui n'a pas de signification
     particuli&egrave;re). Visiblement, ce n'est pas ce qu'on attendait...
    </para>
    <para>
     Pour cette raison, il est important de noter que &php; remplacera
     automatiquement les points des noms de variables entrantes par
     des soulign&eacute;s (underscore).
    </para>
   </sect2>
   <sect2 id="language.variables.determining-type-of">
    <title>D&eacute;termination du type des variables</title>
    <para>
     Parceque &php; d&eacute;termine le type des variables et
     les convertit (g&eacute;n&eacute;ralement) comme il faut,
     ce n'est pas toujours le type de variable que vous souhaitez.
     &php; inclut des fonctions permettant de d&eacute;terminer le
     type d'une variable :
     <function>gettype</function>,
     <function>is_long</function>,
     <function>is_double</function>,
     <function>is_string</function>,
     <function>is_array</function> et
     <function>is_object</function>.
    </para>
   </sect2>
  </sect1>
 </chapter>
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
indent-tabs-mode:nil
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
