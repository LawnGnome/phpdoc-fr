<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.29 $ -->
 <chapter id="language.variables">
  <title>Les variables</title>
  <sect1 id="language.variables.basics">
   <title>Essentiel</title>
   <simpara>
    En PHP, les variables sont repr&eacute;sent&eacute;es par un signe
    dollar "$" suivi du nom de la variable. Le nom est sensible &agrave;
    la casse (ie : $x != $X).
   </simpara>
   <para>
    Les noms de variables suivent les m&ecirc;mes r&egrave;gles de nommage que
    les autres entit&eacute;s PHP. Un nom de variable valide doit commencer par
    une lettre ou un soulign&eacute; (_), suivi de lettres, chiffres ou
    soulign&eacute;s. Exprim&eacute; sous la forme d'une expression
    r&eacute;guli&egrave;re, cela donne :
    '[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*'
   </para>
   <note>
    <simpara>
     Dans nos propos, une lettre peut &ecirc;tre une des lettres minuscules
     (a &agrave; z) ou majuscules (A &agrave; Z), et les caract&egrave;res
     ASCII de 127 &agrave; 255 (0x7f-0xff).
    </simpara>
   </note>
    <para>
    <informalexample>
     <programlisting role="php">
&lt;?php
$var = "Jean";
$Var = "Paul";
echo "$var, $Var";         // affiche "Jean, Paul"
$4site = 'pas encore';     // invalide : commence par un nombre
$_4site = 'pas encore';    // valide : commence par un soulign&eacute;
$ma&#239;s = 'jaune';      // valide; '&iuml;' est ASCII 239.
?&gt;
     </programlisting>
    </informalexample>
   </para>
   <para>
    En PHP 3, les variables sont toujours assign&eacute;es par valeur.
    C'est-&agrave;-dire, lorsque vous assignez une expression &agrave;
    une variable, la valeur de l'expression est recopi&eacute;e dans
    la variable. Cela signifie, par exemple, qu'apr&egrave;s avoir
    assign&eacute; la valeur d'une variable &agrave; une autre,
    modifier l'une des variables n'aura pas d'effet sur l'autre. Pour plus
    de d&eacute;tails sur ce genre d'assignation, reportez-vous &agrave;
    <link linkend="language.expressions">Expressions</link>.
   </para>
   <para>
    PHP 4 permet aussi d'assigner les valeurs aux variables
    <emphasis>par r&eacute;f&eacute;rence</emphasis>. Cela
    signifie que la nouvelle variable ne fait que r&eacute;f&eacute;rencer
    (en d'autres terme, "devient un alias de", ou encore "pointe sur") la
    variable originale. Les modifications de la nouvelle variable
    affecteront l'ancienne, et vice versa. Cela signifie aussi
    qu'aucune copie n'est faite : l'assignation est donc beaucoup
    plus rapide. Cela se fera notamment sentir dans des boucles,
    ou lors d'assignation de grands objets (tableaux).
   </para>
   <para>
    Pour assigner par r&eacute;f&eacute;rence, ajoutez simplement
    un &amp (ET commercial) au d&eacute;but de la variable qui
    est assign&eacute;e (la variable source). Dans l'exemple suivant,
    &quot;<literal>Mon nom est Pierre</literal>&quot; s'affichera deux
    fois :
    <informalexample>
     <programlisting role="php">
&lt;?php
$foo = 'Pierre';              // Assigne la valeur 'Pierre' &agrave; $foo
$bar = &amp;$foo;              // R&eacute;f&eacute;rence $foo avec $bar.
$bar = "Mon nom est Pierre";  // Modifie $bar...
echo $foo;                 // $foo est aussi modifi&eacute;e
echo $bar;
?&gt;
     </programlisting>
    </informalexample>
   </para>
   <para>
    Une chose importante &agrave; noter est que seules les variables
    nomm&eacute;es peuvent &ecirc;tre assign&eacute;es par r&eacute;f&eacute;rence.
    <informalexample>
     <programlisting role="php">
&lt;?php
$foo = 25;
$bar = &amp;$foo;      // assignation valide .
$bar = &amp;(24 * 7);  // assignation invalide : r&eacute;f&eacute;rence une expression sans nom
function test() {
   return 25;
}
$bar = &amp;test();    // assignation invalide.
?&gt;
     </programlisting>
    </informalexample>
   </para>
  </sect1>
  <sect1 id="language.variables.predefined">
   <title>Variables pr&eacute;d&eacute;finies</title>
   <simpara>
    PHP fourni un grand nombre de variables pr&eacute;d&eacute;finies.
    Cependant, beaucoup de ces variables ne peuvent pas &ecirc;tre
    pr&eacute;sent&eacute;es ici, car elles d&eacute;pendent du serveur
    sur lequel elles tournent, de la version du serveur, et de la
    configuration du serveur, ou encore d'autres facteurs. Certaines
    de ces variables ne seront pas accessibles lorsque PHP fonctionne
    en ex&eacute;cutable.
   </simpara>
   <simpara>
    Malgr&eacute; ces donn&eacute;es, voici une liste de variables
    pr&eacute;d&eacute;finies, qui seront accessibles avec une
    installation ad hoc de PHP3, fonctionnant en module, sous
    <ulink url="&url.apache;">Apache</ulink> 1.3.6.
   </simpara>
   <simpara>
    Pour la liste compl&egrave;te des variables pr&eacute;d&eacute;finies
    (et d'autres informations pratiques) reportez-vous (et usez) de
    <function>phpinfo</function>.
   </simpara>
   <note>
    <simpara>
     Cette liste n'est pas exhaustive et ne le sera pas. C'est simplement un
     aper&ccedil;u des variables pr&eacute;d&eacute;finies qui
     peuvent &ecirc;tre accessibles dans les scripts.
    </simpara>
   </note>
   <sect2 id="language.variables.predefined.apache">
    <title>Variables Apache</title>
    <simpara>
     Ces variables sont cr&eacute;&eacute;es par le serveur
     <ulink url="&url.apache;">Apache</ulink>. Si vous utilisez un autre
     serveur web, il n'est pas sur que celui-ci vous fournira
     les m&ecirc;mes variables. Il peut ne pas les fournir, en
     fournir d'autres. Cependant, un bon nombre de ces variables
     font partie de l'interface <ulink url="&url.cgispec;">CGI 1.1</ulink>,
     et on peut s'attendre &agrave; les retrouver.
    </simpara>
    <simpara>
     Notez que peu d'entre elles seront accessibles lorsque PHP est appel&eacute;
     en ligne de commande, (et elles n'auront alors peut &ecirc;tre pas de sens)
    </simpara>
    <para>
     <variablelist>
      <varlistentry>
       <term>$GATEWAY_INTERFACE</term>
       <listitem>
	<simpara>
	 Num&eacute;ro de r&eacute;vision de l'interface CGI du serveur :
	 i.e. 'CGI/1.1'.
	</simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$SERVER_NAME</term>
       <listitem>
	    <simpara>
    	 Le nom du serveur h&ocirc;te qui &eacute;x&eacute;cute le script suivant.
    	 Si le script est ex&eacute;cut&eacute; sur un h&ocirc;te virtuel, ce sera
    	 la valeur d&eacute;finie pour cet h&ocirc;te virtuel.
    	</simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$SERVER_SOFTWARE</term>
       <listitem>
    	<simpara>
    	 Cha&icirc;ne d'identification du serveur, qui est donn&eacute;e dans
    	 les en-t&ecirc;tes lors de la r&eacute;ponse aux requ&ecirc;tes.
    	</simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$SERVER_PROTOCOL</term>
       <listitem>
    	<simpara>
    	 Nom et r&eacute;vision du protocole de communication : i.e. 'HTTP/1.0';
    	</simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$REQUEST_METHOD</term>
       <listitem>
	    <simpara>
    	 M&eacute;thode de requ&ecirc;te utilis&eacute;e pour acc&eacute;der
    	 &agrave; la page; i.e. 'GET', 'HEAD', 'POST', 'PUT'.
    	</simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$QUERY_STRING</term>
       <listitem>
	    <simpara>
    	 La cha&icirc;ne de requ&ecirc;te, si elle existe, qui est
    	 utilis&eacute;e pour acc&eacute;der &agrave; la page.
    	</simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$DOCUMENT_ROOT</term>
       <listitem>
    	<simpara>
	     La racine sous laquelle le script courant est ex&eacute;cut&eacute;,
	     comme d&eacute;fini dans la configuration du serveur.
    	</simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$HTTP_ACCEPT</term>
       <listitem>
	    <simpara>
    	 Contenu de l'en-t&ecirc;te <literal>Accept:</literal> de la
    	 requ&ecirc;te courante, s'il y en a une.
    	</simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$HTTP_ACCEPT_CHARSET</term>
       <listitem>
	    <simpara>
	     Contenu de l'en-t&ecirc;te <literal>Accept-Charset:</literal>
	     de la requ&ecirc;te courante, s'elle existe. Par exemple :
	     '<literal>iso-8859-1,*,utf-8</literal>'.
    	</simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$HTTP_ACCEPT_ENCODING</term>
       <listitem>
    	<simpara>
	     Contenu de l'en-t&ecirc;te <literal>Accept-Encoding:</literal>
	     de la requ&ecirc;te courante, si elle existe. Par exemple : 'gzip'.
    	</simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$HTTP_ACCEPT_LANGUAGE</term>
       <listitem>
	    <simpara>
	     Contenu de l'en-t&ecirc;te <literal>Accept-Language:</literal> de
	     la requ&ecirc;te courante, si elle existe. Par exemple : 'en'.
    	</simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$HTTP_CONNECTION</term>
       <listitem>
	    <simpara>
	     Contenu de l'en-t&ecirc;te <literal>Connection:</literal> de la
	     requ&ecirc;te courante, si elle existe. Par exemple : 'Keep-Alive'.
    	</simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$HTTP_HOST</term>
       <listitem>
	    <simpara>
	      Contenu de l'en-t&ecirc;te <literal>Host:</literal> de la
	      requ&ecirc;te courante, si elle existe.
    	</simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$HTTP_REFERER</term>
       <listitem>
	    <simpara>
	     L'adresse de la page (si elle existe) qui a conduit le
	     client &agrave; la page courante. Cette valeur est
	     affect&eacute;e par le client, et tous les clients ne le font pas.
    	</simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$HTTP_USER_AGENT</term>
       <listitem>
    	<simpara>
	     Contenu de l'en-t&ecirc;te <literal>User_Agent:</literal> de
	     la requ&ecirc;te courante, si elle existe. C'est une cha&icirc;ne
	     qui d&eacute;crit le client HTML utilis&eacute; pour voir
	     la page courante. Par exemple :
	     <computeroutput>Mozilla/4.5 [en] (X11; U; Linux	 2.2.9 i586)</computeroutput>.
	     Entre autres choses, vous pouvez utiliser cette valeur avec
	     <function>get_browser</function> pour optimiser votre page
	     en fonction des capacit&eacute;s du client.
    	</simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$REMOTE_ADDR</term>
       <listitem>
	    <simpara>
	     L'adresse IP du client qui demande la page courante.
	    </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$REMOTE_PORT</term>
       <listitem>
	    <simpara>
	     Le port utilis&eacute; par la machine cliente pour communiquer
	     avec le serveur web.
    	</simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$SCRIPT_FILENAME</term>
       <listitem>
	    <simpara>
	     Le chemin absolu jusqu'au script courant.
	    </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$SERVER_ADMIN</term>
       <listitem>
	    <simpara>
	     La valeur donn&eacute;e &agrave; la directive SERVER_ADMIN
	     (pour Apache), dans le fichier de configuration. Si le script
	     est ex&eacute;cut&eacute; par un h&ocirc;te virtuel, ce sera la
	     valeur d&eacute;finie par l'h&ocirc;te virtuel.
    	</simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$SERVER_PORT</term>
       <listitem>
    	<simpara>
	     Le port de la machine serveur utilis&eacute; pour les
	     communications. Par d&eacute;faut, c'est '80'. En utilisant
	     SSL, par exemple, il sera remplac&eacute; par le num&eacute;ro
	     de port HTTP s&eacute;curis&eacute;.
    	</simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$SERVER_SIGNATURE</term>
       <listitem>
	    <simpara>
	     Cha&icirc;ne contenant le num&eacute;ro de version du serveur
	     et le nom d'h&ocirc;te virtuel, qui sont ajout&eacute;s aux
	     pages g&eacute;n&eacute;r&eacute;es par le serveur, si cette
	     option est activ&eacute;e.
    	</simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$PATH_TRANSLATED</term>
       <listitem>
	    <simpara>
	     Chemin dans le syst&egrave;me de fichier (pas le document root-)
	     jusqu'au script courant, une fois que le serveur a fait
	     une chemin traduction virtuel->r&eacute;el.
    	</simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$SCRIPT_NAME</term>
       <listitem>
    	<simpara>
	     Contient le nom du script courant. Cela sert lorsque
	     les pages doivent s'appeler elles-m&ecirc;mes.
    	</simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$REQUEST_URI</term>
       <listitem>
	    <simpara>
	     L'URI qui a &eacute;t&eacute; fourni pour acc&eacute;der
	     &agrave; cette page. Par exemple : '/index.html'.
	    </simpara>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </sect2>
   <sect2 id="language.variables.predefined.environment">
    <title>Variables d'environnement</title>
    <simpara>
     Ces variables sont import&eacute;es dans l'espace de nom global
     de PHP, depuis l'environnement sous lequel PHP fonctionne. Beaucoup
     d'entre elles sont fournies par le shell qui ex&eacute;cute PHP et
     diff&eacute;rents syst&egrave;mes &eacute;tant susceptibles
     de disposer de diff&eacute;rents shells, une liste d&eacute;finitive
     est impossible &agrave; &eacute;tablir. Reportez-vous &agrave; la
     documentation de votre shell, pour conna&icirc;tre la liste des
     variables d'environnement pr&eacute;d&eacute;finies.
    </simpara>
    <simpara>
     Les autres variables d'environment incluent les variables CGI,
     plac&eacute;es ici, quelquefois la m&eacute;thode
     d'&eacute;x&eacute;cution de PHP (CGI ou module).
    </simpara>
   </sect2>
   <sect2 id="language.variables.predefined.php">
    <title>Variables PHP</title>
    <simpara>
     Ces variables sont cr&eacute;&eacute;es par PHP lui_m&ecirc;me.
     Les variables <varname>$HTTP_*_VARS</varname> ne sont disponibles
     que si l'option de configuration
     <link linkend="ini.track-vars">track_vars</link> a
     &eacute;t&eacute; activ&eacute;e. Lorsque c'est le cas, ces variables
     existent toujours, m&ecirc;me si ce sont des tableaux vides. Cela &eacute;vite les
     usurpations mal intentionn&eacute;es de ces variables.
    </simpara>
    <note>
     <para>
      Depuis PHP 4.0.3,
      <link linkend="ini.track-vars">track_vars</link> est toujours
      activ&eacute;, quelle que soit la configuration.
     </para>
    </note>
    <para>
     Si la directive
     <link linkend="ini.register-globals">register_globals</link> est activ&eacute;e,
     alors ces variables seront aussi disponibles comme variables
     globales du script : c'est-&agrave;-dire, ind&eacute;pendamment des tableaux
     <varname>$HTTP_*_VARS</varname>. Cette fonctionnalit&eacute;
     doit &ecirc;tre utilis&eacute;e avec pr&eacute;cautions, et de
     pr&eacute;f&eacute;rence, d&eacute;sactiv&eacute;e.
     Si <varname>$HTTP_*_VARS</varname> est s&eacute;curis&eacute;,
     les &eacute;quivalents globaux peuvent &ecirc;tre &eacute;cras&eacute;s
     par les donn&eacute;es d'entr&eacute;e de l'utilisateur,
     avec des intrusions possibles. Si vous ne pouvez pas d&eacute;sactiver
     <link linkend="ini.register-globals">register_globals</link>, vous
     devez prendre toutes les dispositions possibles pour vous assurer
     que les donn&eacute;es utilis&eacute;es sont s&ucirc;res.
    </para>
    <para>
     <variablelist>
      <varlistentry>
       <term>$argv</term>
       <listitem>
    	<simpara>
	     Tableau des arguments pass&eacute;es au script. Lorsque le script
    	 est appel&eacute; en ligne de commande, cela donne acc&egrave;s
	     aux arguments, comme en langage C. Lorsque le script est
    	 appel&eacute; avec la m&eacute;thode GET, ce tableau contiendra
	     la cha&icirc;ne de requ&ecirc;te.
	    </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$argc</term>
       <listitem>
	    <simpara>
	     Contient le nombre de param&egrave;tres de la ligne de commande
	     pass&eacute;s au script (si le script fonctionne en ligne de commande).
	    </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$PHP_SELF</term>
       <listitem>
	    <simpara>
	     Le nom du fichier du script en cour d'&eacute;x&eacute;cution, par
	     rapport au document root. Si PHP fonctionne en ligne de commande,
	     cette variable n'est pas disponible.
	    </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$HTTP_COOKIE_VARS</term>
       <listitem>
	    <simpara>
    	 Un tableau associatif des variables pass&eacute;es au script
    	 courant via les HTTP cookies. Uniquement possible si le suivi
    	 des variables a &eacute;t&eacute; activ&eacute; avec
    	 la directive g&eacute;n&eacute;rale
    	 <link linkend="ini.track-vars">track_vars</link> ou
    	 avec la directive locale
    	 <computeroutput>&lt;? php_track_vars ?&gt;</computeroutput>.
    	</simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$HTTP_GET_VARS</term>
       <listitem>
	    <simpara>
	     Un tableau associatif des variables pass&eacute;es au script
	     courant via les HTTP GET. Uniquement possible si le suivi des
	     variables a &eacute;t&eacute; activ&eacute; avec la directive
	     g&eacute;n&eacute;rale
	     <link linkend="ini.track-vars">track_vars</link> ou
	     avec la directive locale
	     <computeroutput>&lt;? php_track_vars ?&gt;</computeroutput>.
    	</simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$HTTP_POST_VARS</term>
       <listitem>
    	<simpara>
    	 Un tableau associatif des variables pass&eacute;es au script
    	 courant via les HTTP POST. Uniquement possible si le suivi des
    	 variables a &eacute;t&eacute; activ&eacute; avec la directive
    	 g&eacute;n&eacute;rale
    	 <link linkend="ini.track-vars">track_vars</link> ou
    	 avec la directive locale
    	 <computeroutput>&lt;? php_track_vars ?&gt;</computeroutput>.
    	</simpara>
       </listitem>
      </varlistentry>
       <varlistentry>
       <term>$HTTP_POST_FILES</term>
       <listitem>
        <simpara>
         Un tableau associatif contenant les informations sur les
         fichiers t&eacute;l&eacute;charg&eacute;s avec la m&eacute;thode
         HTTP POST. Reportez-vous au chapitre
         <link linkend="features.file-upload.post-method">
         T&eacute;l&eacute;chargement par m&eacute;thode POST</link>
         pour plus de d&eacute;tails sur le contenu de
         <varname>$HTTP_POST_FILES</varname>.
        </simpara>
        <para>
         <varname>$HTTP_POST_FILES</varname> n'est disponible que dans
         les versions 4.0.0 et plus r&eacute;centes de PHP.
        </para>
       </listitem>
      </varlistentry>
    <varlistentry>
       <term>$HTTP_ENV_VARS</term>
       <listitem>
        <simpara>
         Un tableau associatif des variables pass&eacute;es au script
         par l'environnement parent.
        </simpara>
       </listitem>
      </varlistentry>
    <varlistentry>
       <term>$HTTP_SERVER_VARS</term>
       <listitem>
        <simpara>
         Un tableau associatif des variables pass&eacute;es au script
         par le serveur HTTP. Ces variables sont analogues
         aux variables d&eacute;crites ci-dessus.
        </simpara>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </sect2>
  </sect1>
  <sect1 id="language.variables.scope">
   <title>Port&eacute;e des variables</title>
   <simpara>
	La port&eacute;e d'une variable d&eacute;pend du contexte
	dans lequel la variable est d&eacute;finie. Pour la majorit&eacute; des
	variables, la port&eacute;e concerne la totalit&eacute; d'un script
	PHP. Mais, lorsque vous d&eacute;finissez une fonction, la
	port&eacute;e d'une variable d&eacute;finie dans cette fonction
	est locale &agrave; la fonction. Par exemple:
   </simpara>
   <informalexample>
    <programlisting role="php">
&lt;?php
$a = 1;
include "b.inc";
?&gt;
    </programlisting>
   </informalexample>
   <simpara>
    Ici, la variable $a sera accessible dans le script inclus
    <filename>b.inc</filename>. Cependant, dans les fonctions
    d&eacute;finies par l'utilisateur, une nouvelle d&eacute;finition
    de cette variable sera donn&eacute;e, limit&eacute;e &agrave; la
    fonction. Toute variable utilis&eacute;e dans une fonction est
    par d&eacute;finition, locale. Par exemple :
   </simpara>
   <informalexample>
    <programlisting role="php">
&lt;?php
$a = 1; /* port&eacute;e globale */
function test() {
    echo $a; /* port&eacute;e locale */
}
test();
?&gt;
    </programlisting>
   </informalexample>
   <simpara>
	Le script n'affichera rien &agrave; l'&eacute;cran car
	la fonction <function>echo</function> utilise la variable locale $a,
	et celle-ci n'a pas &eacute;t&eacute; assign&eacute;e
	pr&eacute;alablement dans la fonction. Vous pouvez noter que
	ce concept diff&egrave;re un petit peu du langage C dans
	lequel une variable globale est automatiquement accessible dans
	les fonctions, &agrave; moins d'&ecirc;tre red&eacute;finie
	localement dans la fonction. Cela peut poser des probl&egrave;mes
	si vous red&eacute;finissez des variables globales localement.
	En PHP, une variable globale doit &ecirc;tre
	d&eacute;clar&eacute;e &agrave; l'int&eacute;rieur de chaque
	fonction afin de pouvoir &ecirc;tre utilis&eacute;e dans cette
	fonction. Par exemple:
   </simpara>
   <informalexample>
    <programlisting role="php">
&lt;?php
$a = 1;
$b = 2;
function somme() {
    global $a, $b;
    $b = $a + $b;
}
somme();
echo $b;
    </programlisting>
   </informalexample>
   <simpara>
	Le script ci-dessus va afficher la valeur &quot;3&quot;.
	En d&eacute;clarant globales les variables $a et $b locales
	de la fonction somme(), toutes les r&eacute;f&eacute;rences &agrave;
	ces variables concerneront les variables globales. Il n'y a
	aucune limite au nombre de variables globales qui peuvent
	&ecirc;tre manipul&eacute;es par une fonction.
   </simpara>
   <simpara>
	Une deuxi&egrave;me m&eacute;thode pour acc&eacute;der aux
	variables globales est d'utiliser le tableau associatif
	pr&eacute;d&eacute;fini $GLOBALS. Le pr&eacute;c&eacute;dent
	exemple peut &ecirc;tre r&eacute;&eacute;crit de la
	mani&egrave;re suivante:
   </simpara>
   <informalexample>
    <programlisting role="php">
&lt;?php
$a = 1;
$b = 2;
function somme() {
    $GLOBALS["b"] = $GLOBALS["a"] + $GLOBALS["b"];
}
somme();
echo $b;
?&gt;
    </programlisting>
   </informalexample>
   <simpara>
	Le tableau $GLOBALS est un tableau associatif avec le nom
	des variables globales comme clef et les valeurs des &eacute;l&eacute;ments
	du tableau comme valeur des variables.
   </simpara>
   <simpara>
	Une autre caract&eacute;ristique importante de la port&eacute;e des variables est
	la notion de variable <emphasis>static</emphasis>. Une variable statique a
	une port&eacute;e locale uniquement, mais elle ne perd pas sa valeur lorsque le
	script appelle la fonction. Prenons l'exemple suivant:
   </simpara>
   <informalexample>
    <programlisting role="php">
&lt;?php
function test() {
    $a = 0;
    echo $a;
    $a++;
}
?&gt;
    </programlisting>
   </informalexample>
   <simpara>
	Cette fonction est un peu inutile car &agrave; chaque fois
	qu'elle est appel&eacute;e, elle initialise $a &agrave; 0 et
	affiche "0". L'incr&eacute;mentation de la variable ($a++)
	ne sert pas &agrave; grand chose, car d&egrave;s que la
	fonction est termin&eacute;e la variable dispara&icirc;t.
	Pour faire une fonction de comptage utile, c'est-&agrave;-dire qui
	ne perdra pas la trace du compteur, la variable $a est
	d&eacute;clar&eacute;e comme une variable statique:
   </simpara>
   <informalexample>
    <programlisting role="php">
&lt;?php
function test() {
    static $a = 0;
    echo $a;
    $a++;
}
?&gt;
    </programlisting>
   </informalexample>
   <simpara>
    Maintenant, &agrave; chaque fois que la fonction Test() est
    appel&eacute;e, elle affichera une valeur de $a incr&eacute;ment&eacute;e
    de 1.
   </simpara>
   <simpara>
	Les variables statiques sont essentielles lorsque vous faites des
	appels r&eacute;cursifs &agrave; une fonction. Une fonction
	r&eacute;cursive est une fonction qui s'appelle elle-m&ecirc;me.
	Il faut faire attention lorsque vous &eacute;crivez une fonction
	r&eacute;cursive car il est facile de faire une boucle infinie.
	Vous devez v&eacute;rifier que vous avez bien une condition qui
	permet de terminer votre r&eacute;cursivit&eacute;. La fonction
	suivante compte r&eacute;cursivement jusqu'&agrave; 10:
   </simpara>
   <informalexample>
    <programlisting role="php">
&lt;?php
function test() {
    static $count = 0;
    $count++;
    echo $count;
    if ($count &lt; 10) {
        test();
    }
    $count--;
}
?&gt;
    </programlisting>
   </informalexample>
  </sect1>
  <sect1 id="language.variables.variable">
   <title>Les variables dynamiques</title>
   <simpara>
	Il est pratique d'avoir parfois des noms de variables qui sont variables.
	C'est-&agrave;-dire un nom de variable qui est affect&eacute;e et utilis&eacute;e
	dynamiquement. Une variable classique est affect&eacute; avec
	l'instruction suivante:
   </simpara>
   <informalexample>
    <programlisting role="php">
&lt;?php
$a = "bonjour";
?&gt;
    </programlisting>
   </informalexample>
   <simpara>
	Une variable dynamique prend la valeur d'une variable et l'utilise
	comme nom d'une autre variable. Dans l'exemple ci-dessous,
	<emphasis>bonjour</emphasis> peut &ecirc;tre utilis&eacute; comme le nom d'une
	variable en utilisant le "$$" pr&eacute;c&eacute;dent la variable.
	C'est-&agrave;-dire
   </simpara>
   <informalexample>
    <programlisting role="php">
&lt;?php
$$a = "monde";
?&gt;
    </programlisting>
   </informalexample>
   <simpara>
	A ce niveau, deux variables ont &eacute;t&eacute; d&eacute;finies et
	stock&eacute;es dans l'arbre des symboles PHP: $a avec comme valeur
	"bonjour" et $bonjour avec comme valeur "monde". Alors, l'instruction
    </simpara>
   <informalexample>
    <programlisting role="php">
&lt;?php
echo "$a ${$a}";
?&gt;
    </programlisting>
   </informalexample>
   <simpara>
    produira le m&ecirc;me affichage que :
   </simpara>
   <informalexample>
    <programlisting  role="php">
&lt;?php
echo "$a $bonjour";
?&gt;
    </programlisting>
   </informalexample>
   <simpara>
    c'est-&agrave;-dire : <emphasis>bonjour monde</emphasis>.
   </simpara>
   <simpara>
	Afin de pouvoir utiliser les variables dynamiques avec les tableaux,
	vous avez &agrave; r&eacute;soudre un probl&egrave;me ambigu. Si vous
	&eacute;crivez $$a[1], le parseur a besoin de savoir si vous
	parler de la variable qui a pour nom $a[1] ou bien si vous voulez
	l'index [1] de la variable $$a. La syntaxe pour r&eacute;soudre
	cette ambigu&iuml;t&eacute; est la suivante: ${$a[1]} pour le premier
	cas, et ${$a}[1] pour le deuxi&egrave;me.
    </simpara>
  </sect1>
  <sect1 id="language.variables.external">
   <title>Variables externes &agrave; PHP</title>
   <sect2 id="language.variables.external.form">
    <title>Formulaires HTML (GET et POST)</title>
    <simpara>
	Lorsqu'un formulaire est envoy&eacute; &agrave; un script PHP,
	toutes les variables du formulaire seront automatiquement disponibles
	dans le script. Par exemple, consid&eacute;rons le formulaire suivant:
    </simpara>
    <para>
     <example>
      <title>Exemple avec un formulaire simple</title>
      <programlisting role="html">
&lt;form action="foo.php" method="post"&gt;
    Nom: &lt;input type="text" name="nom"&gt;&lt;br&gt;
    &lt;input type="submit"&gt;
&lt;/form>
      </programlisting>
     </example>
    </para>
    <simpara>
	Lorsque ce formulaire est envoy&eacute;, le PHP va cr&eacute;er la variable
	<computeroutput>$nom</computeroutput>, qui contiendra la valeur
	que vous avez entr&eacute;e dans le champs <emphasis>Nom:</emphasis>
	du formulaire.
    </simpara>
    <note>
     <para>
      La directive de configuration <link
      linkend="ini.magic-quotes-gpc">magic_quotes_gpc</link> affecte les valeurs 
      issues des m&eacute;thodes GET et POST ainsi aue des Cookies. Si cette 
      directive est active, une valeur telle que <literal>It's "PHP!"</literal>
      sera automagiquement transform&eacute;e en <literal>It&#92;'s
      &#92;"PHP!&#92;"</literal>.
      L'&eacute;chappement est n&eacute;cessaire pour les insertions en base de
      donn&eacute;es. Voyez <function>addslashes</function>,
      <function>stripslashes</function> et  
      <link linkend="ini.magic-quotes-sybase">magic_quotes_sybase</link>.
     </para>
    </note>
    <simpara>
	Le PHP permet aussi l'utilisation des tableaux dans le contexte de
	formulaire, mais seulement des tableaux &agrave; une seule dimension. Comme
	cela, vous pouvez rassembler des variables ou utiliser cette
	fonctionnalit&eacute; pour r&eacute;cup&eacute;rer les valeurs d'un choix
	multiple :
    </simpara>
    <para>
     <example>
      <title>Variables complexes de formulaire</title>
      <programlisting role="html">
&lt;form action="array.php" method="post"&gt;
    Name: &lt;input type="text" name="personal[name]"&gt;&lt;br&gt;
    Email: &lt;input type="text" name="personal[email]"&gt;&lt;br&gt;
    Beer: &lt;br&gt;
    &lt;select multiple name="vin[]"&gt;
        &lt;option value="medoc"&gt;M&eacute;doc
        &lt;option value="chablis"&gt;Chablis
        &lt;option value="riesling"&gt;Riesling
        &lt;/select&gt;
    &lt;input type="submit"&gt;
&lt;/form&gt;
      </programlisting>
     </example>
    </para>
    <simpara>
	Si l'option "track_vars" est activ&eacute;e, soit par l'option de
	compilation
	<link linkend="ini.track-vars">track_vars</link>, soit par la directive de
	configuration <computeroutput>&lt;? php_track_vars ?&gt;</computeroutput>,
	les variables transmises par les m&eacute;thodes POST et GET
	pourront aussi &ecirc;tre trouv&eacute;es dans le tableau
	associatif global $HTTP_POST_VARS ou $HTTP_GET_VARS
	suivant la m&eacute;thode utlis&eacute;e.
    </simpara>
    <sect3 id="language.variables.external.form.submit">
     <title>Bouton "submit" sous forme d'image</title>
     <simpara>
      Lorsque vous envoyez le r&eacute;sultat d'un formulaire, vous
      pouvez utiliser une image au lieu du bouton "submit" standard
      en utilisant un tag :
     </simpara>
     <informalexample>
      <programlisting role="html">
&lt;input type=image src="image.gif" name="sub"&gt;
      </programlisting>
     </informalexample>
     <simpara>
       Lorsqu'un utilisateur clique sur l'image, le formulaire sera
       transmis au serveur avec deux variables de plus, sub_x et
       sub_y. Ces deux variables contiennent les coordonn&eacute;es
       de l'endroit o&ugrave; l'utilisateur &agrave; cliqu&eacute;. Les
       utilisateurs exp&eacute;riment&eacute;s remarqueront que les noms
       de variables sont transmis avec une virgule &agrave; la place du
       caract&egrave;re "_", mais le PHP fait la conversion
       automatiquement.
     </simpara>
    </sect3>
   </sect2>
   <sect2 id="language.variables.external.cookies">
    <title>HTTP Cookies</title>
    <simpara>
	Le PHP supporte les cookies HTTP de mani&egrave;re totalement
	transparente, comme d&eacute;fini dans les
	<ulink url="&spec.cookies;">Netscape's Spec</ulink>. Les cookies
	sont un m&eacute;canisme permettant de stocker des donn&eacute;es
	sur la machine cliente &agrave; des fins d'authentification de
	l'utilisateur. Vous pouvez &eacute;tablir un cookie gr&acirc;ce &agrave;
	la fonction <function>setcookie</function>. Les cookies
	font partie int&eacute;grante du "header" HTTP, et donc
	la fonction <function>setcookie</function> doit &ecirc;tre
	appel&eacute;e avant que le moindre affichage ne soit envoy&eacute;
	au navigateur. C'est la m&ecirc;me restriction que pour la fonction
	<function>header</function>. Tout cookie envoy&eacute; depuis le
	client sur le serveur sera automatiquement stock&eacute; sous
	forme de variable, comme pour la m&eacute;thode POST ou GET.
     </simpara>
    <simpara>
	Si vous souhaitez assigner plusieurs valeurs &agrave; un seul
	cookie, il vous faut ajouter les caract&egrave;res
	<emphasis>[]</emphasis> au nom de votre cookie.
	Par exemple :
    </simpara>
    <informalexample>
     <programlisting role="php">
&lt;?php
setcookie ("MonCookie[]", "test", time()+3600);
?&gt;
     </programlisting>
    </informalexample>
    <simpara>
	Il est &agrave; noter qu'un cookie remplace le cookie
	pr&eacute;c&eacute;dent par un cookie de m&ecirc;me nom tant que
	le "path" ou le domaine sont identiques. Donc, pour une application
	de caddie, vous devez impl&eacute;menter un compteur et
	l'incr&eacute;menter au fur et &agrave; mesure. C'est-&agrave;-dire:
    </simpara>
    <example>
     <title>Exemple avec <function>setcookie</function></title>
     <programlisting role="php">
&lt;?php
$compte++;
SetCookie ("Compte", $compte, time()+3600);
SetCookie ("Caddie[$compte]", $item, time()+3600);
?&gt;
     </programlisting>
    </example>
   </sect2>
   <sect2 id="language.variables.external.environment">
    <title>Variables d'environnement </title>
    <para>
	Le PHP fait en sorte que les variables d'environnement soient accessibles
	directement comme des variables PHP normales.
     <informalexample>
      <programlisting role="php">
&lt;?php
echo $HOME;  /* Affiche la valeur de la variable d'environnement HOME,
               si celle-ci est affect&eacute;e. */
?&gt;
      </programlisting>
     </informalexample>
    </para>
    <para>
	M&ecirc;me si le PHP cr&eacute;e les variables lors de l'utilisation
	des m&eacute;thodes GET, POST et cookie, il est de temps en temps
	pr&eacute;f&eacute;rable de transmettre explicitement la valeur de
	la variable afin d'&ecirc;tre s&ucirc;r de la valeur.
	La fonction <function>getenv</function> peut &ecirc;tre
	utilis&eacute;e pour r&eacute;cup&eacute;rer la valeur
	des variables d'environnement. Vous pouvez aussi affecter
	une variable d'environnement gr&acirc;ce &agrave; la fonction
	<function>putenv</function>.
    </para>
   </sect2>
   <sect2 id="language.variables.external.dot-in-names">
    <title>Cas des points dans les noms de variables</title>
    <para>
     Typiquement, PHP ne modifie pas les noms des variables lorsqu'elles
     sont pass&eacute;es &agrave; un script. Cependant, il faut noter que
     les points (.) ne sont pas autoris&eacute;s dans les noms de variables
     PHP. Pour cette raison, jetez un oeil sur :
     <programlisting role="php">
&lt;?php
$varname.ext;  /* nom de variable invalide */
?&gt;
     </programlisting>
     Dans ce cas, l'analyseur croit voir la variable nomm&eacute;e
     $varname, suivie par l'op&eacute;rateur de concat&eacute;nation,
     et suivi encore par la cha&icirc;ne non-guillemet&eacute;e (une
     cha&icirc;ne sans guillemets, et qui n'a pas de signification
     particuli&egrave;re). Visiblement, ce n'est pas ce qu'on attendait...
    </para>
    <para>
     Pour cette raison, il est important de noter que PHP remplacera
     automatiquement les points des noms de variables entrantes par
     des soulign&eacute;s (underscore).
    </para>
   </sect2>
   <sect2 id="language.variables.determining-type-of">
    <title>D&eacute;termination du type des variables</title>
    <para>
     Parceque le PHP d&eacute;termine le type des variables et
     les convertit (g&eacute;n&eacute;ralement) comme il faut,
     ce n'est pas toujours le type de variable que vous souhaitez.
     PHP inclut des fonctions permettant de d&eacute;terminer le
     type d'une variable :
     <function>gettype</function>,
     <function>is_long</function>,
     <function>is_double</function>,
     <function>is_string</function>,
     <function>is_array</function> et
     <function>is_object</function>.
    </para>
   </sect2>
  </sect1>
 </chapter>
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
