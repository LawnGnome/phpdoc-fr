<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.24 $ -->
 <chapter id="control-structures">
  <title>Les structures de contr&ocirc;le</title>
  <simpara>
    Tous les scripts &php; sont une suite d'instructions. Une instruction
    peut &ecirc;tre une assignation, un appel de fonction, une instruction
    conditionnelle ou bien une instruction qui ne fait rien (une instruction
    vide). Une instruction se termine habituellement par un point virgule
    (";"). De plus, plusieurs instructions peuvent &ecirc;tre
    regroup&eacute;es en bloc, d&eacute;limit&eacute; par des
    accolades ("{}"). Un bloc est consid&eacute;r&eacute; comme une instruction.
    Les diff&eacute;rents types d'instruction sont d&eacute;crits dans ce
    chapitre.
  </simpara>
  <sect1 id="control-structures.if">
   <title><literal>if</literal></title>
   <para>
    L'instruction <literal>if</literal> est une des plus importantes
    instructions de tous les langages, &php; inclus. Elle permet
    l'ex&eacute;cution conditionnelle d'une partie de code. Les
    fonctionnalit&eacute;s de l'instruction <literal>if</literal>
    sont les m&ecirc;mes en &php; qu'en C :
    <informalexample>
     <programlisting role="php">
 <![CDATA[
<?php
  if (expression)
    commandes
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Comme nous l'avons vu dans le paragraphe consacr&eacute; aux 
    <link linkend="language.expressions">expressions</link>,
    <replaceable>expr</replaceable> est convertie en sa valeur
    bool&eacute;enne. Si l'expression <replaceable>expr</replaceable> vaut
    &true;, &php; ex&eacute;cutera l'instruction et si elle
    vaut &false;, l'instruction sera ignor&eacute;e.
    Plus de d&eacute;tails sur les valeurs qui valent &false; sont disponibles dans
    la section 
    <link linkend="language.types.boolean.casting">Conversion en bool&eacute;en</link>.
   </simpara>
   <para>
    L'exemple suivant affiche la phrase <computeroutput>a est plus grand
    que b</computeroutput> si <replaceable>$a</replaceable> est plus grand
    que <replaceable>$b</replaceable>:
    <informalexample>
     <programlisting role="php">
 <![CDATA[
<?php
  if ($a > $b)
    print "a est plus grand que b";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Souvent, vous voulez que plusieurs instructions soient
    ex&eacute;cut&eacute;es apr&egrave;s un branchement conditionnel. Bien
    &eacute;videmment, il n'est pas obligatoire de r&eacute;p&eacute;ter
    l'instruction conditionnelle autant de fois que vous avez d'instructions
    &agrave; ex&eacute;cuter. A la place, vous pouvez rassembler toutes les
    instructions dans un bloc. L'exemple suivant affiche <computeroutput>a
    est plus grand que b</computeroutput>, et assigne la valeur de la
    variable <replaceable>$a</replaceable> &agrave; la variable
    <replaceable>$b</replaceable>:
    <informalexample>
     <programlisting role="php">
 <![CDATA[
<?php
if ($a > $b) {
    print "a est plus grand que b";
    $b = $a;
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Vous pouvez imbriquer ind&eacute;finiment des instructions
    <literal>if</literal> les unes dans les autres, ce qui permet
    une grande flexibilit&eacute; dans l'ex&eacute;cution d'une
    partie de code suivant un grand nombre de conditions.
   </simpara>
  </sect1>
  <sect1 id="control-structures.else">
   <title><literal>else</literal></title>
   <para>
    Souvent, vous voulez ex&eacute;cuter une instruction si une
    condition est remplie, et une autre instruction si cette condition
    n'est pas remplie. C'est &agrave; cela que sert <literal>else</literal>.
    <literal>else</literal> fonctionne apr&egrave;s un
    <literal>if</literal> et ex&eacute;cute les instructions
    correspondantes au cas o&uacute; l'expression du <literal>if</literal>
    est &false;. Dans l'exemple suivant, ce bout de code
    affiche <computeroutput>a est plus grand que b</computeroutput> si la
    variable <replaceable>$a</replaceable> est plus grande que la variable
    <replaceable>$a</replaceable>, et <computeroutput>a est plus petit que b</computeroutput>
    sinon:
    <informalexample>
     <programlisting role="php">
 <![CDATA[
<?php
if ($a > $b) {
    print "a est plus grand que b";
} else {
    print "a est plus petit que b";
}
?>
]]>
     </programlisting>
    </informalexample>
    Les instructions apr&egrave;s le <literal>else</literal> ne sont
    ex&eacute;cut&eacute;es que si l'expression du <literal>if</literal>
    est &false;, et si elle n'est pas suivi par l'expression
    <literal>elseif</literal>.
   </para>
  </sect1>
  <sect1 id="control-structures.elseif">
   <title><literal>elseif</literal></title>
   <para>
      <literal>elseif</literal>, comme son nom l'indique, est une combinaison
      de <literal>if</literal> et de <literal>else</literal>. Comme l'expression
      <literal>else</literal>, il permet d'ex&eacute;cuter une instruction
      apr&egrave;s un <literal>if</literal> dans le cas o&uacute; le "premier"
      if est &eacute;valu&eacute; comme &false;. Mais,
      &agrave; la diff&eacute;rence de l'expression <literal>else</literal>,
      il n'ex&eacute;cutera l'instruction que si l'expression condionnelle
      <literal>elseif</literal> est &eacute;valu&eacute;e comme
      &true;. L'exemple suivant affichera
      <computeroutput>a est plus grand que b</computeroutput>,
      <computeroutput>a est &eacute;gal &agrave; b</computeroutput> ou
      <computeroutput>a est plus petit que b</computeroutput>:
    <informalexample>
     <programlisting role="php">
 <![CDATA[
<?php
if ($a > $b) {
    print "a est plus grand que b";
} elseif ($a == $b) {
    print "a est &eacute;gal &agrave; b";
} else {
    print "a est plus petit que b";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
     Vous pouvez avoir plusieurs <literal>elseif</literal> qui se suivent
     les uns apr&egrave;s les autres, apr&egrave;s un <literal>if</literal> initial.
     Le premier <literal>elseif</literal> qui sera &eacute;valu&eacute;
     &agrave; &true; sera ex&eacute;cut&eacute;. En &php;, vous
     pouvez aussi &eacute;crire "else if" en deux mots et son comportement sera
     identique &agrave; la version en un seul mot. La s&eacute;mantique des
     deux expressions est l&eacute;g&egrave;rement diff&eacute;rente, mais au bout du compte,
     le r&eacute;sultat sera exactement le m&ecirc;me.
   </simpara>
   <simpara>
      L'expression <literal>elseif</literal> est ex&eacute;cut&eacute;e
      seulement si le <literal>if</literal> pr&eacute;c&eacute;dent et tout
      autre <literal>elseif</literal> pr&eacute;c&eacute;dent sont
      &eacute;valu&eacute;s comme &false;, et que
      votre <literal>elseif</literal> est &eacute;valu&eacute; &agrave;
      &true;.
   </simpara>
  </sect1>
  <sect1 id="control-structures.alternative-syntax">
   <title>Syntaxe alternative</title>
   <para>
    &php; propose une autre mani&egrave;re de rassembler des
    instructions &agrave; l'int&eacute;rieur d'un bloc, pour les
    fonctions de contr&ocirc;le <literal>if</literal>,
    <literal>while</literal>, <literal>for</literal>,
    <literal>foreach</literal> et <literal>switch</literal>.
    Dans chaque cas, le principe
    est de remplacer l'accolade d'ouverture par deux points (:)
    et l'accolade de fermeture par, respectivement,
    <literal>endif;</literal>, <literal>endwhile;</literal>,
    <literal>endfor;</literal>, ou <literal>endswitch;</literal>.
    <informalexample>
     <programlisting role="php">
 <![CDATA[
<?php if ($a == 5): ?>
A &eacute;gal 5
<?php endif; ?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
     Dans l'exemple ci-desssus, le block HTML "A = 5" est inclus
     &agrave; l'int&eacute;rieur d'un <literal>if</literal> en
     utilisant cette nouvelle syntaxe. Ce code HTML ne sera
     affich&eacute; que si la variable $a est &eacute;gale &agrave; 5.
   </simpara>
   <para>
    Cette autre syntaxe fonctionne aussi avec le <literal>else</literal> et
    <literal>elseif</literal>. L'exemple suivant montre une structure avec un
    <literal>if</literal>, un <literal>elsif</literal> et un
    <literal>else</literal> utilisant cette autre syntaxe:
    <informalexample>
     <programlisting role="php">
 <![CDATA[
<?php
if ($a == 5):
    print "a &eacute;gale 5";
    print "...";
elseif ($a == 6):
    print "a &eacute;gale 6";
    print "!!!";
else:
    print "a ne vaut ni 5 ni 6";
endif;
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Voir aussi
    <link linkend="control-structures.while">while</link>,
    <link linkend="control-structures.for">for</link>, et
    <link linkend="control-structures.if">if</link> pour d'autres exemples.
   </para>
  </sect1>
  <sect1 id="control-structures.while">
   <title><literal>while</literal></title>
   <para>
     La boucle <literal>while</literal> est le moyen le plus
     simple d'impl&eacute;menter une boucle en &php;. Cette boucle
     se comporte de la m&ecirc;me mani&egrave;re qu'en C.
     L'exemple le plus simple d'une boucle <literal>while</literal>
     est le suivant :
    <informalexample>
     <programlisting role="php">
 <![CDATA[
<?php
  while (expression) commandes
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
     La signification d'une boucle <literal>while</literal> est
     tr&egrave;s simple. PHP ex&eacute;cute l'instruction tant
     que l'expression de la boucle <literal>while</literal> est
     &eacute;valu&eacute;e comme &true;. La valeur
     de l'expression est v&eacute;rifi&eacute;e &agrave; chaque
     d&eacute;but de boucle, et, si la valeur change durant
     l'ex&eacute;cution de l'instruction, l'ex&eacute;cution ne
     s'arr&ecirc;tera qu'&agrave; la fin de l'it&eacute;ration
     (chaque fois que &php; ex&eacute;cute l'instruction, on appelle
     cela une it&eacute;ration). De temps en temps, si l'expression du
     <literal>while</literal> est &false; avant la
     premi&egrave;re it&eacute;ration, l'instruction ne sera jamais
     ex&eacute;cut&eacute;e.
   </simpara>
   <para>
     Comme avec le <literal>if</literal>, vous pouvez regrouper
     plusieurs instructions dans la m&ecirc;me boucle
     <literal>while</literal> en les regroupant &agrave; l'int&eacute;rieur
     de parenth&egrave;ses ou en utilisant la syntaxe suivante:
    <informalexample>
     <programlisting role="php">
 <![CDATA[
<?php
while (expression): commandes ... endwhile;
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Les exemples suivants sont identiques, et affichent tous les nombres
    de 1 &agrave; 10:
    <informalexample>
     <programlisting role="php">
 <![CDATA[
<?php
/* exemple 1 */
$i = 1;
while ($i <= 10) {
    print $i++;  /* La valeur affiche est $i avant l'incr&eacute;mentation
                     (post-incr&eacute;mentation)  */
}
/* exemple 2 */
$i = 1;
while ($i <= 10):
    print $i;
    $i++;
endwhile;
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>
  <sect1 id="control-structures.do.while">
   <title><literal>do..while</literal></title>
   <simpara>
     Les boucles <literal>do..while</literal> ressemblent beaucoup
     aux boucles <literal>while</literal>, mais l'expression est
     test&eacute;e &agrave; la fin de chaque it&eacute;ration plut&ocirc;t
     qu'au d&eacute;but. La principale diff&eacute;rence par rapport
     &agrave; la boucle <literal>while</literal> est que la
     premi&egrave;re it&eacute;ration de la boucle
     <literal>do..while</literal> est toujours ex&eacute;cut&eacute;e
     (l'expression n'est test&eacute;e qu'&agrave; la fin de
     l'it&eacute;ration), ce qui n'est pas le cas lorsque vous
     utilisez une boucle <literal>while</literal> (l'expression
     est v&eacute;rifi&eacute;e au d&eacute;but de chaque it&eacute;ration).
   </simpara>
   <para>
    Il n'y a qu'une syntaxe possible pour les boucles <literal>do..while</literal>:
    <informalexample>
     <programlisting role="php">
 <![CDATA[
<?php
$i = 0;
do {
   print $i;
} while ($i>0);
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
     La boucle ci-dessus ne va &ecirc;tre ex&eacute;cut&eacute;e
     qu'une seule fois, car lorsque l'expression est
     &eacute;valu&eacute;e, elle vaut &false; (car
     la variable $i n'est pas plus grande que 0) et l'ex&eacute;cution
     de la boucle s'arr&ecirc;te.
   </simpara>
   <para>
     Les utilisateurs familiers du C sont habitu&eacute;s &agrave;
     une utilisation diff&eacute;rente des boucles
     <literal>do..while</literal> , qui permet de stopper
     l'ex&eacute;cution de la boucle au milieu des instructions, en
     l'encapsulant dans un <literal>do..while</literal>(0) la
     fonction <link linkend="control-structures.break"><literal>break</literal></link>.
     Le code suivant montre une utilisation possible:
    <informalexample>
     <programlisting role="php">
 <![CDATA[
<?php
do {
    if ($i < 5) {
        print "i n'est pas suffisamment grand";
        break;
    }
    $i *= $factor;
    if ($i < $minimum_limit) {
        break;
    }
    print "i est bon";
     ...process i...
} while(0);
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
     Ne vous inqui&eacute;tez pas si vous ne comprenez
     pas tout correctement. Vous pouvez &eacute;crire des scripts
     tr&egrave;s tr&egrave;s puissants sans utiliser
     cette fonctionnalit&eacute;.
   </simpara>
  </sect1>
  <sect1 id="control-structures.for">
   <title><literal>for</literal></title>
   <para>
     Les boucles <literal>for</literal> sont les boucles les plus complexes en &php;.
     Elles fonctionnent comme les boucles <literal>for</literal> du langage C.
     La syntaxe des boucles for est la suivante:
    <informalexample>
     <programlisting role="php">
 <![CDATA[
<?php
  for (expr1; expr2; expr3) statement
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    La premi&egrave;re expression (<replaceable>expr1</replaceable>) est
    &eacute;valu&eacute;e (ex&eacute;cut&eacute;e), quoi qu'il arrive au
    d&eacute;but de la boucle.
   </simpara>
   <simpara>
    Au d&eacute;but de chaque it&eacute;ration, l'expression
    <replaceable>expr2</replaceable> est &eacute;valu&eacute;e.
    Si l'&eacute;valuation vaut &true;, la boucle
    continue et l'instruction est ex&eacute;cut&eacute;e. Si
    l'&eacute;valuation vaut &false;,
    l'ex&eacute;cution de la boucle s'arr&ecirc;te.
   </simpara>
   <simpara>
    A la fin de chaque it&eacute;ration, l'expression
    <replaceable>expr3</replaceable> est &eacute;valu&eacute;e
    (ex&eacute;cut&eacute;e).
   </simpara>
   <simpara>
    Les expressions peuvent &eacute;ventuellement &ecirc;tre
    laiss&eacute;es vides. Si l'expression <replaceable>expr2</replaceable>
    est laiss&eacute;e vide, cela signifie que c'est une boucle infinie
    (&php; consid&egrave;re implicitement qu'elle vaut &true;,
    comme en C). Cela n'est pas vraiment tr&egrave;s utile, &agrave; moins que vous
    souhaitiez terminer votre boucle par l'instruction conditionnelle
    <link linkend="control-structures.break"><literal>break</literal></link>.
   </simpara>
   <para>
    Consid&eacute;rons les exemples suivants. Tous affichent les chiffres de
    1 &agrave; 10:
    <informalexample>
     <programlisting role="php">
 <![CDATA[
<?php
/* exemple 1 */
for ($i = 1; $i <= 10; $i++) {
    print $i;
}
/* exemple 2 */
for ($i = 1;;$i++) {
    if ($i > 10) {
        break;
    }
    print $i;
}
/* exemple 3 */
$i = 1;
for (;;) {
    if ($i > 10) {
        break;
    }
    print $i;
    $i++;
}
/* exemple 4 */
for ($i = 1; $i <= 10; print $i, $i++) ;
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
     Bien &eacute;videmment, le premier exemple est le plus simple
     de tous (ou peut &ecirc;tre le quatri&egrave;me), mais vous
     pouvez aussi pensez qu'utiliser une expression vide dans une
     boucle <literal>for</literal> peut &ecirc;tre utile parfois.
   </simpara>
   <para>
     &php; supporte aussi la syntaxe alternative suivante pour les boucles
     <literal>for</literal> :
    <informalexample>
     <programlisting role="php">
 <![CDATA[
<?php
  for (expr1; expr2; expr3): statement; ...; endfor;
?>
]]>
     </programlisting>
     </informalexample>
   </para>
   <para>
     Les autres langages ont l'instruction <literal>foreach</literal>
     pour acc&eacute;der aux &eacute;l&eacute;ments d'un tableau. &php; 3
     ne dispose pas d'une telle fonction; &php; 4 en dispose (voir
     <link linkend="control-structures.foreach">foreach</link>). En &php; 3,
     vous pouvez combiner <link linkend="control-structures.while">while</link>
     avec <function>list</function> et <function>each</function> pour
     obtenir le m&ecirc;me r&eacute;sultat. Reportez-vous aux exemples
     de la documentation.
   </para>
  </sect1>
  <sect1 id="control-structures.foreach">
   <title><literal>foreach</literal></title>
   <para>
    &php; 4 (mais pas &php; 3) inclut une commande <literal>foreach</literal>,
    comme en Perl ou d'autres langages. C'est un moyen simple de passer
    en revue un tableau. Il y a deux syntaxes possibles : la seconde est
    une extension mineure mais pratique de la premi&egrave;re:
    <informalexample>
     <programlisting role="php">
 <![CDATA[
<?php
  foreach(array_expression as $value) commandes
  foreach(array_expression as $key => $value) commandes
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    La premi&egrave;re forme passe en revue le tableau
    <literal>array_expression</literal>. A chaque it&eacute;ration,
    la valeur de l'&eacute;l&eacute;ment courant est assign&eacute;e &agrave;
    <literal>$value</literal> et le pointeur interne de tableau est
    avanc&eacute; d'un &eacute;l&eacute;ment (ce qui fait qu'&agrave;
    la prochaine it&eacute;ration, on acc&eacute;dera &agrave;
    l'&eacute;l&eacute;ment suivant).
   </simpara>
   <simpara>
     La deuxi&egrave;me forme fait exactement la m&ecirc;me chose, mais
     c'est la cl&eacute; de l'&eacute;l&eacute;ment courant qui est
     assign&eacute; &agrave; la variable <literal>$key</literal>.
   </simpara>
   <simpara>
    Lorsque <literal>foreach</literal> d&eacute;marre, le pointeur interne
    de fichier est automatiquement ramen&eacute; au premier
    &eacute;l&eacute;ment du tableau. Cela signifie que vous n'aurez
    pas &agrave; faire appel &agrave; <function>reset</function> avant
    <literal>foreach</literal>.
   </simpara>
    <note>
     <para>
      De plus, notez que <literal>foreach</literal> travaille sur une copie
      du tableau sp&eacute;cifi&eacute;, et pas sur le tableau lui-m&ecirc;me.
      Par cons&eacute;quent,
      le pointeur de tableau n'est pas modifi&eacute;, comme il le serait
      avec le fonction <function>each</function>, et les modifications
      faites dans le tableau ne seront pas prises en compte dans le
      tableau original.
      </para>
     </note>
   <note>
    <para>
     <literal>foreach</literal> n'accepte pas l'op&eacute;rateur de supppression
     des erreurs <link linkend="language.operators.errorcontrol">&#64;</link>.
    </para>
   </note>
   <para>
    Vous pouvez remarquer que les exemples suivants fonctionnent de
    mani&egrave;re identique :
    <informalexample>
     <programlisting role="php">
 <![CDATA[
<?php
  reset($arr);
  while (list(, $value) = each ($arr)) {
    echo "Valeur: $value<br>\n";
  }
  foreach ($arr as $value) {
    echo "Valeur: $value<br>\n";
  }
?>
]]>
     </programlisting>
    </informalexample>
    Les exemples suivants sont aussi fonctionnellement identiques :
    <informalexample>
     <programlisting role="php">
 <![CDATA[
<?php
  reset($arr);
  while (list($key, $value) = each ($arr)) {
    echo "Cl&eacute;: $key; Valeur: $value<br>\n";
  }
  foreach ($arr as $key => $value) {
    echo "Cl&eacute;: $key; Valeur: $value<br>\n";
  }
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Voici quelques exemples de plus :
    <informalexample>
     <programlisting role="php">
 <![CDATA[
<?php
/* exemple foreach 1 : la valeur seulement */

$a = array (1, 2, 3, 17);

foreach ($a as $v) {
   print "Current value of \$a: $v.\n";
}

/* exemple foreach 2 : la valeur et sa cl&eacute; d'index */

$a = array (1, 2, 3, 17);

$i = 0; /* uniquement pour l'illustration */

foreach($a as $v) {
    print "\$a[$i] => $v.\n";
    $i++;
}

/* exemple foreach 3 : la cl&eacute; et la valeur */

$a = array (
    "un" => 1,
    "deux" => 2,
    "trois" => 3,
    "dix-sept" => 17
);

foreach($a as $k => $v) {
    print "\$a[$k] => $v.\n";
}

/* exemple foreach 4 : tableaux multi-dimensionnels */

$a[0][0] = "a";
$a[0][1] = "b";
$a[1][0] = "y";
$a[1][1] = "z";

foreach($a as $v1) {
    foreach ($v1 as $v2) {
        print "$v2\n";
    }
}

/* exemple foreach 5 : tableaux dynamiques */

foreach(array(1, 2, 3, 4, 5) as $v) {
    print "$v\n";
}

?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>
  <sect1 id="control-structures.break">
   <title><literal>break</literal></title>
   <simpara>
     L'instruction <literal>break</literal> permet de sortir d'une structure
     <literal>for</literal>, <literal>while</literal>,
     <literal>foreach</literal> ou <literal>switch</literal>.
   </simpara>
   <simpara>
    <literal>break</literal> accepte un argument num&eacute;rique optionnel
    qui vous indiquera combien de structures emboit&eacute;es ont
    &eacute;t&eacute; interrompues.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
 <![CDATA[
<?php
$arr = array ('un', 'deux', 'trois', 'quatre', 'stop', 'cinq');
while (list (, $val) = each ($arr)) {
    if ($val == 'stop') {
        break;    /* Vous pourriez aussi utiliser 'break 1;' ici. */
    }
    echo "$val<br>\n";
}

/* Utilisation de l'argument optionnel. */

$i = 0;
while (++$i) {
    switch ($i) {
    case 5:
        echo "A 5<br>\n";
        break 1;  /* Termine uniquement le switch. */
    case 10:
        echo "At 10; quitting<br>\n";
        break 2;  /* Termine le switch et la buocle while. */
    default:
        break;
    }
}

?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>
  
  <sect1 id="control-structures.continue">
   <title><literal>continue</literal></title>
   <simpara>
     L'instruction <literal>continue</literal> est utilis&eacute;e
     dans une boucle afin d'&eacute;luder les instructions de
     l'it&eacute;ration courante afin de passer directement &agrave;
     l'it&eacute;ration suivante.
   </simpara>
   <note>
    <simpara>
    Notez qu'en &php;, la structure
    <link linkend="control-structures.switch"><literal>switch</literal></link>
     est consid&eacute;r&eacute;e comme une boucle par <literal>continue</literal>.
    </simpara>
   </note>
   <simpara>
    <literal>continue</literal> accepte un argument num&eacute;rique
    optionnel qui vous indiquera combien de structures
    emboit&eacute;es ont &eacute;t&eacute; ignor&eacute;es.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
 <![CDATA[
<?php
while (list ($cle, $valeur) = each ($arr)) {
   if (!($cle % 2)) { // &eacute;vite les membres impairs
       continue;
   }
   fonction_quelconque($valeur);
}
$i = 0;
while ($i++ < 5) {
    echo "Dehors<br>\n";
    while (1) {
        echo "&nbsp;&nbsp;Milieu<br>\n";
        while (1) {
             echo "&nbsp;&nbsp;Int&eacute;rieur<br>\n";
             continue 3;
        }
        echo "Ceci n'est jamais atteint.<br>\n";
    }
    echo "Ceci non plus.<br>\n";
}
?>
]]>
     </programlisting>
     </informalexample>
    </para>
  </sect1>
  <sect1 id="control-structures.switch">
   <title><literal>switch</literal></title>
   <simpara>
    L'instruction <literal>switch</literal> &eacute;quivaut
    &agrave; une s&eacute;rie d'instructions <literal>if</literal>.
    En de nombreuses occasions, vous aurez besoin de comparer
    la m&ecirc;me variable (ou expression) avec un grand nombre
    de valeurs diff&eacute;rentes, et d'ex&eacute;cuter
    diff&eacute;rentes parties de code suivant la valeur
    &agrave; laquelle elle est &eacute;gale. C'est exactement
    &agrave; cela que sert l'instruction <literal>switch</literal>.
   </simpara>
   <note>
    <simpara>
    Notez que contrairement &agrave; d'autres langages, la structure 
    <link linkend="control-structures.continue">continue</link> s'applique
    aux structures <literal>switch</literal> et de comporte diff&eacute;remment de
    <literal>break</literal>. 
    Si vous avez un <literal>switch</literal> dans une boucle, et que vous 
    souhaitez continuer jusqu'&agrave; la prochaine it&eacute;ration de la boucle 
    ext&eacute;rieure, vous vous devez utiliser <literal>continue 2</literal>.
    </simpara>
   </note>
   <para>
    Les deux exemples suivants sont deux mani&egrave;res
    diff&eacute;rentes d'&eacute;crire la m&ecirc;me chose,
    l'une en utilisant une s&eacute;ries de <literal>if</literal>,
    et l'autre en utilisant l'instruction <literal>switch</literal>:
    <informalexample>
     <programlisting role="php">
 <![CDATA[
<?php
if ($i == 0) {
    print "i &eacute;gale 0";
}
if ($i == 1) {
    print "i &eacute;gale 1";
}
if ($i == 2) {
    print "i &eacute;gale 2";
}
switch ($i) {
    case 0:
        print "i &eacute;gale 0";
        break;
    case 1:
        print "i &eacute;gale 1";
        break;
    case 2:
        print "i &eacute;gale 2";
        break;
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Il est important de comprendre que l'instruction
    <literal>switch</literal> ex&eacute;cute chacune des
    clauses dans l'ordre. L'instruction <literal>switch</literal>
    est ex&eacute;cut&eacute;e ligne par ligne. Au d&eacute;but,
    aucun code n'est ex&eacute;cut&eacute;. Seulement
    lorsqu'un <literal>case</literal> est v&eacute;rifi&eacute;,
    &php; ex&eacute;cute alors les instructions correspondantes.
    &php; continue d'ex&eacute;cuter les instructions jusqu'&agrave;
    la fin du bloc d'instructions du <literal>switch</literal>,
    ou bien d&egrave;s qu'il trouve l'instruction <literal>break</literal>.
    Si vous ne pouvez pas utiliser l'instruction
    <literal>break</literal> &agrave; la fin de l'instruction
    <literal>case</literal>, &php; continuera &agrave; ex&eacute;cuter
    toutes les instructions qui suivent. Par exemple :
    <informalexample>
     <programlisting role="php">
 <![CDATA[
<?php
switch ($i) {
    case 0:
        print "i &eacute;gale 0";
    case 1:
        print "i &eacute;gale 1";
    case 2:
        print "i &eacute;gale 2";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Dans cet exemple, si $i est &eacute;gal &agrave; 0, &php; va
    ex&eacute;cuter quand m&ecirc;me toutes les instructions qui
    suivent. Si $i est &eacute;gal &agrave; 1, &php; ex&eacute;cutera
    les deux derni&egrave;res instructions. Et seulement si $i est
    &eacute;gal &agrave; 2, vous obtiendrez le r&eacute;sultat
    escompt&eacute;, c'est-&agrave;-dire, l'affiche de
    "i &eacute;gal 2". Donc, l'important est de ne pas oublier
    l'instruction <literal>break</literal> (m&ecirc;me s'il est
    possible que vous l'omettiez dans certaines circonstances).
   </simpara>
   <simpara>
    Dans une commande <literal>switch</literal>, une condition n'est
    &eacute;valu&eacute;e qu'une fois, et le r&eacute;sultat est
    compar&eacute; &agrave; chaque <literal>case</literal>.
    Dans une structure <literal>elseif</literal>, les conditions sont
    &eacute;valu&eacute;es &agrave; chaque comparaison. Si votre
    condition est plus compliqu&eacute;e qu'une simple
    comparaison, ou bien fait partie d'une boucle,
    <literal>switch</literal> sera plus rapide.
   </simpara>
   <para>
    La liste de commandes d'un <literal>case</literal> peut
    &ecirc;tre vide, auquel cas &php; utilisera la liste de
    commandes du cas suivant.
    <informalexample>
     <programlisting role="php">
 <![CDATA[
<?php
switch ($i) {
    case 0:
    case 1:
    case 2:
        print "i est plus petit que 3 mais n'est pas n&eacute;gatif";
        break;
    case 3:
        print "i &eacute;gale 3";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Un <literal>case</literal> sp&eacute;cial est
    <literal>default</literal>. Ce cas est utilis&eacute; lorsque tous
    les <literal>case</literal> ont &eacute;chou&eacute;s. Il doit
    &ecirc;tre le dernier cas list&eacute;. Par exemple :
    <informalexample>
     <programlisting role="php">
 <![CDATA[
<?php
switch ($i) {
    case 0:
        print "i &eacute;gale 0";
        break;
    case 1:
        print "i &eacute;gale 1";
        break;
    case 2:
        print "i &eacute;gale  2";
        break;
    default:
        print "i n'est ni &eacute;gal &agrave; 2, ni &agrave; 1, ni &agrave; 0.";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Une autre chose &agrave; mentionner est que l'instruction
    <literal>case</literal> peut &ecirc;tre une expression &agrave;
    de type scalaire, c'est-&agrave;-dire nombre entier, nombre
    &agrave; virgule flottante et cha&icirc;ne de caract&egrave;res.
    Les tableaux sont sans int&eacute;r&ecirc;t dans ce contexte-l&agrave;.
   </para>
   <para>
    La syntaxe alternative pour cette structure de contr&ocirc;le est
    la suivante :  pour plus d'informations, voir
    <link linkend="control-structures.alternative-syntax">syntaxes alternatives</link>).
    <informalexample>
     <programlisting role="php">
 <![CDATA[
<?php
  switch ($i):
    case 0:
        print "i &eacute;gale 0";
        break;
    case 1:
        print "i &eacute;gale 1";
        break;
    case 2:
        print "i &eacute;gale 2";
        break;
    default:
        print "i n'est ni &eacute;gal &agrave; 2, ni &agrave; 1, ni &agrave; 0";
  endswitch;
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>
  <sect1 id="control-structures.declare">
   <title><literal>declare</literal></title>
    <para>
     L'&eacute;l&eacute;ment de langage <literal>declare</literal> sert &agrave; ajouter des
     directives d'ex&eacute;cutions dans un bloc de code. La syntaxe de
     <literal>declare</literal> est similaire &agrave; la syntaxe des autres
     fonctions de contr&ocirc;le :
     <informalexample>
     <programlisting>
 <![CDATA[
<?php
  declare (directive) statement
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    L'expression <literal>directive</literal> permet de contr&ocirc;ler l'intervention
    du bloc <literal>declare</literal>. Actuellement, une seule directive
    est reconnue : la directive <literal>ticks</literal> (Voir plus bas pour plus
    de d&eacute;tails) sur les <link linkend="control-structures.declare.ticks">ticks</link>).
   </para>
   <para>
    L'expression <literal>statement</literal> du bloc de
    <literal>declare</literal> sera ex&eacute;cut&eacute;e. Comment elle sera ex&eacute;cut&eacute;e,
    et quels effets cela aura d&eacute;pend de la directive utilis&eacute;e dans le bloc
    <literal>directive</literal>.
   </para>
   <sect2 id="control-structures.declare.ticks">
    <title>Ticks</title>
    <para>
     Un tick est un &eacute;v&eacute;nement qui intervient toutes les
    <replaceable>N</replaceable> commandes bas niveau, ex&eacute;cut&eacute;es par l'analyseur
    dans le bloc de <literal>declare</literal>.
    La valeur de <replaceable>N</replaceable> est sp&eacute;cifi&eacute;e avec la syntaxe
    <literal>ticks=<replaceable>N</replaceable></literal>
    dans le bloc de directive <literal>declare</literal>.
   </para>
   <para>
    Un &eacute;v&eacute;nement qui intervient &agrave; chaque tick est sp&eacute;cifi&eacute; avec la fonction
    <function>register_tick_function</function>. Reportez vous &agrave; l'exemple
    ci-dessous pour plus de d&eacute;tails. Notez que plus d'un &eacute;v&eacute;nement peut
    intervenir par tick.
   </para>
   <para>
    <example>
     <title>Profiler une section de code &php;</title>
     <programlisting role="php">
<![CDATA[
<?php
// Un fonction qui enregistre l'heure &agrave; laquelle elle est appel&eacute;e
  function profile($dump = FALSE){
    static $profile;
    // Retourne les horaires stock&eacute;s dans le profile, et l'efface
    if ($dump) {
        $temp = $profile;
        unset ($profile);
        return ($temp);
    }
    $profile[] = microtime ();
  }

// Enregistre un gestionnaire de tick
  register_tick_function("profile");

// Initialise la fonction avant le bloc de d&eacute;claration
  profile();

// Ex&eacute;cute un bloc de code, et appele un tick toutes les deux secondes
  declare (ticks=2) {
    for ($x = 1; $x < 50; ++$x) {
        echo similar_text(md5($x), md5($x*$x)), "<br>";
    }
  }

// Affiche les donn&eacute;es de la variable $profile
  print_r(profile(TRUE));
?>
]]>
     </programlisting>
    </example>
     Cet exemple profile le code &php; dans le bloc de d&eacute;claration,
     et enregistre l'heure de chaque commande bas niveau. Cette
     information peut &ecirc;tre r&eacute;utilis&eacute;e pour d&eacute;busquer les segments
     de code lents. Vous pouvez impl&eacute;menter d'autres m&eacute;thodes, mais
     les ticks sont plus rapides et plus efficaces.
   </para>
   <simpara>
    Les ticks sont bien pratiques pour d&eacute;bugger, impl&eacute;menter un
    multi-t&acirc;ches simple, des entr&eacute;es sorties en t&acirc;che de
    fond, ou bien d'autres choses, avec &php;.
   </simpara>
   <simpara>
    Voir aussi
     <function>register_tick_function</function> et
    <function>unregister_tick_function</function>.
   </simpara>
   </sect2>
  </sect1>
  <sect1 id="function.return">
   <title>return</title>
   <simpara>
    Si appel&eacute;e depuis une fonction, la commande <function>return</function>
    termine imm&eacute;diatement la fonction, et retourne l'argument qui lui
    est pass&eacute;. <function>return</function> interromp aussi l'ex&eacute;cution
    de commande <function>eval</function> ou de scripts.
   </simpara>
   <simpara>
    Si appel&eacute;e depuis l'environnement global, l'ex&eacute;cution du script
    est interrompue. Si le script courant &eacute;tait 
    <function>include</function> ou <function>require</function>,
    alors le contr&ocirc;le est rendu au script appelant, et la valeur
    retourn&eacute;e sera utilis&eacute;e comme r&eacute;sultat de la fonction
    <function>include</function>. Si <function>return</function> est
    appel&eacute;e depuis le script principal, alors l'ex&eacute;cution du script
    s'arr&ecirc;te. Si le script courant est
    <link linkend="ini.auto-prepend-file">auto_prepend_file</link> ou 
    <link linkend="ini.auto-append-file">auto_append_file</link>
    dans le fichier &php.ini;, alors l'ex&eacute;cution du script
    s'arr&ecirc;te.
   </simpara>
   <simpara>
    Pour plus d'informations, voyez 
    <link linkend="functions.returning-values">retourner des valeurs</link>.
   </simpara>
   <note>
    <simpara>
     Notez que puisque <function>return</function> est une structure de langage
     et non pas une fonction, les parenth&egrave;ses <emphasis>ne sont pas</emphasis> requises :
     en fait, il est classique de les ignorer, m&ecirc;me si cela ne change rien.
    </simpara>
   </note>
  </sect1>
  <sect1 id="function.require">
   <title><function>require</function></title>
   <simpara>
    <function>require</function> inclut et ex&eacute;cute un
    fichier &php;.
   </simpara>
   <simpara>
    La commande <function>require</function> se remplace elle-m&ecirc;me
    par le contenu du fichier sp&eacute;cifi&eacute;, tel que
    d&eacute;crit dans la documentation de la fonction <function>include</function>.
   </simpara>
   <simpara>
    <function>require</function> et <function>include</function> 
    sont identiques, sauf dans leur fa&ccedil;on de g&eacute;rer les erreurs.
     <function>include</function> produite une 
     <link linkend="internal.e-warning">Alerte (warning)</link> tandis
     que <function>require</function> g&eacute;n&egrave;re une
     <link linkend="internal.e-error">erreur fatale</link>. En
     d'autres termes, n'h&eacute;sitez pas &agrave; utiliser 
     <function>require</function> si vous voulez qu'un fichier
     d'inclusion manquant interrompe votre script.
     <function>include</function> ne se comporte pas de cette fa&ccedil;on,
     et le script continuera son ex&eacute;cution. Assurez vous d'avoir
     bien configur&eacute; le <link linkend="ini.include-path">include_path</link>
     aussi.
   </simpara>
   <para>
    <example>
     <title>Exemples avec <function>require</function></title>
     <programlisting role="php">
<![CDATA[
<?php
  require 'prepend.php';

  require $somefile;

  require ('unfichier.txt');
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Voyez la documentation de la fonction <function>include</function> pour plus
    d'exemples.
   </simpara>
   <note>
    <simpara>
     Avant &php; 4.0.2, ceci s'appliquait : <function>require</function> tentait
     de lire le fichier cible, m&ecirc;me si les lignes n'&eacute;taient pas utilis&eacute;es.
     Une condition if n'avait aucun effet sur <function>require</function>. Cependant,
     si la ligne du <function>require</function> n'est jamais utilis&eacute;e,
     le code inclus ne le sera pas non plus. De m&ecirc;me, les boucles n'ont pas
     d'effet sur le comportement de <function>require</function>. Bien que le
     code contenu dans le fichier subit la boucle, la fonction elle m&ecirc;me
     <function>require</function> n'est appel&eacute;e qu'une fois.
    </simpara>
   </note>
   &warn.no-win32-fopen-wrapper;
   <simpara>
    Voir aussi
    <function>include</function>, 
    <function>require_once</function>,
    <function>include_once</function>, 
    <function>eval</function>, 
    <function>file</function>, 
    <function>readfile</function>, 
    <function>virtual</function> et 
    <link linkend="ini.include-path">include_path</link>.
   </simpara>
  </sect1>
  <sect1 id="function.include">
   <title><function>include</function></title>
   <simpara>
      La fonction <function>include</function> inclut et ex&eacute;cute
      le fichier sp&eacute;cifi&eacute; en argument.
   </simpara>
   <simpara>
     Cette documentation s'applique aussi &agrave; la fonction 
     <function>require</function>. Les deux structures de
     langage sont identiques, hormis dans leur gestion des
     erreurs. 
     <function>include</function> produit une 
     <link linkend="internal.e-warning">Alerte (warning)</link> tandis
     que <function>require</function> g&eacute;n&egrave;re une
     <link linkend="internal.e-error">erreur fatale</link>. En
     d'autres termes, n'h&eacute;sitez pas &agrave; utiliser 
     <function>require</function> si vous voulez qu'un fichier
     d'inclusion manquant interrompe votre script.
     <function>include</function> ne se comporte pas de cette fa&ccedil;on,
     et le script continuera son ex&eacute;cution. Assurez-vous d'avoir
     bien configur&eacute; le <link linkend="ini.include-path">include_path</link>
     aussi.
   </simpara>
   <simpara>
     Lorsqu'un fichier est inclus, le code qu'il contient h&eacute;rite
     des variables qui existent dans ce 
     <link linkend="language.variables.scope">contexte</link>.
     Toute variable accessible &agrave; la ligne qui r&eacute;alise l'ex&eacute;cution
     est aussi accessible dans le fichier inclus.
   </simpara>
   <para>
     <example>
      <title>Exemple avec <function>include</function></title>
      <programlisting role="php">
<![CDATA[
vars.php
<?php

$couleur = 'verte';
$fruit = 'pomme';

?>

test.php
<?php

echo "Une $couleur $fruit"; // Une

include 'vars.php';

echo "Une $color $fruit"; // Une verte pomme 

?>
]]>
      </programlisting>
     </example>
   </para>
   <simpara>
     Si l'inclusion intervient &agrave; l'int&eacute;rieure d'une fonction,
     le code inclus sera alors consid&eacute;r&eacute; comme faisant partie de la
     fonction. Cela modifie donc le contexte de variables accessibles.
   </simpara>
   <para>
     <example>
     <title>Inclusion de fichiers dans une fonction</title>
      <programlisting role="php">
<![CDATA[
<?php

function foo() {
    global $couleur;

    include 'vars.php';

    echo "Une $couleur $fruit"; 
}

/* vars.php est dans le contexte de foo()    *
 * donc $fruit n'est pas dispnibles hors de  *
 * cette fonction. $couleur l'est, car c'est *
 * une variable globale                      */

foo();                      // Une verte pomme 
echo "Une $couleur $fruit"; // Une verte

?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
      Il est important de noter que lorsqu'un fichier est
      <function>include</function> ou <function>require</function>,
      les erreurs d'analyse appara&icirc;tront en HTML tout
      au d&eacute;but du fichier, et l'analyse du fichier
      parent ne sera pas interrompue. Pour cette raison, le code
      qui est dans le fichier doit &ecirc;tre plac&eacute; entre
      <link linkend="language.basic-syntax.phpmode">les balises
      habituelles de &php;</link>.
   </simpara>
   <simpara>
     Si les "<link linkend="ini.allow-url-fopen">URL fopen wrappers</link>"
     sont activ&eacute;s dans &php; (ce qui est le cas par d&eacute;faut),
     vous pouvez localiser le fichier avec une URL (via HTTP ou
     bien avec un gestionnaire adapt&eacute; : voir <xref linkend="wrappers"/>
     pour une liste des protocoles), au lieu d'un simple chemin
     local. Si le serveur distant interpr&ecirc;te le fichier comme du code
     &php;, des variables peuvent &ecirc;tre transmises au serveur distant
     via l'URL et la m&eacute;thode GET. Ce n'est pas, &agrave; strictement
     parler, la m&ecirc;me chose que d'h&eacute;riter du contexte de variable.
     Le fichier inclus est en fait un script ex&eacute;cut&eacute; &agrave; distance,
     et son r&eacute;sultat est inclus dans le code courant.
   </simpara>
   &warn.no-win32-fopen-wrapper;
   <para>
    <example>
     <title>Utiliser <function>include</function> via HTTP</title>
     <programlisting role="php">
<![CDATA[
<?php

/* Cet exemple suppose que www.exemple.com est configur pour traiter 
 * les fichiers .php et non pas les fichiers .txt. De plus,
 * 'Work' signifie ici que les variables 
 * $foo et $bar sont disponibles dans le fichier inclus  
 */

// Ne fonctionne pas : file.txt n'a pas &eacute;t&eacute; trait&eacute; par www.exemple.com comme du PHP
include 'http://www.example.com/file.txt?foo=1&bar=2';

// Ne fonctionne pas : le script cherche un fichier nomm&eacute; 
// 'file.php?foo=1&bar=2' sur le syst&egrave;me local
include 'file.php?foo=1&bar=2';

// R&eacute;ussi
include 'http://www.example.com/file.php?foo=1&bar=2';

$foo = 1;
$bar = 2;
include 'file.txt';  // OK.
include 'file.php';  // OK.

?>
]]>
     </programlisting>
    </example>
     Voir aussi
     <link linkend="features.remote-files">travailler avec les fichiers distants</link>,
     <function>fopen</function> et 
     <function>file</function> pour des informations reli&eacute;es.
   </para>
   <para>
     Comme <function>include</function> et <function>require</function>
     sont des structures du langage particuli&egrave;res, vous devez les
     placer dans un bloc s'ils sont plac&eacute;s dans un bloc conditionnel.
   </para>
   <para>
    <example>
     <title><function>include</function> et les conditions</title>
     <programlisting role="php">
<![CDATA[
<?php

// Ceci est FAUX et &eacute;chouera
if ($condition)
    include $file;
else
    include $other;


// Ceci est CORRECT.
if ($condition) {
    include $file;
} else {
    include $other;
}

?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Gestion du retour : il est possible d'ex&eacute;cuter une commande
    <function>return</function> dans un fichier inclus pour en
    terminer le traitement et retourner au fichier appelant. De plus,
    il est possible de retourner des valeurs des fichiers inclus.
    vous pouvez prendre et traiter la valeur retourn&eacute;e par la 
    fonction, comme toute autre fonction.
   </simpara>
   <note>
    <simpara>
     En &php; 3, le return n'est pas utilisable &agrave; moins que ce
     ne soit dans un bloc de fonction, auquel cas le 
     <function>return</function> s'applique &agrave; une fonction et non
     pas au fichier.
    </simpara>
   </note>
   <para>
    <example>
     <title><function>include</function> et <function>return</function></title>
      <programlisting role="php">
<![CDATA[
return.php
<?php

$var = 'PHP';

return $var;

?>

noreturn.php
<?php

$var = 'PHP';

?>

testreturns.php
<?php

$foo = include 'return.php';

echo $foo; // prints 'PHP'

$bar = include 'noreturn.php';

echo $bar; // prints 1

?>
]]>
      </programlisting>
    </example>
   </para>
   <simpara>
    <literal>$bar</literal> a la valeur de <literal>1</literal> car
    l'inclusion &eacute;tait r&eacute;ussie. Notez la diff&eacute;rence entre les deux
    exemples ci-dessus. Le premier utilise la commande <function>return</function> 
    dans le fichier inclus, alors que le second ne le fait pas.
    Un autre moyen d'inclure des fichiers dans des variables
    est d'utiliser la fonction <function>fopen</function> ou
    <function>file</function> ou d'utiliser 
    <function>include</function> avec les 
    <link linkend="ref.outcontrol">fonctions de contr&ocirc;le de sortie</link>.
   </simpara>

   <simpara>
    Voir aussi 
    <function>require</function>, 
    <function>require_once</function>,
    <function>include_once</function>, 
    <function>readfile</function>,
    <function>virtual</function> et
    <link linkend="ini.include-path">include_path</link>.
   </simpara>
   </sect1>
    <sect1 id="function.require-once">
   <title><function>require_once</function></title>
   <para>
    La commande <function>require_once</function> se remplace elle-m&ecirc;me
    par le fichier sp&eacute;cifi&eacute;, un peu comme les commandes de
    pr&eacute;processeur C <literal>#include</literal>, et ressemble sur
    ce point &agrave; <function>require</function>. La principale
    diff&eacute;rence est qu'avec <function>require_once</function>,
    vous &ecirc;tes assur&eacute;s que ce code ne sera ajout&eacute;
    qu'une seule fois, &eacute;vitant de ce fait les red&eacute;finitions de
    variables ou de fonctions, g&eacute;n&eacute;ratrices d'alertes.
   </para>
   <para>
    <function>require_once</function> doit &ecirc;tre utilis&eacute;e dans les cas
    o&ugrave; le m&ecirc;me fichier risque d'&ecirc;tre inclus et &eacute;valu&eacute; plusieurs fois
    durant l'ex&eacute;cution d'un script. Vous serez alors s&ucirc;rs qu'il ne sera inclut qu'une fois
    et vous &eacute;viterez les probl&egrave;mes de re-d&eacute;clarations de fonctions ou autres.
   </para>
   <para>
    Pour des exemples avec <function>require_once</function> et
    <function>include_once</function>, reportez-vous au code 
    <ulink url="&url.php.pear;">PEAR</ulink> inclus dans les 
    derni&egrave;res distributions &php;.
   </para>
   <note>
    <para>
     <function>require_once</function> a &eacute;t&eacute; ajout&eacute; en &php; 4.0.1pl2
    </para>
   </note>
   <note>
    <para>
     Attention, <function>require_once</function> et 
     <function>include_once</function> sont sensibles &agrave; la casse
     sous Windows.
     <example>
      <title><function>require_once</function> est sensible &agrave; la casse</title>
      <programlisting role="php">
<![CDATA[
require_once("a.php"); // ceci inclut le fichier a.php
require_once("A.php"); // ceci inclut encore le fichier a.php sous Windows!
]]>
       </programlisting>
     </example>
    </para>
   </note>
   &warn.no-win32-fopen-wrapper;
   <para>
    Voir aussi 
    <function>require</function>,
    <function>include</function>, 
    <function>include_once</function>,
    <function>get_required_files</function>,
    <function>get_included_files</function>, 
    <function>readfile</function> et
	<function>virtual</function>.
   </para>
  </sect1>
  <sect1 id="function.include-once">
   <title><function>include_once</function></title>
   <para>
    La commande <function>include_once</function> inclut et
    &eacute;value le fichier sp&eacute;cifi&eacute; durant
    l'ex&eacute;cution du script. Le comportement est similaire &agrave;
    <function>include</function>, mais la diff&eacute;rence est que si
    le code a d&eacute;j&agrave; &eacute;t&eacute; inclus, il ne le
    sera pas une seconde fois.
   </para>
   <para>
    La fonction <function>include_once</function> est utilis&eacute;e de
    pr&eacute;f&eacute;rence lorsque le	fichier doit &ecirc;tre
    inclus ou &eacute;valu&eacute; plusieurs fois dans un script,
    ou bien	lorsque vous voulez &ecirc;tre s&ucirc;r qu'il ne sera inclus
    qu'une seule fois, pour &eacute;viter des red&eacute;finitions
    de fonction.
   </para>
   <para>
    Pour plus d'exemples avec <function>require_once</function> et
    <function>include_once</function>, jetez un oeil dans le code de PEAR
	inclus dans la derni&egrave;re distribution de &php;.
   </para>
   <note>
    <para>
     <function>include_once</function> a &eacute;t&eacute; ajout&eacute; en &php; 4.0.1pl2
    </para>
   </note>
   <note>
    <para>
     Attention, <function>include_once</function> et 
     <function>include_once</function> sont sensibles &agrave; la casse
     sous Windows.
     <example>
      <title><function>include_once</function> est sensible &agrave; la casse</title>
      <programlisting role="php">
<![CDATA[
include_once("a.php"); // ceci inclut le fichier a.php
include_once("A.php"); // ceci inclut encore le fichier a.php sous Windows!
]]>
       </programlisting>
     </example>
    </para>
   </note>
   &warn.no-win32-fopen-wrapper;
   <para>
    Voir aussi 
    <function>require</function>,
    <function>include</function>, 
    <function>require_once</function>,
    <function>get_required_files</function>,
    <function>get_included_files</function>, 
    <function>readfile</function> et 
    <function>virtual</function>.
   </para>
  </sect1>
 </chapter>
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
indent-tabs-mode:nil
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
