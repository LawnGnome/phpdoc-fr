<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.67 $ -->
<!-- EN-Revision: 1.113 Maintainer: dams Status: ready -->
 <chapter id="language.control-structures">
  <title>Les structures de contrôle</title>

  <simpara>
   Tous les scripts &php; sont une suite d'instructions. Une instruction
   peut être une assignation, un appel de fonction, une instruction
   conditionnelle ou bien une instruction qui ne fait rien (une instruction
   vide). Une instruction se termine habituellement par un point virgule
   ("<literal>;</literal>"). De plus, plusieurs instructions peuvent être
   regroupées en bloc, délimité par des
   accolades ("<literal>{}</literal>"). Un bloc est considéré
   comme une instruction. Les différents types d'instruction sont
   décrits dans ce chapitre.
  </simpara>

  <sect1 id="control-structures.if">
   <title><literal>if</literal></title>
   <para>
    L'instruction <literal>if</literal> est une des plus importantes
    instructions de tous les langages, &php; inclus. Elle permet
    l'exécution conditionnelle d'une partie de code. Les
    fonctionnalités de l'instruction <literal>if</literal>
    sont les mêmes en &php; qu'en C :
    <example>
     <title>Instruction if () </title>
     <programlisting role="php">
 <![CDATA[
<?php
if (expression)
    commandes
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Comme nous l'avons vu dans le paragraphe consacré aux
    <link linkend="language.expressions">expressions</link>,
    <replaceable>expr</replaceable> est convertie en sa valeur
    booléenne. Si l'expression <replaceable>expr</replaceable> vaut
    &true;, &php; exécutera l'instruction et si elle
    vaut &false;, l'instruction sera ignorée.
    Plus de détails sur les valeurs qui valent &false; sont disponibles dans
    la section
    <link linkend="language.types.boolean.casting">Conversion en booléen</link>.
   </simpara>
   <para>
    L'exemple suivant affiche la phrase <computeroutput>a est plus grand
    que b</computeroutput> si <varname>$a</varname> est plus grand
    que <varname>$b</varname> :
    <example>
     <title>Instruction if () (2)</title>
     <programlisting role="php">
 <![CDATA[
<?php
if ($a > $b)
    print "a est plus grand que b";
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Souvent, vous voulez que plusieurs instructions soient
    exécutées après un branchement conditionnel. Bien
    évidemment, il n'est pas obligatoire de répéter
    l'instruction conditionnelle autant de fois que vous avez d'instructions
    à exécuter. A la place, vous pouvez rassembler toutes les
    instructions dans un bloc. L'exemple suivant affiche <computeroutput>a
    est plus grand que b</computeroutput>, et assigne la valeur de la
    variable <varname>$a</varname> à la variable
    <varname>$b</varname> :
    <example>
     <title>Instruction if () et bloc</title>
     <programlisting role="php">
 <![CDATA[
<?php
if ($a > $b) {
  echo "a est plus grand que b";
  $b = $a;
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Vous pouvez imbriquer indéfiniment des instructions
    <literal>if</literal> les unes dans les autres, ce qui permet
    une grande flexibilité dans l'exécution d'une
    partie de code suivant un grand nombre de conditions.
   </simpara>
  </sect1>

  <sect1 id="control-structures.else">
   <title><literal>else</literal></title>
   <para>
    Souvent, vous voulez exécuter une instruction si une
    condition est remplie, et une autre instruction si cette condition
    n'est pas remplie. C'est à cela que sert <literal>else</literal>.
    <literal>else</literal> fonctionne après un
    <literal>if</literal> et exécute les instructions
    correspondantes au cas o&uacute; l'expression du <literal>if</literal>
    est &false;. Dans l'exemple suivant, ce bout de code
    affiche <computeroutput>a est plus grand que b</computeroutput> si la
    variable <varname>$a</varname> est plus grande que la variable
    <varname>$a</varname>, et <computeroutput>a est plus petit que b</computeroutput>
    sinon :
    <example>
     <title>Instruction <literal>if () else</literal></title>
     <programlisting role="php">
 <![CDATA[
<?php
if ($a > $b) {
    echo "a est plus grand que b";
} else {
    echo "a est plus petit que b";
}
?>
]]>
     </programlisting>
    </example>

    Les instructions après le <literal>else</literal> ne sont
    exécutées que si l'expression du <literal>if</literal>
    est &false;, et si elle n'est pas suivi par l'expression
    <literal>elseif</literal> - uniquement si elles sont évaluées à &false; (voir <link
    linkend="control-structures.elseif">elseif</link>).

   </para>
  </sect1>

  <sect1 id="control-structures.elseif">
   <title><literal>elseif</literal></title>
   <para>
    <literal>elseif</literal>, comme son nom l'indique, est une combinaison
    de <literal>if</literal> et de <literal>else</literal>. Comme l'expression
    <literal>else</literal>, il permet d'exécuter une instruction
    après un <literal>if</literal> dans le cas où le "premier"
    if est évalué comme &false;. Mais,
    à la différence de l'expression <literal>else</literal>,
    il n'exécutera l'instruction que si l'expression conditionnelle
    <literal>elseif</literal> est évaluée comme
    &true;. L'exemple suivant affichera
    <computeroutput>a est plus grand que b</computeroutput>,
    <computeroutput>a est égal à b</computeroutput> ou
    <computeroutput>a est plus petit que b</computeroutput> :
    <example>
     <title>Instruction <literal>elseif</literal></title>
     <programlisting role="php">
 <![CDATA[
<?php
if ($a > $b) {
    echo "a est plus grand que b";
} elseif ($a == $b) {
    echo "a est égal à b";
} else {
    echo "a est plus petit que b";
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Vous pouvez avoir plusieurs <literal>elseif</literal> qui se suivent
    les uns après les autres, après un <literal>if</literal> initial.
    Le premier <literal>elseif</literal> qui sera évalué
    à &true; sera exécuté. En &php;, vous
    pouvez aussi écrire "<literal>else if</literal>" en deux mots et
    son comportement sera identique à la version en un seul mot.
    La sémantique des deux expressions est légèrement
    différente, mais au bout du compte, le résultat sera
    exactement le même.
   </simpara>
   <simpara>
    L'expression <literal>elseif</literal> est exécutée
    seulement si le <literal>if</literal> précédent et tout
    autre <literal>elseif</literal> précédent sont
    évalués comme &false;, et que
    votre <literal>elseif</literal> est évalué à
    &true;.
   </simpara>
  </sect1>

  <sect1 id="control-structures.alternative-syntax">
   <title>Syntaxe alternative</title>
   <para>
    &php; propose une autre manière de rassembler des
    instructions à l'intérieur d'un bloc, pour les
    fonctions de contrôle <literal>if</literal>,
    <literal>while</literal>, <literal>for</literal>,
    <literal>foreach</literal> et <literal>switch</literal>.
    Dans chaque cas, le principe
    est de remplacer l'accolade d'ouverture par deux points (:)
    et l'accolade de fermeture par, respectivement,
    <literal>endif;</literal>, <literal>endwhile;</literal>,
    <literal>endfor;</literal> ou <literal>endswitch;</literal>.
    <example>
     <title>Instruction alternative <literal>if()</literal></title>
     <programlisting role="php">
 <![CDATA[
<?php if ($a == 5): ?>
A égal 5
<?php endif; ?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Dans l'exemple ci-dessus, le bloc HTML "A égal 5" est inclus
    à l'intérieur d'un <literal>if</literal> en
    utilisant cette nouvelle syntaxe. Ce code HTML ne sera
    affiché que si la variable <varname>$a</varname> est égale à 5.
   </simpara>
   <para>
    Cette autre syntaxe fonctionne aussi avec le <literal>else</literal> et
    <literal>elseif</literal>. L'exemple suivant montre une structure avec un
    <literal>if</literal>, un <literal>elsif</literal> et un
    <literal>else</literal> utilisant cette autre syntaxe :
    <example>
     <title>
      Instruction alternative <literal>if() elseif()</literal> et
      <literal>else</literal>
     </title>
     <programlisting role="php">
 <![CDATA[
<?php
if ($a == 5):
    echo "a égale 5";
    echo "...";
elseif ($a == 6):
    echo "a égale 6";
    echo "!!!";
else:
    echo "a ne vaut ni 5 ni 6";
endif;
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Voir aussi
    <link linkend="control-structures.while"><literal>while</literal></link>,
    <link linkend="control-structures.for"><literal>for</literal></link>, et
    <link linkend="control-structures.if">if</link> pour d'autres exemples.
   </para>
  </sect1>

  <sect1 id="control-structures.while">
   <title><literal>while</literal></title>
   <para>
    La boucle <literal>while</literal> est le moyen le plus
    simple d'implémenter une boucle en &php;. Cette boucle
    se comporte de la même manière qu'en C.
    L'exemple le plus simple d'une boucle <literal>while</literal>
    est le suivant :
    <example>
     <title>Instruction <literal>while</literal></title>
     <programlisting role="php">
 <![CDATA[
<?php
while (expression)
  commandes
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    La signification d'une boucle <literal>while</literal> est
    très simple. &php; exécute l'instruction tant
    que l'expression de la boucle <literal>while</literal> est
    évaluée comme &true;. La valeur
    de l'expression est vérifiée à chaque
    début de boucle, et, si la valeur change durant
    l'exécution de l'instruction, l'exécution ne
    s'arrêtera qu'à la fin de l'itération
    (chaque fois que &php; exécute l'instruction, on appelle
    cela une itération). De temps en temps, si l'expression du
    <literal>while</literal> est &false; avant la
    première itération, l'instruction ne sera jamais
    exécutée.
   </simpara>
   <para>
    Comme avec le <literal>if</literal>, vous pouvez regrouper
    plusieurs instructions dans la même boucle
    <literal>while</literal> en les regroupant à l'intérieur
    de parenthèses ou en utilisant la syntaxe suivante :
    <example>
     <title>Instruction <literal>while</literal> avec bloc</title>
     <programlisting role="php">
 <![CDATA[
<?php
while (expression):
  commandes
  ...
endwhile;
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Les exemples suivants sont identiques et affichent tous les nombres
    de 1 à 10 :
    <example>
     <title>Exemple avec <literal>while</literal> </title>
     <programlisting role="php">
 <![CDATA[
<?php
/* exemple 1 */

$i = 1;
while ($i <= 10) {
    echo $i++;  /* La valeur affiche est $i avant l'incrémentation
                     (post-incrémentation)  */
}

/* exemple 2 */

$i = 1;
while ($i <= 10):
    echo $i;
    $i++;
endwhile;
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect1>

  <sect1 id="control-structures.do.while">
   <title><literal>do-while</literal></title>
   <simpara>
    Les boucles <literal>do-while</literal> ressemblent beaucoup
    aux boucles <literal>while</literal>, mais l'expression est
    testée à la fin de chaque itération plutôt
    qu'au début. La principale différence par rapport
    à la boucle <literal>while</literal> est que la
    première itération de la boucle
    <literal>do-while</literal> est toujours exécutée
    (l'expression n'est testée qu'à la fin de
    l'itération), ce qui n'est pas le cas lorsque vous
    utilisez une boucle <literal>while</literal> (l'expression
    est vérifiée au début de chaque itération).
   </simpara>
   <para>
    Il n'y a qu'une syntaxe possible pour les boucles <literal>do-while</literal> :

    <example>
     <title>Instruction <literal>do-while</literal></title>
     <programlisting role="php">
 <![CDATA[
<?php
$i = 0;
do {
    echo $i;
} while ($i > 0);
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    La boucle ci-dessus ne va être exécutée
    qu'une seule fois, car lorsque l'expression est
    évaluée, elle vaut &false; (car
    la variable <varname>$i</varname> n'est pas plus grande que 0) et l'exécution
    de la boucle s'arrête.
   </simpara>
   <para>
    Les utilisateurs familiers du C sont habitués à
    une utilisation différente des boucles
    <literal>do-while</literal> , qui permet de stopper
    l'exécution de la boucle au milieu des instructions, en
    l'encapsulant dans un <literal>do-while</literal>(0) la
    fonction <link linkend="control-structures.break"><literal>break</literal></link>.
    Le code suivant montre une utilisation possible :
    <example>
     <title>Instruction <literal>while</literal> et <literal>break</literal></title>
     <programlisting role="php">
 <![CDATA[
<?php
do {
    if ($i < 5) {
        echo "i n'est pas suffisamment grand";
        break;
    }
    $i *= $factor;
    if ($i < $minimum_limit) {
        break;
    }
   echo "i est bon";

    /* ...traitement de i... */

} while (0);
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Ne vous inquiétez pas si vous ne comprenez
    pas tout correctement. Vous pouvez écrire des scripts
    très très puissants sans utiliser
    cette fonctionnalité.
   </simpara>
  </sect1>

  <sect1 id="control-structures.for">
   <title><literal>for</literal></title>
   <para>
    Les boucles <literal>for</literal> sont les boucles les plus complexes en &php;.
    Elles fonctionnent comme les boucles <literal>for</literal> du langage C.
    La syntaxe des boucles <literal>for</literal> est la suivante :
    <example>
     <title>Instruction <literal>for</literal> </title>
     <programlisting role="php">
 <![CDATA[
<?php
for (expr1; expr2; expr3)
  statement
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    La première expression (<varname>expr1</varname>) est
    évaluée (exécutée), quoi qu'il arrive au
    début de la boucle.
   </simpara>
   <simpara>
    Au début de chaque itération, l'expression
    <varname>expr2</varname> est évaluée.
    Si l'évaluation vaut &true;, la boucle
    continue et l'instruction est exécutée. Si
    l'évaluation vaut &false;,
    l'exécution de la boucle s'arrête.
   </simpara>
   <simpara>
    A la fin de chaque itération, l'expression
    <varname>expr3</varname> est évaluée
    (exécutée).
   </simpara>
   <simpara>
    Les expressions peuvent éventuellement être
    laissées vides. Si l'expression <varname>expr2</varname>
    est laissée vide, cela signifie que c'est une boucle infinie
    (&php; considère implicitement qu'elle vaut &true;,
    comme en C). Cela n'est pas vraiment très utile, à moins que vous
    souhaitiez terminer votre boucle par l'instruction conditionnelle
    <link linkend="control-structures.break"><literal>break</literal></link>.
   </simpara>
   <para>
    Considérons les exemples suivants. Tous affichent les chiffres de
    1 à 10 :
    <example>
     <title>Exemple de boucles</title>
     <programlisting role="php">
<![CDATA[
<?php
/* exemple 1 */

for ($i = 1; $i <= 10; $i++) {
    echo $i;
}

/* exemple 2 */

for ($i = 1; ; $i++) {
    if ($i > 10) {
        break;
    }
    echo $i;
}

/* exemple 3 */

$i = 1;
for (; ; ) {
    if ($i > 10) {
        break;
    }
    echo $i;
    $i++;
}

/* exemple 4 */

for ($i = 1; $i <= 10; print $i, $i++);
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Bien évidemment, le premier exemple est le plus simple
    de tous (ou peut être le quatrième), mais vous
    pouvez aussi pensez qu'utiliser une expression vide dans une
    boucle <literal>for</literal> peut être utile parfois.
   </simpara>
   <para>
    &php; supporte aussi la syntaxe alternative suivante pour les boucles
    <literal>for</literal> :
    <example>
     <title>Instruction <literal>for</literal> alternative</title>
     <programlisting role="php">
<![CDATA[
<?php
for (expr1; expr2; expr3):
  statement;
  ...;
endfor;
?>
]]>
     </programlisting>
     </example>
   </para>
  </sect1>

  <sect1 id="control-structures.foreach">
   <title><literal>foreach</literal></title>
   <para>
    &php; 4 introduit une commande <literal>foreach</literal>,
    comme en Perl ou d'autres langages. C'est un moyen simple de passer
    en revue un tableau. Il y a deux syntaxes possibles : la seconde est
    une extension mineure mais pratique de la première.
    <example>
     <title>Instruction <literal>foreach</literal></title>
     <programlisting role="php">
 <![CDATA[
<?php
foreach(array_expression as $value)
  commandes
foreach(array_expression as $key => $value)
  commandes
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    La première forme passe en revue le tableau
    <literal>array_expression</literal>. A chaque itération,
    la valeur de l'élément courant est assignée à
    <literal>$value</literal> et le pointeur interne de tableau est
    avancé d'un élément (ce qui fait qu'à
    la prochaine itération, on accédera à
    l'élément suivant).
   </simpara>
   <simpara>
    La deuxième forme fait exactement la même chose, mais
    c'est la clé de l'élément courant qui est
    assigné à la variable <literal>$key</literal>.
   </simpara>
   <para>
    <note>
     <para>
      Lorsque <literal>foreach</literal> démarre, le pointeur interne
      de fichier est automatiquement ramené au premier
      élément du tableau. Cela signifie que vous n'aurez
      pas à faire appel à <function>reset</function> avant
      <literal>foreach</literal>.
     </para>
    </note>
   </para>
   <para>
    <note>
     <para>
      De plus, notez que <literal>foreach</literal> travaille sur une copie
      du tableau spécifié, et pas sur le tableau lui-même.
      Par conséquent,
      le pointeur de tableau n'est pas modifié, comme il le serait
      avec le fonction <function>each</function>, et les modifications
      faites dans le tableau ne seront pas prises en compte dans le
      tableau original. Cependant, le pointeur interne du tableau original
      <emphasis>est</emphasis> avancé avec le traitement du tableau.
      En supposant sur la boucle foreach effectue tout le traitement, le pointeur
      interne du tableau sera à la fin du tableau.
     </para>
     <para>
      Depuis &php; 5, vous pouvez facilement modifier les éléments d'un tableau
      en faisant précéder la valeur <literal>$value</literal> avec &amp;.
      Ceci aura pour effet d'assigner par
      <link linkend="language.references">référence</link> au lieu de copier
      la valeur.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$arr = array(1, 2, 3, 4);
foreach ($arr as &$value) {
    $value = $value * 2;
}
// $arr vaut maintenant array(2, 4, 6, 8)
?>
]]>
       </programlisting>
      </informalexample>
      Ceci n'est possible que si le tableau itéré peut être réféencé (i.e. est une variable).
     </para>
    </note>
   </para>
   <para>
    <note>
     <para>
      <literal>foreach</literal> n'accepte pas l'opérateur de suppression
      des erreurs <link linkend="language.operators.errorcontrol">@</link>.
     </para>
    </note>
   </para>
   <para>
    Vous pouvez remarquer que les exemples suivants fonctionnent de
    manière identique :
    <example>
     <title>Instruction <literal>foreach</literal> et <literal>while</literal></title>
     <programlisting role="php">
<![CDATA[
<?php
$arr = array("un", "deux", "trois");
reset($arr);
while (list(, $value) = each($arr)) {
    echo "Valeur : $value<br />\n";
}

foreach ($arr as $value) {
    echo "Valeur : $value<br />\n";
}
?>
]]>
      </programlisting>
     </example>
     Les exemples suivants sont aussi fonctionnellement identiques :
     <example>
      <title>Instruction <literal>foreach</literal>et <literal>while</literal>(2)</title>
      <programlisting role="php">
 <![CDATA[
<?php
$arr = array("un", "deux", "trois");
reset($arr);
while (list($key, $value) = each($arr)) {
    echo "Clé : $key; Valeur : $value<br />\n";
}

foreach ($arr as $key => $value) {
    echo "Clé : $key; Valeur : $value<br />\n";
}
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Voici quelques exemples de plus :
     <example>
      <title>Instruction <literal>foreach</literal> et <literal>while</literal>(3)</title>
      <programlisting role="php">
<![CDATA[
<?php
/* exemple foreach 1 : la valeur seulement */

$a = array(1, 2, 3, 17);

foreach ($a as $v) {
   echo "Current value of \$a : $v.\n";
}

/* exemple foreach 2 : la valeur et sa clé d'index */

$a = array(1, 2, 3, 17);

$i = 0; /* uniquement pour l'illustration */

foreach ($a as $v) {
    echo "\$a[$i] => $v.\n";
    $i++;
}

/* exemple foreach 3 : la clé et la valeur */

$a = array (
    "un" => 1,
    "deux" => 2,
    "trois" => 3,
    "dix-sept" => 17
);

foreach ($a as $k => $v) {
    echo "\$a[$k] => $v.\n";
}

/* exemple foreach 4 : tableaux multi-dimensionnels */

$a = array();
$a[0][0] = "a";
$a[0][1] = "b";
$a[1][0] = "y";
$a[1][1] = "z";

foreach ($a as $v1) {
    foreach ($v1 as $v2) {
        echo "$v2\n";
    }
}

/* exemple foreach 5 : tableaux dynamiques */

foreach (array(1, 2, 3, 4, 5) as $v) {
    echo "$v\n";
}

?>
]]>
      </programlisting>
     </example>
    </para>
   </sect1>

  <sect1 id="control-structures.break">
   <title><literal>break</literal></title>
   <simpara>
    L'instruction <literal>break</literal> permet de sortir d'une structure
    <literal>for</literal>, <literal>foreach</literal>,
    <literal>while</literal>, <literal>do-while</literal>
    ou <literal>switch</literal>.
   </simpara>
   <simpara>
    <literal>break</literal> accepte un argument numérique optionnel
    qui vous indiquera combien de structures emboîtées ont
    été interrompues.
   </simpara>
   <para>
    <example>
     <title>Instruction break </title>
     <programlisting role="php">
<![CDATA[
<?php
$arr = array('un', 'deux', 'trois', 'quatre', 'stop', 'cinq');
while (list(, $val) = each($arr)) {
    if ($val == 'stop') {
        break;    /* Vous pourriez aussi utiliser 'break 1;' ici. */
    }
    echo "$val<br />\n";
}

/* Utilisation de l'argument optionnel. */

$i = 0;
while (++$i) {
    switch ($i) {
    case 5:
        echo "A 5<br />\n";
        break 1;  /* Termine uniquement le switch. */
    case 10:
        echo "A 10; quitter<br />\n";
        break 2;  /* Termine le switch et la boucle while. */
    default:
        break;
    }
}
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect1>

  <sect1 id="control-structures.continue">
   <title><literal>continue</literal></title>
   <simpara>
    L'instruction <literal>continue</literal> est utilisée
    dans une boucle afin d'éluder les instructions de
    l'itération courante afin de passer directement à
    l'itération suivante.
   </simpara>
   <note>
    <simpara>
    Notez qu'en &php;, la structure
    <link linkend="control-structures.switch"><literal>switch</literal></link>
     est considérée comme une boucle par <literal>continue</literal>.
    </simpara>
   </note>
   <simpara>
    <literal>continue</literal> accepte un argument numérique
    optionnel qui vous indiquera combien de structures
    emboîtées ont été ignorées.
   </simpara>
   <para>
    <example>
     <title>Instruction continue</title>
     <programlisting role="php">
<![CDATA[
<?php
while (list($cle, $valeur) = each($arr)) {
    if (!($cle % 2)) { // évite les membres impairs
        continue;
    }
    fonction_quelconque($valeur);
}

$i = 0;
while ($i++ < 5) {
    echo "Dehors<br />\n";
    while (1) {
        echo "&nbsp;&nbsp;Milieu<br />\n";
        while (1) {
            echo "&nbsp;&nbsp;Intérieur<br />\n";
            continue 3;
        }
        echo "Ceci n'est jamais atteint.<br />\n";
    }
    echo "Ceci non plus.<br />\n";
}
?>
]]>
     </programlisting>
     </example>
    </para>
    <para>
     Oublier le point virgule après <literal>continue</literal> peut porter
     à confusion. Voici un exemple de ce que vous ne devez pas faire :
    </para>
    <para>
     <example>
      <title>N'oubliez pas le point-virgule après continue</title>
      <programlisting role="php">
<![CDATA[
<?php
for ($i = 0; $i < 5; ++$i) {
      if ($i == 2)
          continue
      print "$i\n";
  }
?>
]]>
      </programlisting>
      <para>
       On peut s'attendre à ce que le résultat soit :
      </para>
      <screen>
<![CDATA[
0
1
3
4
]]>
      </screen>
      <para>
       mais ce script affichera :
      </para>
      <screen>
<![CDATA[
2
]]>
      </screen>
      <para>
       car la valeur de retour de l'appel à <function>print</function>
       est <literal>int(1)</literal>, et cela se comportera alors comme si
       on avait fournit l'argument optionnel mentionné plus haut.
      </para>
     </example>
    </para>
  </sect1>

  <sect1 id="control-structures.switch">
   <title><literal>switch</literal></title>
   <simpara>
    L'instruction <literal>switch</literal> équivaut
    à une série d'instructions <literal>if</literal>.
    En de nombreuses occasions, vous aurez besoin de comparer
    la même variable (ou expression) avec un grand nombre
    de valeurs différentes, et d'exécuter
    différentes parties de code suivant la valeur
    à laquelle elle est égale. C'est exactement
    à cela que sert l'instruction <literal>switch</literal>.
   </simpara>
   <note>
    <simpara>
     Notez que contrairement à d'autres langages, la structure
     <link linkend="control-structures.continue">continue</link> s'applique
     aux structures <literal>switch</literal> et de comporte différemment de
     <literal>break</literal>.
     Si vous avez un <literal>switch</literal> dans une boucle, et que vous
     souhaitez continuer jusqu'à la prochaine itération de la boucle
     extérieure, vous vous devez utiliser <literal>continue 2</literal>.
    </simpara>
   </note>
   <para>
    Les deux exemples suivants sont deux manières
    différentes d'écrire la même chose,
    l'une en utilisant une séries de <literal>if</literal>,
    et l'autre en utilisant l'instruction <literal>switch</literal> :
    <example>
     <title>Instruction <literal>switch</literal></title>
     <programlisting role="php">
<![CDATA[
<?php
if ($i == 0) {
    echo "i égale 0";
} elseif ($i == 1) {
    echo "i égale 1";
} elseif ($i == 2) {
    echo "i égale 2";
}

switch ($i) {
case 0:
    echo "i égale 0";
    break;
case 1:
    echo "i égale 1";
    break;
case 2:
    echo "i égale 2";
    break;
}
?>
]]>
     </programlisting>
    </example>
    <example>
     <title>Instruction <literal>switch</literal> utilisant une chaîne de caractères</title>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i) {
case "tarte":
    echo "i est une tarte";
    break;
case "barre":
    echo "i est une barre";
    break;
case "gateau":
    echo "i est un gateau";
    break;
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Il est important de comprendre que l'instruction
    <literal>switch</literal> exécute chacune des
    clauses dans l'ordre. L'instruction <literal>switch</literal>
    est exécutée ligne par ligne. Au début,
    aucun code n'est exécuté. Seulement
    lorsqu'un <literal>case</literal> est vérifié,
    &php; exécute alors les instructions correspondantes.
    &php; continue d'exécuter les instructions jusqu'à
    la fin du bloc d'instructions du <literal>switch</literal>,
    ou bien dès qu'il trouve l'instruction <literal>break</literal>.
    Si vous ne pouvez pas utiliser l'instruction
    <literal>break</literal> à la fin de l'instruction
    <literal>case</literal>, &php; continuera à exécuter
    toutes les instructions qui suivent. Par exemple :
    <example>
     <title>Instruction <literal>switch</literal> et <literal>fall through</literal></title>
     <programlisting role="php">
 <![CDATA[
<?php
switch ($i) {
case 0 :
    echo "i égale 0";
case 1 :
    echo "i égale 1";
case 2 :
    echo "i égale 2";
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Dans cet exemple, si <varname>$i</varname> est égal à 0, &php; va
    exécuter quand même toutes les instructions qui
    suivent! Si <varname>$i</varname> est égal à 1, &php; exécutera
    les deux dernières instructions. Et seulement si <varname>$i</varname> est
    égal à 2, vous obtiendrez le résultat
    escompté, c'est-à-dire, l'affiche de
    "i égal 2". Donc, l'important est de ne pas oublier
    l'instruction <literal>break</literal> (même s'il est
    possible que vous l'omettiez dans certaines circonstances).
   </simpara>
   <simpara>
    Dans une commande <literal>switch</literal>, une condition n'est
    évaluée qu'une fois, et le résultat est
    comparé à chaque <literal>case</literal>.
    Dans une structure <literal>elseif</literal>, les conditions sont
    évaluées à chaque comparaison. Si votre
    condition est plus compliquée qu'une simple
    comparaison, ou bien fait partie d'une boucle,
    <literal>switch</literal> sera plus rapide.
   </simpara>
   <para>
    La liste de commandes d'un <literal>case</literal> peut
    être vide, auquel cas &php; utilisera la liste de
    commandes du cas suivant.
    <example>
     <title>Instruction <literal>switch</literal> et cas vide</title>
     <programlisting role="php">
 <![CDATA[
<?php
switch ($i) {
case 0:
case 1:
case 2:
    echo "i est plus petit que 3 mais n'est pas négatif";
    break;
case 3 :
    echo "i égale 3";
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Un <literal>case</literal> spécial est
    <literal>default</literal>. Ce cas est utilisé lorsque tous
    les <literal>case</literal> ont échoués. Il doit
    être le dernier cas listé. Par exemple :
    <example>
     <title>Instruction <literal>switch</literal> et <literal>default</literal></title>
     <programlisting role="php">
 <![CDATA[
<?php
switch ($i) {
case 0:
    echo "i égale 0";
    break;
case 1:
    echo "i égale 1";
    break;
case 2:
    echo "i égale  2";
    break;
default:
    echo "i n'est ni égal à 2, ni à 1, ni à 0.";
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Une autre chose à mentionner est que la valeur du
    <literal>case</literal> peut être toute expression de
    type scalaire, c'est-à-dire nombre entier, nombre
    à virgule flottante et chaîne de caractères.
    Les tableaux sont sans intérêt dans ce contexte-là.
   </para>
   <para>
    La syntaxe alternative pour cette structure de contrôle est
    la suivante :  pour plus d'informations, voir
    <link linkend="control-structures.alternative-syntax">syntaxes alternatives</link>).
    <example>
     <title>Instruction <literal>switch</literal> alternative</title>
     <programlisting role="php">
 <![CDATA[
<?php
switch ($i):
case 0:
    echo "i égale 0";
    break;
case 1:
    echo "i égale 1";
    break;
case 2:
    echo "i égale 2";
    break;
default:
    echo "i n'est ni égal à 2, ni à 1, ni à 0";
endswitch;
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect1>

  <sect1 id="control-structures.declare">
   <title><literal>declare</literal></title>
   <para>
    L'élément de langage <literal>declare</literal> sert à ajouter des
    directives d'exécutions dans un bloc de code. La syntaxe de
    <literal>declare</literal> est similaire à la syntaxe des autres
    fonctions de contrôle :
    <example>
     <title>Instruction <literal>directive</literal></title>
     <programlisting>
 <![CDATA[
<?php
declare (directive)
  statement
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    L'expression <literal>directive</literal> permet de contrôler l'intervention
    du bloc <literal>declare</literal>. Actuellement, une seule directive
    est reconnue : la directive <literal>ticks</literal> (Voir plus bas pour plus
    de détails) sur les <link linkend="control-structures.declare.ticks">ticks</link>).
   </para>
   <para>
    L'expression <literal>statement</literal> du bloc de
    <literal>declare</literal> sera exécutée. Comment elle sera exécutée,
    et quels effets cela aura dépend de la directive utilisée dans le bloc
    <literal>directive</literal>.
   </para>
   <para>
    La structure <literal>declare</literal> peut aussi être utilisée
    dans le contexte global. Elle affecte alors tout le code qui la suit :
    <example>
     <title>Instruction <literal>directive</literal> en contexte global</title>
     <programlisting role="php">
<![CDATA[
<?php
// Ces déclaration sont identiques.

// Vous pouvez utiliser ceci
declare(ticks=1) {
    // script entier ici
}

// ou ceci
declare(ticks=1);
// script entier ici
?>
]]>
     </programlisting>
    </example>
   </para>
   <sect2 id="control-structures.declare.ticks">
    <title>Ticks</title>
    <para>
     Un tick est un événement qui intervient toutes les
     <varname>N</varname> commandes bas niveau, exécutées par l'analyseur
     dans le bloc de <literal>declare</literal>.
     La valeur de <varname>N</varname> est spécifiée avec la syntaxe
     <literal>ticks=<varname>N</varname></literal>
     dans le bloc de directive <literal>declare</literal>.
    </para>
    <para>
     Un événement qui intervient à chaque tick est spécifié avec la fonction
     <function>register_tick_function</function>. Reportez-vous à l'exemple
     ci-dessous pour plus de détails. Notez que plus d'un événement peut
     intervenir par tick.
    </para>
    <para>
     <example>
      <title>Profiler une section de code &php;</title>
      <programlisting role="php">
<![CDATA[
<?php
// Un fonction qui enregistre l'heure à laquelle elle est appelée
function profile($dump = FALSE){
    static $profile;
    // Retourne les horaires stockés dans le profile, et l'efface
    if ($dump) {
        $temp = $profile;
        unset($profile);
        return($temp);
    }
    $profile[] = microtime ();
}

// Enregistre un gestionnaire de tick
register_tick_function("profile");

// Initialise la fonction avant le bloc de déclaration
profile();

// Exécute un bloc de code, et appele un tick toutes les deux secondes
declare (ticks=2) {
    for ($x = 1; $x < 50; ++$x) {
        echo similar_text(md5($x), md5($x*$x)), "<br />";
    }
}

// Affiche les données de la variable $profile
print_r(profile(TRUE));
?>
]]>
      </programlisting>
     </example>
     Cet exemple profile le code &php; dans le bloc de déclaration,
     et enregistre l'heure de chaque commande bas niveau. Cette
     information peut être réutilisée pour débusquer les segments
     de code lents. Vous pouvez implémenter d'autres méthodes, mais
     les ticks sont plus rapides et plus efficaces.
   </para>
   <simpara>
    Les ticks sont bien pratiques pour déboguer, implémenter un
    multi-tâches simple, des entrées sorties en tâche de
    fond, ou bien d'autres choses, avec &php;.
   </simpara>
   <simpara>
    Voir aussi
     <function>register_tick_function</function> et
    <function>unregister_tick_function</function>.
   </simpara>
   </sect2>
  </sect1>

  <sect1 id="function.return">
   <title><function>return</function></title>
   <simpara>
    Si appelée depuis une fonction, la commande <function>return</function>
    termine immédiatement la fonction, et retourne l'argument qui lui
    est passé. <function>return</function> interrompt aussi l'exécution
    de commande <function>eval</function> ou de scripts.
   </simpara>
   <simpara>
    Si appelée depuis l'environnement global, l'exécution du script
    est interrompue. Si le script courant était
    <function>include</function> ou <function>require</function>,
    alors le contrôle est rendu au script appelant, et la valeur
    retournée sera utilisée comme résultat de la fonction
    <function>include</function>. Si <function>return</function> est
    appelée depuis le script principal, alors l'exécution du script
    s'arrête. Si le script courant est
    <link linkend="ini.auto-prepend-file"><option>auto_prepend_file</option></link> ou
    <link linkend="ini.auto-append-file"><option>auto_append_file</option></link>
    dans le fichier &php.ini;, alors l'exécution du script
    s'arrête.
   </simpara>
   <simpara>
    Pour plus d'informations, voyez
    <link linkend="functions.returning-values">retourner des valeurs</link>.
   </simpara>
   <para>
    <note>
     <simpara>
      Notez que puisque <function>return</function> est une structure de langage
      et non pas une fonction, les parenthèses <emphasis>ne sont pas</emphasis> requises :
      en fait, il est classique de les ignorer, même si cela ne change rien.
     </simpara>
    </note>
   </para>
  </sect1>

  <sect1 id="function.require">
   <title><function>require</function></title>

   <simpara>
    <function>require</function> inclut et exécute un
    fichier &php;.
   </simpara>
   <simpara>
    La commande <function>require</function> se remplace elle-même
    par le contenu du fichier spécifié, tel que
    décrit dans la documentation de la fonction <function>include</function>.
   </simpara>
   <simpara>
    <function>require</function> et <function>include</function>
    sont identiques, sauf dans leur façon de gérer les erreurs.
    <function>include</function> produite une
    <link linkend="internal.e-warning">Alerte (<literal>warning</literal>)</link> tandis
    que <function>require</function> génère une
    <link linkend="internal.e-error">erreur fatale</link>. En
    d'autres termes, n'hésitez pas à utiliser
    <function>require</function> si vous voulez qu'un fichier
    d'inclusion manquant interrompe votre script.
    <function>include</function> ne se comporte pas de cette façon,
    et le script continuera son exécution. Assurez-vous d'avoir
    bien configuré le
    <link linkend="ini.include-path"><option>include_path</option></link> aussi.
   </simpara>
   <para>
    <example>
     <title>Exemples avec <function>require</function></title>
     <programlisting role="php">
<![CDATA[
<?php

require 'prepend.php';

require $un_fichier;

require ('un_fichier.txt');

?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Voyez la documentation de la fonction <function>include</function> pour plus
    d'exemples.
   </simpara>
   <para>
    <note>
     <simpara>
      Avant &php; 4.0.2, ceci s'appliquait : <function>require</function> tentait
      de lire le fichier cible, même si les lignes n'étaient pas utilisées.
      Une condition if n'avait aucun effet sur <function>require</function>. Cependant,
      si la ligne du <function>require</function> n'est jamais utilisée,
      le code inclus ne le sera pas non plus. De même, les boucles n'ont pas
      d'effet sur le comportement de <function>require</function>. Bien que le
      code contenu dans le fichier subit la boucle, la fonction elle même
      <function>require</function> n'est appelée qu'une fois.
     </simpara>
    </note>
   </para>

   &note.language-construct;

   &warn.no-win32-fopen-wrapper;

   <simpara>
    Voir aussi
    <function>include</function>,
    <function>require_once</function>,
    <function>include_once</function>,
    <function>eval</function>,
    <function>file</function>,
    <function>readfile</function>,
    <function>virtual</function> et
    <link linkend="ini.include-path">include_path</link>.
   </simpara>
  </sect1>

  <sect1 id="function.include">
   <title><function>include</function></title>
   <simpara>
    La fonction <function>include</function> inclut et exécute
    le fichier spécifié en argument.
   </simpara>
   <simpara>
    Cette documentation s'applique aussi à la fonction
    <function>require</function>. Les deux structures de
    langage sont identiques, hormis dans leur gestion des
    erreurs.
    <function>include</function> produit une
    <link linkend="internal.e-warning">Alerte (<literal>warning</literal>)</link> tandis
    que <function>require</function> génère une
    <link linkend="internal.e-error">erreur fatale</link>. En
    d'autres termes, n'hésitez pas à utiliser
    <function>require</function> si vous voulez qu'un fichier
    d'inclusion manquant interrompe votre script.
    <function>include</function> ne se comporte pas de cette façon,
    et le script continuera son exécution. Assurez-vous d'avoir
    bien configuré le <link linkend="ini.include-path"><option>include_path</option></link>
    aussi. Soyez prévenus qu'une erreur d'analyse dans un fichier
    inclut ne cause pas l'arrêt du script.
   </simpara>
   <simpara>
    Les fichiers à inclure sont d'abord recherchés dans le dossier
    désigné par <option>include_path</option>, relativement au dossier
    courant, puis dans <option>include_path</option>, relativement au dossier
    de travail du script. Par exemple, si <option>include_path</option>
    est <literal>.</literal>, que le dossier de travail est
    <filename class="directory">/www/</filename>, et que vous incluez le fichier
    <filename>include/a.php</filename> et qu'il y a une instruction
    <literal>include "b.php"</literal> dans ce fichier, alors
    <filename>b.php</filename> est d'abord recherché dans
    <filename class="directory">/www/</filename>, puis dans
    <filename class="directory">/www/include/</filename>.
    Si le nom du fichier commence par <literal>../</literal>, il est cherché uniquement
    dans l'<option>include_path</option> relatif au dossier courant d'exécution.
   </simpara>
   <simpara>
    Lorsqu'un fichier est inclus, le code le composant hérite de la
    <link linkend="language.variables.scope">portée des variables </link>
    de la ligne où l'include apparaît. Toutes les variables disponibles à cette ligne
    dans le fichier appelant seront disponibles dans le fichier appelé, à partir
    de ce point.
   </simpara>
   <para>
     <example>
      <title>Exemple avec <function>include</function></title>
      <programlisting role="php">
<![CDATA[
vars.php
<?php

$couleur = 'verte';
$fruit = 'pomme';

?>

test.php
<?php

echo "Une $couleur $fruit"; // Une

include 'vars.php';

echo "Une $couleur $fruit"; // Une verte pomme

?>
]]>
      </programlisting>
     </example>
   </para>
   <simpara>
    Si l'inclusion intervient à l'intérieure d'une fonction,
    le code inclus sera alors considéré comme faisant partie de la
    fonction. Cela modifie donc le contexte de variables accessibles.
   </simpara>
   <para>
    <example>
    <title>Inclusion de fichiers dans une fonction</title>
     <programlisting role="php">
<![CDATA[
<?php

function foo() {
    global $couleur;

    include 'vars.php';

    echo "Une $couleur $fruit";
}

/* vars.php est dans le contexte de foo()    *
 * donc $fruit n'est pas dispnibles hors de  *
 * cette fonction. $couleur l'est, car c'est *
 * une variable globale                      */

foo();                      // Une verte pomme
echo "Une $couleur $fruit"; // Une verte

?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Il est important de noter que lorsqu'un fichier est
    <function>include</function> ou <function>require</function>,
    les erreurs d'analyse apparaîtront en HTML tout
    au début du fichier, et l'analyse du fichier
    parent ne sera pas interrompue. Pour cette raison, le code
    qui est dans le fichier doit être placé entre
    <link linkend="language.basic-syntax.phpmode">les balises
    habituelles de &php;</link>.
   </simpara>
   <simpara>
    Si les <link linkend="ini.allow-url-fopen">Gestionnaires d'URL</link>
    sont activés dans &php; (ce qui est le cas par défaut),
    vous pouvez localiser le fichier avec une URL (via HTTP ou
    bien avec un gestionnaire adapté : voir <xref linkend="wrappers"/>
    pour une liste des protocoles), au lieu d'un simple chemin
    local. Si le serveur distant interprète le fichier comme du code
    &php;, des variables peuvent être transmises au serveur distant
    via l'URL et la méthode GET. Ce n'est pas, à strictement
    parler, la même chose que d'hériter du contexte de variable.
    Le fichier inclus est en fait un script exécuté à distance,
    et son résultat est inclus dans le code courant.
   </simpara>
   &warn.no-win32-fopen-wrapper;
   <para>
    <example>
     <title>Utiliser <function>include</function> via HTTP</title>
     <programlisting role="php">
<![CDATA[
<?php

/* Cet exemple suppose que www.example.com est configuré pour traiter
 * les fichiers .php et non pas les fichiers .txt. De plus,
 * 'Work' signifie ici que les variables
 * $foo et $bar sont disponibles dans le fichier inclus
 */

// Ne fonctionne pas : file.txt n'a pas été traité par www.example.com comme du PHP
include 'http://www.example.com/file.txt?foo=1&bar=2';

// Ne fonctionne pas : le script cherche un fichier nommé
// 'file.php?foo=1&bar=2' sur le système local
include 'file.php?foo=1&bar=2';

// Réussi
include 'http://www.example.com/file.php?foo=1&bar=2';

$foo = 1;
$bar = 2;
include 'file.txt';  // OK.
include 'file.php';  // OK.
?>
]]>
     </programlisting>
    </example>
    Voir aussi
    <link linkend="features.remote-files">travailler avec les fichiers distants</link>,
    <function>fopen</function> et
    <function>file</function> pour des informations reliées.
   </para>
   <para>
    Comme <function>include</function> et <function>require</function>
    sont des structures du langage particulières, vous devez les
    placer dans un bloc s'ils sont placés dans un bloc conditionnel.
   </para>
   <para>
    <example>
     <title><function>include</function> et les conditions</title>
     <programlisting role="php">
<![CDATA[
<?php

// Ceci est FAUX et échouera
if ($condition)
    include $file;
else
    include $other;


// Ceci est CORRECT.
if ($condition) {
    include $file;
} else {
    include $other;
}

?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Gestion du retour : il est possible d'exécuter une commande
    <function>return</function> dans un fichier inclus pour en
    terminer le traitement et retourner au fichier appelant. De plus,
    il est possible de retourner des valeurs des fichiers inclus.
    Vous pouvez prendre et traiter la valeur retournée par la
    fonction, comme toute autre fonction. Ce n'est cependant pas possible
    lors de l'inclusion de fichier distant à moins que le fichier distant
    a des <link linkend="language.basic-syntax.phpmode">balises valides de
    début et de fin de script &php;</link> (comme avec les fichiers locaux).
    Vous pouvez déclarer les variables nécessaire dans ces tags et elles seront
    introduites à l'endroit où le fichier a été inclus.
   </simpara>
   <para>
    Comme <function>include</function> est une structure de langage particulière,
    les parenthèses ne sont pas nécessaires autour de l'argument. Faîtes attention
    lorsque vous comparez la valeur retournée.
    <example>
     <title>Comparaison de la valeur de retour d'un include</title>
     <programlisting role="php">
<![CDATA[
<?php
// ne fonctionne pas, évaluer comme include(('vars.php') == 'OK'), i.e. include('')
if (include('vars.php') == 'OK') {
    echo 'OK';
}

// fonctionne
if ((include 'vars.php') == 'OK') {
    echo 'OK';
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <note>
     <simpara>
      En &php; 3, le <function>return</function> n'est pas utilisable à moins que ce
      ne soit dans un bloc de fonction, auquel cas le
      <function>return</function> s'applique à une fonction et non
      pas au fichier.
     </simpara>
    </note>
   </para>
   <para>
    <example>
     <title><function>include</function> et <function>return</function></title>
      <programlisting role="php">
<![CDATA[
return.php
<?php

$var = 'PHP';

return $var;

?>

noreturn.php
<?php

$var = 'PHP';

?>

testreturns.php
<?php

$foo = include 'return.php';

echo $foo; // affiche 'PHP'

$bar = include 'noreturn.php';

echo $bar; // affiche 1

?>
]]>
      </programlisting>
    </example>
   </para>
   <simpara>
    <literal>$bar</literal> a la valeur de &one; car
    l'inclusion était réussie. Notez la différence entre les deux
    exemples ci-dessus. Le premier utilise la commande <function>return</function>
    dans le fichier inclus, alors que le second ne le fait pas.
    Si le fichier ne peut être inclus, &false; est retourné et une erreur
    de niveau <literal>E_WARNING</literal> est envoyée.
   </simpara>
   <para>
    S'il y a des fonctions de définies dans le fichier inclus, elles peuvent être
    utilisées dans le fichier principal si elles sont avant le <function>return</function>
    ou après. Si le fichier est inclus deux fois, &php; 5 enverra une erreur fatale car
    les fonctions seront déjà déclarées, tandis que &php; 4 ne se plaindra pas 
    des fonctions définies après <function>return</function>.
    Il est recommandé d'utiliser <function>include_once</function> au lieu de vérifier
    si le fichier a déjà été inclus et donc de retourner conditonnellement l'inclusion du fichier.
   </para>
   <simpara>
    Un autre moyen d'inclure des fichiers dans des variables
    est d'utiliser la fonction <function>fopen</function> ou
    <function>file</function> ou d'utiliser
    <function>include</function> avec les
    <link linkend="ref.outcontrol">fonctions de contrôle de sortie</link>.
   </simpara>

   &note.language-construct;

   <simpara>
    Voir aussi
    <function>require</function>,
    <function>require_once</function>,
    <function>include_once</function>,
    <function>readfile</function>,
    <function>virtual</function> et
    <link linkend="ini.include-path">include_path</link>.
   </simpara>
   </sect1>

  <sect1 id="function.require-once">
   <title><function>require_once</function></title>
   <para>
    La commande <function>require_once</function> se remplace elle-même
    par le fichier spécifié, un peu comme les commandes de
    préprocesseur C <literal>#include</literal>, et ressemble sur
    ce point à <function>require</function>. La principale
    différence est qu'avec <function>require_once</function>,
    vous êtes assurés que ce code ne sera ajouté
    qu'une seule fois, évitant de ce fait les redéfinitions de
    variables ou de fonctions, génératrices d'alertes.
   </para>
   <para>
    <function>require_once</function> doit être utilisée dans les cas
    où le même fichier risque d'être inclus et évalué plusieurs fois
    durant l'exécution d'un script. Vous serez alors sûrs qu'il ne sera inclus qu'une fois
    et vous éviterez les problèmes de re-déclarations de fonctions ou autres.
   </para>
   <para>
    Pour des exemples avec <function>require_once</function> et
    <function>include_once</function>, reportez-vous au code
    <ulink url="&url.php.pear;">PEAR</ulink> inclus dans les
    dernières distributions &php;.
   </para>
   <para>
    Les valeurs retournées sont les mêmes que lors de l'utilisation de
    <function>include</function>. Si le fichier a déjà été inclus, cette fonction
    retourne &true;.
   </para>
   <para>
    <note>
     <para>
      <function>require_once</function> a été ajouté en &php; 4.0.1pl2
     </para>
    </note>
   </para>
   <para>
    <note>
     <para>
      Attention, <function>require_once</function> et
      <function>include_once</function> sont insensibles à la casse
      sous les systèmes comme Windows.
      <example>
       <title><function>require_once</function> est insensible à la casse sur Windows</title>
       <programlisting role="php">
<![CDATA[
require_once("a.php"); // ceci inclut le fichier a.php
require_once("A.php"); // ceci inclut encore le fichier a.php sous Windows! (uniquement en PHP 4)
]]>
       </programlisting>
      </example>
      Ce comportement a changé en &php; 5 - le chemin est normalisé d'abord, donc,
      le fichier <filename>C:\PROGRA~1\A.php</filename> est reconnu
      comme étant identique au fichier
      <filename>C:\Program Files\a.php</filename> et le fichier ne sera
      requis qu'une seule fois.
     </para>
    </note>
   </para>
   &warn.no-win32-fopen-wrapper;
   <para>
    Voir aussi
    <function>require</function>,
    <function>include</function>,
    <function>include_once</function>,
    <function>get_required_files</function>,
    <function>get_included_files</function>,
    <function>readfile</function> et
    <function>virtual</function>.
   </para>
  </sect1>

  <sect1 id="function.include-once">
   <title><function>include_once</function></title>
   <para>
    La commande <function>include_once</function> inclut et
    évalue le fichier spécifié durant
    l'exécution du script. Le comportement est similaire à
    <function>include</function>, mais la différence est que si
    le code a déjà été inclus, il ne le
    sera pas une seconde fois.
   </para>
   <para>
    La fonction <function>include_once</function> est utilisée de
    préférence lorsque le fichier doit être
    inclus ou évalué plusieurs fois dans un script,
    ou bien lorsque vous voulez être sûr qu'il ne sera inclus
    qu'une seule fois, pour éviter des redéfinitions
    de fonction.
   </para>
   <para>
    Pour plus d'exemples avec <function>require_once</function> et
    <function>include_once</function>, jetez un oeil dans le code de PEAR
    inclus dans la dernière distribution de &php;.
   </para>
   <para>
    Les valeurs retournées sont les mêmes que lors de l'utilisation de
    <function>include</function>. Si le fichier a déjà été inclus, cette fonction
    retourne &true;.
   </para>
   <para>
    <note>
     <para>
      <function>include_once</function> a été ajouté en &php; 4.0.1pl2
     </para>
    </note>
   </para>
   <para>
    <note>
     <para>
      Attention, <function>require_once</function> et
      <function>include_once</function> sont insensibles à la casse
      sous les systèmes comme Windows.
      <example>
       <title>
        <function>include_once</function> est insensible à la casse sous Windows
       </title>
       <programlisting role="php">
<![CDATA[
<?php
include_once("a.php"); // ceci inclut le fichier a.php
include_once("A.php"); // ceci inclut encore le fichier a.php sous Windows! (uniquement en PHP 4)
?>
]]>
       </programlisting>
      </example>
      Ce comportement a changé en &php; 5 - le chemin est normalisé d'abord, donc,
      le fichier <filename>C:\PROGRA~1\A.php</filename> est reconnu
      comme étant identique au fichier
      <filename>C:\Program Files\a.php</filename> et le fichier ne sera
      inclus qu'une seule fois.
     </para>
    </note>
   </para>
   &warn.no-win32-fopen-wrapper;
   <para>
    Voir aussi
    <function>require</function>,
    <function>include</function>,
    <function>require_once</function>,
    <function>get_required_files</function>,
    <function>get_included_files</function>,
    <function>readfile</function> et
    <function>virtual</function>.
   </para>
  </sect1>

 </chapter>
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
indent-tabs-mode:nil
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
