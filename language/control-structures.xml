 <chapter id="control-structures">
  <title>Les structures de contr&ocirc;le</title>
  <simpara>
    Tous les scripts PHP sont une suite d'instructions. Une instruction
    peut &ecirc;tre une assignation, un appel de fonction, une instruction
    conditionnelle ou bien une instruction qui ne fait rien (une instruction
    vide). Une instruction se termine habituellement par un point virgule
    (";"). De plus, plusieurs instructions peuvent &ecirc;tre
    regroup&eacute;es en bloc, d&eacute;limit&eacute; par des
    accolades ("{}"). Un bloc est consid&eacute;r&eacute; comme une instruction.
    Les diff&eacute;rents types d'instruction sont d&eacute;crits dans ce
    chapitre.
  </simpara>
  <sect1 id="control-structures.if">
   <title><literal>if</literal></title>
   <para>
    L'instruction <literal>if</literal> est une des plus importantes
    instructions de tous les langages, PHP inclus. Elle permet
    l'ex&eacute;cution conditionnelle d'une partie de code. Les
    fonctionnalit&eacute;s de l'instruction <literal>if</literal>
    sont les m&ecirc;mes en PHP qu'en C :
    <informalexample>
     <programlisting role="php">
&lt;?php
if (expression)
    commandes
?&gt;
     </programlisting>
    </informalexample>
   </para>
   <simpara>
     Comme nous l'avons vu dans le paragraphe consacr&eacute; aux expressions,
     <replaceable>expr</replaceable> est &eacute;valu&eacute;e &agrave;
     sa vraie valeur. Si l'expression <replaceable>expr</replaceable> est
     <literal>TRUE</literal>, PHP ex&eacute;cutera l'instruction et si elle
     est <literal>FALSE</literal>, l'instruction sera ignor&eacute;e.
   </simpara>
   <para>
     L'exemple suivant affiche la phrase <computeroutput>a est plus grand
     que b</computeroutput> si <replaceable>$a</replaceable> est plus grand
     que <replaceable>$b</replaceable>:
    <informalexample>
     <programlisting role="php">
&lt;?php
if ($a > $b)
    print "a est plus grand que b";
?&gt;
     </programlisting>
    </informalexample>
   </para>
   <para>
    Souvent, vous voulez que plusieurs instructions soient
    ex&eacute;cut&eacute;es apr&egrave;s un branchement conditionnel. Bien
    &eacute;videmment, il n'est pas obligatoire de r&eacute;p&eacute;ter
    l'instruction conditonnelle autant de fois que vous avez d'instructions
    &agrave; ex&eacute;cuter. A la place, vous pouvez rassembler toutes les
    instructions dans un bloc. L'exemple suivant affiche <computeroutput>a
    est plus grand que b</computeroutput>, et assigne la valeur de la
    variable <replaceable>$a</replaceable> &agrave; la variable
    <replaceable>$b</replaceable>:
    <informalexample>
     <programlisting role="php">
&lt;?php
if ($a > $b) {
    print "a est plus grand que b";
    $b = $a;
}
?&gt;
     </programlisting>
    </informalexample>
   </para>
   <simpara>
      Vous pouvez imbriquer ind&eacute;finiment des instructions
      <literal>if</literal> les unes dans les autres, ce qui permet
      une grande flexibilit&eacute; dans l'ex&eacute;cution d'une
      partie de code suivant un grand nombre de conditions.
   </simpara>
  </sect1>
  <sect1 id="control-structures.else">
   <title><literal>else</literal></title>
   <para>
      Souvent, vous voulez ex&eacute;cuter une instruction si une
      condition est remplie, et une autre instruction si cette condition
      n'est pas remplie. C'est &agrave; cela que sert <literal>else</literal>.
      <literal>else</literal> fonctionne avec apr&egrave;s un
      <literal>if</literal> et ex&eacute;cute les instructions
      correspondantes au cas o&uacute; l'expression du <literal>if</literal>
      est <literal>FALSE</literal>. Dans l'exemple suivant, ce bout de code
      affiche <computeroutput>a est plus grand que b</computeroutput> si la
      variable <replaceable>$a</replaceable> est plus grande que la variable
      <replaceable>$a</replaceable>, et <computeroutput>a est plus petit que b
      </computeroutput> sinon:
    <informalexample>
     <programlisting role="php">
&lt;?php
if ($a > $b) {
    print "a est plus grand que b";
} else {
    print "a est plus petit que b";
}
?&gt;
     </programlisting>
    </informalexample>
      Les instructions apr&egrave;s le <literal>else</literal> ne sont
      ex&eacute;cut&eacute;es que si l'expression du <literal>if</literal>
      est <literal>FALSE</literal>, et si elle n'est pas suivi par l'expression
      <literal>elseif</literal>.
   </para>
  </sect1>
  <sect1 id="control-structures.elseif">
   <title><literal>elseif</literal></title>
   <para>
      <literal>elseif</literal>, comme son nom l'indique, est une combinaison
      de <literal>if</literal> et <literal>else</literal>. Comme l'expression
      <literal>else</literal>, il permet d'ex&eacute;cuter une instruction
      apr&egrave; un <literal>if</literal> dans le cas o&uacute; le "premier"
      if est &eacute;valu&eacute; comme <literal>FALSE</literal>. Mais,
      &agrave; la diff&eacute;rence de l'expression <literal>else</literal>,
      il n'ex&eacute;cutera l'instruction que si l'expression condionnelle
      <literal>elseif</literal> est &eacute;valu&eacute;e comme
      <literal>TRUE</literal>. L'exemple suivant affichera
      <computeroutput>a est plus grand que b</computeroutput>,
      <computeroutput>a est &eacute;gal &agrave; b</computeroutput> ou
      <computeroutput>a est plus petit que b</computeroutput>:
    <informalexample>
     <programlisting role="php">
&lt;?php
if ($a > $b) {
    print "a est plus grand que b";
} elseif ($a == $b) {
    print "a est &eacute;gal &agrave; b";
} else {
    print "a est plus petit que b";
}
?&gt;
     </programlisting>
    </informalexample>
   </para>
   <simpara>
     Vous pouvez avoir plusieurs <literal>elseif</literal> qui s'imbriquent
     les uns dans les autres, apr&egrave;s un <literal>if</literal> initial.
     Le premier <literal>elseif</literal> qui sera &eacute;valu&eacute;
     &agrave; <literal>TRUE</literal> sera ex&eacute;cut&eacute;. En PHP, vous
     pouvez aussi &eacute;crire "else if" en deux mots et son comportement sera
     identique &agrave; la version en un seul mot.
   </simpara>
   <simpara>
      L'expression <literal>elseif</literal> est ex&eacute;cut&eacute;e
      seulement si le <literal>if</literal> pr&eacute;c&eacute;dent et tout
      autre <literal>elseif</literal> pr&eacute;c&eacute;dent est
      &eacute;valu&eacute;s comme <literal>FALSE</literal>, et que
      votre <literal>elseif</literal> est &eacute;valu&eacute; &agrave;
      <literal>TRUE</literal>.
   </simpara>
  </sect1>
  <sect1 id="control-structures.alternative-syntax">
   <title>Syntaxe alternative</title>
   <para>
      Le PHP propose une autre mani&egrave;re de rassembler des
      instructions &agrave; l'int&eacute;rieur d'un bloc, pour les
      fonctions de contr&ocirc;le <literal>if</literal>,
      <literal>while</literal>, <literal>for</literal>, et
      <literal>switch</literal>. Dans chaque cas, le principe
      est de remplacer l'accolade d'ouverture par deux points (:)
      et l'accolade de fermeture par, respectivement,
      <literal>endif;</literal>, <literal>endwhile;</literal>,
      <literal>endfor;</literal>, ou <literal>endswitch;</literal>.
    <informalexample>
     <programlisting role="php">
&lt;?php if ($a == 5): ?&gt;
 A vaut 5
&lt;?php endif; ?&gt;
     </programlisting>
    </informalexample>
   </para>
   <simpara>
     Dans l'exemple ci-desssus, le block HTML "A = 5" est inclus
     &agrave; l'int&eacute;rieur d'un <literal>if</literal> en
     utilisant cette nouvelle syntaxe. Ce code HTML ne sera
     affich&eacute; que si la variable $a est &eacute;gale &agrave; 5.
   </simpara>
   <para>
    Cette autre syntaxe fonctionne aussi avec le <literal>else</literal> et
    <literal>elseif</literal>. L'exemple suivant montre une structure avec un
    <literal>if</literal>, un <literal>elsif</literal> et un
    <literal>else</literal> utilisant cette autre syntaxe:
    <informalexample>
     <programlisting role="php">
&lt;?php
if ($a == 5):
    print "a &eacute;gale 5";
    print "...";
elseif ($a == 6):
    print "a &eacute;gale 6";
    print "!!!";
else:
    print "a ne vaut ni 5 ni 6";
endif;
?&gt;
     </programlisting>
    </informalexample>
   </para>
   <para>
    Allez voir <link linkend="control-structures.while">while</link>,
    <link linkend="control-structures.for">for</link>, et
    <link linkend="control-structures.if">if</link> pour d'autres exemples.
   </para>
  </sect1>
  <sect1 id="control-structures.while">
   <title><literal>while</literal></title>
   <para>
     La boucle <literal>while</literal> est le moyen le plus
     simple d'impl&eacute;menter une boucle en PHP. Cette boucle
     se comporte de la m&ecirc;me mani&egrave;re qu'en C.
     L'exemple le plus simple d'une boucle <literal>while</literal>
     est le suivant :
    <informalexample>
     <programlisting role="php">
&lt;?php
while (expression) commandes
?&gt;
     </programlisting>
    </informalexample>
   </para>
   <simpara>
     La signification d'une boucle <literal>while</literal> est
     tr&egrave;s simple. Le PHP ex&eacute;cute l'instruction tant
     que l'expression de la boucle <literal>while</literal> est
     &eacute;valu&eacute;e comme <literal>TRUE</literal>. La valeur
     de l'expression est v&eacute;rifi&eacute;e &agrave; chaque
     d&eacute;but de boucle, et, si la valeur change durant
     l'ex&eacute;cution de l'instruction, l'ex&eacute;cution ne
     s'arr&ecirc;tera qu'&agrave; la fin de l'it&eacute;ration
     (chaque fois que le PHP ex&eacute;cute l'instruction, on appelle
     cela une it&eacute;ration). De temps en temps, si l'expression du
     <literal>while</literal> est <literal>FALSE</literal> avant la
     premi&egrave;re it&eacute;ration, l'instruction ne sera jamais
     ex&eacute;cut&eacute;e.
   </simpara>
   <para>
     Comme avec le <literal>if</literal>, vous pouvez regrouper
     plusieurs instructions dans la m&ecirc;me boucle
     <literal>while</literal> en les regroupant &agrave; l'int&eacute;rieur
     de parenth&egrave;ses ou en utilisant la syntaxe suivante:
    <informalexample>
     <programlisting role="php">
&lt;?php
while (expression): commandes ... endwhile;
?&gt;
     </programlisting>
    </informalexample>
   </para>
   <para>
    Les exemples suivants sont identiques, et affichent tous les nombres
    de 1 &agrave; 10:
    <informalexample>
     <programlisting role="php">
&lt;?php
/* exemple 1 */
$i = 1;
while ($i <= 10) {
    print $i++;  /* La valeur affiche est $i avant l'incr&eacute;mentation
                     (post-incr&eacute;mentation)  */
}
/* exemple 2 */
$i = 1;
while ($i <= 10):
    print $i;
    $i++;
endwhile;
?&gt;
     </programlisting>
    </informalexample>
   </para>
  </sect1>
  <sect1 id="control-structures.do.while">
   <title><literal>do..while</literal></title>
   <simpara>
     Les boucles <literal>do..while</literal> ressemblent beaucoup
     aux boucles <literal>while</literal>, mais l'expression est
     test&eacute;e &agrave; la fin de chaque it&eacute;ration plut&ocirc;t
     qu'au d&eacute;but. La principale diff&eacute;rence par rapport
     &agrave; la boucle <literal>while</literal> est que la
     premi&egrave;re it&eacute;ration de la boucle
     <literal>do..while</literal> est toujours ex&eacute;cut&eacute;e
     (l'expression n'est test&eacute;e qu'&agrave; la fin de
     l'it&eacute;ration), ce qui n'est pas le cas lorsque vous
     utilisez une boucle <literal>while</literal> (l'expression
     est v&eacute;rifi&eacute;e au d&eacute;but de chaque it&eacute;ration).
   </simpara>
   <para>
    Il n'y a qu'un syntaxe possible pour les boucles <literal>do..while</literal>:
    <informalexample>
     <programlisting role="php">
&lt;?php
$i = 0;
do {
   print $i;
} while ($i>0);
?&gt;
     </programlisting>
    </informalexample>
   </para>
   <simpara>
     La boucle ci-dessus ne va &ecirc;tre ex&eacute;cut&eacute;e
     qu'une seule fois, car lorsque l'expression est
     &eacute;valu&eacute;e, elle vaut <literal>FALSE</literal> (car
     la variable $i n'est pas plus grande que 0) et l'ex&eacute;cution
     de la boucle s'arr&ecirc;te.
   </simpara>
   <para>
     Les utilisateurs familiers du C sont habitu&eacute;s &agrave;
     une utilisation diff&eacute;rente des boucles
     <literal>do..while</literal> , qui permet de stopper
     l'ex&eacute;cution de la boucle au milieu des instructions, en
     l'encapsulant dans un <literal>do..while</literal>(0) la
     fonction <link linkend="control-structures.break"><literal>break</literal></link>.
     Le code suivant montre une utilisation possible:
    <informalexample>
     <programlisting role="php">
&lt;?php
do {
    if ($i < 5) {
        print "i n'est pas suffisamment grand";
        break;
    }
    $i *= $factor;
    if ($i < $minimum_limit) {
        break;
    }
    print "i est bon";
     ...process i...
} while(0);
?&gt;
     </programlisting>
    </informalexample>
   </para>
   <simpara>
     Ne vous inqui&eacute;tez pas si vous ne comprenez
     pas tout correctement. Vous pouvez &eacute;crire des scripts
     tr&egrave;s tr&egrave;s puissants sans utiliser
     cette fonctionnalit&eacute;.
   </simpara>
  </sect1>
  <sect1 id="control-structures.for">
   <title><literal>for</literal></title>
   <para>
     Les boucles <literal>for</literal> sont les boucles les plus complexes en PHP.
     Elles fonctionnent comme les boucles <literal>for</literal> du langage C.
     La syntaxe des boucles for est la suivante:
    <informalexample>
     <programlisting role="php">
&lt;?php
for (expr1; expr2; expr3) statement
?&gt;
     </programlisting>
    </informalexample>
   </para>
   <simpara>
     La premi&egrave;re expression (<replaceable>expr1</replaceable>) est
     &eacute;valu&eacute;e (ex&eacute;cut&eacute;e), quoi qu'il arrive au
     d&eacute;but de la boucle.
   </simpara>
   <simpara>
     Au d&eacute;but de chaque it&eacute;ration, l'expression
     <replaceable>expr2</replaceable> est &eacute;valu&eacute;e.
     Si l'&eacute;valuation vaut <literal>TRUE</literal>, la boucle
     continue et l'instruction est ex&eacute;cut&eacute;e. Si
     l'&eacute;valuation vaut <literal>FALSE</literal>,
     l'ex&eacute;cution de la boucle s'arr&ecirc;te.
   </simpara>
   <simpara>
     A la fin de chaque it&eacute;ration, l'expression
     <replaceable>expr3</replaceable> est &eacute;valu&eacute;e
     (ex&eacute;cut&eacute;e).
   </simpara>
   <simpara>
      Les expressions peuvent &eacute;ventuellement &ecirc;tre
      laiss&eacute;es vides. Si l'expression <replaceable>expr2</replaceable>
      est laiss&eacute;e vide, cela signifie que c'est une boucle infinie
      (PHP consid&egrave;re implicitement qu'elle vaut <literal>TRUE</literal>, comme en C).
      Cela n'est pas vraiment tr&egrave;s utile, &agrave; moins que vous
      souhaitiez terminer votre boucle par l'instruction conditionnelle
      <link linkend="control-structures.break"><literal>break</literal></link>.
   </simpara>
   <para>
      Consid&eacute;rons les exemples suivants. Tous affichent les chiffres de
      1 &agrave; 10:
    <informalexample>
     <programlisting role="php">
&lt;?php
/* exemple 1 */
for ($i = 1; $i <= 10; $i++) {
    print $i;
}
/* exemple 2 */
for ($i = 1;;$i++) {
    if ($i > 10) {
        break;
    }
    print $i;
}
/* exemple 3 */
$i = 1;
for (;;) {
    if ($i > 10) {
        break;
    }
    print $i;
    $i++;
}
/* exemple 4 */
for ($i = 1; $i <= 10; print $i, $i++) ;
?&gt;
     </programlisting>
    </informalexample>
   </para>
   <simpara>
     Bien &eacute;videmment, le premier exemple est le plus simple
     de tous (ou peut &ecirc;tre le quatri&egrave;me), mais vous
     pouvez aussi pensez qu'utiliser une expression vide dans une
     boucle <literal>for</literal> peut &ecirc;tre utile parfois.
   </simpara>
   <para>
     PHP supporte aussi la syntaxe alternative suivante pour les boucles
     <literal>for</literal> :
    <informalexample>
     <programlisting role="php">
&lt;?php
for (expr1; expr2; expr3): statement; ...; endfor;
?&gt;
     </programlisting>
     </informalexample>
   </para>
   <para>
     Les autres langages ont l'instruction <literal>foreach</literal>
     pour acc&eacute;der aux &eacute;l&eacute;ments d'un tableau. PHP 3
     ne dispose pas d'une telle fonction; PHP 4 en dispose (voir
     <link linkend="control-structures.foreach">foreach</link>). En PHP 3,
     vous pouvez combiner <link linkend="control-structures.while">while</link>
     avec <function>list</function> et <function>each</function> pour
     obtenir le m&ecirc;me r&eacute;sultat. Reportez vous aux exemples
     de la documentation.
   </para>
  </sect1>
  <sect1 id="control-structures.foreach">
   <title><literal>foreach</literal></title>
   <para>
    PHP 4 (mais pas PHP 3) inclus une commande <literal>foreach</literal>,
    comme en Perl ou d'autres langages. C'est un moyen simple de passer
    en revue un tableau. Il y a deux syntaxes possibles : la seconde est
    une extension mineure mais pratique de la premi&egrave;re:
    <informalexample>
     <programlisting role="php">
&lt;?php
foreach(array_expression as $value) commandes
foreach(array_expression as $key => $value) commandes
?&gt;
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    La premi&egrave;re forme passe en revue le tableau
    <literal>array_expression</literal>. A chaque it&eacute;ration,
    la valeur de l'&eacute;l&eacute;ment courant est assign&eacute; &agrave;
    <literal>$value</literal> et le pointeur interne de tableau est
    avanc&eacute; d'un &eacute;l&eacute;ment (ce qui fait qu'&agrave;
    la procha&icirc;ne it&eacute;ration, on acc&eacute;dera &agrave;
    l'&eacute;l&eacute;ment suivant).
   </simpara>
   <simpara>
     La deuxi&egrave;me forme fait exactement la m&ecirc;me chose, mais
     c'est la cl&eacute; de l'&eacute;l&eacute;ment courant qui est
     assign&eacute; &agrave; la variable <literal>$key</literal>.
   </simpara>
   <simpara>
    Lorsque <literal>foreach</literal> d&eacute;mare, le pointeur interne
    de fichier est automatiquement ramen&eacute; au premier
    &eacute;l&eacute;ment du tableau. Cela signifie que vous n'aurez
    pas &agrave; faire appel &agrave; <function>reset</function> avant
    <literal>foreach</literal>.
   </simpara>
   <para>
    Vous pouvez remarquer que les exemples suivants fonctionnent de
    mani&egrave;re identique :
    <informalexample>
     <programlisting role="php">
reset ($arr);
while (list(, $value) = each ($arr)) {
    echo "Valeur: $value&lt;br&gt;\n";
}
foreach ($arr as $value) {
    echo "Valeur: $value&lt;br&gt;\n";
}
     </programlisting>
    </informalexample>
Les exemples suivants sont aussi fonctionnellement identiques :
    <informalexample>
     <programlisting role="php">
reset ($arr);
while (list($key, $value) = each ($arr)) {
    echo "Cl&eacute;: $key; Valeur: $value&lt;br&gt;\n";
}
foreach ($arr as $key => $value) {
    echo "Cl&eacute;: $key; Valeur: $value&lt;br&gt;\n";
}
     </programlisting>
    </informalexample>
   </para>
   <para>
    Voici quelques exemples de plus :
    <informalexample>
     <programlisting role="php">
&lt;?php
/* exemple 1: valeur seule */
$a = array (1, 2, 3, 17);
foreach ($a as $v) {
   print "Valeur courante de \$a: $v.\n";
}
/* exemple 1: valeur (avec cl&eacute; associ&eacute;e) */
$a = array (1, 2, 3, 17);
$i = 0; /* pour affichage seulement*/
foreach($a as $v) {
    print "\$a[$i] => $k.\n";
}
/* exemple 1: valeur et cl&eacute; */
$a = array (
    "un" => 1,
    "deux" => 2,
    "trois" => 3,
    "dix-sept" => 17
);
foreach($a as $k => $v) {
    print "\$a[$k] => $v.\n";
}
?&gt;
     </programlisting>
    </informalexample>
   </para>
  </sect1>
  <sect1 id="control-structures.break">
   <title><literal>break</literal></title>
   <simpara>
     L'instruction <literal>break</literal> permet de sortir d'une structure
     <literal>if</literal>, <literal>for</literal>, <literal>while</literal>, ou
     <literal>switch</literal>.
   </simpara>
   <simpara>
    <literal>break</literal> accepte un argument num&eacute;rique optionnel
    qui vous indiquera combien de structures embo&icirc;t&eacute;es ont
    &eacute;t&eacute; interrompues.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
&lt;?php
$i = 0;
while ($i < 10) {
    if ($arr[$i] == "stop") {
        break;  /* Vous pouvez aussi &eacute;crire 'break 1;' ici. */
    }
    $i++;
}
/* Utilisation de l'argument optionnel. */
$i = 0;
while ( ++$i ) {
    switch ( $i ) {
    case 5:
        echo "&agrave; 5&lt;br&gt;\n";
        break 1;  /* Ne sort que du switch. */
    case 10:
        echo "&agrave; 10; quitting&lt;br&gt;\n";
        break 2;  /* Sort du switch et du while. */
    default:
        break;
    }
}
?&gt;
     </programlisting>
    </informalexample>
   </para>
  </sect1>
  <sect1 id="control-structures.continue">
   <title><literal>continue</literal></title>
   <simpara>
     L'instruction <literal>continue</literal> est utilis&eacute;e
     dans une boucle afin d'&eacute;luder les instructions de
     l'it&eacute;ration courante afin de passer directement &agrave;
     l'it&eacute;ration suivante.
   </simpara>
   <simpara>
    <literal>continue</literal> accepte un argument num&eacute;rique
    optionnel qui vous indiquera combien de structures
    embo&icirc;t&eacute;es ont &eacute;t&eacute; ignor&eacute;es.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
while (list ($cle, $valeur) = each ($arr)) {
   if (!($cle % 2)) { // &eacute;vite les membres impairs
       continue;
   }
   fonction_quelconque($valeur);
}
$i = 0;
while ($i++ &lt; 5) {
    echo "Dehors&lt;br&gt;\n";
    while (1) {
        echo "&nbsp;&nbsp;Milieu&lt;br&gt;\n";
        while (1) {
             echo "&nbsp;&nbsp;Int&eacute;rieur&lt;br&gt;\n";
             continue 3;
        }
        echo "Ceci n'est jamais atteint.&lt;br&gt;\n";
    }
    echo "Ceci non plus.&lt;br&gt;\n";
}
     </programlisting>
     </informalexample>
    </para>
  </sect1>
  <sect1 id="control-structures.switch">
   <title><literal>switch</literal></title>
   <simpara>
      L'instruction <literal>switch</literal> &eacute;quivaut
      &agrave; une s&eacute;rie d'instructions <literal>if</literal>.
      En de nombreuses occasions, vous aurez besoin de comparer
      la m&ecirc;me variable (ou expression) avec un grand nombre
      de valeurs diff&eacute;rentes, et d'ex&eacute;cuter
      diff&eacute;rentes parties de code suivant la valeur
      &agrave; laquelle elle est &eacute;gale. C'est exactement
      &agrave; cela que sert l'instruction <literal>switch</literal>.
   </simpara>
   <para>
     L4es deux exemples suivants sont deux mani&egrave;res
     diff&eacute;rentes d'&eacute;crire la m&ecirc;me chose,
     l'une en utilisant une s&eacute;ries de <literal>if</literal>,
     et l'autre en utilisant l'instruction <literal>switch</literal>:
    <informalexample>
     <programlisting role="php">
if ($i == 0) {
    print "i &eacute;gale 0";
}
if ($i == 1) {
    print "i &eacute;gale 1";
}
if ($i == 2) {
    print "i &eacute;gale 2";
}
switch ($i) {
    case 0:
        print "i &eacute;gale 0";
        break;
    case 1:
        print "i &eacute;gale 1";
        break;
    case 2:
        print "i &eacute;gale 2";
        break;
}
     </programlisting>
    </informalexample>
   </para>
   <para>
     Il est important de comprendre que l'instruction
     <literal>switch</literal> ex&eacute;cute chacune des
     clauses dans l'ordre. L'instruction <literal>switch</literal>
     est ex&eacute;cut&eacute;e ligne par ligne. Au d&eacute;but,
     aucun code n'est ex&eacute;cut&eacute;. Seulement
     lorsqu'un <literal>case</literal> est v&eacute;rifi&eacute;,
     PHP ex&eacute;cute alors les instructions correspondantes.
     PHP continue d'ex&eacute;cuter les instructions jusqu'&agrave;
     la fin du bloc d'instructions du <literal>switch</literal>,
     ou bien d&egrave;s qu'il trouve l'instruction <literal>break</literal>.
     Si vous ne pouvez pas utiliser l'instruction
     <literal>break</literal> &agrave; la fin de l'instruction
     <literal>case</literal>, PHP continuera &agrave; ex&eacute;cuter
     toutes les instructions qui suivent. Par exemple :
    <informalexample>
     <programlisting role="php">
switch ($i) {
    case 0:
        print "i &eacute;gale 0";
    case 1:
        print "i &eacute;gale 1";
    case 2:
        print "i &eacute;gale 2";
}
     </programlisting>
    </informalexample>
   </para>
   <simpara>
     Dans cet exemple, si $i est &eacute;gal &agrave; 0, PHP va
     ex&eacute;cuter quand m&ecirc;me toutes les instructions qui
     suivent. Si $i est &eacute;gal &agrave; 1, PHP ex&eacute;cutera
     les deux derni&egrave;res instructions. Et seulement si $i est
     &eacute;gal &agrave;, vous obtiendrez le r&eacute;sultat
     escompt&eacute;, c'est-&agrave;-dire, l'affiche de
     "i &eacute;gal 2. Donc, l'important est de ne pas oublier
     l'instruction <literal>break</literal> (m&ecirc;me si il est
     possible que vous l'omettiez dans certaines circonstances).
   </simpara>
   <simpara>
    Dans une commande <literal>switch</literal>, une condition n'est
    &eacute;valu&eacute;e qu'une fois, est le r&eacute;sultat est
    compar&eacute; &agrave; chaque <literal>case</literal>.
    Dans une structure <literal>elseif</literal>, les conditions sont
    &eacute;valu&eacute;es &agrave; chaque comparaison. Si votre
    condition est plus compliqu&eacute;e qu'une simple
    comparaison, ou bien fait partie d'une boucle,
    <literal>switch</literal> sera plus rapide.
   </simpara>
   <para>
     La liste de commande d'un <literal>case</literal> peut
     &ecirc;tre vide, auquel cas PHP utilisera la liste de
     commandes du cas suivant.
    <informalexample>
     <programlisting role="php">
switch ($i) {
    case 0:
    case 1:
    case 2:
        print "i est plus petit que 3 mais n'est pas n&eacute;gatif";
        break;
    case 3:
        print "i &eacute;gale 3";
}
     </programlisting>
    </informalexample>
   </para>
   <para>
    Un <literal>case</literal> sp&eacute;cial est
    <literal>default</literal>. Ce cas est utilis&eacute; lorsque tous
    les <literal>case</literal> ont &eacute;chou&eacute;s. Par exemple :
    <informalexample>
     <programlisting role="php">
switch ($i) {
    case 0:
        print "i &eacute;gale 0";
        break;
    case 1:
        print "i &eacute;gale 1";
        break;
    case 2:
        print "i &eacute;gale  2";
        break;
    default:
        print "i n'est ni &eacute;gal &agrave; 2, ni &agrave; 1, ni &agrave; 0.";
}
     </programlisting>
    </informalexample>
   </para>
   <para>
     Une autre chose &agrave; mentionner est que l'instruction
     <literal>case</literal> peut &ecirc;tre une expression &agrave;
     de type scalaire, c'est-&agrave;-dire nombre entier, nombre
     &agrave; virgule flottante et cha&icirc;ne de caract&egrave;re.
     Les tableaux sont sans inter&ecirc;t dans ce contexte-l&agrave;.
   </para>
   <para>
     La syntaxe alternative pour cette structure de contr&ocirc;le est
     la suivante :  pour plus d'informations, voir
    <link linkend="control-structures.alternative-syntax">syntaxes alternatives</link>).
    <informalexample>
     <programlisting role="php">
switch ($i):
    case 0:
        print "i &eacute;gale 0";
        break;
    case 1:
        print "i &eacute;gale 1";
        break;
    case 2:
        print "i &eacute;gale 2";
        break;
    default:
        print "i n'est ni &eacute;gal &agrave; 2, ni &agrave; 1, ni &agrave; 0";
endswitch;
     </programlisting>
    </informalexample>
   </para>
  </sect1>
  <sect1 id="function.require">
   <title><function>require</function></title>
   <simpara>
    La commande <function>require</function> se remplace elle m&ecirc;me
    par le contenu du fichier sp&eacute;cifi&eacute;, comme les
    pr&eacute;processeurs C le font avec la commande <literal>#include</literal>.
   </simpara>
   <simpara>
     Il est important de noter que lorsqu'un fichier est
     <function>include</function> ou <function>require</function>,
     les erreurs d'analyse appara&icirc;tront en HTML tout au d&eacute;but
     du fichier, et l'analyse du fichier parent ne sera pas interrompue. Pour
     cette raison, le code qui est dans le fichier doit &ecirc;tre plac&eacute;
     entre <link linkend="language.basic-syntax.phpmode">les balises habituelles
     de PHP</link>.
   </simpara>
   <simpara>
    <function>require</function> n'est pas vraiment une fonction PHP :
    c'est plus un instruction du langage. Elle ne fonctionne pas comme
    les fonctions standards. Par exemple, <function>require</function>
    ne peut pas contenir d'autres structures de contr&ocirc;le. De plus,
    il ne retourne aucune valeur. Lire une valeur retourn&eacute;e par un
    <function>require</function> retourne une erreur
    d'analyse.
   </simpara>
   <simpara>
    Contrairement &agrave; <function>include</function>,
    <function>require</function> va <emphasis>toujours</emphasis> lire dans
    le fichier cible, m&ecirc;me si la ligne n'est jamais
    ex&eacute;cut&eacute;e. Si vous souhaitez une inclusion
    conditionnelle, utilisez <function>include</function>. La
    condition ne va jamais affecter <function>require</function>.
    Cependant, si la ligne de <function>require</function>
    n'est jamais ex&eacute;cut&eacute;e, le code du fichier ne
    le sera jamais non plus.
   </simpara>
   <simpara>
    Les boucles n'affectent pas le comportement de
    <function>require</function>. M&ecirc;me si le code
    contenu dans le fichier source est appel&eacute; dans la boucle,
    <function>require</function> n'est ex&eacute;cut&eacute; qu'une
    fois.
   </simpara>
   <para>
    Cela signifie qu'on ne peut pas mettre un
    <function>require</function> dans une boucle, et s'attendre
    &agrave; ce qu'il inclue du code &agrave; chaque it&eacute;ration.
    Pour cela, il faut utiliser <function>include</function>.
    <informalexample>
     <programlisting role="php">
require ('header.inc');
     </programlisting>
    </informalexample>
   </para>
   <para>
    Attention :  <function>include</function> et
    <function>require</function> ajoute le contenu du fichier cible
    dans le script lui-m&ecirc;me. Elle n'utilise pas le protocole
    HTTP ou tout autre protocole. Toute variable qui est dans le
    champs du script sera accessible dans le fichier d'inclusion,
    et vice versa.
    <informalexample>
     <programlisting role="php">
require ("file.inc?varone=1&amp;vartwo=2"); /* Ne fonctionne pas. */
$varone = 1;
$vartwo = 2;
require ("file.inc");  /* $varone et $vartwo seront accessible &agrave; file.inc */
     </programlisting>
    </informalexample>
   </para>
   <simpara>
     Ne vous laissez pas abuser par le fait que vous pouvez
     requ&eacute;rir ou inclure des fichiers via HTTP en
     utilisant la fonctionnalit&eacute; de
     <link linkend="features.remote-files">gestion des fichiers distants</link>
     ce qui est au dessus reste vrai.
   </simpara>
   <simpara>
     En PHP 3, il est possible d'ex&eacute;cuter une commande
     <literal>return</literal> depuis un fichier inclus, tant
     que cette commande intervient au niveau global du fichier
     inclus. Elle ne doit intervenir dans aucun bloc (entre accolade {}).
     En PHP 4, cette possibilit&eacute; a &eacute;t&eacute;
     supprim&eacute;e. Si vous en avez besoin, utilisez plut&ocirc;t
   <function>include</function>.
   </simpara>
  </sect1>
  <sect1 id="function.include">
   <title><function>include</function></title>
   <simpara>
      La fonction <function>include</function> inclus et &eacute;value le
      fichier sp&eacute;cifi&eacute; en argument.
   </simpara>
   <simpara>
      Il est important de noter que lorsqu'un fichier est
      <function>include</function> ou <function>require</function>,
      les erreurs d'analyse appara&icirc;tront en HTML tout
      au d&eacute;but du fichier, et l'analyse du fichier
      parent ne sera pas interrompue. Pour cette raison, le code
      qui est dans le fichier doit &ecirc;tre plac&eacute; entre
      <link linkend="language.basic-syntax.phpmode">les balises
      habituelles de PHP</link>.
   </simpara>
   <para>
      Cela a lieu &agrave; chaque fois que la fonction
      <function>include</function> est rencontr&eacute;e. Donc vous
      vous pouvez utiliser la fonction <function>include</function>
      dans une boucle pour inclure un nombre infini de
      fois un fichier, ou m&ecirc;me des fichiers diff&eacute;rents.
    <informalexample>
     <programlisting role="php">
&lt;?php
$files = array ('first.inc', 'second.inc', 'third.inc');
for ($i = 0; $i < count($files); $i++) {
    include $files[$i];
}
?&gt;
     </programlisting>
    </informalexample>
   </para>
   <para>
    <function>include</function> diff&egrave;re de
    <function>require</function> car le fichier inclus est
    r&eacute;-&eacute;valu&eacute;e &agrave; chaque fois que la
    commande est ex&eacute;cut&eacute;e, tandis que
    <function>require</function> est remplac&eacute;e
    par le fichier cible lors de la premi&egrave;re
    ex&eacute;cution, que son contenu soit utilis&eacute;
    ou non. De plus, cela se fait m&ecirc;me si il
    est plac&eacute; dans une structure conditionnelle,
    comme dans un <link linkend="control-structures.if">if</link>).
   </para>
   <para>
     Parce que la fonction <function>include</function> n&eacute;cessite
     une construction particuli&egrave;re, vous devez l'inclure dans un
     bloc si elle est inclue dans une structure conditionnelle.
    <informalexample>
     <programlisting role="php">
&lt;?php
/*  Ceci est faux, et ne fonctionnera pas ce qu'on attend. */
if ($condition)
    include($file);
else
    include($other);
/* Ceci est CORRECT. */
if ($condition) {
    include($file);
} else {
    include($other);
}
?&gt;
     </programlisting>
    </informalexample>
   </para>
   <simpara>
     En PHP 3, il est possible d'ex&eacute;cuter une commande
     <literal>return</literal> depuis un fichier inclus, tant
     que cette commande intervient au niveau global du fichier
     inclus. Elle ne doit intervenir dans aucun bloc (entre accolade
     {}). En PHP 4, cette possibilit&eacute; a &eacute;t&eacute;
     supprim&eacute;e. Cependant, PHP 4 vous autorise &agrave;
     retourner des valeurs d'un fichier inclus. Vous pouvez
     traiter <function>include</function> comme une fonction
     normale, qui retourne une valeur. Mais cela g&eacute;n&egrave;re
     une erreur d'analyse en PHP 3.
   </simpara>
   <example>
    <title><function>include</function> en PHP 3 et PHP 4</title>
    <para>
       On suppose que le fichier <filename>test.inc</filename> existe,
       et est plac&eacute; dans le m&ecirc;me dossier que le fichier
       principal :
     <programlisting role="php">
&lt?;php
echo "Avant le retour&lt;br&gt;\n";
if (1) {
    return 27;
}
echo "Apr&egrave;s le retour &lt;br&gt;\n";
?&gt;
     </programlisting>
    </para>
    <para>
     On suppose que le fichier <filename>main.html</filename> contient ceci :
     <programlisting role="php">
&lt?;php
$retval = include ('test.inc');
echo "Fichier inclus: '$retval'&lt;br&gt;\n";
?&gt;
     </programlisting>
    </para>
    <para>
     Lorsque <filename>main.html</filename> est appel&eacute; en PHP 3,
     il va g&eacute;n&eacute;rer une erreur d'analyse (parse error)
     &agrave; la ligne 2; vous ne pouvez pas vous attendre &agrave; un
     retour sur une fonction <function>include</function> en PHP 3. En
     PHP 4, cependant,le r&eacute;sultat sera :
     <screen>
Avant le retour
Ficher inclus : '27'
     </screen>
    </para>
    <para>
     Supposons maintenant que <filename>main.html</filename> a
     &eacute;t&eacute; modifi&eacute; et contient maintenant le
     code suivant :
     <programlisting role="php">
&lt?;php
include ('test.inc');
echo "Retour dans le main.html&lt;br&gt;\n";
?&gt;
     </programlisting>
    </para>
    <para>
     En PHP 4, l'affichage sera :
     <screen>
Avant le retour
Retour dans le main.html
     </screen>
     Au contraire, PHP 3 affichera :
     <screen>
Avant le retour
27Retour dans le main.html
Parse error: parse error in /home/torben/public_html/phptest/main.html on line 5
     </screen>
    </para>
    <para>
     L'erreur d'analyse ci-dessus est le r&eacute;sultat du fait que la commande
     <literal>return</literal> est dans un bloc qui n'est pas une fonction, dans
     <filename>test.inc</filename>. Lors que le return est sorti du bloc,
     l'affichage devient :
     <screen>
Avant le retour
27Retour dans le main.html
     </screen>
    </para>
    <para>
     Le '27' est du au fait que PHP 3 ne supporte pas le <literal>return</literal>
     dans ces fichiers.
    </para>
   </example>
   <para>
     Il est important de noter que lorsqu'un fichier est <function>include</function>
     ou <function>require</function>, les erreurs d'analyse appara&icirc;tront en
     HTML tout au d&eacute;but du fichier, et l'analyse du fichier parent ne sera
     pas interrompue. Pour cette raison, le code qui est dans le fichier doit
     &ecirc;tre plac&eacute; entre <link linkend="language.basic-syntax.phpmode">
     les balises habituelle de PHP</link>.
    <informalexample>
     <programlisting role="php">
include ("file.inc?varone=1&amp;vartwo=2"); /* ne fonctionne pas. */
$varone = 1;
$vartwo = 2;
include ("file.inc");  /* $varone et $vartwo sont accessibles dans file.inc */
     </programlisting>
    </informalexample>
   </para>
   <simpara>
     Ne vous laissez pas abuser par le fait que vous pouvez requ&eacute;rir
     ou inclure des fichiers via HTTP en utilisant la fonctionnalit&eacute;
     de <link linkend="features.remote-files">gestion des fichiers distants
     </link> ce qui est au dessus reste vrai.
   </simpara>
   <simpara>
    Voir aussi <function>readfile</function>, <function>require</function>
    et <function>virtual</function>.
   </simpara>
  </sect1>
    <sect1 id="function.require-once">
   <title><function>require_once</function></title>
   <para>
    La commande <function>require_once</function> se remplace elle m&ecirc;me
    par le fichier sp&eacute;cifi&eacute;, un peu comme les commandes de
    pr&eacute;processeur C <literal>#include</literal>, et ressemble sur
    ce point &agrave; <function>require</function>. La principale
    diff&eacute;rence est qu'avec <function>require_once</function>,
    vous &ecirc;tes assur&eacute;s que ce code ne sera ajout&eacute;
    qu'une seule fois, &eacute;vitant de ce fait les red&eacute;fintions de
    variables ou de fonctions, g&eacute;n&eacute;ratrices d'alertes.
   </para>
   <para>
     Par exemple, si vous cr&eacute;ez les deux fichiers d'inclusion
	 <literal>utils.inc</literal> et <literal>foolib.inc</literal>
	 <example>
	 <title>utils.inc</title>
	 <programlisting role="php">
&lt;?php
define(PHPVERSION, floor(phpversion()));
echo "LES GLOBALES SONT SYMPAS\n";
function goodTea() {
	return "Le Earl Grey est d&eacute;licieux!";
}
?&gt;
	 </programlisting>
	 </example>
	 <example>
	 <title>foolib.inc</title>
	 <programlisting role="php">
&lt;?php
require ("utils.inc");
function showVar($var) {
	if (PHPVERSION == 4) {
		print_r($var);
	} else {
		dump_var($var);
	}
}
// Une s&eacute;rie de fonctions
?&gt;
	 </programlisting>
	 </example>
	 Puis, vous &eacute;crivez un script <literal>cause_error_require.php</literal>
	 <example>
	 <title>cause_error_require.php</title>
	 <programlisting role="php">
&lt;?php
require("foolib.inc");
/* Ceci g&eacute;n&egrave;re une erreur*/
require("utils.inc");
$foo = array("1",array("complex","quaternion"));
echo "Ce code requiert utils.inc une deuxi&egrave;me fois, car il est requis \n";
echo "dans foolib.inc\n";
echo "Utilisation de GoodTea: ".goodTea()."\n";
echo "Affichage de foo: \n";
showVar($foo);
?&gt;
	 </programlisting>
	 </example>
	 Lorsque vous ex&eacute;cutez le script ci dessus, le
	 r&eacute;sultat sera (sous PHP 4.01pl2):
	 <informalexample>
	  <computeroutput>
GLOBALS ARE NICE
GLOBALS ARE NICE
Fatal error:  Cannot redeclare causeerror() in utils.inc on line 5
	  </computeroutput>
	 </informalexample>
	 En modifiant <literal>foolib.inc</literal> et
	 <literal>cause_errror_require.php</literal>
	 pour qu'elles utilisent <function>require_once</function>
	 au lieu de <function>require</function> et ne renommant le fichier
	 en <literal>avoid_error_require_once.php</literal>, on obtiend :
	 <example>
	 <title>foolib.inc (corrig&eacute;)</title>
	 <programlisting role="php">
&lt;?php
require_once("utils.inc");
function showVar($var) {
?&gt;
	 </programlisting>
	 </example>
	 <example>
	 <title>avoid_error_require_once.php</title>
	 <programlisting role="php">
&lt;?php
require_once("foolib.inc");
require_once("utils.inc");
$foo = array("1",array("complexe","quaternion"));
?&gt;
	 </programlisting>
	 </example>
	 L'ex&eacute;cution de ce script, sous PHP 4.0.1pl2, donne :
	 <informalexample>
	  <computeroutput>
LES GLOBALES SONT SYMPA
Ce code requiert utils.inc une deuxi&egrave;me fois, car il est requis
dans foolib.inc
Utilisation de GoodTea: Le Earl Grey est d&eacute;licieux!
Affichage de foo:
Array
(
    [0] =&gt; 1
    [1] =&gt; Array
        (
            [0] =&gt; complexe
            [1] =&gt; quaternion
        )
)
	  </computeroutput>
	 </informalexample>
   </para>
   <para>
     Notez aussi que, de la m&ecirc;me mani&egrave;re que les
     pr&eacute;processeur traitent les <literal>#include</literal>,
     cette commande est ex&eacute;cut&eacute;e au moment de la
     compilation, c'est &agrave; dire lorsque le script est
     analys&eacute;e, et avant qu'il soit ex&eacute;cut&eacute;,
     et ne doit pas &ecirc;tre utilis&eacute;e pour ins&eacute;rer
     des donn&eacute;es dynamiques li&eacute;es &agrave;
     l'&eacute;x&eacute;cution. Il vaut alors mieux utiliser
     <function>include_once</function> ou <function>include</function>.
   </para>
   <para>
     Pour plus d'exemples avec <function>require_once</function> et
	 <function>include_once</function>, jetez un oeil dans le code de PEAR
	 inclus dans la derni&egrave;re distribution de PHP.
   </para>
   <para>
    Voir aussi : <function>require</function>,
    <function>include</function>, <function>include_once</function>,
    <function>get_required_files</function>,
    <function>get_included_files</function>, <function>readfile</function>,
	et <function>virtual</function>.
   </para>
  </sect1>
  <sect1 id="function.include-once">
   <title><function>include_once</function></title>
   <para>
    La commande <function>include_once</function> inclus et
    &eacute;value le fichier sp&eacute;cifi&eacute; durant
    l'ex&eacute;cution du script. Le comportement est similaire &agrave;
    <function>include</function>, mais la diff&eacute;rence est que si
    le code a d&eacute;j&agrave; &eacute;t&eacute; inclus, il ne le
    sera pas une seconde fois.
   </para>
   <para>
    Comme pr&eacute;cis&eacute; dans la section
    <function>require_once</function>, la fonction
    <function>include_once</function> est utilis&eacute;e de
    pr&eacute;f&eacute;rence lorsque le	fichier doit &ecirc;tre
    inclus ou &eacute;valu&eacute; plusieurs fois dans un script,
    ou bien	lorsque vous voulez &ecirc;tre sur qu'il ne sera inclus
    qu'une seule fois, pour &eacute;viter des red&eacute;finitions
    de fonction.
   </para>
   <para>
     Pour plus d'exemples avec <function>require_once</function> et
	 <function>include_once</function>, jetez un oeil dans le code de PEAR
	 inclus dans la derni&egrave;re distribution de PHP.
   </para>
   <para>
    Voir aussi: <function>require</function>,
    <function>include</function>, <function>require_once</function>,
    <function>get_required_files</function>,
    <function>get_included_files</function>, <function>readfile</function>,
	et <function>virtual</function>.
   </para>
  </sect1>
 </chapter>
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
