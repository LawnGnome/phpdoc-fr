<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.39 $ -->
<!-- EN-Revision: 1.91 Maintainer: dams Status: ready -->
 <chapter id="language.control-structures">
  <title>Les structures de contrôle</title>
  <simpara>
    Tous les scripts &php; sont une suite d'instructions. Une instruction
    peut être une assignation, un appel de fonction, une instruction
    conditionnelle ou bien une instruction qui ne fait rien (une instruction
    vide). Une instruction se termine habituellement par un point virgule
    (";"). De plus, plusieurs instructions peuvent être
    regroupées en bloc, délimité par des
    accolades ("<literal>{}</literal>"). Un bloc est considéré
    comme une instruction. Les différents types d'instruction sont 
    décrits dans ce chapitre.
  </simpara>
  <sect1 id="control-structures.if">
   <title><literal>if</literal></title>
   <para>
    L'instruction <literal>if</literal> est une des plus importantes
    instructions de tous les langages, &php; inclus. Elle permet
    l'exécution conditionnelle d'une partie de code. Les
    fonctionnalités de l'instruction <literal>if</literal>
    sont les mêmes en &php; qu'en C :
    <example>
     <title>Instruction if () </title>
     <programlisting role="php">
 <![CDATA[
<?php
  if (expression)
    commandes
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Comme nous l'avons vu dans le paragraphe consacré aux 
    <link linkend="language.expressions">expressions</link>,
    <replaceable>expr</replaceable> est convertie en sa valeur
    booléenne. Si l'expression <replaceable>expr</replaceable> vaut
    &true;, &php; exécutera l'instruction et si elle
    vaut &false;, l'instruction sera ignorée.
    Plus de détails sur les valeurs qui valent &false; sont disponibles dans
    la section 
    <link linkend="language.types.boolean.casting">Conversion en booléen</link>.
   </simpara>
   <para>
    L'exemple suivant affiche la phrase <computeroutput>a est plus grand
    que b</computeroutput> si <varname>$a</varname> est plus grand
    que <varname>$b</varname>:
    <example>
     <title>Instruction if () (2)</title>
     <programlisting role="php">
 <![CDATA[
<?php
  if ($a > $b)
    print "a est plus grand que b";
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Souvent, vous voulez que plusieurs instructions soient
    exécutées après un branchement conditionnel. Bien
    évidemment, il n'est pas obligatoire de répéter
    l'instruction conditionnelle autant de fois que vous avez d'instructions
    à exécuter. A la place, vous pouvez rassembler toutes les
    instructions dans un bloc. L'exemple suivant affiche <computeroutput>a
    est plus grand que b</computeroutput>, et assigne la valeur de la
    variable <varname>$a</varname> à la variable
    <varname>$b</varname>:
    <example>
     <title>Instruction if () et bloc</title>
     <programlisting role="php">
 <![CDATA[
<?php
if ($a > $b) {
    print "a est plus grand que b";
    $b = $a;
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Vous pouvez imbriquer indéfiniment des instructions
    <literal>if</literal> les unes dans les autres, ce qui permet
    une grande flexibilité dans l'exécution d'une
    partie de code suivant un grand nombre de conditions.
   </simpara>
  </sect1>
  <sect1 id="control-structures.else">
   <title><literal>else</literal></title>
   <para>
    Souvent, vous voulez exécuter une instruction si une
    condition est remplie, et une autre instruction si cette condition
    n'est pas remplie. C'est à cela que sert <literal>else</literal>.
    <literal>else</literal> fonctionne après un
    <literal>if</literal> et exécute les instructions
    correspondantes au cas o&uacute; l'expression du <literal>if</literal>
    est &false;. Dans l'exemple suivant, ce bout de code
    affiche <computeroutput>a est plus grand que b</computeroutput> si la
    variable <varname>$a</varname> est plus grande que la variable
    <varname>$a</varname>, et <computeroutput>a est plus petit que b</computeroutput>
    sinon :
    <example>
     <title>Instruction if () else</title>
     <programlisting role="php">
 <![CDATA[
<?php
if ($a > $b) {
    print "a est plus grand que b";
} else {
    print "a est plus petit que b";
}
?>
]]>
     </programlisting>
    </example>
    Les instructions après le <literal>else</literal> ne sont
    exécutées que si l'expression du <literal>if</literal>
    est &false;, et si elle n'est pas suivi par l'expression
    <literal>elseif</literal>.
   </para>
  </sect1>
  <sect1 id="control-structures.elseif">
   <title><literal>elseif</literal></title>
   <para>
      <literal>elseif</literal>, comme son nom l'indique, est une combinaison
      de <literal>if</literal> et de <literal>else</literal>. Comme l'expression
      <literal>else</literal>, il permet d'exécuter une instruction
      après un <literal>if</literal> dans le cas o&uacute; le "premier"
      if est évalué comme &false;. Mais,
      à la différence de l'expression <literal>else</literal>,
      il n'exécutera l'instruction que si l'expression conditionnelle
      <literal>elseif</literal> est évaluée comme
      &true;. L'exemple suivant affichera
      <computeroutput>a est plus grand que b</computeroutput>,
      <computeroutput>a est égal à b</computeroutput> ou
      <computeroutput>a est plus petit que b</computeroutput>:
    <example>
     <title>Instruction elseif () </title>
     <programlisting role="php">
 <![CDATA[
<?php
if ($a > $b) {
    print "a est plus grand que b";
} elseif ($a == $b) {
    print "a est égal à b";
} else {
    print "a est plus petit que b";
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
     Vous pouvez avoir plusieurs <literal>elseif</literal> qui se suivent
     les uns après les autres, après un <literal>if</literal> initial.
     Le premier <literal>elseif</literal> qui sera évalué
     à &true; sera exécuté. En &php;, vous
     pouvez aussi écrire "<literal>else if</literal>" en deux mots et 
     son comportement sera identique à la version en un seul mot. 
     La sémantique des deux expressions est légèrement
     différente, mais au bout du compte, le résultat sera 
     exactement le même.
   </simpara>
   <simpara>
      L'expression <literal>elseif</literal> est exécutée
      seulement si le <literal>if</literal> précédent et tout
      autre <literal>elseif</literal> précédent sont
      évalués comme &false;, et que
      votre <literal>elseif</literal> est évalué à
      &true;.
   </simpara>
  </sect1>
  <sect1 id="control-structures.alternative-syntax">
   <title>Syntaxe alternative</title>
   <para>
    &php; propose une autre manière de rassembler des
    instructions à l'intérieur d'un bloc, pour les
    fonctions de contrôle <literal>if</literal>,
    <literal>while</literal>, <literal>for</literal>,
    <literal>foreach</literal> et <literal>switch</literal>.
    Dans chaque cas, le principe
    est de remplacer l'accolade d'ouverture par deux points (:)
    et l'accolade de fermeture par, respectivement,
    <literal>endif;</literal>, <literal>endwhile;</literal>,
    <literal>endfor;</literal>, ou <literal>endswitch;</literal>.
    <example>
     <title>Instruction if () alternative</title>
     <programlisting role="php">
 <![CDATA[
<?php if ($a == 5): ?>
A égal 5
<?php endif; ?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
     Dans l'exemple ci-desssus, le bloc HTML "A = 5" est inclus
     à l'intérieur d'un <literal>if</literal> en
     utilisant cette nouvelle syntaxe. Ce code HTML ne sera
     affiché que si la variable <varname>$a</varname> est égale à 5.
   </simpara>
   <para>
    Cette autre syntaxe fonctionne aussi avec le <literal>else</literal> et
    <literal>elseif</literal>. L'exemple suivant montre une structure avec un
    <literal>if</literal>, un <literal>elsif</literal> et un
    <literal>else</literal> utilisant cette autre syntaxe :
    <example>
     <title>Instruction alternative if () elseif et else</title>
     <programlisting role="php">
 <![CDATA[
<?php
if ($a == 5):
    print "a égale 5";
    print "...";
elseif ($a == 6):
    print "a égale 6";
    print "!!!";
else:
    print "a ne vaut ni 5 ni 6";
endif;
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Voir aussi
    <link linkend="control-structures.while">while</link>,
    <link linkend="control-structures.for">for</link>, et
    <link linkend="control-structures.if">if</link> pour d'autres exemples.
   </para>
  </sect1>
  <sect1 id="control-structures.while">
   <title><literal>while</literal></title>
   <para>
     La boucle <literal>while</literal> est le moyen le plus
     simple d'implémenter une boucle en &php;. Cette boucle
     se comporte de la même manière qu'en C.
     L'exemple le plus simple d'une boucle <literal>while</literal>
     est le suivant :
    <example>
     <title>Instruction while () </title>
     <programlisting role="php">
 <![CDATA[
<?php
  while (expression) commandes
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
     La signification d'une boucle <literal>while</literal> est
     très simple. &php; exécute l'instruction tant
     que l'expression de la boucle <literal>while</literal> est
     évaluée comme &true;. La valeur
     de l'expression est vérifiée à chaque
     début de boucle, et, si la valeur change durant
     l'exécution de l'instruction, l'exécution ne
     s'arrêtera qu'à la fin de l'itération
     (chaque fois que &php; exécute l'instruction, on appelle
     cela une itération). De temps en temps, si l'expression du
     <literal>while</literal> est &false; avant la
     première itération, l'instruction ne sera jamais
     exécutée.
   </simpara>
   <para>
     Comme avec le <literal>if</literal>, vous pouvez regrouper
     plusieurs instructions dans la même boucle
     <literal>while</literal> en les regroupant à l'intérieur
     de parenthèses ou en utilisant la syntaxe suivante :
    <example>
     <title>Instruction while () avec bloc</title>
     <programlisting role="php">
 <![CDATA[
<?php
while (expression): commandes ... endwhile;
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Les exemples suivants sont identiques, et affichent tous les nombres
    de 1 à 10 :
    <example>
     <title>Exemple avec while () </title>
     <programlisting role="php">
 <![CDATA[
<?php
/* exemple 1 */
$i = 1;
while ($i <= 10) {
    print $i++;  /* La valeur affiche est $i avant l'incrémentation
                     (post-incrémentation)  */
}
/* exemple 2 */
$i = 1;
while ($i <= 10):
    print $i;
    $i++;
endwhile;
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect1>
  <sect1 id="control-structures.do.while">
   <title><literal>do..while</literal></title>
   <simpara>
     Les boucles <literal>do..while</literal> ressemblent beaucoup
     aux boucles <literal>while</literal>, mais l'expression est
     testée à la fin de chaque itération plutôt
     qu'au début. La principale différence par rapport
     à la boucle <literal>while</literal> est que la
     première itération de la boucle
     <literal>do..while</literal> est toujours exécutée
     (l'expression n'est testée qu'à la fin de
     l'itération), ce qui n'est pas le cas lorsque vous
     utilisez une boucle <literal>while</literal> (l'expression
     est vérifiée au début de chaque itération).
   </simpara>
   <para>
    Il n'y a qu'une syntaxe possible pour les boucles <literal>do..while</literal>:
    <example>
     <title>Instruction do ... while () </title>
     <programlisting role="php">
 <![CDATA[
<?php
$i = 0;
do {
   print $i;
} while ($i>0);
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
     La boucle ci-dessus ne va être exécutée
     qu'une seule fois, car lorsque l'expression est
     évaluée, elle vaut &false; (car
     la variable <varname>$i</varname> n'est pas plus grande que 0) et l'exécution
     de la boucle s'arrête.
   </simpara>
   <para>
     Les utilisateurs familiers du C sont habitués à
     une utilisation différente des boucles
     <literal>do..while</literal> , qui permet de stopper
     l'exécution de la boucle au milieu des instructions, en
     l'encapsulant dans un <literal>do..while</literal>(0) la
     fonction <link linkend="control-structures.break"><literal>break</literal></link>.
     Le code suivant montre une utilisation possible :
    <example>
     <title>Instruction while () et break </title>
     <programlisting role="php">
 <![CDATA[
<?php
do {
    if ($i < 5) {
        print "i n'est pas suffisamment grand";
        break;
    }
    $i *= $factor;
    if ($i < $minimum_limit) {
        break;
    }
    print "i est bon";
     ...process i...
} while(0);
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
     Ne vous inquiétez pas si vous ne comprenez
     pas tout correctement. Vous pouvez écrire des scripts
     très très puissants sans utiliser
     cette fonctionnalité.
   </simpara>
  </sect1>
  <sect1 id="control-structures.for">
   <title><literal>for</literal></title>
   <para>
     Les boucles <literal>for</literal> sont les boucles les plus complexes en &php;.
     Elles fonctionnent comme les boucles <literal>for</literal> du langage C.
     La syntaxe des boucles for est la suivante :
    <example>
     <title>Instruction for() </title>
     <programlisting role="php">
 <![CDATA[
<?php
  for (expr1; expr2; expr3) statement
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    La première expression (<varname>expr1</varname>) est
    évaluée (exécutée), quoi qu'il arrive au
    début de la boucle.
   </simpara>
   <simpara>
    Au début de chaque itération, l'expression
    <varname>expr2</varname> est évaluée.
    Si l'évaluation vaut &true;, la boucle
    continue et l'instruction est exécutée. Si
    l'évaluation vaut &false;,
    l'exécution de la boucle s'arrête.
   </simpara>
   <simpara>
    A la fin de chaque itération, l'expression
    <varname>expr3</varname> est évaluée
    (exécutée).
   </simpara>
   <simpara>
    Les expressions peuvent éventuellement être
    laissées vides. Si l'expression <varname>expr2</varname>
    est laissée vide, cela signifie que c'est une boucle infinie
    (&php; considère implicitement qu'elle vaut &true;,
    comme en C). Cela n'est pas vraiment très utile, à moins que vous
    souhaitiez terminer votre boucle par l'instruction conditionnelle
    <link linkend="control-structures.break"><literal>break</literal></link>.
   </simpara>
   <para>
    Considérons les exemples suivants. Tous affichent les chiffres de
    1 à 10 :
    <example>
     <title>Exemple de boucles</title>
     <programlisting role="php">
 <![CDATA[
<?php
/* exemple 1 */

for ($i = 1; $i <= 10; $i++) {
    echo $i;
}

/* exemple 2 */

for ($i = 1; ; $i++) {
    if ($i > 10) {
        break;
    }
    echo $i;
}

/* exemple 3 */

$i = 1;
for (; ; ) {
    if ($i > 10) {
        break;
    }
    echo $i;
    $i++;
}

/* exemple 4 */

for ($i = 1; $i <= 10; echo $i, $i++);
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
     Bien évidemment, le premier exemple est le plus simple
     de tous (ou peut être le quatrième), mais vous
     pouvez aussi pensez qu'utiliser une expression vide dans une
     boucle <literal>for</literal> peut être utile parfois.
   </simpara>
   <para>
     &php; supporte aussi la syntaxe alternative suivante pour les boucles
     <literal>for</literal> :
    <example>
     <title>Instruction for() alternative</title>
     <programlisting role="php">
 <![CDATA[
<?php
  for (expr1; expr2; expr3): statement; ...; endfor;
?>
]]>
     </programlisting>
     </example>
   </para>
   <para>
     Les autres langages ont l'instruction <literal>foreach</literal>
     pour accéder aux éléments d'un tableau. &php; 3
     ne dispose pas d'une telle fonction; &php; 4 en dispose (voir
     <link linkend="control-structures.foreach">foreach</link>). En &php; 3,
     vous pouvez combiner <link linkend="control-structures.while">while</link>
     avec <function>list</function> et <function>each</function> pour
     obtenir le même résultat. Reportez-vous aux exemples
     de la documentation.
   </para>
  </sect1>
  <sect1 id="control-structures.foreach">
   <title><literal>foreach</literal></title>
   <para>
    &php; 4 (mais pas &php; 3) inclut une commande <literal>foreach</literal>,
    comme en Perl ou d'autres langages. C'est un moyen simple de passer
    en revue un tableau. Il y a deux syntaxes possibles : la seconde est
    une extension mineure mais pratique de la première :
    <example>
     <title>Instruction foreach() </title>
     <programlisting role="php">
 <![CDATA[
<?php
  foreach(array_expression as $value) commandes
  foreach(array_expression as $key => $value) commandes
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    La première forme passe en revue le tableau
    <literal>array_expression</literal>. A chaque itération,
    la valeur de l'élément courant est assignée à
    <literal>$value</literal> et le pointeur interne de tableau est
    avancé d'un élément (ce qui fait qu'à
    la prochaine itération, on accédera à
    l'élément suivant).
   </simpara>
   <simpara>
     La deuxième forme fait exactement la même chose, mais
     c'est la clé de l'élément courant qui est
     assigné à la variable <literal>$key</literal>.
   </simpara>
   <simpara>
    Lorsque <literal>foreach</literal> démarre, le pointeur interne
    de fichier est automatiquement ramené au premier
    élément du tableau. Cela signifie que vous n'aurez
    pas à faire appel à <function>reset</function> avant
    <literal>foreach</literal>.
   </simpara>
    <note>
     <para>
      De plus, notez que <literal>foreach</literal> travaille sur une copie
      du tableau spécifié, et pas sur le tableau lui-même.
      Par conséquent,
      le pointeur de tableau n'est pas modifié, comme il le serait
      avec le fonction <function>each</function>, et les modifications
      faites dans le tableau ne seront pas prises en compte dans le
      tableau original.
      </para>
     </note>
   <note>
    <para>
     <literal>foreach</literal> n'accepte pas l'opérateur de suppression
     des erreurs <link linkend="language.operators.errorcontrol">&#64;</link>.
    </para>
   </note>
   <para>
    Vous pouvez remarquer que les exemples suivants fonctionnent de
    manière identique :
    <example>
     <title>Instruction foreach() et while() </title>
     <programlisting role="php">
 <![CDATA[
<?php
$arr = array("un", "deux", "trois");
reset($arr);
while (list(, $value) = each ($arr)) {
  echo "Valeur : $value<br>\n";
}
foreach ($arr as $value) {
  echo "Valeur : $value<br>\n";
}
?>
]]>
     </programlisting>
    </example>
    Les exemples suivants sont aussi fonctionnellement identiques :
    <example>
     <title>Instruction foreach() et while() (2)</title>
     <programlisting role="php">
 <![CDATA[
<?php
$arr = array("un", "deux", "trois");
reset($arr);
while (list($key, $value) = each ($arr)) {
  echo "Clé : $key; Valeur : $value<br>\n";
}
foreach ($arr as $key => $value) {
  echo "Clé : $key; Valeur : $value<br>\n";
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Voici quelques exemples de plus :
    <example>
     <title>Instruction foreach() et while() (3)</title>
     <programlisting role="php">
 <![CDATA[
<?php
/* exemple foreach 1 : la valeur seulement */

$a = array (1, 2, 3, 17);

foreach ($a as $v) {
   print "Current value of \$a : $v.\n";
}

/* exemple foreach 2 : la valeur et sa clé d'index */

$a = array (1, 2, 3, 17);

$i = 0; /* uniquement pour l'illustration */

foreach($a as $v) {
    print "\$a[$i] => $v.\n";
    $i++;
}

/* exemple foreach 3 : la clé et la valeur */

$a = array (
    "un" => 1,
    "deux" => 2,
    "trois" => 3,
    "dix-sept" => 17
);

foreach($a as $k => $v) {
    print "\$a[$k] => $v.\n";
}

/* exemple foreach 4 : tableaux multi-dimensionnels */

$a[0][0] = "a";
$a[0][1] = "b";
$a[1][0] = "y";
$a[1][1] = "z";

foreach($a as $v1) {
    foreach ($v1 as $v2) {
        print "$v2\n";
    }
}

/* exemple foreach 5 : tableaux dynamiques */

foreach(array(1, 2, 3, 4, 5) as $v) {
    print "$v\n";
}

?>
]]>
     </programlisting>
    </example>
   </para>
  </sect1>
  <sect1 id="control-structures.break">
   <title><literal>break</literal></title>
   <simpara>
     L'instruction <literal>break</literal> permet de sortir d'une structure
     <literal>for</literal>, <literal>while</literal>,
     <literal>foreach</literal> ou <literal>switch</literal>.
   </simpara>
   <simpara>
    <literal>break</literal> accepte un argument numérique optionnel
    qui vous indiquera combien de structures emboîtées ont
    été interrompues.
   </simpara>
   <para>
    <example>
     <title>Instruction break </title>
     <programlisting role="php">
 <![CDATA[
<?php
$arr = array ('un', 'deux', 'trois', 'quatre', 'stop', 'cinq');
while (list (, $val) = each ($arr)) {
    if ($val == 'stop') {
        break;    /* Vous pourriez aussi utiliser 'break 1;' ici. */
    }
    echo "$val<br>\n";
}

/* Utilisation de l'argument optionnel. */

$i = 0;
while (++$i) {
    switch ($i) {
    case 5 :
        echo "A 5<br>\n";
        break 1;  /* Termine uniquement le switch. */
    case 10 :
        echo "At 10; quitting<br>\n";
        break 2;  /* Termine le switch et la boucle while. */
    default :
        break;
    }
}

?>
]]>
     </programlisting>
    </example>
   </para>
  </sect1>
  
  <sect1 id="control-structures.continue">
   <title><literal>continue</literal></title>
   <simpara>
     L'instruction <literal>continue</literal> est utilisée
     dans une boucle afin d'éluder les instructions de
     l'itération courante afin de passer directement à
     l'itération suivante.
   </simpara>
   <note>
    <simpara>
    Notez qu'en &php;, la structure
    <link linkend="control-structures.switch"><literal>switch</literal></link>
     est considérée comme une boucle par <literal>continue</literal>.
    </simpara>
   </note>
   <simpara>
    <literal>continue</literal> accepte un argument numérique
    optionnel qui vous indiquera combien de structures
    emboitées ont été ignorées.
   </simpara>
   <para>
    <example>
     <title>Instruction continue</title>
     <programlisting role="php">
 <![CDATA[
<?php
while (list ($cle, $valeur) = each ($arr)) {
   if (!($cle % 2)) { // évite les membres impairs
       continue;
   }
   fonction_quelconque($valeur);
}
$i = 0;
while ($i++ < 5) {
    echo "Dehors<br>\n";
    while (1) {
        echo "&nbsp;&nbsp;Milieu<br>\n";
        while (1) {
             echo "&nbsp;&nbsp;Intérieur<br>\n";
             continue 3;
        }
        echo "Ceci n'est jamais atteint.<br>\n";
    }
    echo "Ceci non plus.<br>\n";
}
?>
]]>
     </programlisting>
     </example>
    </para>
    <para>
     Oublier le point virgule après <literal>continue</literal> peut porter
     à confusion. Voici un exemple de ce que vous ne devez pas faire :
    </para>
    <para>
     <example>
      <title>N'oubliez pas le point-virgule après continue</title>
      <programlisting role="php">
<![CDATA[
<?php
  for ($i = 0; $i < 5; ++$i) {
      if ($i == 2)
          continue
      print "$i\n";
  }
?>
]]>
      </programlisting>
      <para>
       On peut s'attendre à ce que le résultat soit :
      </para>
      <screen>
<![CDATA[
0
1
3
4
]]>
      </screen>
      <para>
       mais ce script affichera :
      </para>
      <screen>
<![CDATA[
2
]]>
      </screen>
      <para>
       car la valeur de retour de l'appel à <function>print</function>
       est <literal>int(1)</literal>, et cela se comportera alors comme si
       on avait fournit l'argument optionnel mentionné plus haut.
      </para>
     </example>
    </para>
  </sect1>
  <sect1 id="control-structures.switch">
   <title><literal>switch</literal></title>
   <simpara>
    L'instruction <literal>switch</literal> équivaut
    à une série d'instructions <literal>if</literal>.
    En de nombreuses occasions, vous aurez besoin de comparer
    la même variable (ou expression) avec un grand nombre
    de valeurs différentes, et d'exécuter
    différentes parties de code suivant la valeur
    à laquelle elle est égale. C'est exactement
    à cela que sert l'instruction <literal>switch</literal>.
   </simpara>
   <note>
    <simpara>
    Notez que contrairement à d'autres langages, la structure 
    <link linkend="control-structures.continue">continue</link> s'applique
    aux structures <literal>switch</literal> et de comporte différemment de
    <literal>break</literal>. 
    Si vous avez un <literal>switch</literal> dans une boucle, et que vous 
    souhaitez continuer jusqu'à la prochaine itération de la boucle 
    extérieure, vous vous devez utiliser <literal>continue 2</literal>.
    </simpara>
   </note>
   <para>
    Les deux exemples suivants sont deux manières
    différentes d'écrire la même chose,
    l'une en utilisant une séries de <literal>if</literal>,
    et l'autre en utilisant l'instruction <literal>switch</literal>:
    <example>
     <title>Instruction switch()</title>
     <programlisting role="php">
 <![CDATA[
<?php
if ($i == 0) {
    print "i égale 0";
}
if ($i == 1) {
    print "i égale 1";
}
if ($i == 2) {
    print "i égale 2";
}
switch ($i) {
    case 0 :
        print "i égale 0";
        break;
    case 1 :
        print "i égale 1";
        break;
    case 2 :
        print "i égale 2";
        break;
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Il est important de comprendre que l'instruction
    <literal>switch</literal> exécute chacune des
    clauses dans l'ordre. L'instruction <literal>switch</literal>
    est exécutée ligne par ligne. Au début,
    aucun code n'est exécuté. Seulement
    lorsqu'un <literal>case</literal> est vérifié,
    &php; exécute alors les instructions correspondantes.
    &php; continue d'exécuter les instructions jusqu'à
    la fin du bloc d'instructions du <literal>switch</literal>,
    ou bien dès qu'il trouve l'instruction <literal>break</literal>.
    Si vous ne pouvez pas utiliser l'instruction
    <literal>break</literal> à la fin de l'instruction
    <literal>case</literal>, &php; continuera à exécuter
    toutes les instructions qui suivent. Par exemple :
    <example>
     <title>Instruction switch et fall through</title>
     <programlisting role="php">
 <![CDATA[
<?php
switch ($i) {
    case 0 :
        print "i égale 0";
    case 1 :
        print "i égale 1";
    case 2 :
        print "i égale 2";
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Dans cet exemple, si $i est égal à 0, &php; va
    exécuter quand même toutes les instructions qui
    suivent. Si $i est égal à 1, &php; exécutera
    les deux dernières instructions. Et seulement si $i est
    égal à 2, vous obtiendrez le résultat
    escompté, c'est-à-dire, l'affiche de
    "i égal 2". Donc, l'important est de ne pas oublier
    l'instruction <literal>break</literal> (même s'il est
    possible que vous l'omettiez dans certaines circonstances).
   </simpara>
   <simpara>
    Dans une commande <literal>switch</literal>, une condition n'est
    évaluée qu'une fois, et le résultat est
    comparé à chaque <literal>case</literal>.
    Dans une structure <literal>elseif</literal>, les conditions sont
    évaluées à chaque comparaison. Si votre
    condition est plus compliquée qu'une simple
    comparaison, ou bien fait partie d'une boucle,
    <literal>switch</literal> sera plus rapide.
   </simpara>
   <para>
    La liste de commandes d'un <literal>case</literal> peut
    être vide, auquel cas &php; utilisera la liste de
    commandes du cas suivant.
    <example>
     <title>Instruction switch() et case vide</title>
     <programlisting role="php">
 <![CDATA[
<?php
switch ($i) {
    case 0 :
    case 1 :
    case 2 :
        print "i est plus petit que 3 mais n'est pas négatif";
        break;
    case 3 :
        print "i égale 3";
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Un <literal>case</literal> spécial est
    <literal>default</literal>. Ce cas est utilisé lorsque tous
    les <literal>case</literal> ont échoués. Il doit
    être le dernier cas listé. Par exemple :
    <example>
     <title>Instruction switch() et default</title>
     <programlisting role="php">
 <![CDATA[
<?php
switch ($i) {
    case 0 :
        print "i égale 0";
        break;
    case 1 :
        print "i égale 1";
        break;
    case 2 :
        print "i égale  2";
        break;
    default :
        print "i n'est ni égal à 2, ni à 1, ni à 0.";
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Une autre chose à mentionner est que l'instruction
    <literal>case</literal> peut être une expression à
    de type scalaire, c'est-à-dire nombre entier, nombre
    à virgule flottante et chaîne de caractères.
    Les tableaux sont sans intérêt dans ce contexte-là.
   </para>
   <para>
    La syntaxe alternative pour cette structure de contrôle est
    la suivante :  pour plus d'informations, voir
    <link linkend="control-structures.alternative-syntax">syntaxes alternatives</link>).
    <example>
     <title>Instruction switch() alternative</title>
     <programlisting role="php">
 <![CDATA[
<?php
  switch ($i):
    case 0 :
        print "i égale 0";
        break;
    case 1 :
        print "i égale 1";
        break;
    case 2 :
        print "i égale 2";
        break;
    default :
        print "i n'est ni égal à 2, ni à 1, ni à 0";
  endswitch;
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect1>
  <sect1 id="control-structures.declare">
   <title><literal>declare</literal></title>
    <para>
     L'élément de langage <literal>declare</literal> sert à ajouter des
     directives d'exécutions dans un bloc de code. La syntaxe de
     <literal>declare</literal> est similaire à la syntaxe des autres
     fonctions de contrôle :
     <example>
     <title>Instruction <literal>directive</literal></title>
     <programlisting>
 <![CDATA[
<?php
  declare (directive) statement
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    L'expression <literal>directive</literal> permet de contrôler l'intervention
    du bloc <literal>declare</literal>. Actuellement, une seule directive
    est reconnue : la directive <literal>ticks</literal> (Voir plus bas pour plus
    de détails) sur les <link linkend="control-structures.declare.ticks">ticks</link>).
   </para>
   <para>
    L'expression <literal>statement</literal> du bloc de
    <literal>declare</literal> sera exécutée. Comment elle sera exécutée,
    et quels effets cela aura dépend de la directive utilisée dans le bloc
    <literal>directive</literal>.
   </para>
   <para>
    La structure <literal>declare</literal> peut aussi être utilisée
    dans le contexte global. Elle affecte alors tout le code qui la suit :
    <example>
     <title>Instruction <literal>directive</literal> en contexte global</title>
     <programlisting role="php">
<![CDATA[
<?php
// Ces déclaration sont identiques.

// Vous pouvez utiliser ceci
declare(ticks=1) {
    // script entier ici
}

// ou ceci
declare(ticks=1);
// script entier ici
?>
]]>
     </programlisting>
    </example>
   </para>
   <sect2 id="control-structures.declare.ticks">
    <title>Ticks</title>
    <para>
     Un tick est un événement qui intervient toutes les
    <varname>N</varname> commandes bas niveau, exécutées par l'analyseur
    dans le bloc de <literal>declare</literal>.
    La valeur de <varname>N</varname> est spécifiée avec la syntaxe
    <literal>ticks=<varname>N</varname></literal>
    dans le bloc de directive <literal>declare</literal>.
   </para>
   <para>
    Un événement qui intervient à chaque tick est spécifié avec la fonction
    <function>register_tick_function</function>. Reportez vous à l'exemple
    ci-dessous pour plus de détails. Notez que plus d'un événement peut
    intervenir par tick.
   </para>
   <para>
    <example>
     <title>Profiler une section de code &php;</title>
     <programlisting role="php">
<![CDATA[
<?php
// Un fonction qui enregistre l'heure à laquelle elle est appelée
  function profile($dump = FALSE){
    static $profile;
    // Retourne les horaires stockés dans le profile, et l'efface
    if ($dump) {
        $temp = $profile;
        unset ($profile);
        return ($temp);
    }
    $profile[] = microtime ();
  }

// Enregistre un gestionnaire de tick
  register_tick_function("profile");

// Initialise la fonction avant le bloc de déclaration
  profile();

// Exécute un bloc de code, et appele un tick toutes les deux secondes
  declare (ticks=2) {
    for ($x = 1; $x < 50; ++$x) {
        echo similar_text(md5($x), md5($x*$x)), "<br>";
    }
  }

// Affiche les données de la variable $profile
  print_r(profile(TRUE));
?>
]]>
     </programlisting>
    </example>
     Cet exemple profile le code &php; dans le bloc de déclaration,
     et enregistre l'heure de chaque commande bas niveau. Cette
     information peut être réutilisée pour débusquer les segments
     de code lents. Vous pouvez implémenter d'autres méthodes, mais
     les ticks sont plus rapides et plus efficaces.
   </para>
   <simpara>
    Les ticks sont bien pratiques pour déboguer, implémenter un
    multi-tâches simple, des entrées sorties en tâche de
    fond, ou bien d'autres choses, avec &php;.
   </simpara>
   <simpara>
    Voir aussi
     <function>register_tick_function</function> et
    <function>unregister_tick_function</function>.
   </simpara>
   </sect2>
  </sect1>
  <sect1 id="function.return">
   <title>return</title>
   <simpara>
    Si appelée depuis une fonction, la commande <function>return</function>
    termine immédiatement la fonction, et retourne l'argument qui lui
    est passé. <function>return</function> interromp aussi l'exécution
    de commande <function>eval</function> ou de scripts.
   </simpara>
   <simpara>
    Si appelée depuis l'environnement global, l'exécution du script
    est interrompue. Si le script courant était 
    <function>include</function> ou <function>require</function>,
    alors le contrôle est rendu au script appelant, et la valeur
    retournée sera utilisée comme résultat de la fonction
    <function>include</function>. Si <function>return</function> est
    appelée depuis le script principal, alors l'exécution du script
    s'arrête. Si le script courant est
    <link linkend="ini.auto-prepend-file">auto_prepend_file</link> ou 
    <link linkend="ini.auto-append-file">auto_append_file</link>
    dans le fichier &php.ini;, alors l'exécution du script
    s'arrête.
   </simpara>
   <simpara>
    Pour plus d'informations, voyez 
    <link linkend="functions.returning-values">retourner des valeurs</link>.
   </simpara>
   <note>
    <simpara>
     Notez que puisque <function>return</function> est une structure de langage
     et non pas une fonction, les parenthèses <emphasis>ne sont pas</emphasis> requises :
     en fait, il est classique de les ignorer, même si cela ne change rien.
    </simpara>
   </note>
  </sect1>
  <sect1 id="function.require">
   <title><function>require</function></title>
   <simpara>
    <function>require</function> inclut et exécute un
    fichier &php;.
   </simpara>
   <simpara>
    La commande <function>require</function> se remplace elle-même
    par le contenu du fichier spécifié, tel que
    décrit dans la documentation de la fonction <function>include</function>.
   </simpara>
   <simpara>
    <function>require</function> et <function>include</function> 
    sont identiques, sauf dans leur façon de gérer les erreurs.
     <function>include</function> produite une 
     <link linkend="internal.e-warning">Alerte (warning)</link> tandis
     que <function>require</function> génère une
     <link linkend="internal.e-error">erreur fatale</link>. En
     d'autres termes, n'hésitez pas à utiliser 
     <function>require</function> si vous voulez qu'un fichier
     d'inclusion manquant interrompe votre script.
     <function>include</function> ne se comporte pas de cette façon,
     et le script continuera son exécution. Assurez vous d'avoir
     bien configuré le <link linkend="ini.include-path">include_path</link>
     aussi.
   </simpara>
   <para>
    <example>
     <title>Exemples avec <function>require</function></title>
     <programlisting role="php">
<![CDATA[
<?php
  require 'prepend.php';

  require $somefile;

  require ('unfichier.txt');
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Voyez la documentation de la fonction <function>include</function> pour plus
    d'exemples.
   </simpara>
   <note>
    <simpara>
     Avant &php; 4.0.2, ceci s'appliquait : <function>require</function> tentait
     de lire le fichier cible, même si les lignes n'étaient pas utilisées.
     Une condition if n'avait aucun effet sur <function>require</function>. Cependant,
     si la ligne du <function>require</function> n'est jamais utilisée,
     le code inclus ne le sera pas non plus. De même, les boucles n'ont pas
     d'effet sur le comportement de <function>require</function>. Bien que le
     code contenu dans le fichier subit la boucle, la fonction elle même
     <function>require</function> n'est appelée qu'une fois.
    </simpara>
   </note>
   &note.language-construct;
   &warn.no-win32-fopen-wrapper;
   <simpara>
    Voir aussi
    <function>include</function>, 
    <function>require_once</function>,
    <function>include_once</function>, 
    <function>eval</function>, 
    <function>file</function>, 
    <function>readfile</function>, 
    <function>virtual</function> et 
    <link linkend="ini.include-path">include_path</link>.
   </simpara>
  </sect1>
  <sect1 id="function.include">
   <title><function>include</function></title>
   <simpara>
      La fonction <function>include</function> inclut et exécute
      le fichier spécifié en argument.
   </simpara>
   <simpara>
     Cette documentation s'applique aussi à la fonction 
     <function>require</function>. Les deux structures de
     langage sont identiques, hormis dans leur gestion des
     erreurs. 
     <function>include</function> produit une 
     <link linkend="internal.e-warning">Alerte (warning)</link> tandis
     que <function>require</function> génère une
     <link linkend="internal.e-error">erreur fatale</link>. En
     d'autres termes, n'hésitez pas à utiliser 
     <function>require</function> si vous voulez qu'un fichier
     d'inclusion manquant interrompe votre script.
     <function>include</function> ne se comporte pas de cette façon,
     et le script continuera son exécution. Assurez-vous d'avoir
     bien configuré le <link linkend="ini.include-path">include_path</link>
     aussi. Soyez prévenus qu'une erreur d'analyse dans un fichier 
     inclut ne cause pas l'arrêt du script.
   </simpara>
   <simpara>
    Les fichiers à inclure sont d'abord recherchés dans le dossier
    désigné par <option>include_path</option>, relativement au dossier
    courant, puis dans <option>include_path</option>, relativement au dossier
    de travail du script. Par exemple, si <option>include_path</option>
    est <literal>.</literal>, que le dossier de travail est 
    <filename class="directory">/www/</filename>, et que vous incluez le fichier
    <filename>include/a.php</filename> et qu'il y a une instruction 
    <literal>include "b.php"</literal> dans ce fichier, alors 
    <filename>b.php</filename> est d'abord recherché dans 
    <filename class="directory">/www/</filename>, puis dans 
    <filename class="directory">/www/include/</filename>.
   </simpara>
   <para>
     <example>
      <title>Exemple avec <function>include</function></title>
      <programlisting role="php">
<![CDATA[
vars.php
<?php

$couleur = 'verte';
$fruit = 'pomme';

?>

test.php
<?php

echo "Une $couleur $fruit"; // Une

include 'vars.php';

echo "Une $coleur $fruit"; // Une verte pomme 

?>
]]>
      </programlisting>
     </example>
   </para>
   <simpara>
     Si l'inclusion intervient à l'intérieure d'une fonction,
     le code inclus sera alors considéré comme faisant partie de la
     fonction. Cela modifie donc le contexte de variables accessibles.
   </simpara>
   <para>
     <example>
     <title>Inclusion de fichiers dans une fonction</title>
      <programlisting role="php">
<![CDATA[
<?php

function foo() {
    global $couleur;

    include 'vars.php';

    echo "Une $couleur $fruit"; 
}

/* vars.php est dans le contexte de foo()    *
 * donc $fruit n'est pas dispnibles hors de  *
 * cette fonction. $couleur l'est, car c'est *
 * une variable globale                      */

foo();                      // Une verte pomme 
echo "Une $couleur $fruit"; // Une verte

?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
      Il est important de noter que lorsqu'un fichier est
      <function>include</function> ou <function>require</function>,
      les erreurs d'analyse apparaîtront en HTML tout
      au début du fichier, et l'analyse du fichier
      parent ne sera pas interrompue. Pour cette raison, le code
      qui est dans le fichier doit être placé entre
      <link linkend="language.basic-syntax.phpmode">les balises
      habituelles de &php;</link>.
   </simpara>
   <simpara>
     Si les <link linkend="ini.allow-url-fopen">Gestionnaires d'URL</link>
     sont activés dans &php; (ce qui est le cas par défaut),
     vous pouvez localiser le fichier avec une URL (via HTTP ou
     bien avec un gestionnaire adapté : voir <xref linkend="wrappers"/>
     pour une liste des protocoles), au lieu d'un simple chemin
     local. Si le serveur distant interprête le fichier comme du code
     &php;, des variables peuvent être transmises au serveur distant
     via l'URL et la méthode GET. Ce n'est pas, à strictement
     parler, la même chose que d'hériter du contexte de variable.
     Le fichier inclus est en fait un script exécuté à distance,
     et son résultat est inclus dans le code courant.
   </simpara>
   &warn.no-win32-fopen-wrapper;
   <para>
    <example>
     <title>Utiliser <function>include</function> via HTTP</title>
     <programlisting role="php">
<![CDATA[
<?php

/* Cet exemple suppose que www.example.com est configuré pour traiter 
 * les fichiers .php et non pas les fichiers .txt. De plus,
 * 'Work' signifie ici que les variables 
 * $foo et $bar sont disponibles dans le fichier inclus  
 */

// Ne fonctionne pas : file.txt n'a pas été traité par www.example.com comme du PHP
include 'http://www.example.com/file.txt?foo=1&bar=2';

// Ne fonctionne pas : le script cherche un fichier nommé 
// 'file.php?foo=1&bar=2' sur le système local
include 'file.php?foo=1&bar=2';

// Réussi
include 'http://www.example.com/file.php?foo=1&bar=2';

$foo = 1;
$bar = 2;
include 'file.txt';  // OK.
include 'file.php';  // OK.

?>
]]>
     </programlisting>
    </example>
     Voir aussi
     <link linkend="features.remote-files">travailler avec les fichiers distants</link>,
     <function>fopen</function> et 
     <function>file</function> pour des informations reliées.
   </para>
   <para>
     Comme <function>include</function> et <function>require</function>
     sont des structures du langage particulières, vous devez les
     placer dans un bloc s'ils sont placés dans un bloc conditionnel.
   </para>
   <para>
    <example>
     <title><function>include</function> et les conditions</title>
     <programlisting role="php">
<![CDATA[
<?php

// Ceci est FAUX et échouera
if ($condition)
    include $file;
else
    include $other;


// Ceci est CORRECT.
if ($condition) {
    include $file;
} else {
    include $other;
}

?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Gestion du retour : il est possible d'exécuter une commande
    <function>return</function> dans un fichier inclus pour en
    terminer le traitement et retourner au fichier appelant. De plus,
    il est possible de retourner des valeurs des fichiers inclus.
    vous pouvez prendre et traiter la valeur retournée par la 
    fonction, comme toute autre fonction.
   </simpara>
   <note>
    <simpara>
     En &php; 3, le return n'est pas utilisable à moins que ce
     ne soit dans un bloc de fonction, auquel cas le 
     <function>return</function> s'applique à une fonction et non
     pas au fichier.
    </simpara>
   </note>
   <para>
    <example>
     <title><function>include</function> et <function>return</function></title>
      <programlisting role="php">
<![CDATA[
return.php
<?php
$var = 'PHP';
return $var;
?>

noreturn.php
<?php
$var = 'PHP';
?>

testreturns.php
<?php
$foo = include 'return.php';
echo $foo; // affiche 'PHP'
$bar = include 'noreturn.php';
echo $bar; // affiche 1

?>
]]>
      </programlisting>
    </example>
   </para>
   <simpara>
    <literal>$bar</literal> a la valeur de <literal>1</literal> car
    l'inclusion était réussie. Notez la différence entre les deux
    exemples ci-dessus. Le premier utilise la commande <function>return</function> 
    dans le fichier inclus, alors que le second ne le fait pas.
    Un autre moyen d'inclure des fichiers dans des variables
    est d'utiliser la fonction <function>fopen</function> ou
    <function>file</function> ou d'utiliser 
    <function>include</function> avec les 
    <link linkend="ref.outcontrol">fonctions de contrôle de sortie</link>.
   </simpara>
   &note.language-construct;

   <simpara>
    Voir aussi 
    <function>require</function>, 
    <function>require_once</function>,
    <function>include_once</function>, 
    <function>readfile</function>,
    <function>virtual</function> et
    <link linkend="ini.include-path">include_path</link>.
   </simpara>
   </sect1>
    <sect1 id="function.require-once">
   <title><function>require_once</function></title>
   <para>
    La commande <function>require_once</function> se remplace elle-même
    par le fichier spécifié, un peu comme les commandes de
    préprocesseur C <literal>#include</literal>, et ressemble sur
    ce point à <function>require</function>. La principale
    différence est qu'avec <function>require_once</function>,
    vous êtes assurés que ce code ne sera ajouté
    qu'une seule fois, évitant de ce fait les redéfinitions de
    variables ou de fonctions, génératrices d'alertes.
   </para>
   <para>
    <function>require_once</function> doit être utilisée dans les cas
    où le même fichier risque d'être inclus et évalué plusieurs fois
    durant l'exécution d'un script. Vous serez alors sûrs qu'il ne sera inclut qu'une fois
    et vous éviterez les problèmes de re-déclarations de fonctions ou autres.
   </para>
   <para>
    Pour des exemples avec <function>require_once</function> et
    <function>include_once</function>, reportez-vous au code 
    <ulink url="&url.php.pear;">PEAR</ulink> inclus dans les 
    dernières distributions &php;.
   </para>
   <note>
    <para>
     <function>require_once</function> a été ajouté en &php; 4.0.1pl2
    </para>
   </note>
   <note>
    <para>
     Attention, <function>require_once</function> et 
     <function>include_once</function> sont insensibles à la casse
     sous Windows.
     <example>
      <title><function>require_once</function> est insensible à la casse sur Windows</title>
      <programlisting role="php">
<![CDATA[
require_once("a.php"); // ceci inclut le fichier a.php
require_once("A.php"); // ceci inclut encore le fichier a.php sous Windows!
]]>
       </programlisting>
     </example>
    </para>
   </note>
   &warn.no-win32-fopen-wrapper;
   <para>
    Voir aussi 
    <function>require</function>,
    <function>include</function>, 
    <function>include_once</function>,
    <function>get_required_files</function>,
    <function>get_included_files</function>, 
    <function>readfile</function> et
	<function>virtual</function>.
   </para>
  </sect1>
  <sect1 id="function.include-once">
   <title><function>include_once</function></title>
   <para>
    La commande <function>include_once</function> inclut et
    évalue le fichier spécifié durant
    l'exécution du script. Le comportement est similaire à
    <function>include</function>, mais la différence est que si
    le code a déjà été inclus, il ne le
    sera pas une seconde fois.
   </para>
   <para>
    La fonction <function>include_once</function> est utilisée de
    préférence lorsque le	fichier doit être
    inclus ou évalué plusieurs fois dans un script,
    ou bien	lorsque vous voulez être sûr qu'il ne sera inclus
    qu'une seule fois, pour éviter des redéfinitions
    de fonction.
   </para>
   <para>
    Pour plus d'exemples avec <function>require_once</function> et
    <function>include_once</function>, jetez un oeil dans le code de PEAR
	inclus dans la dernière distribution de &php;.
   </para>
   <note>
    <para>
     <function>include_once</function> a été ajouté en &php; 4.0.1pl2
    </para>
   </note>
   <note>
    <para>
     Attention, <function>require_once</function> et 
     <function>include_once</function> sont insensibles à la casse
     sous Windows.
     <example>
      <title>
       <function>include_once</function> est insensible à la casse sous Windows
      </title>
      <programlisting role="php">
<![CDATA[
include_once("a.php"); // ceci inclut le fichier a.php
include_once("A.php"); // ceci inclut encore le fichier a.php sous Windows!
]]>
       </programlisting>
     </example>
    </para>
   </note>
   &warn.no-win32-fopen-wrapper;
   <para>
    Voir aussi 
    <function>require</function>,
    <function>include</function>, 
    <function>require_once</function>,
    <function>get_required_files</function>,
    <function>get_included_files</function>, 
    <function>readfile</function> et 
    <function>virtual</function>.
   </para>
  </sect1>
 </chapter>
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
indent-tabs-mode:nil
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
