<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.6 $ -->
<!-- EN-Revision: 1.7 Maintainer: yannick Status: ready -->
<!-- Reviewed: yes -->

<sect1 xml:id="language.types.array">
 <title>Les tableaux</title>

 <para>
  Un tableau en PHP est actuellement une carte ordonnée. Une carte est un type
  qui associe des <emphasis>valeurs</emphasis> en <emphasis>clés</emphasis>.
  Ce type est optimisé pour différentes utilisations ; il peut être considéré
  comme un tableau, une liste, une table de hashage, un dictionnaire, une
  collection, une pile, une file d'attente et probablement plus. On peut avoir,
  comme valeur d'un tableau, d'autres tableaux, multidimensionnels ou non.
 </para>

 <para>
  La structure de ces données dépasse l'objet de ce manuel, mais vous trouverez
  au moins un exemple pour chacun des cas évoqués. Pour plus d'informations,
  reportez-vous aux différentes explications sur le sujet que l'on trouve
  sur le web.
 </para>

 <sect2 xml:id="language.types.array.syntax">
  <title>Syntaxe</title>

  <sect3 xml:id="language.types.array.syntax.array-func">
   <title>Syntaxe d'un tableau</title>

   <para>
    Un tableau peut être créé avec le constructeur de langage
    <function>array</function>. Il prend un nombre illimité de paramètres,
    chacun séparé par une virgule, sous la forme d'une paire
    <literal><replaceable>clé</replaceable> =&gt;
    <replaceable>valeur</replaceable></literal>.
   </para>

   <synopsis>
array( <optional> <replaceable>clé</replaceable> =&gt; </optional> <replaceable>valeur</replaceable>
     , ...
     )
// <replaceable>clé</replaceable> ne peut être qu'un &integer; ou une &string;
// <replaceable>valeur</replaceable> peut être de n'importe quel type</synopsis>
   <!-- Do not fix the whitespace for the synopsis end element. A limitation of PhD prevents proper trimming -->

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$arr = array("foo" => "bar", 12 => true);

echo $arr["foo"]; // bar
echo $arr[12];    // 1
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Une <varname>clé</varname> peut être soit un &integer;, soit une &string;.
    Si une clé est une représentation standard d'un &integer;, elle sera interprétée
    comme telle (i.e. <literal>"8"</literal> sera interprété comme <literal>8</literal>,
    alors que <literal>"08"</literal> sera interprétée comme <literal>"08"</literal>).
    Les nombres à virgule flottante, en tant que clé, seront tronqués en &integer;.
    Les tableaux indexés ou associatifs, en PHP, sont du même type ; ils peuvent
    ainsi contenir des indices sous la forme d'&integer; et de &string;.
   </para>

   <para>
    Une valeur peut être de n'importe quel type PHP.
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$arr = array("somearray" => array(6 => 5, 13 => 9, "a" => 42));

echo $arr["somearray"][6];    // 5
echo $arr["somearray"][13];   // 9
echo $arr["somearray"]["a"];  // 42
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Si une clé n'est pas spécifiée pour une valeur, l'indice &integer; maximal
    sera pris et la nouvelle clé sera cette valeur, plus 1. Si une clé contient
    déjà une valeur associée, cette valeur sera écrasée.
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
// Ce tableau est identique à ...
array(5 => 43, 32, 56, "b" => 12);

// ...ce tableau
array(5 => 43, 6 => 32, 7 => 56, "b" => 12);
?>
]]>
    </programlisting>
   </informalexample>

   <warning>
    <simpara>
     Avant PHP 4.3.0, le fait d'ajouter à un tableau une valeur, dont la précédent
     clé est négative, reproduisait le comportement ci-dessus. Depuis PHP 4.3.0, la
     nouvelle clé sera <literal>0</literal>.
    </simpara>
   </warning>

   <para>
    Utiliser &true; comme <varname>clé</varname> sera évalué à l'&integer; <literal>1</literal>.
    Utiliser &false; comme <varname>clé</varname> sera évalué à l'&integer; <literal>0</literal>.
    Utiliser &null; comme clé sera évalué à une &string; vide.
    Utiliser une &string; vide comme clé créera une clé (ou l'écrasera) vide et sa valeur
    ne sera <emphasis>pas</emphasis> la même si on utilise des parenthèses vides.
   </para>

   <para>
    Les tableaux et les objets ne peuvent être utilisés comme clés. Si vous tentez de le faire,
    une message de type Alerte sera émis : <literal>Illegal offset type</literal>.
   </para>

  </sect3>

  <sect3 xml:id="language.types.array.syntax.modifying">
   <title>Création/modification avec des crochets</title>

   <para>
    Un tableau existant peut être modifié en y assignant explicitement des valeurs.
   </para>

   <para>
    L'assignation d'une valeur dans un tableau est effectué en spécifiant
    la clé, entre crochets. La clé peut également ne pas être renseignée, sous
    la forme : <literal>[]</literal>.
   </para>

   <synopsis>
$arr[<replaceable>clé</replaceable>] = <replaceable>valeur</replaceable>;
$arr[] = <replaceable>valeur</replaceable>;
// <replaceable>clé</replaceable> peut être un &integer; ou une &string;
// <replaceable>valeur</replaceable> peut être n'importe quel type</synopsis>

   <para>
    Si <varname>$arr</varname> n'existe pas lors de l'assignation, il sera
    créé ; c'est ainsi une façon détournée de créer un tableau. Pour modifier
    une valeur en particulier, il convient d'assigner une valeur en spécifiant
    sa clé. Pour effacer une paire clé/valeur, il convient d'appeler la fonction
    <function>unset</function> sur la clé désirée.
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$arr = array(5 => 1, 12 => 2);

$arr[] = 56;    // Identique à $arr[13] = 56;
                // à cet endroit du script

$arr["x"] = 42; // Ceci ajoute un nouvel élément au
                // tableau avec la clé "x"

unset($arr[5]); // Ceci efface l'élément du tableau

unset($arr);    // Ceci efface complètement le tableau
?>
]]> 
    </programlisting>
   </informalexample>

   <note>
    <para>
     Comme dit plus haut, si aucune clé n'est spécifiée, l'indice maximal
     existant est repris, et la nouvelle clé sera ce nombre, plus 1. Si
     aucun indice entier n'existe, la clé sera <literal>0</literal> (zéro).
     Si une clé existe, sa valeur sera écrasée.
    </para>

    <para>
     Notez que la clé entière maximale pour cette opération <emphasis>n'a
     pas besoin d'exister dans le tableau au moment de la manipulation</emphasis>.
     Elle doit seulement avoir existé dans le tableau à un moment ou un autre
     depuis la dernière fois où le tableau a été ré-indexé.
     Voici un exemple qui illustre ce principe :
    </para>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// Création d'un tableau simple.
$array = array(1, 2, 3, 4, 5);
print_r($array);

// Maintennant, on efface tous les éléments, mais on concerne le tableau :
foreach ($array as $i => $value) {
    unset($array[$i]);
}
print_r($array);

// Ajout d'un élément (notez que la nouvelle clé est 5, et non 0).
$array[] = 6;
print_r($array);

// Ré-indexation :
$array = array_values($array);
$array[] = 7;
print_r($array);
?>
]]> 
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Array
(
    [0] => 1
    [1] => 2
    [2] => 3
    [3] => 4
    [4] => 5
)
Array
(
)
Array
(
    [5] => 6
)
Array
(
    [0] => 6
    [1] => 7
)
]]>
     </screen>
    </informalexample>

   </note>

  </sect3>
 </sect2><!-- end syntax -->

 <sect2 xml:id="language.types.array.useful-funcs">
  <title>Fonctions utiles</title>

  <para>
   Il y a beaucoup de fonctions utiles pour travailler avec les tableaux.
   Nous vous invitons à lire la section de ce manuel sur les
   <link linkend="ref.array">fonctions</link> en rapport avec les tableaux.
  </para>

  <note>
   <para>
    La fonction <function>unset</function> permet d'effacer les clés d'un tableau.
    Soyez attentif sur le fait que le tableau ne sera <emphasis>pas</emphasis>
    ré-indexé. Si vous voulez réaliser un effacement complet et une ré-indexation
    de votre tableau, vous devez utiliser la fonction
    <function>array_values</function>.
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$a = array(1 => 'one', 2 => 'two', 3 => 'three');
unset($a[2]);
/* produira un tableau comme ceci
   $a = array(1 => 'one', 3 => 'three');
   et NON un tableau comme ceci
   $a = array(1 => 'one', 2 =>'three');
*/

$b = array_values($a);
// Maintenant, $b vaut array(0 => 'one', 1 =>'three')
?>
]]>
    </programlisting>
   </informalexample>
  </note>

  <para>
   La structure de contrôle <link linkend="control-structures.foreach">foreach</link>
   existe tout spécialement pour les tableaux. Elle fournit une manière pratique
   de parcourir un tableau.
  </para>
 </sect2>

 <sect2 xml:id="language.types.array.donts">
  <title>Ce qu'il est possible de faire ou non avec un tableau</title>

  <sect3 xml:id="language.types.array.foo-bar">
   <title>Pourquoi <literal>$foo[bar]</literal> est incorrect ?</title>

   <para>
    Utiliser toujours des guillemets autour d'un index littéral. Par exemple,
    <literal>$foo['bar']</literal> est correct, alors que
    <literal>$foo[bar]</literal> ne l'est pas. Mais pourquoi ? il est courant
    de rencontrer ce genre de syntaxe dans d'ancien script :
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$foo[bar] = 'enemy';
echo $foo[bar];
// etc
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    C'est incorrect, mais ça fonctionne. La raison est que ce code a une constante
    indéfinie (bar) plutôt qu'une chaîne ('bar' - noter les guillemets). PHP
    peut définir plus loin une constante portant le même nom.
    Cela fonctionne car PHP convertit automatiquement une <emphasis>chaîne nue</emphasis>
    (une chaîne sans guillemets qui ne correspond à aucun symbole connu) en une chaîne
    qui la contient. Actuellement, s'il n'y a aucune constante nommée <constant>bar</constant>,
    alors PHP substituera <literal>'bar'</literal> dans la chaîne et l'utilisera.
   </para>

   <note>
    <simpara>
     Ceci ne signifie pas qu'il faut <emphasis>toujours</emphasis> mettre la clé entre guillemets.
     N'utilisez pas de guillemets avec les clés qui sont des
     <link linkend="language.constants">constantes</link> ou des
     <link linkend="language.variables">variables</link>, car cela empêcherait PHP de
     les interpréter.
    </simpara>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
error_reporting(E_ALL);
ini_set('display_errors', true);
ini_set('html_errors', false);
// Tableau simple :
$array = array(1, 2);
$count = count($array);
for ($i = 0; $i < $count; $i++) {
    echo "\nVérification de $i : \n";
    echo "Mauvais : " . $array['$i'] . "\n";
    echo "Bon : " . $array[$i] . "\n";
    echo "Mauvais : {$array['$i']}\n";
    echo "Bon : {$array[$i]}\n";
}
?>
]]>
     </programlisting>
    </informalexample>
    &example.outputs;
    <screen>
<![CDATA[
Vérification de 0 :
Notice: Undefined index:  $i in /path/to/script.html on line 9
Mauvais :
Bon : 1
Notice: Undefined index:  $i in /path/to/script.html on line 11
Mauvais :
Bon : 1

Vérification de 1 :
Notice: Undefined index:  $i in /path/to/script.html on line 9
Mauvais :
Bon : 2
Notice: Undefined index:  $i in /path/to/script.html on line 11
Mauvais :
Bon : 2
]]>
    </screen>
   </note>

   <para>
    Plus d'exemples pour expliquer ce comportement :
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
// Affichons toutes les erreurs
error_reporting(E_ALL);

$arr = array('fruit' => 'apple', 'veggie' => 'carrot');

// Correct
print $arr['fruit'];  // apple
print $arr['veggie']; // carrot

// Incorrect.  Ceci fonctionne mais PHP émettera une erreur de type E_NOTICE car
// on utilise la constante nommée fruit qui est indéfinie
// 
// Notice: Use of undefined constant fruit - assumed 'fruit' in...
print $arr[fruit];    // apple

// Ceci définit une constante pour expliquer ce qu'il ne va pas. La valeur 'veggie'
// est assignée à la constante nommée fruit.
define('fruit', 'veggie');

// Noter la différence maintenant
print $arr['fruit'];  // apple
print $arr[fruit];    // carrot

// Ce qui squit est correct, car c'est dans une chaîne. Les constantes ne sont pas recherchées
// dans les chaînes, et donc, aucune alerte E_NOTICE ne sera émise
print "Hello $arr[fruit]";      // Hello apple

// Avec une exception : les parenthèses autour d'un tableau dans une chaîne permettent
// aux constantes d'être interprétées
print "Hello {$arr[fruit]}";    // Hello carrot
print "Hello {$arr['fruit']}";  // Hello apple

// Ceci ne fonctionnera pas, et en résultera une erreur d'analyse, comme ceci :
// Parse error: parse error, expecting T_STRING' or T_VARIABLE' or T_NUM_STRING'
// Ceci arrive lors de l'utilisation d'une supergloables dans les chaînes
print "Hello $arr['fruit']";
print "Hello $_GET['foo']";

// La concaténation est une autre solution
print "Hello " . $arr['fruit']; // Hello apple
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Lorsque <link linkend="ini.error-reporting">error_reporting</link> est défini afin
    de montrer les erreurs de type <constant>E_NOTICE</constant> (en le définissant à
    <constant>E_ALL</constant>, par exemple), une telle pratique devient immédiatement
    visible. Par défaut,
    <link linkend="ini.error-reporting">error_reporting</link> n'est pas défini pour
    afficher toutes les alertes.
   </para>

   <para>
    Comme vu dans la section "<link linkend="language.types.array.syntax">syntaxe</link>",
    ce qui se trouve entre crochets ('<literal>[</literal>' et
    '<literal>]</literal>') doit être une expression. Ceci signifie que le code ci-dessous
    fonctionne :
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
echo $arr[somefunc($bar)];
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    C'est un exemple d'utilisation d'une fonction retournant une valeur qui sera
    la clé du tableau. PHP comprend également les constantes :
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$error_descriptions[E_ERROR]   = "A fatal error has occured";
$error_descriptions[E_WARNING] = "PHP issued a warning";
$error_descriptions[E_NOTICE]  = "This is just an informal notice";
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Noter que <literal>E_ERROR</literal> est également un identifiant valide,
    tout comme <literal>bar</literal> dans le premier exemple. Mais le dernier
    exemple est finalement le même que celui-ci :
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$error_descriptions[1] = "A fatal error has occured";
$error_descriptions[2] = "PHP issued a warning";
$error_descriptions[8] = "This is just an informal notice";
?>
]]>
    </programlisting>
   </informalexample>
   
   <para>
    car <literal>E_ERROR</literal> vaut <literal>1</literal>, etc.
   </para>

   <sect4 xml:id="language.types.array.foo-bar.why">
    <title>Alors, pourquoi est-ce une mauvaise pratique ?</title>

    <para>
     Dans le futur, les développeurs PHP peuvent vouloir ajouter une autre
     constante ou un autre mot clé, ou bien une constante dans une autre partie
     du code qui peut interférer. Par exemple, il est toujours incorrect d'utiliser
     le mot <literal>empty</literal> et <literal>default</literal>, sachant que ce sont
     des <link linkend="reserved">mots réservés</link>.
    </para>

    <note>
     <simpara>
      Pour être plus clair, dans une chaîne entourée de guillemets doubles,
      il est valide de ne pas entourer les indexes d'un tableau avec des
      guillemets, et donc, <literal>"$foo[bar]"</literal> est valide. Voir
      les exemples ci-dessous pour plus détails mais aussi la section sur
      l'<link linkend="language.types.string.parsing">analyse des variables
      dans les chaînes</link>.
     </simpara>
    </note>

   </sect4>
  </sect3>
 </sect2>

 <sect2 xml:id="language.types.array.casting">
  <title>Conversion en un tableau</title>

  <para>
   Pour tous les types : &integer;, &float;, &string;, &boolean; et &resource;,
   le fait de convertir une valeur en un tableau résulte en un tableau contenant
   un seul élément dont l'indexe vaut zéro et la valeur, une valeur scalaire convertie.
   En d'autres termes, <literal>(array)$scalarValue</literal> est exactement la
   même chose que <literal>array($scalarValue)</literal>.
  </para>

  <para>
   Si un objet est converti en un tableau, le résultat sera un tableau dont les
   éléments sont les propriétés de l'objet. Les clés sont les noms des membres,
   avec une légère exception : les variables ayant un nom sous forme d'entier sont
   inaccessible; les variables privées auront le nom de la classe
   ajouté au nom de la variable ; les variables protégées auront un '*' ajouté
   au nom de la variable. Ce comportement peut amener à des résultats inattendus :
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php

class A {
    private $A; // Ceci devient '\0A\0A'
}

class B extends A {
    private $A; // Ceci devient '\0B\0A'
    public $AA; // Ceci devient 'AA'
}

var_dump((array) new B());
?>
]]>
   </programlisting>
  </informalexample>

  <para>
   Ici, on pourrait penser qu'il y a 2 clés nommées 'AA', alors qu'une est
   actuellement nommée '\0A\0A'.
  </para>

  <para>
   La conversion de &null; en un tableau résultat en un tableau vide.
  </para>
 </sect2>

 <sect2 xml:id="language.types.array.comparing">
  <title>Comparaison</title>

  <para>
   Il est possible de comparer plusieurs tableaux avec la fonction
   <function>array_diff</function> ainsi qu'avec les
   <link linkend="language.operators.array">opérateurs de tableaux</link>.
  </para>
 </sect2>

 <sect2 xml:id="language.types.array.examples">
  <title>Exemples</title>

  <para>
   Le type tableau en PHP est vraiment versatile. Voici quelques exemples :
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
// This
$a = array( 'color' => 'red',
            'taste' => 'sweet',
            'shape' => 'round',
            'name'  => 'apple',
             4        // la clé sera 0
          );

// est strictement équivalent à
$a = array();
$a['color'] = 'red';
$a['taste'] = 'sweet';
$a['shape'] = 'round';
$a['name']  = 'apple';
$a[]        = 4;        // la clé sera 0

$b[] = 'a';
$b[] = 'b';
$b[] = 'c';

// Après exécution du code ci-dessus, $a sera le tableau
// array('color' => 'red', 'taste' => 'sweet', 'shape' => 'round', 
// 'name' => 'apple', 0 => 4), et $b sera le tableau
// array(0 => 'a', 1 => 'b', 2 => 'c'), ou simplement array('a', 'b', 'c').
?>
]]>
   </programlisting>
  </informalexample>

  <example>
   <title>Utilisation de array()</title>
   <programlisting role="php">
<![CDATA[
<?php
// Tableau comme carte de propriétés
$map = array( 'version'    => 4,
              'OS'         => 'Linux',
              'lang'       => 'english',
              'short_tags' => true
            );

// clés numériques strictes
$array = array( 7,
                8,
                0,
                156,
                -10
              );
// est identique à array(0 => 7, 1 => 8, ...)

$switching = array(         10, // clé = 0
                    5    =>  6,
                    3    =>  7, 
                    'a'  =>  4,
                            11, // clé = 6 (l'indice entier maximal est 5)
                    '8'  =>  2, // clé = 8 (intier !)
                    '02' => 77, // clé = '02'
                    0    => 12  // la valeur 10 sera écrasée par la valeur 12
                  );

// empty array
$empty = array();
?>
]]>
   </programlisting>
  </example>

  <example xml:id="language.types.array.examples.loop">
   <title>Collection</title>
   <programlisting role="php">
<![CDATA[
<?php
$colors = array('rouge', 'bleu', 'verte', 'jaune');

foreach ($colors as $color) {
    echo "Aimez-vous la couleur $color ?\n";
}

?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Aimez-vous la couleur rouge ?
Aimez-vous la couleur bleu ?
Aimez-vous la couleur verte ?
Aimez-vous la couleur jaune ?
]]>
   </screen>
  </example>

  <para>
   La modification directe de valeurs d'un tableau est possible depuis PHP 5
   en le passant par référence. Avant cette version, nous devions utiliser l'astuce
   suivante :
  </para>

  <example xml:id="language.types.array.examples.changeloop">
   <title>Collection</title>
   <programlisting role="php">
<![CDATA[
<?php
// PHP 5
foreach ($colors as &$color) {
    $color = strtoupper($color);
}
unset($color); /* On s'assure que les écritures suivantes
sur $color ne modifie pas le dernier élément du tableau */

// Astuce pour les anciennes versions
foreach ($colors as $key => $color) {
    $colors[$key] = strtoupper($color);
}

print_r($colors);
?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [0] => ROUGE
    [1] => BLEU
    [2] => VERTE
    [3] => JAUNE
)
]]>
   </screen>
  </example>

  <para>
   Cet exemple crée un tableau, dont l'indexation commence à 1.
  </para>

  <example>
   <title>Indexation commençant à 1</title>
   <programlisting role="php">
<![CDATA[
<?php
$firstquarter  = array(1 => 'Janvier', 'Février', 'Mars');
print_r($firstquarter);
?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array 
(
    [1] => 'Janvier'
    [2] => 'Février'
    [3] => 'Mars'
)
]]>
   </screen>
  </example>

  <example>
   <title>Remplissage d'un tableau</title>
   <programlisting role="php">
<![CDATA[
<?php
// Remplit un tableau avec tous les éléments d'un dossier
$handle = opendir('.');
while (false !== ($file = readdir($handle))) {
    $files[] = $file;
}
closedir($handle); 
?>
]]>
   </programlisting>
  </example>

  <para>
   Les tableaux sont ordonnés. L'ordre peut être modifié en utilisant plusieurs
   fonctions. Voir la section sur les <link linkend="ref.array">fonctions sur les
   tableaux</link> pour plus d'informations. La fonction <function>count</function>
   peut être utilisée pour compter le nombre d'éléments d'un tableau.
  </para>

  <example>
   <title>Trie d'un tableau</title>
   <programlisting role="php">
<![CDATA[
<?php
sort($files);
print_r($files);
?>
]]>
   </programlisting>
  </example>

  <para>
   Sachant que la valeur d'une tableau peut être n'importe quoi, elle peut
   aussi être un autre tableau. Ceci permet la création de tableaux récursifs
   et de tableaux multidimensionnels.
  </para>

  <example>
   <title>Tableaux récursifs et multidimensionnels</title>
   <programlisting role="php">
<![CDATA[
<?php
$fruits = array ( "fruits"  => array ( "a" => "orange",
                                       "b" => "banana",
                                       "c" => "apple"
                                     ),
                  "numbers" => array ( 1,
                                       2,
                                       3,
                                       4,
                                       5,
                                       6
                                     ),
                  "holes"   => array (      "first",
                                       5 => "second",
                                            "third"
                                     )
                );

// Quelques exemples pour retrouver les valeurs dans le tableau ci-dessus 
echo $fruits["holes"][5];    // affiche "second"
echo $fruits["fruits"]["a"]; // affiche "orange"
unset($fruits["holes"][0]);  // efface "first"

// Création d'un tableau multi-dimensionnel
$juices["apple"]["green"] = "good"; 
?>
]]>
   </programlisting>
  </example>

  <para>
   L'assignation d'un tableau induit toujours la copie des valeurs.
   Utilisez l'<link linkend="language.operators">opérateur de référence</link>
   pour copier un tableau par référence.
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$arr1 = array(2, 3);
$arr2 = $arr1;
$arr2[] = 4; // $arr2 est modifié,
             // $arr1 vaut toujours array(2, 3)

$arr3 = &$arr1;
$arr3[] = 4; // maintenant, $arr1 et $arr3 sont identiques
?>
]]>
   </programlisting>
  </informalexample>

 </sect2>
</sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->