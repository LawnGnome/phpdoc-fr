<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.2 $ -->
<!-- EN-Revision: 1.10 Maintainer: yannick Status: ready -->
<!-- Reviewed: no -->

<sect1 xml:id="language.types.string">
 <title>Les chaînes de caractères</title>

 <para>
  Une &string; est une série de caractères. Avant PHP 6, un caractère est
  la même chose qu'un octet. Ainsi, il y a exactement 256 caractères différents.
  Ceci impliquait également que PHP n'avait pas de support natif pour l'unicode.
  Voir les fonctions <function>utf8_encode</function> et <function>utf8_decode</function>
  pour des fonctionnalités Unicode basiques.
 </para>

 <note>
  <simpara>
   Ce n'est pas un problème pour une &string; de devient très grande. PHP
   n'impose pas de taille à une &string; ; la seule limite est la mémoire
   disponible sur le système sous lequel PHP s'exécute.
  </simpara>
 </note>

 <sect2 xml:id="language.types.string.syntax">
  <title>Syntaxe</title>

  <para>
   Une &string; litérale peut être spécifiée de 4 façons différentes :
  </para>

  <itemizedlist>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.single">Entourée de simple guillemet</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.double">Entourée de guillemet double</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.heredoc">syntaxe heredoc</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.nowdoc">syntax nowdoc</link>
     (depuis PHP 5.3.0)
    </simpara>
   </listitem>
  </itemizedlist>

  <sect3 xml:id="language.types.string.syntax.single">
   <title>Entourée de simple guillemet</title>

   <para>
    La façon la plus simple de spécifier une &string; est de l'entourer de guillemet
    simple (le caractère <literal>'</literal>).
   </para>

   <para>
    Pour spécifier un guillemet simple litéral, vous devrez l'échapper d'un antislash
    (<literal>\</literal>). Pour spécifier un antislash litéral avant un guillemet simple,
    ou à la fin d'une &string;, échappez-le deux fois (<literal>\\</literal>).
    Notez que si vous tentez d'échapper n'importe quel autre caractère, l'antislash
    s'affichera.
   </para>

   <note>
    <simpara>
     Contrairement aux 2 autres syntaxes, les
     <link linkend="language.variables">variables</link> et les séquences échappées
     des caracères spéciaux ne soront <emphasis>pas</emphasis> traitées lorsqu'elles
     seront dans une &string; entourée de simple guillemet.
    </simpara>
   </note>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
echo 'ceci est une chaîne simple';

echo 'Vous pouvez également ajouter des nouvelles lignes
dans vos chaînes
de cette façon';

// Affiche : Arnold dit : "I'll be back"
echo 'Arnold dit : "I\'ll be back"';

// Affiche : Voulez-vous supprimer C:\*.*?
echo 'Voulez-vous supprimer C:\\*.*?';

// Affiche : Voulez-vous supprimer C:\*.*?
echo 'Voulez-vous supprimer C:\*.*?';

// Affiche : Ceci n'affichera pas \n de nouvelle ligne
echo 'Ceci n\'affichera pas \n de nouvelle ligne';

// Affiche : Les variables ne seront pas $traitees $ici
echo 'Les variables ne seront pas $traitees $ici';
?>
]]>
    </programlisting>
   </informalexample>

  </sect3>

  <sect3 xml:id="language.types.string.syntax.double">
   <title>Entourée de guillement double</title>

   <para>
    Si la &string; est entourée de guillemet double ("), PHP interprétera
    plus de séquences échappées pour les caractères spéciaux :
   </para>

   <table>
    <title>Caractères échappés</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>Séquence</entry>
       <entry>Signification</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal>\n</literal></entry>
       <entry>Fin de ligne (LF ou 0x0A (10) en ASCII)</entry>
      </row>
      <row>
       <entry><literal>\r</literal></entry>
       <entry>Retour à la ligne (CR ou 0x0D (13) en ASCII)</entry>
      </row>
      <row>
       <entry><literal>\t</literal></entry>
       <entry>Tabulation horizontale (HT or 0x09 (9) en ASCII)</entry>
      </row>
      <row>
       <entry><literal>\v</literal></entry>
       <entry>Tabulation verticale (VT or 0x0B (11) en ASCII) (depuis PHP 5.2.5)</entry>
      </row>
      <row>
       <entry><literal>\f</literal></entry>
       <entry>Saut de page (FF ou 0x0C (12) en ASCII) (depuis PHP 5.2.5)</entry>
      </row>
      <row>
       <entry><literal>\\</literal></entry>
       <entry>Antislash</entry>
      </row>
      <row>
       <entry><literal>\$</literal></entry>
       <entry>Signe dollars</entry>
      </row>
      <row>
       <entry><literal>\"</literal></entry>
       <entry>Guillemet double</entry>
      </row>
      <row>
       <entry><literal>\[0-7]{1,3}</literal></entry>
       <entry>
        La séquence de caractères correspondant à une expression régulière
        est un caractère, en notation octal
       </entry>
      </row>
      <row>
       <entry><literal>\x[0-9A-Fa-f]{1,2}</literal></entry>
       <entry>
        La séquence de caractères correspondant à une expression régulière
        est un caractère, en notation héxadécimale
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    De la même façon que pour les chaînes entourées de simple guillemet,
    l'échappement de tout autre caractère affichera l'antislash. Avant PHP 5.1.1,
    l'antislash de <literal>\{$var}</literal> été également affiché.
   </para>

   <para>
    La fonctionnalité la plus intéressante des chaînes entourées de guillement
    double est que les noms de variables sont traités. Voir la documentation sur
    <link linkend="language.types.string.parsing">l'analyse des chaînes de caractères</link>
    pour plus de détails.
   </para>
  </sect3>

  <sect3 xml:id="language.types.string.syntax.heredoc">
   <title>Syntaxe Heredoc</title>

   <simpara>
    Une 3ème façon de délimiter une &string; est la syntaxe Heredoc :
    <literal>&lt;&lt;&lt;</literal>. Après cet opérateur, un identifiant
    est fourni, puis, une nouvelle ligne. La chaîne elle-même suit, puis,
    le même identifiant pour fermer la notation.
   </simpara>

   <simpara>
    L'identifiant <emphasis>doit</emphasis> commencer la première colonne de
    la ligne. De plus, l'identifiant doit suivre les mêmes règles que n'importe
    quel libellé PHP : il ne doit contenir que des caractères alphanumériques et
    des underscores, et doit commencer par un caractère non numérique ou un underscore.
   </simpara>

   <warning>
    <simpara>
     Il est très important de noter que la ligne contenant l'identifiant ne
     doit contenir aucun autre caractère, mise à part, <emphasis>éventuellement</emphasis>,
     un point-virgule (<literal>;</literal>). Cela signifie que l'identifiant
     <emphasis>ne doit pas être indenté</emphasis>, et il ne doit y avoir aucun
     espace ou tabulation avant ou après le point-virgule. Il est également important
     de garder à l'esprit que le premier caractère avant l'identifiant de fermeture
     doit être une nouvelle ligne sur les systèmes Unix, incluant Max OS X.
     Le délimiteur de fermeture (pouvant être suivi d'un point-virgule) doit aussi
     être suivi d'une nouvelle ligne.
    </simpara>

    <simpara>
     Si cette règle n'est pas respectée et que l'identifiant de fermeture
     n'est pas "propre", il ne sera pas considéré comme identifiant de fermeture,
     et PHP continuera à en chercher un. Si un identifiant de fermeture "propre"
     n'est pas trouvé avant la fin du fichier courant, une erreur d'analyse
     sera émise à la dernière ligne.
    </simpara>

    <para>
     Heredocs ne peut être utilisé pour initialiser les membres d'une classe.
     Utilisez la syntaxe
     <link linkend="language.types.string.syntax.nowdoc">nowdocs</link> à la place.
    </para>

    <example>
     <title>Exemple invalide</title>
     <programlisting role="php">
<![CDATA[
<?php
class foo {
    public $bar = <<<EOT
bar
EOT;
}
?>
]]>
     </programlisting>
    </example>
   </warning>

   <para>
    Heredoc se comporte exactement comme une chaîne entourée de double guillement,
    sans avoir de double guillement. Cela signifie que les guillements dans une
    syntaxe Heredoc n'ont pas besoin d'être échappés, mais les codes d'échappement
    listés ci-dessus peuvent toujours être utilisés. Les variables seront traitées
    mais les mêmes attentions doivent être prises lorsque vous utilisez des
    variables complexes dans une syntaxe Heredoc.
   </para>

   <example>
    <title>Exemple de chaînes Heredoc</title>
    <programlisting role="php">
<![CDATA[
<?php
$str = <<<EOD
Exemple de chaîne
sur plusieurs lignes
en utilisant la syntaxe heredoc.
EOD;

/* Exemple plus complexe, avec des variables. */
class foo
{
    var $foo;
    var $bar;

    function foo()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'MyName';

echo <<<EOT
Mon nom est "$name". J'affiche quelques $foo->foo.
Maintenant, j'affiche quelques {$foo->bar[1]}.
Et ceci devrait afficher un 'A': \x41
EOT;
?>
]]>
    </programlisting>
   </example>
   &example.outputs;
   <screen>
<![CDATA[
Mon nom est "MyName". J'affiche quelques Foo.
Maintenant, j'affiche quelques Bar2.
Et ceci devrait afficher un 'A': A
]]></screen>
   <note>
    <para>
     Le support de la syntaxe Heredoc a été ajouté en PHP 4.
    </para>
   </note>
  </sect3>

  <sect3 xml:id="language.types.string.syntax.nowdoc">
   <title>Nowdoc</title>
   <para>
    Nowdocs est aux chaînes entourées de guillemet simple ce qu'heredocs est
    aux chaînes entourées de guillement double. nowdoc est spécifié de manière
    similaire à heredoc, mut <emphasis>aucune analyse n'est effectuée</emphasis>
    dans une syntaxe nowdoc. La construction est idéale pour embarquer du code PHP
    oud'autres larges blocs de texte, sans avoir besoin d'échapper quoi que ce soit.
    Cette syntaxe partage les mêmes fonctionnalités que le constructeur SGML
    <literal>&lt;![CDATA[ ]]&gt;</literal>, en ce qu'elle déclare un bloc de texte
    qui ne doit pas être analysé.
   </para>

   <para>
    Nowdoc est identifié avec la même séquence <literal>&lt;&lt;&lt;</literal>
    utilisée par heredocs, mais l'identifiant qui suit est entouré de guillement
    simple,e.g. <literal>&lt;&lt;&lt;'EOT'</literal>. Toutes les règles concernant
    les identifiants heredoc sont également appliquer aux identifiants nowdoc,
    et tout spécialement, celles concernantl'apparence de l'identifiant.
   </para>

   <example>
    <title>Exemple de chaînes Nowdoc</title>
    <programlisting role="php">
<![CDATA[
<?php
$str = <<<'EOD'
Exemple de chaîne
sur plusieurs lignes
en utilisant la syntaxe nowdoc.
EOD;

/* Exemple complexe, avec des variables. */
class foo
{
    public $foo;
    public $bar;

    function foo()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'MyName';

echo <<<'EOT'
Mom nom est "$name". J'affiche quelques $foo->foo.
Maintenant, j'affiche quelques {$foo->bar[1]}.
Ceci ne devrait pas afficher un 'A': \x41
EOT;
?>
]]>
    </programlisting>
   </example>
   &example.outputs;
   <screen>
<![CDATA[
Mom nom est "$name". J'affiche quelques $foo->foo.
Maintenant, j'affiche quelques {$foo->bar[1]}.
Ceci ne devrait pas afficher un 'A': \x41]]></screen>

   <note>
    <para>
     Contrairement à heredocs, nowdocs peut être utilisé dans n'importe quel contexte
     de données statiques. L'exemple typique est l'initialisation de membres ou de constantes
     de classe :
    </para>

    <example>
     <title>Exemple avec des données statiques</title>
     <programlisting role="php">
<![CDATA[
<?php
class foo {
    public $bar = <<<'EOT'
bar
EOT;
}
?>
]]>
     </programlisting>
    </example>
   </note>

   <note>
    <para>
     Le support Nowdoc a été ajouté en PHP 5.3.0.
    </para>
   </note>

  </sect3>

  <sect3 xml:id="language.types.string.parsing">
   <title>Analyse des variables</title>

   <simpara>
    Lorsqu'une &string; est spécifié en guillemet double ou en heredoc,
    les <link linkend="language.variables">variables</link> sont analysées.
   </simpara>

   <simpara>
    Il y a 2 types de syntaxe : une
    <link linkend="language.types.string.parsing.simple">simple</link> et une
    <link linkend="language.types.string.parsing.complex">complexe</link>.
    La syntaxe simple est la plus commune et la plus pratique. Elle fournit
    une façon d'embarquer une variable, un &array; ou un &object; dans une
    chaîne avec un minimum d'effort.
   </simpara>

   <simpara>
    La syntaxe complexe a été introduite en PHP 4, et se reconnait en l'utilisation
    d'accolades autour de l'expression.
   </simpara>

   <sect4 xml:id="language.types.string.parsing.simple">
    <title>Syntaxe simple</title>

    <simpara>
     Si un signe dollars (<literal>$</literal>) est rencontré, l'analyse prendra
     autant de caractères que possible pour former un nom de variable valide.
     Si vous entourez un nom de variable par des accolades explicitement, alors
     le nom de la variable n'aura aucune ambiguïté.
    </simpara>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$beer = 'Heineken';
echo "$beer's taste is great"; // fonctionne ; "'" est un caractère invalide pour les noms de variable
echo "He drank some $beers";   // ne fonctionne pas ; 's' est un caractère valide pour les noms de variable
echo "He drank some ${beer}s"; // fonctionne
echo "He drank some {$beer}s"; // fonctionne
?>
]]>
     </programlisting>
    </informalexample>

    <simpara>
     De la même façon, l'index d'un &array; ou la propriété d'un &object;
     peut être analysé. Avec les indices d'un tableau, les crochets
     (<literal>]</literal>) forment la fin de l'index. Les mêmes règles sont
     appliquées aux propriétés d'objet comme pour les simples variables.
    </simpara>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// Ces exemples sont spécifiques à l'utilisation des tableaux dans des chaînes.
// Lorsqu'ils sont à l'extérieur d'une chaîne, quottez toujours les chaînes représentant
// les clés du tableau et n'utilisez pas d'{accolades}.

// Montre toutes les erreurs
error_reporting(E_ALL);

$fruits = array('strawberry' => 'red', 'banana' => 'yellow');

// Fonctionne, mais notez que cela fonctionne différemment à l'extérieur d'une chaîne
echo "A banana is $fruits[banana].";

// Fonctionne
echo "A banana is {$fruits['banana']}.";

// Fonctionne, mais PHP cherche une constante nommée banana en premier, tel que décrit ci-dessous
echo "A banana is {$fruits[banana]}.";

// Ne fonctionne pas, utilisez des accolades. Ceci produira une erreur d'analyse.
echo "A banana is $fruits['banana'].";

// Fonctionne
echo "A banana is " . $fruits['banana'] . ".";

// Fonctionne
echo "This square is $square->width meters broad.";

// Ne fonctionne pas. Pour une solution, repportez-vous à la syntaxe complexe.
echo "This square is $square->width00 centimeters broad.";
?>
]]>
     </programlisting>
    </informalexample>

    <simpara>
     Pour tout ce qui est encore plus complexe, vous devriez utiliser la
     syntaxe complexe.
    </simpara>
   </sect4>

   <sect4 xml:id="language.types.string.parsing.complex">
    <title>Syntaxe complexe</title>

    <simpara>
     Cette syntaxe est appelée complexe, non pas par qu'elle est complexe,
     mais parce qu'elle permet l'utilisation d'expressions complexes.
    </simpara>

    <simpara>
     En fait, n'importe quelle valeur d'un espace de nom peut être
     inclue dans une &string; avec cette syntaxe. Écrivez simple
     l'expression de la même façon qu'elle devrait l'être à l'extérieur
     de la chaîne et ensuite, entourez-là des caractères
     <literal>{</literal> et <literal>}</literal>. Sachant que le caractère
     <literal>{</literal> ne peut pas être échappé, cette syntaxe ne sera reconnue
     que lorsque le caractère <literal>$</literal> suit immédiatement le caractère
     <literal>{</literal>. Utilisez <literal>{\$</literal> pour afficher littéralement
     <literal>{$</literal>. Quelques exemples pour être clair :
    </simpara>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// Montre toutes les erreurs
error_reporting(E_ALL);

$great = 'fantastic';

// Ne fonctionne pas, affiche : This is { fantastic}
echo "This is { $great}";

// Fonctionne, affiche : This is fantastic
echo "This is {$great}";
echo "This is ${great}";

// Fonctionne
echo "This square is {$square->width}00 centimeters broad."; 

// Fonctionne
echo "This works: {$arr[4][3]}";

// Ceci est faux pour la même raison pour laquelle $foo[bar] est faux à l'extérieur d'une chaîne.
// En d'autres termes, ceci fonctionnera, mais uniquement parceque PHP cherchera d'abord
// une constante nommée foo ; une erreur de niveau E_NOTICE (constante indéfinie) sera émise.
echo "This is wrong: {$arr[foo][3]}"; 

// Fonctionne. Lors de l'utilisation de tableaux multi-dimentionnels, utilisez toujours
// les accolades autour du tableaux lorsqu'il se trouve dans la chaîne
echo "This works: {$arr['foo'][3]}";

// Fonctionne.
echo "This works: " . $arr['foo'][3];

echo "This works too: {$obj->values[3]->name}";

echo "This is the value of the var named $name: {${$name}}";

echo "This is the value of the var named by the return value of getName(): {${getName()}}";

echo "This is the value of the var named by the return value of \$object->getName(): {${$object->getName()}}";
?>
]]>
     </programlisting>
    </informalexample>

    <note>
     <para>
      Les appels de fonctions et de méthodes dans <literal>{$}</literal>
      fonctionnent depuis PHP 5.
     </para>
    </note>

   </sect4>
  </sect3>

  <sect3 xml:id="language.types.string.substr">
   <title>Accès et modification d'une chaîne, par caractère</title>

   <para>
    On peut accéder et modifier les caractères d'une &string; en spécifiant
    sa position (à partir de 0) en utilisant la même syntaxe que pour les tableaux.
    Il convient de voir une &string; comme un &array; dans ce cas.
   </para>

   <note>
    <simpara>
     On peut également accéder à une chaîne en utilisant des accolades, comme ceci :
     <varname>$str{42}</varname>. Cependant, cette syntaxe est obsolète depuis PHP 6.
     Utilisez les crochets à la place.
    </simpara>
   </note>

   <example>
    <title>Quelques exemples de chaînes</title>
    <programlisting role="php">
<![CDATA[
<?php
// Récupération du premier caractère d'une chaîne
$str = 'This is a test.';
$first = $str[0];

// Récupération du troisième caractère d'une chaîne
$third = $str[2];

// Récupération du dernier caractère d'une chaîne
$str = 'This is still a test.';
$last = $str[strlen($str)-1]; 

// Modification du dernier caractère d'une chaîne
$str = 'Look at the sea';
$str[strlen($str)-1] = 'e';

?>
]]>
    </programlisting>
   </example>

   <note>
    <para>
     L'accès aux autres types de variables en utilisant <literal>[]</literal> ou
     <literal>{}</literal> retournera silencieusement &null;.
    </para>
   </note>

  </sect3>
 </sect2><!-- end syntax -->

 <sect2 xml:id="language.types.string.useful-funcs">
  <title>Fonctions et opérateurs utiles</title>

  <para>
   Une &string; peut être concaténée en utilisant l'opérateur '.' (point). Notez
   que l'opérateur '+' (addition) ne fonctionnera <emphasis>pas</emphasis>.
   Repportez-vous aux <link linkend="language.operators.string">opérateurs de chaîne</link>
   pour plus d'informations.
  </para>

  <para>
   Il y a beaucoup de fonctions utiles pour la manipulation de &string;.
  </para>

  <simpara>
   Repportez-vous à la section sur les <link linkend="ref.strings">fonctions des chaînes
    de caracères</link> pour plus de précisions et à la section sur les
   <link linkend="ref.regex">expressions rationnelles</link> ou sur les
   <link linkend="ref.pcre">expressions rationnelles compatibles Perl</link>
   pour des recherches et des remplacements avancés.
  </simpara>

  <simpara>
   Il y a également des <link linkend="ref.url">fonctions pour les URL</link>, et
   des fonctions pour chiffrer, déchiffrer les chaînes de caractères
   (<link linkend="ref.mcrypt">mcrypt</link> et
   <link linkend="ref.mhash">mhash</link>).
  </simpara>

  <simpara>
   Et pour finir, repportez-vous aux <link linkend="ref.ctype">fonctions "type
    de caractères"</link>.
  </simpara>
 </sect2>

 <sect2 xml:id="language.types.string.casting">
  <title>Conversion en &string;</title>

  <para>
   Une valeur peut être convertie en une &string;, en utilisant le mot clé
   <literal>(string)</literal> ou la fonction <function>strval</function>.
   La conversion d'une &string; est automatiquement effectuée dans le contexte
   d'une expression où une &string; est nécessaire. Ceci survient lors de
   l'utilisation des fonctions <function>echo</function> ou <function>print</function>
   ou lorsqu'une variable est comparée à une chaîne. Les sections sur les
   <link linkend="language.types">types</link> et sur le
   <link linkend="language.types.type-juggling">transtypage</link> expliquent
   ce qui suit de manière plus détaillées. Repportez-vous également à la
   fonction <function>settype</function>.
  </para>

  <para>
   La valeur booléenne &true; est convertie en la chaîne
   <literal>"1"</literal>. La valeur booléenne &false; est convertie en
   <literal>""</literal> (une chaîne vide). Ceci permet les conversions vers et
   depuis une chaîne et un booléen.
  </para>

  <para>
   Un &integer; ou un &float; est converti en une &string; représentant
   le nombre de façon textuel (incluant la partie exponentionnelle pour
   les nombres à virgule flottante). Les nombres à virgule flottante
   peuvent être convertis en utilisant la notation exponentielle
   (<literal>4.1E+6</literal>).
  </para>

  <note>
   <para>
    Le point décimal est définit dans la locale du script (catégorie
    LC_NUMERIC). Repportez-vous à la fonction <function>setlocale</function>.
   </para>
  </note>

  <para>
   Les tableaux sont toujours convertis en la chaîne
   <literal>"Array"</literal> ; ainsi, <function>echo</function> et
   <function>print</function> ne peuvent être utilisés pour afficher le contenu
   d'un &array;. Pour afficher un seul élément, utilisez un constructeur
   comme <literal>echo $arr['foo']</literal>. Voir ci-dessous pour des astuces
   permettant d'afficher le contenu complet.
  </para>

  <para>
   Les objets en PHP 4 sont toujours convertis en la chaîne
   <literal>"Object"</literal>. Pour afficher les valeurs des membres de l'objet
   (aux fins de déboguage, par exemple), lisez le paragraphes ci-dessous.
   Pour récupérer le nom de la classe de l'objet, utilisez la fonction
   <function>get_class</function>. Depuis PHP 5, la méthode
   <link linkend="language.oop5.magic">__toString</link> est utilisée lorsqu'elle
   peut s'appliquer.
  </para>

  <para>
   Les ressources sont toujours converties en la chaîne
   <literal>"Resource id #1"</literal>, où <literal>1</literal> est le nombre
   unique assigné à la ressource par PHP au moment de l'exécution. Ne vous fiez pas
   à cette structure, il est possible qu'elle change. Pour récupérer le type de la
   ressource, utilisez la fonction <function>get_resource_type</function>.
  </para>

  <para>
   &null; est toujours converti en une chaîne vide.
  </para>

  <para>
   Au vue de tout cela, la conversion d'un &array;, d'un &object; ou
   d'une ressource en une &string; ne fournit aucune information utile sur
   la valeur contenue dans ce type. Repportez-vous aux fonctions
   <function>print_r</function> et <function>var_dump</function> pour plus
   d'informations sur le contenu de ces types.
  </para>

  <para>
   La plupart des valeurs en PHP peuvent également être convertie en &string;
   afin de les stocker. Cette méthode est appelée "linéarisation", et
   est effectuée par la fonction <function>serialize</function>. Si le
   moteur PHP a été compilé avec le support
   <link linkend="ref.wddx">WDDX</link>, les valeurs PHP peuvent également
   être linéarisées en XML.
  </para>

 </sect2>

 <sect2 xml:id="language.types.string.conversion">
  <title>Conversion de chaînes en nombres</title>

  <simpara>
   Lorsqu'une &string; est évalutée dans un contexte numérique, la valeur et le
   type résultants sont déterminés comme suit.
  </simpara>

  <simpara>
   La &string; sera évaluée en &float; si elle contient une des caracères suivants
   '.', 'e', ou 'E'. Sinon, elle sera évalué en un &integer;.
  </simpara>

  <para>
   La valeur est fournie par la portion initiale de la &string;. Si la &string;
   commence par un caractère numérique valide, ce sera la valeur utilisée.
   Sinon, la valeur sera de 0 (zéro). Une valeur numérique valide est
   un signe optionnel, suivi par un ou plusieurs nombres (contenant, optionnellement,
   un point décimal), suivi par, éventuellement, un exponentiel. L'exponentiel est un
   'e' ou 'E' suivi par un ou plusieurs nombres.
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$foo = 1 + "10.5";                // $foo est un nombre à virgule flottante (11.5)
$foo = 1 + "-1.3e3";              // $foo est un nombre à virgule flottante (-1299)
$foo = 1 + "bob-1.3e3";           // $foo est un entier (1)
$foo = 1 + "bob3";                // $foo est un entier (1)
$foo = 1 + "10 Small Pigs";       // $foo est un entier (11)
$foo = 4 + "10.2 Little Piggies"; // $foo est un nombre à virgule flottante (14.2)
$foo = "10.0 pigs " + 1;          // $foo est un nombre à virgule flottante (11)
$foo = "10.0 pigs " + 1.0;        // $foo est un nombre à virgule flottante (11)
?>
]]>
   </programlisting>
  </informalexample>

  <simpara>
   Pour plus d'informations sur ces conversions, repportez-vous au
   manuel Unix de la fonction strtod(3).
  </simpara>

  <para>
   Pour tester un exemple de cette section, copiez/collez l'exemple et insérez
   la ligne suivante pour voir ce qu'il se passe :
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
echo "Le type de \$foo==$foo; est " . gettype ($foo) . "<br />\n";
?>
]]>
   </programlisting>
  </informalexample>

  <para>
   Ne vous attendez pas à récupérer le code d'un caractère en le convertissant
   en entier, comme cela est possible en C. Utilisez la fonction
   <function>ord</function> et la fonction <function>chr</function>
   pour convertir les caractères en codes ASCII.
  </para>

 </sect2>
</sect1><!-- end string -->

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
