<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 293550 Maintainer: dams Status: ready -->
<!-- Reviewed: yes -->

<sect1 xml:id="language.types.string">
 <title>Les chaînes de caractères</title>

 <para>
  Une &string; est une série de caractères. Avant PHP 6, un caractère est
  la même chose qu'un octet. Ainsi, il y a exactement 256 caractères différents.
  Ceci impliquait également que PHP n'avait pas de support natif pour l'Unicode.
  Voir les fonctions <function>utf8_encode</function> et <function>utf8_decode</function>
  pour des fonctionnalités Unicode simples.
 </para>

 <note>
  <simpara>
   Ce n'est pas un problème pour une &string; de devenir très grande. PHP
   n'impose pas de taille à une &string; ; la seule limite est la mémoire
   disponible sur le système sous lequel PHP s'exécute.
  </simpara>
 </note>

 <sect2 xml:id="language.types.string.syntax">
  <title>Syntaxe</title>

  <para>
   Une &string; littérale peut être spécifiée de 4 façons différentes :
  </para>

  <itemizedlist>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.single">Entourée de guillemets simples</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.double">Entourée de guillemets doubles</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.heredoc">syntaxe Heredoc</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.nowdoc">syntaxe Nowdoc</link>
     (depuis PHP 5.3.0)
    </simpara>
   </listitem>
  </itemizedlist>

  <sect3 xml:id="language.types.string.syntax.single">
   <title>Entourée de simple guillemet</title>

   <para>
    La façon la plus simple de spécifier une &string; est de l'entourer de guillemet
    simple (le caractère <literal>'</literal>).
   </para>

   <para>
    Pour spécifier un guillemet simple littéral, vous devrez l'échapper d'un antislash
    (<literal>\</literal>). Pour spécifier un antislash littéral avant un guillemet simple,
    ou à la fin d'une &string;, échappez-le deux fois (<literal>\\</literal>).
    Notez que si vous tentez d'échapper n'importe quel autre caractère, l'antislash
    s'affichera.
   </para>

   <note>
    <simpara>
     Contrairement aux 2 autres syntaxes, les
     <link linkend="language.variables">variables</link> et les séquences échappées
     des caractères spéciaux ne seront <emphasis>pas</emphasis> traitées lorsqu'elles
     seront dans une &string; entourée de simple guillemet.
    </simpara>
   </note>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
echo 'ceci est une chaîne simple';

echo 'Vous pouvez également ajouter des nouvelles lignes
dans vos chaînes
de cette façon';

// Affiche : Arnold dit : "I'll be back"
echo 'Arnold dit : "I\'ll be back"';

// Affiche : Voulez-vous supprimer C:\*.*?
echo 'Voulez-vous supprimer C:\\*.*?';

// Affiche : Voulez-vous supprimer C:\*.*?
echo 'Voulez-vous supprimer C:\*.*?';

// Affiche : Ceci n'affichera pas \n de nouvelle ligne
echo 'Ceci n\'affichera pas \n de nouvelle ligne';

// Affiche : Les variables ne seront pas $traitees $ici
echo 'Les variables ne seront pas $traitees $ici';
?>
]]>
    </programlisting>
   </informalexample>

  </sect3>

  <sect3 xml:id="language.types.string.syntax.double">
   <title>Entourée de guillemet double</title>

   <para>
    Si la &string; est entourée de guillemet double ("), PHP interprétera
    plus de séquences échappées pour les caractères spéciaux :
   </para>

   <table>
    <title>Caractères échappés</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>Séquence</entry>
       <entry>Signification</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal>\n</literal></entry>
       <entry>Fin de ligne (LF ou 0x0A (10) en ASCII)</entry>
      </row>
      <row>
       <entry><literal>\r</literal></entry>
       <entry>Retour à la ligne (CR ou 0x0D (13) en ASCII)</entry>
      </row>
      <row>
       <entry><literal>\t</literal></entry>
       <entry>Tabulation horizontale (HT or 0x09 (9) en ASCII)</entry>
      </row>
      <row>
       <entry><literal>\v</literal></entry>
       <entry>Tabulation verticale (VT or 0x0B (11) en ASCII) (depuis PHP 5.2.5)</entry>
      </row>
      <row>
       <entry><literal>\f</literal></entry>
       <entry>Saut de page (FF ou 0x0C (12) en ASCII) (depuis PHP 5.2.5)</entry>
      </row>
      <row>
       <entry><literal>\\</literal></entry>
       <entry>Antislash</entry>
      </row>
      <row>
       <entry><literal>\$</literal></entry>
       <entry>Signe dollars</entry>
      </row>
      <row>
       <entry><literal>\"</literal></entry>
       <entry>Guillemet double</entry>
      </row>
      <row>
       <entry><literal>\[0-7]{1,3}</literal></entry>
       <entry>
        La séquence de caractères correspondant à une expression régulière
        est un caractère, en notation octal
       </entry>
      </row>
      <row>
       <entry><literal>\x[0-9A-Fa-f]{1,2}</literal></entry>
       <entry>
        La séquence de caractères correspondant à une expression régulière
        est un caractère, en notation hexadécimale
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    De la même façon que pour les chaînes entourées de simple guillemet,
    l'échappement de tout autre caractère affichera l'antislash. Avant PHP 5.1.1,
    l'antislash de <literal>\{$var}</literal> n'était pas affiché.
   </para>

   <para>
    La fonctionnalité la plus intéressante des chaînes entourées de guillemet
    double est que les noms de variables sont traités. Voir la documentation sur
    <link linkend="language.types.string.parsing">l'analyse des chaînes de caractères</link>
    pour plus de détails.
   </para>
  </sect3>

  <sect3 xml:id="language.types.string.syntax.heredoc">
   <title>Syntaxe Heredoc</title>

   <simpara>
    Une 3ème façon de délimiter une &string; est la syntaxe Heredoc :
    <literal>&lt;&lt;&lt;</literal>. Après cet opérateur, un identifiant
    est fourni, puis, une nouvelle ligne. La chaîne elle-même suit, puis,
    le même identifiant pour fermer la notation.
   </simpara>

   <simpara>
    L'identifiant <emphasis>doit</emphasis> commencer la première colonne de
    la ligne. De plus, l'identifiant doit suivre les mêmes règles que n'importe
    quel libellé PHP : il ne doit contenir que des caractères alphanumériques et
    des soulignés, et doit commencer par un caractère non numérique ou un souligné
    (<literal>"underscore"</literal>).
   </simpara>

   <warning>
    <simpara>
     Il est très important de noter que la ligne contenant l'identifiant ne
     doit contenir aucun autre caractère, mise à part, <emphasis>éventuellement</emphasis>,
     un point-virgule (<literal>;</literal>). Cela signifie que l'identifiant
     <emphasis>ne doit pas être indenté</emphasis>, et il ne doit y avoir aucun
     espace ou tabulation avant ou après le point-virgule. Il est également important
     de garder à l'esprit que le premier caractère avant l'identifiant de fermeture
     doit être une nouvelle ligne sur les systèmes Unix, incluant Mac OSX
     (caractère <literal>\n</literal>).
     Le délimiteur de fermeture (pouvant être suivi d'un point-virgule) doit aussi
     être suivi d'une nouvelle ligne.
    </simpara>

    <simpara>
     Si cette règle n'est pas respectée et que l'identifiant de fermeture
     n'est pas "propre", il ne sera pas considéré comme identifiant de fermeture,
     et PHP continuera à en chercher un. Si un identifiant de fermeture "propre"
     n'est pas trouvé avant la fin du fichier courant, une erreur d'analyse
     sera émise à la dernière ligne.
    </simpara>

    <para>
     Heredoc ne peut être utilisé pour initialiser les proriétés d'une classe.
     Depuis PHP 5.3, cette limitation ne s'applique qu'aux Heredoc qui contiennent
     des variables.
    </para>

    <example>
     <title>Exemple invalide</title>
     <programlisting role="php">
<![CDATA[
<?php
class foo {
    public $bar = <<<EOT
bar
EOT;
}
?>
]]>
     </programlisting>
    </example>
   </warning>

   <para>
    Heredoc se comporte exactement comme une chaîne entourée de double guillemet,
    sans avoir de double guillemet. Cela signifie que les guillemets dans une
    syntaxe Heredoc n'ont pas besoin d'être échappés, mais les codes d'échappement
    listés ci-dessus peuvent toujours être utilisés. Les variables seront traitées
    mais les mêmes attentions doivent être prises lorsque vous utilisez des
    variables complexes dans une syntaxe Heredoc.
   </para>

   <example>
    <title>Exemple de chaînes Heredoc</title>
    <programlisting role="php">
<![CDATA[
<?php
$str = <<<EOD
Exemple de chaîne
sur plusieurs lignes
en utilisant la syntaxe Heredoc.
EOD;

/* Exemple plus complexe, avec des variables. */
class foo
{
    var $foo;
    var $bar;

    function foo()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'MyName';

echo <<<EOT
Mon nom est "$name". J'affiche quelques $foo->foo.
Maintenant, j'affiche quelques {$foo->bar[1]}.
Et ceci devrait afficher un 'A': \x41
EOT;
?>
]]>
    </programlisting>
   </example>
   &example.outputs;
   <screen>
<![CDATA[
Mon nom est "MyName". J'affiche quelques Foo.
Maintenant, j'affiche quelques Bar2.
Et ceci devrait afficher un 'A' majuscule : A
]]>
   </screen>

   <para>
    Il est aussi possible d'utiliser la syntaxe Heredoc 
    pour passer des arguments à une fonction : 
   </para>

   <example> 
    <title>Exemple d'utilisation de Heredoc pour passer des arguments</title>
    <programlisting role="php">
<![CDATA[
<?php
var_dump(array(<<<EOD
foobar!
EOD
));
]]>
    </programlisting>
   </example>

   <para>
    Depuis PHP 5.3.0, il est possible d'initialiser les variables
    statiques et les propriétés ou constantes de classes avec la
    syntaxe Heredoc :
   </para>

   <example> 
    <title>Utilisation de Heredoc pour initialiser des valerus statiques</title>
    <programlisting role="php">
<![CDATA[
<?php
// Variables statiques
function foo()
{
    static $bar = <<<LABEL
Nothing in here...
LABEL;
}

// Constantes et propriétés de classe
class foo
{
    const BAR = <<<FOOBAR
Constant example
FOOBAR;

    public $baz = <<<FOOBAR
Property example
FOOBAR;
}
?>
]]>
    </programlisting>
   </example>

   <para>
    PHP 5.3.0 introduit aussi la possibilité pour Heredoc d'utiliser
    les guillemets doubles dans les déclarations : 
   </para>

   <example> 
    <title>Utilisation des guillemets doubles avec Heredoc</title>
    <programlisting role="php">
<![CDATA[
<?php
echo <<<"FOOBAR"
Hello World!
FOOBAR;
>
]]>
    </programlisting>
   </example>

   <note>
    <para>
     Le support de la syntaxe Heredoc a été ajouté en PHP 4.
    </para>
   </note>
  </sect3>

  <sect3 xml:id="language.types.string.syntax.nowdoc">
   <title>Nowdoc</title>
   <para>
    Nowdoc est aux chaînes entourées de guillemet simple ce qu'Heredoc est
    aux chaînes entourées de guillemet double. Nowdoc est spécifié de manière
    similaire à Heredoc, mut <emphasis>aucune analyse n'est effectuée</emphasis>
    dans une syntaxe Nowdoc. La construction est idéale pour embarquer du code PHP
    ou d'autres larges blocs de texte, sans avoir besoin d'échapper quoi que ce soit.
    Cette syntaxe partage les mêmes fonctionnalités que le constructeur SGML
    <literal>&lt;![CDATA[ ]]&gt;</literal>, en ce qu'elle déclare un bloc de texte
    qui ne doit pas être analysé.
   </para>

   <para>
    Nowdoc est identifié avec la même séquence <literal>&lt;&lt;&lt;</literal>
    utilisée par Heredoc, mais l'identifiant qui suit est entouré de guillemet
    simple,e.g. <literal>&lt;&lt;&lt;'EOT'</literal>. Toutes les règles concernant
    les identifiants Heredoc sont également appliquer aux identifiants Nowdoc,
    et tout spécialement, celles concernant l'apparence de l'identifiant.
   </para>

   <example>
    <title>Exemple de chaînes Nowdoc</title>
    <programlisting role="php">
<![CDATA[
<?php
$str = <<<'EOD'
Exemple de chaîne
sur plusieurs lignes
en utilisant la syntaxe Nowdoc.
EOD;

/* Exemple complexe, avec des variables. */
class foo
{
    public $foo;
    public $bar;

    function foo()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'MyName';

echo <<<'EOT'
Mom nom est "$name". J'affiche quelques $foo->foo.
Maintenant, j'affiche quelques {$foo->bar[1]}.
Ceci ne devrait pas afficher un 'A': \x41
EOT;
?>
]]>
    </programlisting>
   </example>
   &example.outputs;
   <screen>
<![CDATA[
Mom nom est "$name". J'affiche quelques $foo->foo.
Maintenant, j'affiche quelques {$foo->bar[1]}.
Ceci ne devrait pas afficher un 'A': \x41]]></screen>

   <note>
    <para>
     Contrairement à Heredoc, NowDoc peut être utilisé dans 
     n'importe quel contexte de données statiques. L'exemple
     typique est l'initialisation de proriétés ou de constantes
     de classe :
    </para>

    <example>
     <title>Exemple avec des données statiques</title>
     <programlisting role="php">
<![CDATA[
<?php
class foo {
    public $bar = <<<'EOT'
bar
EOT;
}
?>
]]>
     </programlisting>
    </example>
   </note>

   <note>
    <para>
     Le support Nowdoc a été ajouté en PHP 5.3.0.
    </para>
   </note>

  </sect3>

  <sect3 xml:id="language.types.string.parsing">
   <title>Analyse des variables</title>

   <simpara>
    Lorsqu'une &string; est spécifié en guillemet double ou en Heredoc,
    les <link linkend="language.variables">variables</link> sont analysées.
   </simpara>

   <simpara>
    Il y a 2 types de syntaxe : une
    <link linkend="language.types.string.parsing.simple">simple</link> et une
    <link linkend="language.types.string.parsing.complex">complexe</link>.
    La syntaxe simple est la plus commune et la plus pratique. Elle fournit
    une façon d'embarquer une variable, un &array; ou un &object; dans une
    chaîne avec un minimum d'effort.
   </simpara>

   <simpara>
    La syntaxe complexe a été introduite en PHP 4, et se reconnaît en l'utilisation
    d'accolades autour de l'expression.
   </simpara>

   <sect4 xml:id="language.types.string.parsing.simple">
    <title>Syntaxe simple</title>

    <simpara>
     Si un signe dollars (<literal>$</literal>) est rencontré, l'analyse prendra
     autant de caractères que possible pour former un nom de variable valide.
     Si vous entourez un nom de variable par des accolades explicitement, alors
     le nom de la variable n'aura aucune ambiguïté.
    </simpara>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$beer = 'Heineken';
echo "$beer's taste is great"; // fonctionne ; "'" est un caractère invalide pour les noms de variable
echo "He drank some $beers";   // ne fonctionne pas ; 's' est un caractère valide dans un nom de variable et la variable est en fait "$beer"
echo "He drank some ${beer}s"; // fonctionne
echo "He drank some {$beer}s"; // fonctionne
?>
]]>
     </programlisting>
    </informalexample>

    <simpara>
     De la même façon, l'index d'un &array; ou la propriété d'un &object;
     peut être analysé. Avec les indices d'un tableau, les crochets
     (<literal>]</literal>) forment la fin de l'index. Les mêmes règles sont
     appliquées aux propriétés d'objet comme pour les simples variables.
    </simpara>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// Ces exemples sont spécifiques à l'utilisation des tableaux dans des chaînes.
// Lorsqu'ils sont à l'extérieur d'une chaîne, quottez toujours les chaînes représentant
// les clés du tableau et n'utilisez pas d'{accolades}.

// Montre toutes les erreurs
error_reporting(E_ALL);

$fruits = array('strawberry' => 'red', 'banana' => 'yellow');

// Fonctionne, mais notez que cela fonctionne différemment à l'extérieur d'une chaîne
echo "A banana is $fruits[banana].";

// Fonctionne
echo "A banana is {$fruits['banana']}.";

// Fonctionne, mais PHP cherche une constante nommée banana en premier, tel que décrit ci-dessous
echo "A banana is {$fruits[banana]}.";

// Ne fonctionne pas, utilisez des accolades. Ceci produira une erreur d'analyse.
echo "A banana is $fruits['banana'].";

// Fonctionne
echo "A banana is " . $fruits['banana'] . ".";

// Fonctionne
echo "This square is $square->width meters broad.";

// Ne fonctionne pas. Pour une solution, reportez-vous à la syntaxe complexe.
echo "This square is $square->width00 centimeters broad.";
?>
]]>
     </programlisting>
    </informalexample>

    <simpara>
     Pour tout ce qui est encore plus complexe, vous devriez utiliser la
     syntaxe complexe.
    </simpara>
   </sect4>

   <sect4 xml:id="language.types.string.parsing.complex">
    <title>Syntaxe complexe</title>

    <simpara>
     Cette syntaxe est appelée complexe, non pas par qu'elle est complexe,
     mais parce qu'elle permet l'utilisation d'expressions complexes.
    </simpara>

    <simpara>
     En fait, n'importe quelle valeur d'un espace de nom peut être
     inclue dans une &string; avec cette syntaxe. Écrivez simple
     l'expression de la même façon qu'elle devrait l'être à l'extérieur
     de la chaîne et ensuite, entourez-là des caractères
     <literal>{</literal> et <literal>}</literal>. Sachant que le caractère
     <literal>{</literal> ne peut pas être échappé, cette syntaxe ne sera reconnue
     que lorsque le caractère <literal>$</literal> suit immédiatement le caractère
     <literal>{</literal>. Utilisez <literal>{\$</literal> pour afficher littéralement
     <literal>{$</literal>. Quelques exemples pour être clair :
    </simpara>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// Montre toutes les erreurs
error_reporting(E_ALL);

$great = 'fantastic';

// Ne fonctionne pas, affiche : This is { fantastic}
echo "This is { $great}";

// Fonctionne, affiche : This is fantastic
echo "This is {$great}";
echo "This is ${great}";

// Fonctionne
echo "This square is {$square->width}00 centimeters broad."; 

// Fonctionne
echo "This works: {$arr[4][3]}";

// Ceci est faux pour la même raison pour laquelle $foo[bar] est faux à l'extérieur d'une chaîne.
// En d'autres termes, ceci fonctionnera, mais uniquement parceque PHP cherchera d'abord
// une constante nommée foo ; une erreur de niveau E_NOTICE (constante indéfinie) sera émise.
echo "This is wrong: {$arr[foo][3]}"; 

// Fonctionne. Lors de l'utilisation de tableaux multidimensionnels, utilisez toujours
// les accolades autour du tableaux lorsqu'il se trouve dans la chaîne
echo "This works: {$arr['foo'][3]}";

// Fonctionne.
echo "This works: " . $arr['foo'][3];

echo "This works too: {$obj->values[3]->name}";

echo "This is the value of the var named $name: {${$name}}";

echo "This is the value of the var named by the return value of getName(): {${getName()}}";

echo "This is the value of the var named by the return value of \$object->getName(): {${$object->getName()}}";
?>
]]>
     </programlisting>
    </informalexample>

    <para>
     Il est également possible d'accéder aux propriétés de classes
     en utilisant les variables contenues dans des chaînes, en
     utilisant cette synthaxe.
    </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class foo {
    var $bar = 'I am bar.';
}

$foo = new foo();
$bar = 'bar';
$baz = array('foo', 'bar', 'baz', 'quux');
echo "{$foo->$bar}\n";
echo "{$foo->$baz[1]}\n";
?>
]]>
    </programlisting>
   &example.outputs;
   <screen>
I am bar.
I am bar.
   </screen>
   </informalexample>

    <note>
     <para>
      Les appels aux fonctions, méthodes, variables statiques de classes,
      ainsi qu'aux constantes de classes à l'intérieur de <literal>{$}</literal>
      fonctionnent depuis PHP 5. Cependant, la valeur accédée sera interprétée
      comme le nom d'une variable dans le scope duquel la chaîne est définie.
      L'utilisation de simples accolades (<literal>{}</literal>) ne fonctionnera
      pas pour accéder à la valeur retournée par les fonctions, méthodes ou
      les valeurs des constantes et des variables statiques de classes.
     </para>
    </note>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// Affichage de toutes les erreurs.
error_reporting(E_ALL);

class beers {
    const softdrink = 'rootbeer';
    public static $ale = 'ipa';
}

$rootbeer = 'A & W';
$ipa = 'Alexander Keith\'s';

// Ceci fonctionne ; Affiche : I'd like an A & W
echo "I'd like an {${beers::softdrink}}\n";

// Ceci fonctionne également ; Affiche : I'd like an Alexander Keith's
echo "I'd like an {${beers::$ale}}\n";
?>
]]>
     </programlisting>
    </informalexample>

   </sect4>
  </sect3>

  <sect3 xml:id="language.types.string.substr">
   <title>Accès et modification d'une chaîne, par caractère</title>

   <para>
    On peut accéder et modifier les caractères d'une &string; en spécifiant
    sa position (à partir de 0) en utilisant la même syntaxe que pour les tableaux,
    comme pour la variable <varname>$str[42]</varname>.
    Il convient de voir une &string; comme un &array; dans ce cas.
   </para>

   <note>
    <simpara>
     On peut également accéder à une chaîne en utilisant des accolades, comme ceci :
     <varname>$str{42}</varname>. Cependant, cette syntaxe est obsolète depuis PHP 6.
     Utilisez les crochets à la place, comme ceci : <varname>$str[42]</varname>
    </simpara>
   </note>

   <warning>
    <simpara>
     Écrire à une position hors de l'intervalle de l'existant fait que
     la chaîne est complétée par des espaces jusqu'à cette position.
     Les positions sont toujours converties en valeur entière.
     Les positions invalides produisent une alerte <constant>E_NOTICE</constant>.
     Les positions négatives produisent une alerte <constant>E_NOTICE</constant> 
     en écriture, mais lisent une chaîne vide.
     Seul le premier caractère d'une chaîne assignée est utilisée.
     Assigner une chaîne vide assigne le caractère NUL.
    </simpara>
   </warning>

   <example>
    <title>Quelques exemples de chaînes</title>
    <programlisting role="php">
<![CDATA[
<?php
// Récupération du premier caractère d'une chaîne
$str = 'This is a test.';
$first = $str[0];

// Récupération du troisième caractère d'une chaîne
$third = $str[2];

// Récupération du dernier caractère d'une chaîne
$str = 'This is still a test.';
$last = $str[strlen($str)-1]; 

// Modification du dernier caractère d'une chaîne
$str = 'Look at the sea';
$str[strlen($str)-1] = 'e';

?>
]]>
    </programlisting>
   </example>

   <note>
    <para>
     L'accès aux autres types de variables en utilisant <literal>[]</literal> ou
     <literal>{}</literal> retournera silencieusement &null;.
    </para>
   </note>

  </sect3>
 </sect2><!-- end syntax -->

 <sect2 xml:id="language.types.string.useful-funcs">
  <title>Fonctions et opérateurs utiles</title>

  <para>
   Une &string; peut être concaténée en utilisant l'opérateur '.' (point). Notez
   que l'opérateur '+' (addition) ne fonctionnera <emphasis>pas</emphasis>.
   Reportez-vous aux <link linkend="language.operators.string">opérateurs de chaîne</link>
   pour plus d'informations.
  </para>

  <para>
   Il y a beaucoup de fonctions utiles pour la manipulation de &string;.
  </para>

  <simpara>
   Reportez-vous à la section sur les 
   <link linkend="ref.strings">fonctions des chaînes de caractères</link> 
   pour plus de précisions et à la section sur les
   <link linkend="ref.regex">expressions rationnelles</link> ou sur les
   <link linkend="ref.pcre">expressions rationnelles compatibles Perl</link>
   pour des recherches et des remplacements avancés.
  </simpara>

  <simpara>
   Il y a également des <link linkend="ref.url">fonctions pour les URL</link>, et
   des fonctions pour chiffrer, déchiffrer les chaînes de caractères
   (<link linkend="ref.mcrypt">mcrypt</link> et
   <link linkend="ref.mhash">mhash</link>).
  </simpara>

  <simpara>
   Et pour finir, reportez-vous aux <link linkend="ref.ctype">fonctions "type
    de caractères"</link>.
  </simpara>
 </sect2>

 <sect2 xml:id="language.types.string.casting">
  <title>Conversion en &string;</title>

  <para>
   Une valeur peut être convertie en une &string;, en utilisant le mot clé
   <literal>(string)</literal> ou la fonction <function>strval</function>.
   La conversion d'une &string; est automatiquement effectuée dans le contexte
   d'une expression où une &string; est nécessaire. Ceci survient lors de
   l'utilisation des fonctions <function>echo</function> ou <function>print</function>
   ou lorsqu'une variable est comparée à une chaîne. Les sections sur les
   <link linkend="language.types">types</link> et sur le
   <link linkend="language.types.type-juggling">transtypage</link> expliquent
   ce qui suit de manière plus détaillées. Reportez-vous également à la
   fonction <function>settype</function>.
  </para>

  <para>
   La valeur booléenne &true; est convertie en la chaîne
   <literal>"1"</literal>. La valeur booléenne &false; est convertie en
   <literal>""</literal> (une chaîne vide). Ceci permet les conversions vers et
   depuis une chaîne et un booléen.
  </para>

  <para>
   Un &integer; ou un &float; est converti en une &string; représentant
   le nombre de façon textuel (incluant la partie exponentielle pour
   les nombres à virgule flottante). Les nombres à virgule flottante
   peuvent être convertis en utilisant la notation exponentielle
   (<literal>4.1E+6</literal>).
  </para>

  <note>
   <para>
    Le point décimal est définit dans la locale du script (catégorie
    LC_NUMERIC). Reportez-vous à la fonction <function>setlocale</function>.
   </para>
  </note>

  <para>
   Les tableaux sont toujours convertis en la chaîne
   <literal>"Array"</literal> ; ainsi, <function>echo</function> et
   <function>print</function> ne peuvent être utilisés pour afficher le contenu
   d'un &array;. Pour afficher un seul élément, utilisez un constructeur
   comme <literal>echo $arr['foo']</literal>. Voir ci-dessous pour des astuces
   permettant d'afficher le contenu complet.
  </para>

  <para>
   Les objets en PHP 4 sont toujours convertis en la chaîne
   <literal>"Object"</literal>. Pour afficher les valeurs des propriétés de l'objet
   (aux fins de déboguage, par exemple), lisez le paragraphes ci-dessous.
   Pour récupérer le nom de la classe de l'objet, utilisez la fonction
   <function>get_class</function>. Depuis PHP 5, la méthode
   <link linkend="language.oop5.magic">__toString</link> est utilisée lorsqu'elle
   peut s'appliquer.
  </para>

  <para>
   Les ressources sont toujours converties en la chaîne
   <literal>"Resource id #1"</literal>, où <literal>1</literal> est le nombre
   unique assigné à la ressource par PHP au moment de l'exécution. Ne vous fiez pas
   à cette structure, il est possible qu'elle change. Pour récupérer le type de la
   ressource, utilisez la fonction <function>get_resource_type</function>.
  </para>

  <para>
   &null; est toujours converti en une chaîne vide.
  </para>

  <para>
   Au vue de tout cela, la conversion d'un &array;, d'un &object; ou
   d'une ressource en une &string; ne fournit aucune information utile sur
   la valeur contenue dans ce type. Reportez-vous aux fonctions
   <function>print_r</function> et <function>var_dump</function> pour plus
   d'informations sur le contenu de ces types.
  </para>

  <para>
   La plupart des valeurs en PHP peuvent également être convertie en &string;
   afin de les stocker. Cette méthode est appelée "linéarisation", et
   est effectuée par la fonction <function>serialize</function>. Si le
   moteur PHP a été compilé avec le support
   <link linkend="ref.wddx">WDDX</link>, les valeurs PHP peuvent également
   être linéarisées en XML.
  </para>

 </sect2>

 <sect2 xml:id="language.types.string.conversion">
  <title>Conversion de chaînes en nombres</title>

  <simpara>
   Lorsqu'une &string; est évaluée dans un contexte numérique, la valeur et le
   type résultants sont déterminés comme suit.
  </simpara>

  <simpara>
   Si la &string; ne contient aucun '.', 'e', ou 'E' et que la valeur
   numérique est dans l'intervalle de représentation des entiers (et notamment
   plus petite que <constant>PHP_INT_MAX</constant>), alors la 
   &string; sera transformée en &integer;. Dans les autres cas, elle sera 
   interprétée comme un &float;.
  </simpara>

  <para>
   La valeur est fournie par la portion initiale de la &string;. Si la &string;
   commence par un caractère numérique valide, ce sera la valeur utilisée.
   Sinon, la valeur sera de 0 (zéro). Une valeur numérique valide est
   un signe optionnel, suivi par un ou plusieurs nombres (contenant, optionnellement,
   un point décimal), suivi par, éventuellement, un exponentiel. L'exponentiel est un
   'e' ou 'E' suivi par un ou plusieurs nombres.
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$foo = 1 + "10.5";                // $foo est un nombre à virgule flottante (11.5)
$foo = 1 + "-1.3e3";              // $foo est un nombre à virgule flottante (-1299)
$foo = 1 + "bob-1.3e3";           // $foo est un entier (1)
$foo = 1 + "bob3";                // $foo est un entier (1)
$foo = 1 + "10 Small Pigs";       // $foo est un entier (11)
$foo = 4 + "10.2 Little Piggies"; // $foo est un nombre à virgule flottante (14.2)
$foo = "10.0 pigs " + 1;          // $foo est un nombre à virgule flottante (11)
$foo = "10.0 pigs " + 1.0;        // $foo est un nombre à virgule flottante (11)
?>
]]>
   </programlisting>
  </informalexample>

  <simpara>
   Pour plus d'informations sur ces conversions, reportez-vous au
   manuel Unix de la fonction strtod(3).
  </simpara>

  <para>
   Pour tester un exemple de cette section, copiez/collez l'exemple et insérez
   la ligne suivante pour voir ce qu'il se passe :
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
echo "Le type de \$foo==$foo; est " . gettype ($foo) . "<br />\n";
?>
]]>
   </programlisting>
  </informalexample>

  <para>
   Ne vous attendez pas à récupérer le code d'un caractère en le convertissant
   en entier, comme cela est possible en C. Utilisez la fonction
   <function>ord</function> et la fonction <function>chr</function>
   pour convertir les caractères en codes ASCII.
  </para>

 </sect2>
</sect1><!-- end string -->

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
