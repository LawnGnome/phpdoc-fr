 <chapter id="oop">
  <title>Classes et objets</title>
  <sect1 id="keyword.class">
   <title>Les classes : <literal>class</literal></title>
   <para>
     Une classe est une collection de variables et de fonctions qui
     fonctionnent avec ces variables. Une classe est d&eacute;finie
     en utilisant la syntaxe suivante :
    <informalexample>
     <programlisting role="php">
&lt;?php
class Cart {
    var $items;  // El&eacute;ments de notre panier
    // Ajout de $num articles de type $artnr au panier
    function add_item ($artnr, $num) {
        $this->items[$artnr] += $num;
    }
    // Suppression de $num articles du type $artnr du panier
    function remove_item ($artnr, $num) {
        if ($this->items[$artnr] > $num) {
            $this->items[$artnr] -= $num;
            return <literal>TRUE</literal>;
        } else {
            return <literal>FALSE</literal>;
        }
    }
}
?&gt;
     </programlisting>
    </informalexample>
   </para>
   <para>
    L'exemple ci-dessus d&eacute;finit la classe Cart qui est compos&eacute;e d'un
    tableau associatif contenant les articles du panier et de deux fonctions,
    une pour ajouter et une pour enlever des &eacute;l&eacute;ments au panier.
   </para>
   <note>
    <simpara>
     En PHP 4, seuls les initialiseurs constants pour les variables
     <literal>var</literal> sont autoris&eacute;s. Utilisez les constructeurs pour
     les initialisation variables.
    </simpara>
   </note>
   <para>
    Les classes forment un type de variable. Pour cr&eacute;er une variable
    du type d&eacute;sir&eacute;, vous devez utiliser l'op&eacute;rateur new.
   </para>
   <informalexample>
    <programlisting role="php">
&lt;?php
 $cart = new Cart;
 $cart->add_item("10", 1);
?&gt;
    </programlisting>
   </informalexample>
   <para>
    L'instruction ci-dessus cr&eacute;e l'objet $cart de la class Cart.
    La fonction add_idem() est appel&eacute;e afin d'ajouter l'article
    num&eacute;ro 10 dans la panier.
   </para>
   <para>
    Une classe peut &ecirc;tre une extension d'une autre classe.
    Les classes "extended" ou "derived" h&eacute;ritent de toutes
    les variables et de toutes les fonctions de la classe p&egrave;re
    plus toutes les d&eacute;finitions que vous rajoutez &agrave; cette
    classe. Cela se fait avec le mot clef "extends".
    L'h&eacute;ritage multiple n'est pas support&eacute;.
   </para>
   <informalexample>
    <programlisting role="php">
&lt;?php
class Named_Cart extends Cart {
    var $owner;
    function set_owner ($name) {
        $this->owner = $name;
    }
}
?&gt;
    </programlisting>
   </informalexample>
   <para>
     L'exemple ci-desssus d&eacute;finit la classe Named_Cart qui
     poss&egrave;de les m&ecirc;me variables que la classe Cart et
     la variable $owner en plus, ainsi que la fonction set_owner().
     Vous cr&eacute;ez un panier nominatif de la m&ecirc;me
     mani&egrave;re que pr&eacute;c&eacute;demment, et vous pouvez alors
     affecter un nom au panier ou en conna&icirc;tre le nom. Vous pouvez de
     toutes les fa&ccedil;ons utiliser les m&ecirc;me fonctions que sur un
     panier classique.
   </para>
   <informalexample>
    <programlisting role="php">
&lt;?php
$ncart = new Named_Cart;    // Cr&eacute;ation d'un panier nominatif
$ncart->set_owner ("kris"); // Affectation du nom du panier
print $ncart->owner;        // Affichage du nom du panier
$ncart->add_item ("10", 1); // (h&eacute;ritage des fonctions de la classe p&egrave;re)
?&gt;
    </programlisting>
   </informalexample>
   <para>
     Dans les fonctions d'une classe, la variable $this est
     &eacute;gale &agrave; l'objet de la classe. Vous pouvez
     utilisez la forme "$this->quelquechose" pour acc&eacute;der aux
     fonctions ou aux variables de l'objet courant.
   </para>
   <para>
    Le constructeur est la fonction qui est appel&eacute;e
    automatiquement par la classe lorsque vous cr&eacute;ez
    une nouvelle instance d'une classe. La fonction constructeur a
    le m&ecirc;me nom que la classe.
   </para>
   <informalexample>
    <programlisting role="php">
&lt;?php
class Auto_Cart extends Cart {
    function Auto_Cart () {
        $this->add_item ("10", 1);
    }
}
?&gt;
    </programlisting>
   </informalexample>
   <para>
     L'exemple ci-dessus d&eacute;finit la classe Auto_Cart qui
     h&eacute;rite de la classe Cart et d&eacute;finit le construteur
     de la classe. Ce dernier initialise le panier avec 1 article de
     type num&eacute;ro 10 d&egrave;s que l'instruction "new" est
     appel&eacute;e. La fonction constructeur peut prendre ou non,
     des param&egrave;tres optionnels, ce qui la rend
     beaucoup plus pratique.
   </para>
   <informalexample>
    <programlisting role="php">
&lt;?php
class Constructor_Cart extends Cart {
    function Constructor_Cart ($item = "10", $num = 1) {
        $this->add_item ($item, $num);
    }
}
// Place dans le caddie toujours la m&ecirc;me chose...
$default_cart   = new Constructor_Cart;
// Place dans le caddie des objets diff&eacute;rents, comme dans la
// r&eacute;alit&eacute;
$different_cart = new Constructor_Cart ("20", 17);
?&gt;
    </programlisting>
   </informalexample>
   <caution>
    <simpara>
     Pour les classes qui utilisent l'h&eacute;ritage,
     le constructeur de la classe p&egrave;re n'est pas
     automatiquement appel&eacute; lorsque le constructeur de la classe
     d&eacute;riv&eacute;e est appel&eacute;.
    </simpara>
   </caution>
  </sect1>
 </chapter>
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
