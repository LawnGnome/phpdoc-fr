 <chapter id="language.oop">
  <title>Classes et objets</title>
  <sect1 id="keyword.class">
   <title>Les classes : <literal>class</literal></title>
   <para>
     Une classe est une collection de variables et de fonctions qui
     fonctionnent avec ces variables. Une classe est d&eacute;finie
     en utilisant la syntaxe suivante :
    <informalexample>
     <programlisting role="php">
&lt;?php
class Caddie {
    var $items;  // El&eacute;ments de notre panier
    // Ajout de $num articles de type $artnr au panier
    function add_item ($artnr, $num) {
        $this->items[$artnr] += $num;
    }
    // Suppression de $num articles du type $artnr du panier
    function remove_item ($artnr, $num) {
        if ($this->items[$artnr] &gt; $num) {
            $this->items[$artnr] -= $num;
            return <literal>TRUE</literal>;
        } else {
            return <literal>FALSE</literal>;
        }
    }
}
?&gt;
     </programlisting>
    </informalexample>
   </para>
   <para>
    L'exemple ci-dessus d&eacute;finit la classe Caddie qui est compos&eacute;e d'un
    tableau associatif contenant les articles du panier et de deux fonctions,
    une pour ajouter et une pour enlever des &eacute;l&eacute;ments au panier.
   </para>
   <note>
    <simpara>
     En PHP 4, seuls les initialiseurs constants pour les variables
     <literal>var</literal> sont autoris&eacute;s. Utilisez les
     constructeurs pour les initialisations variables, ou utilisant
     des expressions.
    </simpara>
    <informalexample>
     <programlisting role="php">
&lt;?php
/* Aucune de ces syntaxes ne fonctionnera en PHP 4 */
class Caddie {
    var $date_du_jour = date("d/m/Y");
    var $name = $firstname;
    var $owner = 'Fred ' . 'Jones';
}
/* Voici comment cela doit se faire d&eacute;sormais. */
class Caddie {
    var $date_du_jour;
    var $name;
    var $owner;
    function Caddie() {
        $this->date_du_jour = date("d/m/Y");
        $this->name = $GLOBALS['firstname'];
        /* etc... */
    }
}
?&lt;
     </programlisting>
    </informalexample>
   </note>
   <para>
    Les classes forment un type de variable. Pour cr&eacute;er une variable
    du type d&eacute;sir&eacute;, vous devez utiliser l'op&eacute;rateur new.
   </para>
   <informalexample>
    <programlisting role="php">
&lt;?php
 $cart = new Caddie;
 $cart->add_item("10", 1);
?&gt;
    </programlisting>
   </informalexample>
   <para>
    L'instruction ci-dessus cr&eacute;e l'objet $cart de la class Caddie.
    La fonction add_idem() est appel&eacute;e afin d'ajouter l'article
    num&eacute;ro 10 dans la panier.
   </para>
   <para>
    Une classe peut &ecirc;tre une extension d'une autre classe.
    Les classes "extended" ou "derived" h&eacute;ritent de toutes
    les variables et de toutes les fonctions de la classe p&egrave;re
    plus toutes les d&eacute;finitions que vous rajoutez &agrave; cette
    classe. Cela se fait avec le mot clef "extends".
    L'h&eacute;ritage multiple n'est pas support&eacute;.
   </para>
   <informalexample>
    <programlisting role="php">
&lt;?php
class Caddie_nomme extends Caddie {
    var $owner;
    function set_owner ($name) {
        $this->owner = $name;
    }
}
?&gt;
    </programlisting>
   </informalexample>
   <para>
     L'exemple ci-desssus d&eacute;finit la classe Caddie_nomme qui
     poss&egrave;de les m&ecirc;me variables que la classe Caddie et
     la variable $owner en plus, ainsi que la fonction set_owner().
     Vous cr&eacute;ez un panier nominatif de la m&ecirc;me
     mani&egrave;re que pr&eacute;c&eacute;demment, et vous pouvez alors
     affecter un nom au panier ou en conna&icirc;tre le nom. Vous pouvez de
     toutes les fa&ccedil;ons utiliser les m&ecirc;me fonctions que sur un
     panier classique.
   </para>
   <informalexample>
    <programlisting role="php">
&lt;?php
$ncart = new Caddie_nomme;    // Cr&eacute;ation d'un panier nominatif
$ncart->set_owner ("kris"); // Affectation du nom du panier
print $ncart->owner;        // Affichage du nom du panier
$ncart->add_item ("10", 1); // (h&eacute;ritage des fonctions de la classe p&egrave;re)
?&gt;
    </programlisting>
   </informalexample>
   <para>
     Dans les fonctions d'une classe, la variable $this est
     &eacute;gale &agrave; l'objet de la classe. Vous pouvez
     utilisez la forme "$this->quelquechose" pour acc&eacute;der aux
     fonctions ou aux variables de l'objet courant. Aussi bien
     depuis l'objet lui-m&ecirc;me que de l'ext&eacute;rieur, vous n'avez pas
     besoin de <literal>$</literal> pour acc&eacute;der aux
     propri&eacute;t&eacute;s d'un objet.
   </para>
   <informalexample>
    <programlisting role="php">
&lt;?php
$ncart->owner  = "chris"; // pas de '$'
$ncart->$owner = "chris";
// Ceci est invalide, car $ncart->$owner &eacute;quivaut &agrave; $ncart->""
$myvar = 'owner';
$ncart->$myvar = "chris";
// Ceci est valide, car $ncart->$owner &eacute;quivaut &agrave; $ncart->owner
    </programlisting>
   </informalexample>
   <para>
    Le constructeur est la fonction qui est appel&eacute;e
    automatiquement par la classe lorsque vous cr&eacute;ez
    une nouvelle instance d'une classe. La fonction constructeur a
    le m&ecirc;me nom que la classe.
   </para>
   <informalexample>
    <programlisting role="php">
&lt;?php
class Auto_Caddie extends Caddie {
    function Auto_Caddie () {
        $this->add_item ("10", 1);
    }
}
?&gt;
    </programlisting>
   </informalexample>
   <para>
     L'exemple ci-dessus d&eacute;finit la classe Auto_Caddie qui
     h&eacute;rite de la classe Caddie et d&eacute;finit le construteur
     de la classe. Ce dernier initialise le panier avec 1 article de
     type num&eacute;ro 10 d&egrave;s que l'instruction "new" est
     appel&eacute;e. La fonction constructeur peut prendre ou non,
     des param&egrave;tres optionnels, ce qui la rend
     beaucoup plus pratique.
   </para>
   <informalexample>
    <programlisting role="php">
&lt;?php
class Constructor_Caddie extends Caddie {
    function Constructor_Caddie ($item = "10", $num = 1) {
        $this->add_item ($item, $num);
    }
}
// Place dans le caddie toujours la m&ecirc;me chose...
$default_cart   = new Constructor_Caddie;
// Place dans le caddie des objets diff&eacute;rents, comme dans la
// r&eacute;alit&eacute;
$different_cart = new Constructor_Caddie ("20", 17);
?&gt;
    </programlisting>
   </informalexample>
   <caution>
    <simpara>
     Pour les classes qui utilisent l'h&eacute;ritage,
     le constructeur de la classe p&egrave;re n'est pas
     automatiquement appel&eacute; lorsque le constructeur de la classe
     d&eacute;riv&eacute;e est appel&eacute;.
    </simpara>
   </caution>
  </sect1>
  <sect1 id="keyword.newref">
   <title>R&eacute;f&eacute;rences dans un constructeur</title>
   <para>
    Cr&eacute;er des r&eacute;f&eacute;rences dans un constructeur peut conduire &agrave;
    des r&eacute;sultats &eacute;tranges. Ce tutorial vous guide pour &eacute;viter ces
    probl&egrave;mes.
    <informalexample>
     <programlisting role="php">
&lt;?php
class foo {
    function foo($name) {
        // cr&eacute;e une r&eacute;f&eacute;rence dans le tableau global $globalref
        global $globalref;
		$globalref[] = &amp;$this;
        // donne le nom de la variable
        $this-&gt;setName($name);
		// et l'affiche
        $this-&gt;echoName();
    }
    function echoName() {
        echo "&lt;br&gt;",$this-&gt;Name;
    }
	function setName($name)	{
		$this-&gt;Name = $name;
    }
}
?&gt;
    </programlisting>
   </informalexample>
   </para>
   <para>
    V&eacute;rifions maintenant qu'il y a une diff&eacute;rence entre <varname>$bar1</varname>
    qui a &eacute;t&eacute; cr&eacute;&eacute; avec <literal>=</literal> et <varname>$bar2</varname> qui a &eacute;t&eacute;
    cr&eacute;&eacute; avec l'op&eacute;rateur de r&eacute;f&eacute;rence <literal>=&amp;</literal> :
   </para>
    <informalexample>
     <programlisting role="php">
&lt;?php
    $bar1 = new foo('cr&eacute;e dans le constructeur');
    $bar1-&gt;echoName();
    $globalref[0]-&gt;echoName();
    /* affiche :
    cr&eacute;e dans le constructeur
    cr&eacute;e dans le constructeur
    cr&eacute;e dans le constructeur */
    $bar2 =&amp;new foo('cr&eacute;e dans le constructeur');
    $bar2-&gt;echoName();
    $globalref[1]-&gt;echoName();
    /* affiche :
    cr&eacute;e dans le constructeur
    cr&eacute;e dans le constructeur
    cr&eacute;e dans le constructeur */
?&gt;
    </programlisting>
   </informalexample>
   <para>
    Apparement, il n'y a pas de diff&eacute;rence, mais en fait, il y en a une
    significative : <varname>$bar1</varname> et <varname>$globalref[0]</varname>
    ne sont pas r&eacute;f&eacute;renc&eacute;es, ces deux variables sont diff&eacute;rentes.
    Cela est du au fait que  l'op&eacute;rateur "new"ne retourne par de r&eacute;f&eacute;rence,
    mais retourne une copie.
    <note>
     <simpara>
      Il n'y a aucune perte de performance (puisque PHP 4 utilise un compteur de
      r&eacute;f&eacute;rence) &agrave; retourner des copies au lieu de r&eacute;f&eacute;rences. Au contraire, il est
      souvent mieux de travailler sur les copies plut&ocirc;t que sur les r&eacute;f&eacute;rences,
      car cr&eacute;er une r&eacute;f&eacute;rence prend un peu plus de temps que de cr&eacute;er une copie
      qui ne prend virtuellement pas de temps (&agrave; moins qu'il ne se cr&eacute;e un
      tableau g&eacute;ant ou un objet monstreux, auquel cas il est pr&eacute;f&eacute;rable de passer
      par des r&eacute;f&eacute;rences).
     </simpara>
    </note>
    Pour prouver ceci, regardez le code suivant :
   </para>
   <informalexample>
     <programlisting role="php">
&lt;?php
        // maintenant, nous allons changer de nom. Qu'attendez vous?
        // Vous pouvez vous attendre &agrave; ce que les deux variables $bar
        // et  $globalref[0] change de nom...
        $bar1-&gt;setName('modifi&eacute;');
        // comme pr&eacute;dit, ce n'est pas le cas
        $bar1-&gt;echoName();
        $globalref[0]-&gt;echoName();
        /* affiche :
        cr&eacute;e dans le constructeur
        modifi&eacute; */
        // quelle est la diff&eacute;rence entre $bar2 et $globalref[1]
        $bar2-&gt;setName('modifi&eacute;');
        // Heureusement, elles sont non seulement &eacute;gales, mais
        // elles repr&eacute;sentent la m&ecirc;me variable.
        // donc $bar2-&gt;Name et $globalref[1]-&gt;Name sont les m&ecirc;mes
        $bar2-&gt;echoName();
        $globalref[1]-&gt;echoName();
        /* affiche :
        modifi&eacute;
        modifi&eacute; */
?&gt;
    </programlisting>
   </informalexample>
   <para>
   Un dernier exemple pour bien comprendre.
   <informalexample>
     <programlisting role="php">
&lt;?php
class a {
    function a($i) {
        $this-&gt;value = $i;
        // Essayez de comprendre on n'a pas besoin de
        // r&eacute;f&eacute;rence ici
        $this-&gt;b = new b($this);
    }
    function createRef() {
        $this-&gt;c = new b($this);
    }
    function echoValue() {
        echo "&lt;br&gt;","class ",get_class($this),': ',$this-&gt;value;
    }
}
class b  {
    function b(&amp;$a) {
        $this-&gt;a = &amp;$a;
    }
   function echoValue() {
        echo "&lt;br&gt;","class ",get_class($this),': ',$this-&gt;a-&gt;value;
        }
}
// Essayez de comprendre pourquoi une copie simple va
// conduire &agrave; un r&eacute;sultat ind&eacute;sirable &agrave; la ligne marqu&eacute;e d'une &eacute;toile
$a =&amp;new a(10);
$a-&gt;createRef();
$a-&gt;echoValue();
$a-&gt;b-&gt;echoValue();
$a-&gt;c-&gt;echoValue();
$a-&gt;value = 11;
$a-&gt;echoValue();
$a-&gt;b-&gt;echoValue(); // *
$a-&gt;c-&gt;echoValue();
/*
output:
class a: 10
class b: 10
class b: 10
class a: 11
class b: 11
class b: 11
*/
?&gt;
     </programlisting>
    </informalexample>
   </para>
  </sect1>
 </chapter>
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
