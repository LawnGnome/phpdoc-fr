 <chapter id="oop">
  <title>Classes et objets</title>
  <sect1 id="keyword.class">
   <title>Les classes : <literal>class</literal></title>
   <para>
     Une classe est une collection de variables et de fonctions qui
     fonctionnent avec ces variables. Une classe est d&eacute;finie
     en utilisant la syntaxe suivante :
    <informalexample>
     <programlisting role="php">
&lt;?php
class Caddie {
    var $items;  // El&eacute;ments de notre panier
    // Ajout de $num articles de type $artnr au panier
    function add_item ($artnr, $num) {
        $this->items[$artnr] += $num;
    }
    // Suppression de $num articles du type $artnr du panier
    function remove_item ($artnr, $num) {
        if ($this->items[$artnr] &gt; $num) {
            $this->items[$artnr] -= $num;
            return <literal>TRUE</literal>;
        } else {
            return <literal>FALSE</literal>;
        }
    }
}
?&gt;
     </programlisting>
    </informalexample>
   </para>
   <para>
    L'exemple ci-dessus d&eacute;finit la classe Caddie qui est compos&eacute;e d'un
    tableau associatif contenant les articles du panier et de deux fonctions,
    une pour ajouter et une pour enlever des &eacute;l&eacute;ments au panier.
   </para>
   <note>
    <simpara>
     En PHP 4, seuls les initialiseurs constants pour les variables
     <literal>var</literal> sont autoris&eacute;s. Utilisez les
     constructeurs pour les initialisations variables, ou utilisant
     des expressions.
    </simpara>
    <informalexample>
     <programlisting role="php">
&lt;?php
/* Aucune de ces syntaxes ne fonctionnera en PHP 4 */
class Caddie {
    var $date_du_jour = date("d/m/Y");
    var $name = $firstname;
    var $owner = 'Fred ' . 'Jones';
}
/* Voici comment cela doit se faire d&eacute;sormais. */
class Caddie {
    var $date_du_jour;
    var $name;
    var $owner;
    function Caddie() {
        $this->date_du_jour = date("d/m/Y");
        $this->name = $GLOBALS['firstname'];
        /* etc... */
    }
}
?&lt;
     </programlisting>
    </informalexample>
   </note>
   <para>
    Les classes forment un type de variable. Pour cr&eacute;er une variable
    du type d&eacute;sir&eacute;, vous devez utiliser l'op&eacute;rateur new.
   </para>
   <informalexample>
    <programlisting role="php">
&lt;?php
 $cart = new Caddie;
 $cart->add_item("10", 1);
?&gt;
    </programlisting>
   </informalexample>
   <para>
    L'instruction ci-dessus cr&eacute;e l'objet $cart de la class Caddie.
    La fonction add_idem() est appel&eacute;e afin d'ajouter l'article
    num&eacute;ro 10 dans la panier.
   </para>
   <para>
    Une classe peut &ecirc;tre une extension d'une autre classe.
    Les classes "extended" ou "derived" h&eacute;ritent de toutes
    les variables et de toutes les fonctions de la classe p&egrave;re
    plus toutes les d&eacute;finitions que vous rajoutez &agrave; cette
    classe. Cela se fait avec le mot clef "extends".
    L'h&eacute;ritage multiple n'est pas support&eacute;.
   </para>
   <informalexample>
    <programlisting role="php">
&lt;?php
class Caddie_nomme extends Caddie {
    var $owner;
    function set_owner ($name) {
        $this->owner = $name;
    }
}
?&gt;
    </programlisting>
   </informalexample>
   <para>
     L'exemple ci-desssus d&eacute;finit la classe Caddie_nomme qui
     poss&egrave;de les m&ecirc;me variables que la classe Caddie et
     la variable $owner en plus, ainsi que la fonction set_owner().
     Vous cr&eacute;ez un panier nominatif de la m&ecirc;me
     mani&egrave;re que pr&eacute;c&eacute;demment, et vous pouvez alors
     affecter un nom au panier ou en conna&icirc;tre le nom. Vous pouvez de
     toutes les fa&ccedil;ons utiliser les m&ecirc;me fonctions que sur un
     panier classique.
   </para>
   <informalexample>
    <programlisting role="php">
&lt;?php
$ncart = new Caddie_nomme;    // Cr&eacute;ation d'un panier nominatif
$ncart->set_owner ("kris"); // Affectation du nom du panier
print $ncart->owner;        // Affichage du nom du panier
$ncart->add_item ("10", 1); // (h&eacute;ritage des fonctions de la classe p&egrave;re)
?&gt;
    </programlisting>
   </informalexample>
   <para>
     Dans les fonctions d'une classe, la variable $this est
     &eacute;gale &agrave; l'objet de la classe. Vous pouvez
     utilisez la forme "$this->quelquechose" pour acc&eacute;der aux
     fonctions ou aux variables de l'objet courant. Aussi bien
     depuis l'objet lui-m&ecirc;me que de l'ext&eacute;rieur, vous n'avez pas
     besoin de <literal>$</literal> pour acc&eacute;der aux
     propri&eacute;t&eacute;s d'un objet.
   </para>
   <informalexample>
    <programlisting role="php">
&lt;?php
$ncart->owner  = "chris"; // pas de '$'
$ncart->$owner = "chris";
// Ceci est invalide, car $ncart->$owner &eacute;quivaut &agrave; $ncart->""
$myvar = 'owner';
$ncart->$myvar = "chris";
// Ceci est valide, car $ncart->$owner &eacute;quivaut &agrave; $ncart->owner
    </programlisting>
   </informalexample>
   <para>
    Le constructeur est la fonction qui est appel&eacute;e
    automatiquement par la classe lorsque vous cr&eacute;ez
    une nouvelle instance d'une classe. La fonction constructeur a
    le m&ecirc;me nom que la classe.
   </para>
   <informalexample>
    <programlisting role="php">
&lt;?php
class Auto_Caddie extends Caddie {
    function Auto_Caddie () {
        $this->add_item ("10", 1);
    }
}
?&gt;
    </programlisting>
   </informalexample>
   <para>
     L'exemple ci-dessus d&eacute;finit la classe Auto_Caddie qui
     h&eacute;rite de la classe Caddie et d&eacute;finit le construteur
     de la classe. Ce dernier initialise le panier avec 1 article de
     type num&eacute;ro 10 d&egrave;s que l'instruction "new" est
     appel&eacute;e. La fonction constructeur peut prendre ou non,
     des param&egrave;tres optionnels, ce qui la rend
     beaucoup plus pratique.
   </para>
   <informalexample>
    <programlisting role="php">
&lt;?php
class Constructor_Caddie extends Caddie {
    function Constructor_Caddie ($item = "10", $num = 1) {
        $this->add_item ($item, $num);
    }
}
// Place dans le caddie toujours la m&ecirc;me chose...
$default_cart   = new Constructor_Caddie;
// Place dans le caddie des objets diff&eacute;rents, comme dans la
// r&eacute;alit&eacute;
$different_cart = new Constructor_Caddie ("20", 17);
?&gt;
    </programlisting>
   </informalexample>
   <caution>
    <simpara>
     Pour les classes qui utilisent l'h&eacute;ritage,
     le constructeur de la classe p&egrave;re n'est pas
     automatiquement appel&eacute; lorsque le constructeur de la classe
     d&eacute;riv&eacute;e est appel&eacute;.
    </simpara>
   </caution>
  </sect1>
  <sect1 id="keyword.newref">
   <title>Références dans un constructeur</title>
   <para>
    Créer des références dans un constructeur peut conduire à 
    des résultats étranges. Ce tutorial vous guide pour éviter ces
    problèmes.
    <informalexample>
     <programlisting role="php">
&lt;?php
class foo {
    function foo($name) {
        // crée une référence dans le tableau global $globalref
        global $globalref;
		$globalref[] = &amp;$this;
        // donne le nom de la variable
        $this-&gt;setName($name);
		// et l'affiche
        $this-&gt;echoName();
    }

    function echoName() {
        echo "&lt;br&gt;",$this-&gt;Name;
    }
	
	function setName($name)	{
		$this-&gt;Name = $name;
    }
}
?&gt;
    </programlisting>
   </informalexample>
   </para>
   <para>
    Vérifions maintenant qu'il y a une différence entre <varname>$bar1</varname> 
    qui a été créé avec <literal>=</literal> et <varname>$bar2</varname> qui a été
    créé avec l'opérateur de référence <literal>=&amp;</literal> : 
   </para>
    <informalexample>
     <programlisting role="php">
&lt;?php
    $bar1 = new foo('crée dans le constructeur');
    $bar1-&gt;echoName();
    $globalref[0]-&gt;echoName();
    
    /* affiche :
    crée dans le constructeur
    crée dans le constructeur
    crée dans le constructeur */
    
    $bar2 =&amp;new foo('crée dans le constructeur');
    $bar2-&gt;echoName();
    $globalref[1]-&gt;echoName();

    /* affiche :
    crée dans le constructeur
    crée dans le constructeur
    crée dans le constructeur */
?&gt;
    </programlisting>
   </informalexample>
   <para>
    Apparement, il n'y a pas de différence, mais en fait, il y en a une
    significative : <varname>$bar1</varname> et <varname>$globalref[0]</varname> 
    ne sont pas référencées, ces deux variables sont différentes.
    Cela est du au fait que  l'opérateur "new"ne retourne par de référence,
    mais retourne une copie.
    <note>
     <simpara>
      Il n'y a aucune perte de performance (puisque PHP 4 utilise un compteur de
      référence) à retourner des copies au lieu de références. Au contraire, il est
      souvent mieux de travailler sur les copies plutôt que sur les références,
      car créer une référence prend un peu plus de temps que de créer une copie
      qui ne prend virtuellement pas de temps (à moins qu'il ne se crée un
      tableau géant ou un objet monstreux, auquel cas il est préférable de passer
      par des références).
     </simpara>
    </note>
    Pour prouver ceci, regardez le code suivant : 
   </para>
   <informalexample>
     <programlisting role="php">
&lt;?php
        // maintenant, nous allons changer de nom. Qu'attendez vous?
        // Vous pouvez vous attendre à ce que les deux variables $bar 
        // et  $globalref[0] change de nom...
        $bar1-&gt;setName('modifié');

        // comme prédit, ce n'est pas le cas
        $bar1-&gt;echoName();
        $globalref[0]-&gt;echoName();

        /* affiche :
        crée dans le constructeur
        modifié */

        // quelle est la différence entre $bar2 et $globalref[1]
        $bar2-&gt;setName('modifié');

        // Heureusement, elles sont non seulement égales, mais
        // elles représentent la même variable.
        // donc $bar2-&gt;Name et $globalref[1]-&gt;Name sont les mêmes
        $bar2-&gt;echoName();
        $globalref[1]-&gt;echoName();

        /* affiche :
        modifié
        modifié */
?&gt;
    </programlisting>
   </informalexample>   
   <para>
   Un dernier exemple pour bien comprendre.
   <informalexample>
     <programlisting role="php">
&lt;?php
class a {
    function a($i) {
        $this-&gt;value = $i;
        // Essayez de comprendre on n'a pas besoin de
        // référence ici
        $this-&gt;b = new b($this);
    }

    function createRef() {
        $this-&gt;c = new b($this);
    }

    function echoValue() {
        echo "&lt;br&gt;","class ",get_class($this),': ',$this-&gt;value;
    }
}


class b  {

    function b(&amp;$a) {
        $this-&gt;a = &amp;$a;
    }

   function echoValue() {
        echo "&lt;br&gt;","class ",get_class($this),': ',$this-&gt;a-&gt;value;
        }

}

// Essayez de comprendre pourquoi une copie simple va
// conduire à un résultat indésirable à la ligne marquée d'une étoile
$a =&amp;new a(10);
$a-&gt;createRef();

$a-&gt;echoValue();
$a-&gt;b-&gt;echoValue();
$a-&gt;c-&gt;echoValue();

$a-&gt;value = 11;

$a-&gt;echoValue();
$a-&gt;b-&gt;echoValue(); // *
$a-&gt;c-&gt;echoValue();

/*
output:
class a: 10
class b: 10
class b: 10
class a: 11
class b: 11
class b: 11
*/
?&gt;
     </programlisting>
    </informalexample>   
   </para>
  </sect1>
 </chapter>
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
