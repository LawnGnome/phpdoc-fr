<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.38 $ -->
<!-- EN-Revision: 1.51 Maintainer: dams Status: ready -->
 <chapter id="language.oop">
  <title>Les classes et les objets</title>
  <sect1 id="keyword.class">
   <title>Les classes : <literal>class</literal></title>
   <para>
     Une classe est une collection de variables et de fonctions qui
     fonctionnent avec ces variables. Une classe est définie
     en utilisant la syntaxe suivante :
    <example>
     <title>Les classes en &php;</title>
     <programlisting role="php">
 <![CDATA[
<?php
class Panier {
// Eléments de notre panier
    var $items;  

// Ajout de $num articles de type $artnr au panier
    function add_item ($artnr, $num) {
        $this->items[$artnr] += $num;
    }

// Suppression de $num articles du type $artnr du panier
    function remove_item ($artnr, $num) {
        if ($this->items[$artnr] > $num) {
            $this->items[$artnr] -= $num;
            return TRUE;
        } else {
            return FALSE;
        }
    }
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    L'exemple ci-dessus définit la classe Panier qui est composée
    d'un tableau associatif contenant les articles du panier et de deux
    fonctions, une pour ajouter et une pour enlever des éléments
    au panier.
   </para>
   <warning>
    <simpara>
     Vous <emphasis>NE POUVEZ PAS</emphasis> couper la définition d'une
     classe en plusieurs fichiers, on en plusieurs blocs PHP. La notation
     suivante ne fonctionnera pas : 
    </simpara>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class test {
?>
<?php
    function test() {
        print 'OK';
    }
}
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </warning>
    <simpara>
     Les notes suivantes ne sont valables que pour &php; 4.
    </simpara>

   <caution>
    <simpara>
     Le nom <literal>stdClass</literal> est utilisé en interne par
     Zend et ne doit pas être utilisé. Vous ne pouvez pas nommer
     une classe <literal>stdClass</literal> en &php;.
    </simpara>
   </caution>

   <caution>
    <simpara>
      Les noms de fonctions <literal>__sleep</literal> et
      <literal>__wakeup</literal> sont magiques en &php;. Vous ne pouvez
      pas utiliser ces noms de fonctions dans vos classes, à moins
      que vous ne souhaitiez utiliser la magie qui y est associée.
    </simpara>
   </caution>

   <caution>
    <simpara>
      &php; se réserve l'usage de tous les noms de fonctions
      commençants par <literal>__</literal>, pour sa propre magie. 
      Il est vivement recommandé de ne pas utiliser des noms de fonctions
      commençants par <literal>__</literal>, à moins que vous ne
      souhaitiez utiliser la magie qui y est associée.
    </simpara>
   </caution>
   <note>
    <simpara>
     En &php; 4, seuls les initialiseurs constants pour les variables
     <literal>var</literal> sont autorisés. Utilisez les
     constructeurs pour les initialisations variables, ou utilisant
     des expressions.
    </simpara>
    <example>
    <title>Initialisation de membres de classe</title>
     <programlisting role="php">
 <![CDATA[
<?php
/* Aucune de ces syntaxes ne fonctionnera en PHP 4 */
class Panier {
    var $date_du_jour = date("d/m/Y");
    var $name = $firstname;
    var $owner = 'Fred ' . 'Jones';
    var $items = array("DVD", "Télé","Magnétoscope");
}
/* Voici comment cela doit se faire désormais. */
class Panier {
    var $date_du_jour;
    var $name;
    var $owner;
    var $items;
    function Panier() {
        $this->date_du_jour = date("d/m/Y");
        $this->name = $GLOBALS['firstname'];
        /* etc... */
    }
}
?>
]]>
     </programlisting>
    </example>
   </note>
   <para>
    Les classes forment un type de variable. Pour créer une variable
    du type désiré, vous devez utiliser l'opérateur new.
   </para>
   <example>
    <title>Création d'un objet de classe</title>
    <programlisting role="php">
 <![CDATA[
<?php
 $cart = new Panier;
 $cart->add_item("10", 1);
 $another_cart = new Panier;
 $another_cart->add_item("0815", 3);
?>
]]>

    </programlisting>
   </example>
   <para>
    L'instruction ci-dessus crée l'objet <varname>$cart</varname> de la classe 
    <classname>Panier</classname>.
    La fonction <literal>add_idem()</literal> est appelée afin d'ajouter l'article
    numéro 10 dans le panier. 3 articles numéro 0815 sont 
    ajoutés au panier <varname>$another_cart</varname>.
   </para>
   <para>
    <varname>$cart</varname> et <varname>$another_cart</varname> disposent des fonctions 
    <literal>add_item()</literal>, <literal>remove_item()</literal> et de la variable 
    <varname>items</varname>. Ce sont des fonctions
    et variables distinctes. Vous pouvez vous représenter les
    objets comme des dossiers sur votre disque dur. Vous pouvez
    avoir deux fichiers <filename>lisez-moi.txt</filename> sur votre disque dur, tant qu'ils
    ne sont pas dans le même répertoire. De même que vous
    devez alors taper le chemin complet jusqu'au fichier, vous devez 
    spécifier le nom complet de la méthode avant de l'employer :
    en termes &php;, le dossier racine est l'espace de nom global, et le 
    séparateur de dossier est <literal>-&gt;</literal>.  Par exemple, 
    les noms <varname>$cart-&gt;items</varname> et <varname>$another_cart-&gt;items</varname> représentent deux
    variables distinctes. Notez que le nom de la variable est alors
    <varname>$cart-&gt;items,</varname> et non pas <varname>$cart-&gt;$items</varname> : il n'y a qu'un seul
    signe $ dans un nom de variable.
   </para>
   <example>
    <title>Accès aux membres d'une classe</title>
    <programlisting role="php">
 <![CDATA[
<?php
// correct, le signe $ est unique
$cart->items  = array("10" => 1);
// incorrect, car $cart->$items devient $cart->""
$cart->$items = array("10" => 1);
// correct, mais risque de ne pas se comporter comme prévu
// $cart->$myvar devient $cart->items
$myvar = 'items';
$cart->$myvar = array("10" => 1);
?>
]]>
    </programlisting>
   </example>
   <para>
    A l'intérieur d'une définition de classe, vous ne savez pas le
    nom de la variable à partir duquel l'objet sera accessible dans
    le script. On ne peut prévoir que l'objet créé sera 
    affecté à la variable <varname>$cart</varname> ou <varname>$another_cart.</varname> Donc, vous ne 
    pouvez pas utiliser la syntaxe <varname>$cart-&gt;items.</varname> Mais pour pouvoir accéder
    à aux méthodes et membres d'un objet, vous pouvez utiliser la 
    variable spéciale <varname>$this,</varname> qui peut s'interpréter comme 'moi-même',
    ou bien 'l'objet courant'. Par exemple, <literal>'$this->items[$artnr] += $num;'</literal>
    peut se lire comme 'ajouter <varname>$num</varname> au compteur <varname>$artnr</varname> de mon propre tableau
    de compteur' ou bien 'ajouter <varname>$num</varname> au compteur <varname>$artnr</varname> du tableau de compteurs
    de l'objet courant'.
   </para>
   <note>
    <para>
    Il y a des fonctions très pratiques pour gérer les classes et objets.
    Vous pouvez étudier le chapitre sur les 
    <link linkend="ref.classobj">fonctions de classes et objets</link>.
    </para>
   </note>
  </sect1>
  <sect1 id="keyword.extends">
   <title><literal>extends</literal> : héritage</title>
   <para>
    Souvent, vous aurez besoin d'une classe avec des méthodes et
    fonctions similaires à une autre classe. En fait, il est bon
    de définir des classes génériques, qui pourront 
    être réutilisées et adaptées à tous
    vos projets. Pour faciliter cela, une classe peut être une extension
    d'une autre classe. La classe dérivée hérite alors de
    toutes les méthodes et variables de la classe de base (cet 
    héritage a de bien que personne ne meurt pour en profiter), mais peut
    définir ses propres fonctions et variables, qui s'ajouteront. Une
    classe ne peut hériter que d'une seule autre classe, et l'héritage
    multiple n'est pas supporté. Les héritages se font avec le mot 
    clé '<literal>extends</literal>'.
   </para>
   <example>
    <title>Héritage de classes</title>
    <programlisting role="php">
 <![CDATA[
<?php
class Panier_nomme extends Panier {
    var $owner;
    function set_owner ($name) {
        $this->owner = $name;
    }
}
?>
]]>
    </programlisting>
   </example>
   <para>
     L'exemple ci-dessus définit la classe <classname>Panier_nomme</classname> qui
     possède les mêmes variables que la classe Panier et
     la variable <varname>$owner</varname> en plus, ainsi que la fonction 
     <literal>set_owner()</literal>.
     Vous créez un panier nominatif de la même
     manière que précédemment, et vous pouvez alors
     affecter un nom au panier ou en connaître le nom. Vous pouvez de
     toutes les façons utiliser les mêmes fonctions que sur un
     panier classique.
   </para>
   <example>
    <title>Héritage de classes (2)</title>
    <programlisting role="php">
 <![CDATA[
<?php
$ncart = new Panier_nomme;    // Création d'un panier nominatif
$ncart->set_owner ("kris"); // Affectation du nom du panier
print $ncart->owner;        // Affichage du nom du panier
$ncart->add_item ("10", 1); // (héritage des fonctions de la classe père)
?>
]]>
    </programlisting>
   </example>
  </sect1>
  <sect1 id="language.oop.constructor">
   <title><literal>Constructor</literal> : constructeur</title>
   <caution>
    <simpara>
     En &php; 3 et &php; 4, les constructeurs se comportent différemment.
     La sémantique de &php; 4 est fortement recommandée.
    </simpara>
   </caution>
   <para>
    Le constructeur est la fonction qui est appelée
    automatiquement par la classe lorsque vous créez
    une nouvelle instance d'une classe a l'aide de l'opérateur
    <literal>new</literal>. La fonction constructeur a
    le même nom que la classe.
    En &php; 3, une fonction devient le constructeur si elle porte le
    même nom que la classe. En &php; 4, une fonction devient un constructeur
    si elle porte le même nom que la classe dans laquelle elle est définie.
    La différence est subtile, mais cruciale.
   </para>
   <example>
    <title>Constructeur de classe</title>
    <programlisting role="php">
 <![CDATA[
<?php
class Auto_Panier extends Panier {
    function Auto_Panier () {
        $this->add_item ("10", 1);
    }
}
// Cette syntaxe est valable en PHP 3 et 4
?>
]]>
    </programlisting>
   </example>
    <para>
     L'exemple ci-dessus définit la classe <classname>Auto_Panier</classname> qui
     hérite de la classe Panier et définit le constructeur
     de la classe. Ce dernier initialise le panier avec 1 article de
     type numéro 10 dès que l'instruction "new" est
     appelée. La fonction constructeur peut prendre ou non
     des paramètres optionnels, ce qui la rend beaucoup plus
     pratique. Pour pouvoir utiliser cette classe sans paramètre,
     tous les paramètres du constructeurs devraient être optionnels,
     en fournissant une valeur par défaut, comme ci-dessous.
   </para>
   <example>
    <title>Constructeur de classe à argument optionnel</title>
    <programlisting role="php">
 <![CDATA[
<?php
// Cette syntaxe est valable en PHP 3 et 4
class Constructor_Cart extends Cart {
    function Constructor_Cart ($item = "10", $num = 1) {
        $this->add_item ($item, $num);
    }
}
// Création du Panier
$default_cart   = new Constructor_Cart;
// Création d'un vrai Panier
$different_cart = new Constructor_Cart ("20", 17);
?>
]]>
    </programlisting>
   </example>
   <caution>
    <simpara>
     En &php; 3, les classes dérivées et les constructeurs ont un certains
     nombre de limitations. Les exemples suivants doivent être lus avec
     beaucoup d'attention pour comprendre ces limitations.
    </simpara>
   </caution>
   <example>
    <title>Constructeur de classe en &php; 4</title>
    <programlisting role="php">
 <![CDATA[
<?php
class A {
  function A() {
    echo "Je suis le constructeur de A.<br>\n";
  }
}
class B extends A {
  function C() {
    "Je suis une fonction standard.<br>\n";
  }
}
// Aucun constructeur n'est appelé en PHP 3!!
$b = new B;
?>
]]>
    </programlisting>
   </example>
   <para>
    En &php; 3, aucun constructeur ne sera appelé dans l'exemple ci-dessus.
    La règle en &php; 3 est : 'Un constructeur est une méthode qui 
    a le même nom que la classe'. Le nom de la classe est B, et il n'y a pas
    de fonction qui s'appelle B() dans la classe B. Rien ne se passe.
   </para>
   <para>
    Ceci est corrigé en &php; 4, avec l'introduction d'une nouvelle règle :
    Si une classe n'a pas de constructeur, le constructeur de la classe de
    basse est appelé, s'il existe. L'exemple ci-dessus affichera
    '<literal>Je suis le constructeur de A.&lt;br&gt;</literal>' en &php; 4.
   </para>
   <example>
    <title>Constructeur de classe en &php; 4</title>
    <programlisting role="php">
 <![CDATA[
<?php
class A {
  function A() {
    echo "Je suis le constructeur de A.<br>\n";
  }
  function B() {
    echo "Je suis une fonction standard appelée B dans la classe A.<br>\n";
    echo "Je ne suis pas le constructeur de A.<br>\n";
  }
}

class B extends A {
  function C() {
    echo "Je suis une fonction standard.<br>\n";
  }
}
// Cette syntaxe va appeler B() comme constructeur.
$b = new B;
?>
]]>
    </programlisting>
   </example>
   <para>
    En &php; 3, la fonction B() de la classe A va soudainement devenir le
    constructeur de la classe B, bien qu'il n'ai pas été
    prévu pour. La règle de &php; 3 est 'Un constructeur est une
    méthode qui a le même nom que la classe'. &php; 3 ne se soucie
    guère si la fonction est définie dans la classe B ou 
    si elle a été héritée.
   </para>
   <para>
    Ceci est corrigé en &php; 4, avec l'introduction d'une nouvelle
    règle :
    'Un constructeur est une méthode de même nom que la classe, 
    définie dans la classe elle-même'. Donc, en &php; 4, la classe
    B n'a pas de constructeur par elle-même, et le constructeur de la 
    classe A aura été appelé, affichant :
    '<literal>Je suis le constructeur de A.&lt;br&gt;</literal>'.
   </para>
   <caution>
    <simpara>
     Ni &php; 3 ni &php; 4 n'appelle automatiquement le constructeur de
     la classe supérieure depuis le constructeur de la classe
     dérivée. Il est de votre responsabilité de propager
     l'appel des constructeurs.
    </simpara>
   </caution>
   <note>
    <simpara>
     Il n'y a pas de destructeurs en &php; 3 et &php; 4. Vous pouvez utiliser
     la fonction <function>register_shutdown_function</function> à la
     place, pour simuler un destructeur.
    </simpara>
   </note>
   <para>
    Les destructeurs sont des fonctions qui sont appelées lorsqu'un
    objet est détruit, soit avec la fonction <function>unset</function>
    soit par simple sortie d'une fonction (cas des variables locales).
    Il n'y a pas de destructeurs en &php;.
   </para>
  </sect1>
 <sect1 id="keyword.paamayim-nekudotayim">
   <title>Opérateur <literal>::</literal></title>
   <caution>
    <simpara>
     La documentation suivante n'est valable que pour &php; 4 et plus récent.
    </simpara>
   </caution>
   <para>
    Parfois, il est pratique de faire référence aux fonctions
    est variables d'une classe de base, ou bien d'utiliser
    des méthodes de classes qui n'ont pas encore d'objets
    créés. L'opérateur <literal>::</literal> est là pour ces
    situations.
   </para>
   <example>
    <title>Exemples avec l'opérateur <literal>::</literal></title>
    <programlisting role="php">
 <![CDATA[
<?php
class A {
  function example() {
    echo "Je suis la fonction originale A::example().<br>\n";
  }
}
class B extends A {
  function example() {
    echo "Je suis la fonction redéfinie B::example().<br>\n";
    A::example();
  }
}
// Il n'y a pas d'objets de classe A.
// L'affichage est :
//   Je suis la fonction originale A::example().<br>
A::example();
// Création d'un objet de la classe B.
$b = new B;
// L'affichage est :
//   Je suis la fonction redéfinie B::example().<br>
//   Je suis la fonction originale A::example().<br>
$b->example();
?>
]]>
    </programlisting>
   </example>
   <para>
    Les exemples ci-dessus appellent la fonction <literal>example()</literal> dans la
    classe A, mais il n'y a pas encore d'objet de classe A, alors il
    n'est pas possible d'écrire <literal>$a->example()</literal>. A la place, on appelle
    la fonction <literal>example()</literal> comme une fonction de classe, c'est-à-dire
    avec le nom de la classe elle-même, et sans objet.
   </para>
   <para>
    Il y a des fonctions de classe, mais pas de variables de classe.
    En fait, il n'y a aucun objet au moment de l'appel de la fonction.
    Donc, une fonction de classe ne peut accéder à aucune variable
    (mais elle peut accéder aux variables locales et globales).
    Il faut proscrire l'utilisation de <varname>$this</varname>.
   </para>
   <para>
    Dans l'exemple ci-dessus, la classe B redéfinit la fonction <literal>example()</literal>.
    La définition originale dans la classe A est remplacée par celle de
    B, et n'est plus accessible depuis B, à moins que vous n'appeliez
    spécifiquement la fonction <literal>example()</literal> de la classe A avec l'opérateur
    ::. Ecrivez <literal>A::example()</literal> pour cela (en fait, il faudrait écrire
    <literal>parent::example()</literal>, comme expliqué dans la section suivante).
   </para>
   <para>
    Dans ce contexte, il y a un objet courant, qui peut avoir d'autres
    variables objets. De ce fait, lorsqu'il est utilisé depuis une méthode
    d'un objet, vous pouvez utiliser <varname>$this.</varname>
   </para>
 </sect1>
 <sect1 id="keyword.parent">
   <title><literal>parent</literal></title>
  <para>
   Il arrive que vous ayez à écrire du code qui faire référence
   aux variables et fonctions des classes de base. C'est particulièrement
   vrai si votre classe dérivée est une spécialisation de votre classe
   de base.
  </para>
  <para>
   Au lieu d'utiliser le nom littéral de votre classe de base dans
   votre code, vous pouvez utiliser le mot réservé
   <literal>parent</literal>, qui représente votre classe de
   base (celle indiqué par <literal>extends</literal>, dans la déclaration
   de votre classe). En faisant cela, vous éviter d'appeler le
   nom de votre classe de base directement dans votre code.
   Si votre héritage change, vous n'aurez plus qu'à modifier
   le nom de la classe dans la déclaration <literal>extends</literal>
   de votre classe.
  </para>
   <example>
    <title>Exemples avec l'opérateur <literal>parent</literal></title>
   <programlisting role="php">
 <![CDATA[
<?php
class A {
  function example() {
    echo "Je suis A::example() et je fournis une fonctionnalité de base.<br>\n";
  }
}
class B extends A {
  function example() {
    echo "Je suis B::example() et je fournis une fonctionnalité supplémentaire.<br>\n";
    parent::example();
  }
}
$b = new B;
// Cette syntaxe va appeler B::example(), qui, à sont tour, va appeler A::example().
$b->example();
?>
]]>
   </programlisting>
  </example>
 </sect1>
 <sect1 id="language.oop.serialization">
  <title>Sauvegarde d'objets - cas des sessions</title>
  <note>
   <simpara>
    En &php; 3, les objets perdent leur association de classe à travers
    le processus de sauvegarde et relecture. Le type de la variable après
    relecture est bien objet mais il n'a plus de méthode ou de nom
    de classe. Cela rend la fonctionnalité plutôt inutile (l'objet
    est devenu un tableau avec une syntaxe étrange).
   </simpara>
  </note>
  <caution>
   <simpara>
    La documentation suivante n'est valable que pour &php; 4.
   </simpara>
  </caution>
  <para>
   <function>serialize</function> retourne une chaîne représentant
   une valeur qui peut être stockée dans les sessions de &php;, ou une
   base de données. <function>unserialize</function> peut relire cette
   chaîne pour recréer la valeur originale. <function>serialize</function>
   va sauver toutes les variables d'un objet. Le nom de la classe sera
   sauvé mais par les méthodes de cet objet.
  </para>
  <para>
   Pour permettre à <function>unserialize</function> de lire un objet,
   la classe de cet objet doit être définie. C'est-à-dire, si vous avez
   un objet <varname>$a</varname> de la classe A dans une page php1.php, et que vous le
   linéarisez avec <function>serialize</function>, vous obtiendrez une
   chaîne qui fait référence à la classe A, et contient toutes les valeurs
   de <varname>$a.</varname> Pour pouvoir le relire avec la fonction <function>unserialize</function>
   dans une page page2.php, il faut que la définition de la classe
   A soit présente dans cette deuxième page. Cela peut se faire
   de manière pratique en sauvant la définition de la classe A dans un
   fichier séparé, et en l'incluant dans les deux pages page1.php et
   page2.php.
  </para>
  <example>
   <title>La classe d'un objet doit être définie avant sa désérialisation</title>
   <programlisting role="php">
 <![CDATA[
<?php
classa.inc:
  class A {
    var $one = 1;
    function show_one() {
      echo $this->one;
    }
  }
?>
page1.php:
<?php
  include("classa.inc");
  $a = new A;
  $s = serialize($a);
  // enregistrez $s où la page2.php pourra le trouver.
  $fp = fopen("store", "w");
  fputs($fp, $s);
  fclose($fp);
?>
page2.php:
<?php
  // Ceci est nécessaire pour que unserialize() fonctionne correctement
  include("classa.inc");
  $s = implode("", @file("store"));
  unserialize($s);
  // maintenant, utilisez la méthode show_one de l'objet $a.
  $a->show_one();
?>
]]>
   </programlisting>
  </example>
  <para>
   Si vous utilisez les sessions et la fonction <function>session_register</function>
   pour sauver des objets, ces objets seront linéarisés automatiquement
   avec la fonction <function>serialize</function> à la fin de chaque
   script, et relus avec <function>unserialize</function> au début du prochain
   script. Cela signifie que ces objets peuvent apparaître dans n'importe quelle
   page qui utilise vos sessions.
  </para>
  <para>
   Il est vivement recommandé d'inclure la définition de classe dans
   toutes vos pages, même si vous n'utilisez pas ces classes dans
   toutes vos pages. Si vous l'oubliez et qu'un tel objet est
   présent, il perdra sa classe, et deviendra un objet de classe
   <literal>stdClass</literal> sans aucune fonction, et donc, plutôt
   inutile.
  </para>
  <para>
   Si, dans l'exemple ci-dessus, <varname>$a</varname> devient un objet de session
   avec l'utilisation de <literal>session_register("a")</literal>, vous
   devez pensez à inclure le fichier <literal>classa.inc</literal> dans toutes
   vos pages, et pas seulement page1.php et page2.php.
  </para>
 </sect1>
 <sect1 id="language.oop.magic-functions">
  <title>Les fonctions magiques <literal>__sleep</literal> et <literal>__wakeup</literal></title>
  <para>
   <function>serialize</function> s'assure que votre classe a une méthode
   avec le nom magique <literal>__sleep</literal>. Si c'est le cas, cette
   fonction est appelée avant toute linéarisation. Elle peut alors nettoyer
   l'objet et on s'attend à ce qu'elle retourne un tableau avec la liste des
   noms de variables qui doivent être sauvées.
  </para>
  <para>
   Le but de cette fonction <literal>__sleep</literal> est de fermer
   proprement toute connexion à une base de données, de valider les
   requêtes, de finaliser toutes les actions commencées. Cette fonction
   est aussi pratique si vous ave de très grands objets qui n'ont pas
   besoin d'être sauvé entièrement.
  </para>
  <para>
   A l'inverse, <function>unserialize</function> s'assure de la présence
   de la fonction magique <literal>__wakeup</literal>. Si elle existe, cette
   fonction reconstruit toutes les ressources d'un objet.
  </para>
  <para>
    Le but de cette fonction <literal>__wakeup</literal> est de rétablit
    toutes les connexions aux bases de données, et de recréer les
    variables qui n'ont pas été sauvées.
  </para>
 </sect1>
 <sect1 id="language.oop.newref">
   <title>Références dans un constructeur</title>
   <para>
    Créer des références dans un constructeur
    peut conduire à des résultats étranges. 
    Ce tutoriel vous guide pour éviter ces problèmes.
    <example>
     <title>Références dans un constructeur</title>
     <programlisting role="php">
 <![CDATA[
<?php
class foo {
    function foo($name) {
        // crée une référence dans le tableau global $globalref
        global $globalref;
		$globalref[] = &$this;
        // donne le nom de la variable
        $this->setName($name);
		// et l'affiche
        $this->echoName();
    }
    function echoName() {
        echo "<br>",$this->Name;
    }
	function setName($name)	{
		$this->Name = $name;
    }
}
?>
]]>
    </programlisting>
   </example>
   </para>
   <para>
    Vérifions maintenant qu'il y a une différence entre 
    <varname>$bar1</varname> qui a été créé avec
    <literal>=</literal> et <varname>$bar2</varname> qui a été
    créé avec l'opérateur de référence
    <literal>=&amp;</literal> :
   </para>
    <example>
     <title>Références dans un constructeur (2)</title>
     <programlisting role="php">
 <![CDATA[
<?php
    $bar1 = new foo('crée dans le constructeur');
    $bar1->echoName();
    $globalref[0]->echoName();
    /* affiche :
    crée dans le constructeur
    crée dans le constructeur
    crée dans le constructeur */
    $bar2 =&new foo('crée dans le constructeur');
    $bar2->echoName();
    $globalref[1]->echoName();
    /* affiche :
    crée dans le constructeur
    crée dans le constructeur
    crée dans le constructeur */
?>
]]>
    </programlisting>
   </example>
   <para>
    Apparemment, il n'y a pas de différence, mais en fait, il y en a une
    significative : <varname>$bar1</varname> et <varname>$globalref[0]</varname>
    ne sont pas référencées, ces deux variables sont différentes.
    Cela est du au fait que  l'opérateur "new"ne retourne par de référence,
    mais retourne une copie.
    <note>
     <simpara>
      Il n'y a aucune perte de performances (puisque &php; 4 utilise un compteur
      de références) à retourner des copies au lieu de 
      références. Au contraire, il est souvent mieux de travailler
      sur les copies plutôt que sur les références,
      car créer une référence prend un peu plus de temps
      que de créer une copie qui ne prend virtuellement pas de temps
      (à moins de créer un tableau géant ou un objet monstrueux,
      auquel cas il est préférable de passer par des 
      références).
     </simpara>
    </note>
    Pour prouver ceci, regardez le code suivant :
   </para>
   <example>
   <title>Références et constructeurs</title>
     <programlisting role="php">
 <![CDATA[
<?php
        // maintenant, nous allons changer de nom. Qu'attendez-vous?
        // Vous pouvez vous attendre à ce que les deux variables $bar
        // et  $globalref[0] changent de nom...
        $bar1->setName('modifié');
        // comme prédit, ce n'est pas le cas
        $bar1->echoName();
        $globalref[0]->echoName();
        /* affiche :
        crée dans le constructeur
        modifié */
        // quelle est la différence entre $bar2 et $globalref[1]
        $bar2->setName('modifié');
        // Heureusement, elles sont non seulement égales, mais
        // elles représentent la même variable.
        // donc $bar2->Name et $globalref[1]->Name sont les mêmes
        $bar2->echoName();
        $globalref[1]->echoName();
        /* affiche :
        modifié
        modifié */
?>
]]>
    </programlisting>
   </example>
   <para>
   Un dernier exemple pour bien comprendre.
   <example>
    <title>Références dans un constructeur (3)</title>
    <programlisting role="php">
 <![CDATA[
<?php
class a {
    function a($i) {
        $this->value = $i;
        // Essayez de comprendre on n'a pas besoin de
        // référence ici
        $this->b = new b($this);
    }
    function createRef() {
        $this->c = new b($this);
    }
    function echoValue() {
        echo "<br>","class ",get_class($this),': ',$this->value;
    }
}
class b  {
    function b(&$a) {
        $this->a = &$a;
    }
   function echoValue() {
        echo "<br>","class ",get_class($this),': ',$this->a->value;
        }
}
// Essayez de comprendre pourquoi une copie simple va
// conduire à un résultat indésirable à
// la ligne marquée d'une étoile
$a =&new a(10);
$a->createRef();
$a->echoValue();
$a->b->echoValue();
$a->c->echoValue();
$a->value = 11;
$a->echoValue();
$a->b->echoValue(); // *
$a->c->echoValue();
/*
output:
class a: 10
class b: 10
class b: 10
class a: 11
class b: 11
class b: 11
*/
?>
]]>

     </programlisting>
    </example>
   </para>
  </sect1>
  <sect1 id="language.oop.object-comparison-php4">
   <title>Comparer des objets en &php; 4</title>
  <para>
   En &php; 4, les objets sont comparés de manière très simple, 
   à savoir : deux instances sont égales si elles ont les mêmes 
   attributs et valeurs, et qu'elles sont de la même classe. Des règles
   similaires s'appliquent lors de la comparaison avec l'opérateur 
   <literal>===</literal>.
  </para>
  <para>
   Si vous exécutons le code suivant : 
   <example>
    <title>Exemple de comparaison d'objets en &php; 4</title>
    <programlisting role='php'>
<![CDATA[
<?php

function bool2str($bool) {
    if ($bool === false) {
            return 'FALSE';
    } else {
            return 'TRUE';
    }
}

function compareObjects(&$o1, &$o2) {
    echo 'o1 == o2 : '.bool2str($o1 == $o2)."\n";
    echo 'o1 != o2 : '.bool2str($o1 != $o2)."\n";
    echo 'o1 === o2 : '.bool2str($o1 === $o2)."\n";
    echo 'o1 !== o2 : '.bool2str($o1 !== $o2)."\n";
}

class Flag {
    var $flag;

    function Flag($flag=true) {
            $this->flag = $flag;
    }
}

class SwitchableFlag extends Flag {

    function turnOn() {
        $this->flag = true;
    }

    function turnOff() {
        $this->flag = false;
    }
}

$o = new Flag();
$p = new Flag(false);
$q = new Flag();

$r = new SwitchableFlag();

echo "Compare des instances créées avec les mêmes paramètres\n";
compareObjects($o, $q);

echo "\nCompare des instances créées avec différents paramètres\n";
compareObjects($o, $p);

echo "\nCompare une instance d'un parent avec celle d'une sous-classe\n";
compareObjects($o, $r);

?>
]]>
    </programlisting>
   </example>
   Cet exemple va afficher : 
   <screen>
<![CDATA[
Compare des instances créées avec les mêmes paramètres
o1 == o2 : TRUE
o1 != o2 : FALSE
o1 === o2 : TRUE
o1 !== o2 : FALSE

Compare des instances créées avec différents paramètres
o1 == o2 : FALSE
o1 != o2 : TRUE
o1 === o2 : FALSE
o1 !== o2 : TRUE

Compare une instance d'un parent avec celle d'une sous-classe
o1 == o2 : FALSE
o1 != o2 : TRUE
o1 === o2 : FALSE
o1 !== o2 : TRUE
]]>
   </screen>
   Ce qui est le résultat que nous attendions, au vue des règles édictées.
   Seules deux instances avec les mêmes valeurs d'attributs, et issues de la même
   classe sont considérées comme égales.
  </para>
  <para>
   Même lorsque nous avons une composition d'objet, la même règle de comparaison
   s'applique. Dans l'exemple ci-dessous, nous allons créer une classer conteneur,
   qui stocke un tableau associatif <classname>Flag</classname>.
   <example>
    <title>Comparaison d'objets composés en &php; 4</title>
    <programlisting role='php'>
<![CDATA[
<?php

class FlagSet {
    var $set;

    function FlagSet($flagArr = array()) {
        $this->set = $flagArr;
    }

    function addFlag($name, $flag) {
        $this->set[$name] = $flag;
    }

    function removeFlag($name) {
        if (array_key_exists($name, $this->set)) {
            unset($this->set[$name]);
        }
    }
}


$u = new FlagSet();
$u->addFlag('flag1', $o);
$u->addFlag('flag2', $p);
$v = new FlagSet(array('flag1'=>$q, 'flag2'=>$p));
$w = new FlagSet(array('flag1'=>$q));

echo "\nObjects composés u(o,p) et v(q,p)\n";
compareObjects($u, $v);

echo "\nu(o,p) et w(q)\n";
compareObjects($u, $w);

?>
]]>
    </programlisting>
   </example>
   Qui va donner l'affichage suivant : 
   <screen>
Objects composés u(o,p) et v(q,p)
o1 == o2 : TRUE
o1 != o2 : FALSE
o1 === o2 : TRUE
o1 !== o2 : FALSE

u(o,p) et w(q)
o1 == o2 : FALSE
o1 != o2 : TRUE
o1 === o2 : FALSE
o1 !== o2 : TRUE
   </screen>
  </para>
 </sect1>

  <sect1 id="language.oop.object-comparison-php5">
   <title>Comparer des objets en &php; 5</title>
   &warn.experimental;
   <para>
    En &php; 5, la comparaison d'objets et plus compliquée qu'en &php; 4,
    afin d'être plus proche du comportement des langages orienté objet 
    (bien que &php; n'en soit pas un).
   </para>
   <para>
    Lors de l'utilisation de l'opérateur de comparaison <literal>==</literal>, 
    les objets sont comparées de manière simple, à savoir : 
    deux objets sont égaux si ils ont les mêmes attributs et valeurs, et qu'ils
    sont des instances de la même classe.
   </para>
   <para>
    D'un autre coté, lors de l'utilisation de l'opérateur d'identité 
    (<literal>===</literal>), les objets sont identiques uniquement si ils
    font référence au même objet de la même classe.
   </para>
   <para>
    Un exemple va illustrer ces règles.
    <example>
     <title>Exemple de comparaison d'objets en &php; 5</title>
     <programlisting role='php'>
<![CDATA[
<?php

function bool2str($bool) {
    if ($bool === false) {
            return 'FALSE';
    } else {
            return 'TRUE';
    }
}

function compareObjects(&$o1, &$o2) {
    echo 'o1 == o2 : '.bool2str($o1 == $o2)."\n";
    echo 'o1 != o2 : '.bool2str($o1 != $o2)."\n";
    echo 'o1 === o2 : '.bool2str($o1 === $o2)."\n";
    echo 'o1 !== o2 : '.bool2str($o1 !== $o2)."\n";
}

class Flag {
    var $flag;

    function Flag($flag=true) {
            $this->flag = $flag;
    }
}


class OtherFlag {
    var $flag;

    function OtherFlag($flag=true) {
            $this->flag = $flag;
    }
}


$o = new Flag();
$p = new Flag();
$q = $o;
$r = new OtherFlag();

echo "Deux instances de la même classe\n";
compareObjects($o, $p);

echo "\nDeux références sur le même objet\n";
compareObjects($o, $q);

echo "\nInstances de classes différentes\n";
compareObjects($o, $r);

?>
]]>
     </programlisting>
    </example>
    Cet exemple va afficher : 
    <screen>
Deux instances de la même classe
o1 == o2 : TRUE
o1 != o2 : FALSE
o1 === o2 : FALSE
o1 !== o2 : TRUE

Deux références sur le même objet
o1 == o2 : TRUE
o1 != o2 : FALSE
o1 === o2 : TRUE
o1 !== o2 : FALSE

Instances de classes différentes
o1 == o2 : FALSE
o1 != o2 : TRUE
o1 === o2 : FALSE
o1 !== o2 : TRUE
    </screen>
   </para>
 </sect1>
 </chapter>
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
indent-tabs-mode:nil
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
