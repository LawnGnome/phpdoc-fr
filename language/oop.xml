<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.30 $ -->
 <chapter id="language.oop">
  <title>Les classes et les objets</title>
  <sect1 id="keyword.class">
   <title>Les classes : <literal>class</literal></title>
   <para>
     Une classe est une collection de variables et de fonctions qui
     fonctionnent avec ces variables. Une classe est d&eacute;finie
     en utilisant la syntaxe suivante :
    <example>
     <title>Les classes en &php;</title>
     <programlisting role="php">
 <![CDATA[
<?php
class Caddie {
// El&eacute;ments de notre panier
    var $items;  

// Ajout de $num articles de type $artnr au panier
    function add_item ($artnr, $num) {
        $this->items[$artnr] += $num;
    }

// Suppression de $num articles du type $artnr du panier
    function remove_item ($artnr, $num) {
        if ($this->items[$artnr] > $num) {
            $this->items[$artnr] -= $num;
            return &true;;
        } else {
            return FALSE;
        }
    }
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    L'exemple ci-dessus d&eacute;finit la classe Caddie qui est compos&eacute;e
    d'un tableau associatif contenant les articles du panier et de deux
    fonctions, une pour ajouter et une pour enlever des &eacute;l&eacute;ments
    au panier.
   </para>
   <caution>
    <simpara>
     Les notes suivantes ne sont valable que pour &php; 4.
    </simpara>
    <simpara>
     Le nom <literal>stdClass</literal> est utilis&eacute; en interne par
     Zend et ne doit pas &ecirc;tre utilis&eacute;. Vous ne pouvez pas nommer
     une classe <literal>stdClass</literal> en &php;.
    </simpara>
    <simpara>
      Les noms de fonctions <literal>__sleep</literal> et
      <literal>__wakeup</literal> sont magiques en &php;. Vous ne pouvez
      pas utiliser ces noms de fonctions dans vos classes, &agrave; moins
      que vous ne souhaitiez utiliser la magie qui y est associ&eacute;e.
    </simpara>
    <simpara>
      &php; se r&eacute;serve l'usage de tous les noms de fonctions
      commen&ccedil;ants par <literal>__</literal>, pour sa propre magie. 
      Il est vivement recommand&eacute; de ne pas utiliser des noms de fonctions
      commen&ccedil;ants par <literal>__</literal>, &agrave; moins que vous ne
      souhaitiez utiliser la magie qui y est associ&eacute;e.
    </simpara>
   </caution>
   <note>
    <simpara>
     En &php; 4, seuls les initialiseurs constants pour les variables
     <literal>var</literal> sont autoris&eacute;s. Utilisez les
     constructeurs pour les initialisations variables, ou utilisant
     des expressions.
    </simpara>
    <example>
    <title>Initialisation de membres de classe</title>
     <programlisting role="php">
 <![CDATA[
<?php
/* Aucune de ces syntaxes ne fonctionnera en PHP 4 */
class Caddie {
    var $date_du_jour = date("d/m/Y");
    var $name = $firstname;
    var $owner = 'Fred ' . 'Jones';
    var $items = array("DVD", "T&eacute;l&eacute;","Magn&eacute;toscope");
}
/* Voici comment cela doit se faire d&eacute;sormais. */
class Caddie {
    var $date_du_jour;
    var $name;
    var $owner;
    var $items;
    function Caddie() {
        $this->date_du_jour = date("d/m/Y");
        $this->name = $GLOBALS['firstname'];
        /* etc... */
    }
}
?>
]]>
     </programlisting>
    </example>
   </note>
   <para>
    Les classes forment un type de variable. Pour cr&eacute;er une variable
    du type d&eacute;sir&eacute;, vous devez utiliser l'op&eacute;rateur new.
   </para>
   <example>
    <title>Cr&eacute;ation d'un objet de classe</title>
    <programlisting role="php">
 <![CDATA[
<?php
 $cart = new Caddie;
 $cart->add_item("10", 1);
 $another_cart = new Caddie;
 $another_cart->add_item("0815", 3);
?>
]]>

    </programlisting>
   </example>
   <para>
    L'instruction ci-dessus cr&eacute;e l'objet <varname>$cart</varname> de la classe 
    <classname>Caddie</classname>.
    La fonction <literal>add_idem()</literal> est appel&eacute;e afin d'ajouter l'article
    num&eacute;ro 10 dans le panier. 3 articles num&eacute;ro 0815 sont 
    ajout&eacute;s au caddie <varname>$another_cart</varname>.
   </para>
   <para>
    <varname>$cart</varname> et <varname>$another_cart</varname> disposent des fonctions 
    <literal>add_item()</literal>, <literal>remove_item()</literal> et de la variable 
    <varname>items</varname>. Ce sont des fonctions
    et variables distinctes. Vous pouvez vous repr&eacute;senter les
    objets comme des dossiers sur votre disque dur. Vous pouvez
    avoir deux fichiers <filename>lisez-moi.txt</filename> sur votre disque dur, tant qu'ils
    ne sont pas dans le m&ecirc;me r&eacute;pertoire. De m&ecirc;me que vous
    devez alors taper le chemin complet jusqu'au fichier, vous devez 
    sp&eacute;cifier le nom complet de la m&eacute;thode avant de l'employer :
    en termes &php;, le dossier racine est l'espace de nom global, et le 
    s&eacute;parateur de dossier est <literal>-&gt;</literal>.  Par exemple, 
    les noms <varname>$cart-&gt;items</varname> et <varname>$another_cart-&gt;items</varname> repr&eacute;sentent deux
    variables distinctes. Notez que le nom de la variable est alors
    <varname>$cart-&gt;items,</varname> et non pas <varname>$cart-&gt;$items</varname> : il n'y a qu'un seul
    signe $ dans un nom de variable.
   </para>
   <example>
    <title>Acc&egrave;s aux membres d'une classe</title>
    <programlisting role="php">
 <![CDATA[
<?php
// correct, le signe $ est unique
$cart->items  = array("10" => 1);
// incorrect, car $cart->$items devient $cart->""
$cart->$items = array("10" => 1);
// correct, mais risque de ne pas se comporter comme pr&eacute;vu
// $cart->$myvar devient $cart->items
$myvar = 'items';
$cart->$myvar = array("10" => 1);
?>
]]>
    </programlisting>
   </example>
   <para>
    A l'int&eacute;rieur d'une d&eacute;finition de classe, vous ne savez pas le
    nom de la variable &agrave; partir duquel l'objet sera accessible dans
    le script. On ne peut pr&eacute;voir que l'objet cr&eacute;&eacute; sera 
    affect&eacute; &agrave; la variable <varname>$cart</varname> ou <varname>$another_cart.</varname> Donc, vous ne 
    pouvez pas utiliser la syntaxe <varname>$cart-&gt;items.</varname> Mais pour pouvoir acc&eacute;der
    &agrave; aux m&eacute;thodes et membres d'un objet, vous pouvez utiliser la 
    variable sp&eacute;ciale <varname>$this,</varname> qui peut s'interpr&eacute;ter comme 'moi-m&ecirc;me',
    ou bien 'l'objet courant'. Par exemple, <literal>'$this->items[$artnr] += $num;'</literal>
    peut se lire comme 'ajouter <varname>$num</varname> au compteur <varname>$artnr</varname> de mon propre tableau
    de compteur' ou bien 'ajouter <varname>$num</varname> au compteur <varname>$artnr</varname> du tableau de compteurs
    de l'objet courant'.
   </para>
  </sect1>
  <sect1 id="keyword.extends">
   <title><literal>extends</literal> : h&eacute;ritage</title>
   <para>
    Souvent, vous aurez besoin d'une classe avec des m&eacute;thodes et
    fonctions similaires &agrave; une autre classe. En fait, il est bon
    de d&eacute;finir des classes g&eacute;n&eacute;riques, qui pourront 
    &ecirc;tre r&eacute;utilis&eacute;es et adapt&eacute;es &agrave; tous
    vos projets. Pour faciliter cela, une classe peut &ecirc;tre une extension
    d'une autre classe. La classe d&eacute;riv&eacute;e h&eacute;rite alors de
    toutes les m&eacute;thodes et variables de la classe de base (cet 
    h&eacute;ritage a de bien que personne ne meurt pour en profiter), mais peut
    d&eacute;finir ses propres fonctions et variables, qui s'ajouteront. Une
    classe ne peut h&eacute;riter que d'une seule autre classe, et l'h&eacute;ritage
    multiple n'est pas support&eacute;. Les h&eacute;ritages se font avec le mot 
    cl&eacute; '<literal>extends</literal>'.
   </para>
   <example>
    <title>H&eacute;ritage de classes</title>
    <programlisting role="php">
 <![CDATA[
<?php
class Caddie_nomme extends Caddie {
    var $owner;
    function set_owner ($name) {
        $this->owner = $name;
    }
}
?>
]]>
    </programlisting>
   </example>
   <para>
     L'exemple ci-dessus d&eacute;finit la classe <classname>Caddie_nomme</classname> qui
     poss&egrave;de les m&ecirc;mes variables que la classe Caddie et
     la variable <varname>$owner</varname> en plus, ainsi que la fonction 
     <literal>set_owner()</literal>.
     Vous cr&eacute;ez un panier nominatif de la m&ecirc;me
     mani&egrave;re que pr&eacute;c&eacute;demment, et vous pouvez alors
     affecter un nom au panier ou en conna&icirc;tre le nom. Vous pouvez de
     toutes les fa&ccedil;ons utiliser les m&ecirc;mes fonctions que sur un
     panier classique.
   </para>
   <example>
    <title>H&eacute;ritage de classes (2)</title>
    <programlisting role="php">
 <![CDATA[
<?php
$ncart = new Caddie_nomme;    // Cr&eacute;ation d'un panier nominatif
$ncart->set_owner ("kris"); // Affectation du nom du panier
print $ncart->owner;        // Affichage du nom du panier
$ncart->add_item ("10", 1); // (h&eacute;ritage des fonctions de la classe p&egrave;re)
?>
]]>
    </programlisting>
   </example>
  </sect1>
  <sect1 id="language.oop.constructor">
   <title><literal>Constructor</literal> : constructeur</title>
   <caution>
    <simpara>
     En &php; 3 et &php; 4, les constructeurs se comportent diff&eacute;remment.
     La s&eacute;mantique de &php; 4 est fortement recommand&eacute;e.
    </simpara>
   </caution>
   <para>
    Le constructeur est la fonction qui est appel&eacute;e
    automatiquement par la classe lorsque vous cr&eacute;ez
    une nouvelle instance d'une classe a l'aide de l'op&eacute;rateur
    <literal>new</literal>. La fonction constructeur a
    le m&ecirc;me nom que la classe.
    En &php; 3, une fonction devient le constructeur si elle porte le
    m&ecirc;me nom que la classe. En &php; 4, une fonction devient un constructeur
    si elle porte le m&ecirc;me nom que la classe dans laquelle elle est d&eacute;finie.
    La diff&eacute;rence est subtile, mais cruciale.
   </para>
   <example>
    <title>Constructeur de classe</title>
    <programlisting role="php">
 <![CDATA[
<?php
class Auto_Caddie extends Caddie {
    function Auto_Caddie () {
        $this->add_item ("10", 1);
    }
}
// Cette syntaxe est valable en PHP 3 et 4
?>
]]>
    </programlisting>
   </example>
    <para>
     L'exemple ci-dessus d&eacute;finit la classe <classname>Auto_Caddie</classname> qui
     h&eacute;rite de la classe Caddie et d&eacute;finit le constructeur
     de la classe. Ce dernier initialise le panier avec 1 article de
     type num&eacute;ro 10 d&egrave;s que l'instruction "new" est
     appel&eacute;e. La fonction constructeur peut prendre ou non
     des param&egrave;tres optionnels, ce qui la rend beaucoup plus
     pratique. Pour pouvoir utiliser cette classe sans param&egrave;tre,
     tous les param&egrave;tres du constructeurs devraient &ecirc;tre optionnels,
     en fournissant une valeur par d&eacute;faut, comme ci-dessous.
   </para>
   <example>
    <title>Constructeur de classe &agrave; argument optionnel</title>
    <programlisting role="php">
 <![CDATA[
<?php
// Cette syntaxe est valable en PHP 3 et 4
class Constructor_Cart extends Cart {
    function Constructor_Cart ($item = "10", $num = 1) {
        $this->add_item ($item, $num);
    }
}
// Cr&eacute;ation du caddie
$default_cart   = new Constructor_Cart;
// Cr&eacute;ation d'un vrai caddie
$different_cart = new Constructor_Cart ("20", 17);
?>
]]>
    </programlisting>
   </example>
   <caution>
    <simpara>
     En &php; 3, les classes d&eacute;riv&eacute;es et les constructeurs ont un certains
     nombre de limitations. Les exemples suivants doivent &ecirc;tre lus avec
     beaucoup d'attention pour comprendre ces limitations.
    </simpara>
   </caution>
   <example>
    <title>Constructeur de classe en &php; 4</title>
    <programlisting role="php">
 <![CDATA[
<?php
class A {
  function A() {
    echo "Je suis le constructeur de A.<br>\n";
  }
}
class B extends A {
  function C() {
    "Je suis une fonction standard.<br>\n";
  }
}
// Aucun constructeur n'est appel&eacute; en PHP 3!!
$b = new B;
?>
]]>
    </programlisting>
   </example>
   <para>
    En &php; 3, aucun constructeur ne sera appel&eacute; dans l'exemple ci-dessus.
    La r&egrave;gle en &php; 3 est : 'Un constructeur est une m&eacute;thode qui 
    a le m&ecirc;me nom que la classe'. Le nom de la classe est B, et il n'y a pas
    de fonction qui s'appelle B() dans la classe B. Rien ne se passe.
   </para>
   <para>
    Ceci est corrig&eacute; en &php; 4, avec l'introduction d'une nouvelle r&egrave;gle :
    Si une classe n'a pas de constructeur, le constructeur de la classe de
    basse est appel&eacute;, s'il existe. L'exemple ci-dessus affichera
    '<literal>Je suis le constructeur de A.&lt;br&gt;</literal>' en &php; 4.
   </para>
   <example>
    <title>Constructeur de classe en &php; 4</title>
    <programlisting role="php">
 <![CDATA[
<?php
class A {
  function A() {
    echo "Je suis le constructeur de A.<br>\n";
  }
  function B() {
    echo "Je suis une fonction standard appel&eacute;e B dans la classe A.<br>\n";
    echo "Je ne suis pas le constructeur de A.<br>\n";
  }
}

class B extends A {
  function C() {
    echo "Je suis une fonction standard.<br>\n";
  }
}
// Cette syntaxe va appeler B() comme constructeur.
$b = new B;
?>
]]>
    </programlisting>
   </example>
   <para>
    En &php; 3, la fonction B() de la classe A va soudainement devenir le
    constructeur de la classe B, bien qu'il n'ai pas &eacute;t&eacute;
    pr&eacute;vu pour. La r&egrave;gle de &php; 3 est 'Un constructeur est une
    m&eacute;thode qui a le m&ecirc;me nom que la classe'. &php; 3 ne se soucie
    gu&egrave;re si la fonction est d&eacute;finie dans la classe B ou 
    si elle a &eacute;t&eacute; h&eacute;rit&eacute;e.
   </para>
   <para>
    Ceci est corrig&eacute; en &php; 4, avec l'introduction d'une nouvelle
    r&egrave;gle :
    'Un constructeur est une m&eacute;thode de m&ecirc;me nom que la classe, 
    d&eacute;finie dans la classe elle-m&ecirc;me'. Donc, en &php; 4, la classe
    B n'a pas de constructeur par elle-m&ecirc;me, et le constructeur de la 
    classe A aura &eacute;t&eacute; appel&eacute;, affichant :
    '<literal>Je suis le constructeur de A.&lt;br&gt;</literal>'.
   </para>
   <caution>
    <simpara>
     Ni &php; 3 ni &php; 4 n'appelle automatiquement le constructeur de
     la classe sup&eacute;rieure depuis le constructeur de la classe
     d&eacute;riv&eacute;e. Il est de votre responsabilit&eacute; de propager
     l'appel des constructeurs.
    </simpara>
   </caution>
   <note>
    <simpara>
     Il n'y a pas de destructeurs en &php; 3 et &php; 4. Vous pouvez utiliser
     la fonction <function>register_shutdown_function</function> &agrave; la
     place, pour simuler un destructeur.
    </simpara>
   </note>
   <para>
    Les destructeurs sont des fonctions qui sont appel&eacute;es lorsqu'un
    objet est d&eacute;truit, soit avec la fonction <function>unset</function>
    soit par simple sortie d'une fonction (cas des variables locales).
    Il n'y a pas de destructeurs en &php;.
   </para>
  </sect1>
 <sect1 id="keyword.paamayim-nekudotayim">
   <title>Op&eacute;rateur <literal>::</literal></title>
   <caution>
    <simpara>
     La documentation suivante n'est valable que pour &php; 4 et plus r&eacute;cent.
    </simpara>
   </caution>
   <para>
    Parfois, il est pratique de faire r&eacute;f&eacute;rence aux fonctions
    est variables d'une classe de base, ou bien d'utiliser
    des m&eacute;thodes de classes qui n'ont pas encore d'objets
    cr&eacute;&eacute;s. L'op&eacute;rateur <literal>::</literal> est l&agrave; pour ces
    situations.
   </para>
   <example>
    <title>Exemples avec l'op&eacute;rateur <literal>::</literal></title>
    <programlisting role="php">
 <![CDATA[
<?php
class A {
  function example() {
    echo "Je suis la fonction originale A::example().<br>\n";
  }
}
class B extends A {
  function example() {
    echo "Je suis la fonction red&eacute;finie B::example().<br>\n";
    A::example();
  }
}
// Il n'y a pas d'objets de classe A.
// L'affichage est :
//   Je suis la fonction originale A::example().<br>
A::example();
// Cr&eacute;ation d'un objet de la classe B.
$b = new B;
// L'affichage est :
//   Je suis la fonction red&eacute;finie B::example().<br>
//   Je suis la fonction originale A::example().<br>
$b->example();
?>
]]>
    </programlisting>
   </example>
   <para>
    Les exemples ci-dessus appellent la fonction <literal>example()</literal> dans la
    classe A, mais il n'y a pas encore d'objet de classe A, alors il
    n'est pas possible d'&eacute;crire <literal>$a->example()</literal>. A la place, on appelle
    la fonction <literal>example()</literal> comme une fonction de classe, c'est-&agrave;-dire
    avec le nom de la classe elle-m&ecirc;me, et sans objet.
   </para>
   <para>
    Il y a des fonctions de classe, mais pas de variables de classe.
    En fait, il n'y a aucun objet au moment de l'appel de la fonction.
    Donc, une fonction de classe ne peut acc&eacute;der &agrave; aucune variable
    (mais elle peut acc&eacute;der aux variables locales et globales).
    Il faut proscrire l'utilisation de <varname>$this</varname>.
   </para>
   <para>
    Dans l'exemple ci-dessus, la classe B red&eacute;finit la fonction <literal>example()</literal>.
    La d&eacute;finition originale dans la classe A est remplac&eacute;e par celle de
    B, et n'est plus accessible depuis B, &agrave; moins que vous n'appeliez
    sp&eacute;cifiquement la fonction <literal>example()</literal> de la classe A avec l'op&eacute;rateur
    ::. Ecrivez <literal>A::example()</literal> pour cela (en fait, il faudrait &eacute;crire
    <literal>parent::example()</literal>, comme expliqu&eacute; dans la section suivante).
   </para>
   <para>
    Dans ce contexte, il y a un objet courant, qui peut avoir d'autres
    variables objets. De ce fait, lorsqu'il est utilis&eacute; depuis une m&eacute;thode
    d'un objet, vous pouvez utiliser <varname>$this.</varname>
   </para>
 </sect1>
 <sect1 id="keyword.parent">
   <title><literal>parent</literal></title>
  <para>
   Il arrive que vous ayez &agrave; &eacute;crire du code qui faire r&eacute;f&eacute;rence
   aux variables et fonctions des classes de base. C'est particuli&egrave;rement
   vrai si votre classe d&eacute;riv&eacute;e est une sp&eacute;cialisation de votre classe
   de base.
  </para>
  <para>
   Au lieu d'utiliser le nom litt&eacute;ral de votre classe de base dans
   votre code, vous pouvez utiliser le mot r&eacute;serv&eacute;
   <literal>parent</literal>, qui repr&eacute;sente votre classe de
   base (celle indiqu&eacute; par <literal>extends</literal>, dans la d&eacute;claration
   de votre classe). En faisant cela, vous &eacute;viter d'appeler le
   nom de votre classe de base directement dans votre code.
   Si votre h&eacute;ritage change, vous n'aurez plus qu'&agrave; modifier
   le nom de la classe dans la d&eacute;claration <literal>extends</literal>
   de votre classe.
  </para>
   <example>
    <title>Exemples avec l'op&eacute;rateur <literal>parent</literal></title>
   <programlisting role="php">
 <![CDATA[
<?php
class A {
  function example() {
    echo "Je suis A::example() et je fournis une fonctionnalit&eacute; de base.<br>\n";
  }
}
class B extends A {
  function example() {
    echo "Je suis B::example() et je fournis une fonctionnalit&eacute; suppl&eacute;mentaire.<br>\n";
    parent::example();
  }
}
$b = new B;
// Cette syntaxe va appeler B::example(), qui, &agrave; sont tour, va appeler A::example().
$b->example();
?>
]]>
   </programlisting>
  </example>
 </sect1>
 <sect1 id="language.oop.serialization">
  <title>Sauvegarde d'objets - cas des sessions</title>
  <note>
   <simpara>
    En &php; 3, les objets perdent leur association de classe &agrave; travers
    le processus de sauvegarde et relecture. Le type de la variable apr&egrave;s
    relecture est bien objet mais il n'a plus de m&eacute;thode ou de nom
    de classe. Cela rend la fonctionnalit&eacute; plut&ocirc;t inutile (l'objet
    est devenu un tableau avec une syntaxe &eacute;trange).
   </simpara>
  </note>
  <caution>
   <simpara>
    La documentation suivante n'est valable que pour &php; 4.
   </simpara>
  </caution>
  <para>
   <function>serialize</function> retourne une cha&icirc;ne repr&eacute;sentant
   une valeur qui peut &ecirc;tre stock&eacute;e dans les sessions de &php;, ou une
   base de donn&eacute;es. <function>unserialize</function> peut relire cette
   cha&icirc;ne pour recr&eacute;er la valeur originale. <function>serialize</function>
   va sauver toutes les variables d'un objet. Le nom de la classe sera
   sauv&eacute; mais par les m&eacute;thodes de cet objet.
  </para>
  <para>
   Pour permettre &agrave; <function>unserialize</function> de lire un objet,
   la classe de cet objet doit &ecirc;tre d&eacute;finie. C'est-&agrave;-dire, si vous avez
   un objet <varname>$a</varname> de la classe A dans une page php1.php, et que vous le
   lin&eacute;arisez avec <function>serialize</function>, vous obtiendrez une
   cha&icirc;ne qui fait r&eacute;f&eacute;rence &agrave; la classe A, et contient toutes les valeurs
   de <varname>$a.</varname> Pour pouvoir le relire avec la fonction <function>unserialize</function>
   dans une page page2.php, il faut que la d&eacute;finition de la classe
   A soit pr&eacute;sente dans cette deuxi&egrave;me page. Cela peut se faire
   de mani&egrave;re pratique en sauvant la d&eacute;finition de la classe A dans un
   fichier s&eacute;par&eacute;, et en l'incluant dans les deux pages page1.php et
   page2.php.
  </para>
  <informalexample>
   <programlisting role="php">
 <![CDATA[
<?php
classa.inc:
  class A {
    var $one = 1;
    function show_one() {
      echo $this->one;
    }
  }
?>
page1.php:
<?php
  include("classa.inc");
  $a = new A;
  $s = serialize($a);
  // enregistrez $s o&ugrave; la page2.php pourra le trouver.
  $fp = fopen("store", "w");
  fputs($fp, $s);
  fclose($fp);
?>
page2.php:
<?php
  // Ceci est n&eacute;cessaire pour que unserialize() fonctionne correctement
  include("classa.inc");
  $s = implode("", @file("store"));
  unserialize($s);
  // maintenant, utilisez la m&eacute;thode show_one de l'objet $a.
  $a->show_one();
?>
]]>
   </programlisting>
  </informalexample>
  <para>
   Si vous utilisez les sessions et la fonction <function>session_register</function>
   pour sauver des objets, ces objets seront lin&eacute;aris&eacute;s automatiquement
   avec la fonction <function>serialize</function> &agrave; la fin de chaque
   script, et relus avec <function>unserialize</function> au d&eacute;but du prochain
   script. Cela signifie que ces objets peuvent appara&icirc;tre dans n'importe quelle
   page qui utilise vos sessions.
  </para>
  <para>
   Il est vivement recommand&eacute; d'inclure la d&eacute;finition de classe dans
   toutes vos pages, m&ecirc;me si vous n'utilisez pas ces classes dans
   toutes vos pages. Si vous l'oubliez et qu'un tel objet est
   pr&eacute;sent, il perdra sa classe, et deviendra un objet de classe
   <literal>stdClass</literal> sans aucune fonction, et donc, plut&ocirc;t
   inutile.
  </para>
  <para>
   Si, dans l'exemple ci-dessus, <varname>$a</varname> devient un objet de session
   avec l'utilisation de <literal>session_register("a")</literal>, vous
   devez pensez &agrave; inclure le fichier <literal>classa.inc</literal> dans toutes
   vos pages, et pas seulement page1.php et page2.php.
  </para>
 </sect1>
 <sect1 id="language.oop.magic-functions">
  <title>Les fonctions magiques <literal>__sleep</literal> et <literal>__wakeup</literal></title>
  <para>
   <function>serialize</function> s'assure que votre classe a une m&eacute;thode
   avec le nom magique <literal>__sleep</literal>. Si c'est le cas, cette
   fonction est appel&eacute;e avant toute lin&eacute;arisation. Elle peut alors nettoyer
   l'objet et on s'attend &agrave; ce qu'elle retourne un tableau avec la liste des
   noms de variables qui doivent &ecirc;tre sauv&eacute;es.
  </para>
  <para>
   Le but de cette fonction <literal>__sleep</literal> est de fermer
   proprement toute connexion &agrave; une base de donn&eacute;es, de valider les
   requ&ecirc;tes, de finaliser toutes les actions commenc&eacute;es. Cette fonction
   est aussi pratique si vous ave de tr&egrave;s grands objets qui n'ont pas
   besoin d'&ecirc;tre sauv&eacute; enti&egrave;rement.
  </para>
  <para>
   A l'inverse, <function>unserialize</function> s'assure de la pr&eacute;sence
   de la fonction magique <literal>__wakeup</literal>. Si elle existe, cette
   fonction reconstruit toutes les ressources d'un objet.
  </para>
  <para>
    Le but de cette fonction <literal>__wakeup</literal> est de r&eacute;tablit
    toutes les connexions aux bases de donn&eacute;es, et de recr&eacute;er les
    variables qui n'ont pas &eacute;t&eacute; sauv&eacute;es.
  </para>
 </sect1>
 <sect1 id="language.oop.newref">
   <title>R&eacute;f&eacute;rences dans un constructeur</title>
   <para>
    Cr&eacute;er des r&eacute;f&eacute;rences dans un constructeur
    peut conduire &agrave; des r&eacute;sultats &eacute;tranges. 
    Ce tutoriel vous guide pour &eacute;viter ces probl&egrave;mes.
    <informalexample>
     <programlisting role="php">
 <![CDATA[
<?php
class foo {
    function foo($name) {
        // cr&eacute;e une r&eacute;f&eacute;rence dans le tableau global $globalref
        global $globalref;
		$globalref[] = &$this;
        // donne le nom de la variable
        $this->setName($name);
		// et l'affiche
        $this->echoName();
    }
    function echoName() {
        echo "<br>",$this->Name;
    }
	function setName($name)	{
		$this->Name = $name;
    }
}
?>
]]>
    </programlisting>
   </informalexample>
   </para>
   <para>
    V&eacute;rifions maintenant qu'il y a une diff&eacute;rence entre 
    <varname>$bar1</varname> qui a &eacute;t&eacute; cr&eacute;&eacute; avec
    <literal>=</literal> et <varname>$bar2</varname> qui a &eacute;t&eacute;
    cr&eacute;&eacute; avec l'op&eacute;rateur de r&eacute;f&eacute;rence
    <literal>=&amp;</literal> :
   </para>
    <informalexample>
     <programlisting role="php">
 <![CDATA[
<?php
    $bar1 = new foo('cr&eacute;e dans le constructeur');
    $bar1->echoName();
    $globalref[0]->echoName();
    /* affiche :
    cr&eacute;e dans le constructeur
    cr&eacute;e dans le constructeur
    cr&eacute;e dans le constructeur */
    $bar2 =&new foo('cr&eacute;e dans le constructeur');
    $bar2->echoName();
    $globalref[1]->echoName();
    /* affiche :
    cr&eacute;e dans le constructeur
    cr&eacute;e dans le constructeur
    cr&eacute;e dans le constructeur */
?>
]]>
    </programlisting>
   </informalexample>
   <para>
    Apparemment, il n'y a pas de diff&eacute;rence, mais en fait, il y en a une
    significative : <varname>$bar1</varname> et <varname>$globalref[0]</varname>
    ne sont pas r&eacute;f&eacute;renc&eacute;es, ces deux variables sont diff&eacute;rentes.
    Cela est du au fait que  l'op&eacute;rateur "new"ne retourne par de r&eacute;f&eacute;rence,
    mais retourne une copie.
    <note>
     <simpara>
      Il n'y a aucune perte de performances (puisque &php; 4 utilise un compteur
      de r&eacute;f&eacute;rences) &agrave; retourner des copies au lieu de 
      r&eacute;f&eacute;rences. Au contraire, il est souvent mieux de travailler
      sur les copies plut&ocirc;t que sur les r&eacute;f&eacute;rences,
      car cr&eacute;er une r&eacute;f&eacute;rence prend un peu plus de temps
      que de cr&eacute;er une copie qui ne prend virtuellement pas de temps
      (&agrave; moins de cr&eacute;er un tableau g&eacute;ant ou un objet monstrueux,
      auquel cas il est pr&eacute;f&eacute;rable de passer par des 
      r&eacute;f&eacute;rences).
     </simpara>
    </note>
    Pour prouver ceci, regardez le code suivant :
   </para>
   <example>
   <title>R&eacute;f&eacute;rences et constructeurs</title>
     <programlisting role="php">
 <![CDATA[
<?php
        // maintenant, nous allons changer de nom. Qu'attendez-vous?
        // Vous pouvez vous attendre &agrave; ce que les deux variables $bar
        // et  $globalref[0] changent de nom...
        $bar1->setName('modifi&eacute;');
        // comme pr&eacute;dit, ce n'est pas le cas
        $bar1->echoName();
        $globalref[0]->echoName();
        /* affiche :
        cr&eacute;e dans le constructeur
        modifi&eacute; */
        // quelle est la diff&eacute;rence entre $bar2 et $globalref[1]
        $bar2->setName('modifi&eacute;');
        // Heureusement, elles sont non seulement &eacute;gales, mais
        // elles repr&eacute;sentent la m&ecirc;me variable.
        // donc $bar2->Name et $globalref[1]->Name sont les m&ecirc;mes
        $bar2->echoName();
        $globalref[1]->echoName();
        /* affiche :
        modifi&eacute;
        modifi&eacute; */
?>
]]>
    </programlisting>
   </example>
   <para>
   Un dernier exemple pour bien comprendre.
   <informalexample>
     <programlisting role="php">
 <![CDATA[
<?php
class a {
    function a($i) {
        $this->value = $i;
        // Essayez de comprendre on n'a pas besoin de
        // r&eacute;f&eacute;rence ici
        $this->b = new b($this);
    }
    function createRef() {
        $this->c = new b($this);
    }
    function echoValue() {
        echo "<br>","class ",get_class($this),': ',$this->value;
    }
}
class b  {
    function b(&$a) {
        $this->a = &$a;
    }
   function echoValue() {
        echo "<br>","class ",get_class($this),': ',$this->a->value;
        }
}
// Essayez de comprendre pourquoi une copie simple va
// conduire &agrave; un r&eacute;sultat ind&eacute;sirable &agrave;
// la ligne marqu&eacute;e d'une &eacute;toile
$a =&new a(10);
$a->createRef();
$a->echoValue();
$a->b->echoValue();
$a->c->echoValue();
$a->value = 11;
$a->echoValue();
$a->b->echoValue(); // *
$a->c->echoValue();
/*
output:
class a: 10
class b: 10
class b: 10
class a: 11
class b: 11
class b: 11
*/
?>
]]>

     </programlisting>
    </informalexample>
   </para>
  </sect1>
  <sect1 id="language.oop.object-comparison-php4">
   <title>Comparer des objets en &php; 4</title>
  <para>
   En &php; 4, les objets sont compar&eacute;s de mani&egrave;re tr&egrave;s simple, 
   &agrave; savoir : deux instances sont &eacute;gales si elles ont les m&ecirc;mes 
   attributs et valeurs, et qu'elles sont de la m&ecirc;me classe. Des r&egrave;gles
   similaires s'appliquent lors de la comparaison avec l'op&eacute;rateur 
   <literal>===</literal>.
  </para>
  <para>
   Si vous ex&eacute;cutons le code suivant : 
   <example>
    <title>Exemple de comparaison d'objets en &php; 4</title>
    <programlisting role='php'>
<![CDATA[
function bool2str($bool) {
    if ($bool === false) {
            return 'FALSE';
    } else {
            return 'TRUE';
    }
}

function compareObjects(&$o1, &$o2) {
    echo 'o1 == o2 : '.bool2str($o1 == $o2)."\n";
    echo 'o1 != o2 : '.bool2str($o1 != $o2)."\n";
    echo 'o1 === o2 : '.bool2str($o1 === $o2)."\n";
    echo 'o1 !== o2 : '.bool2str($o1 !== $o2)."\n";
}

class Flag {
    var $flag;

    function Flag($flag=true) {
            $this->flag = $flag;
    }
}

class SwitchableFlag extends Flag {

    function turnOn() {
        $this->flag = true;
    }

    function turnOff() {
        $this->flag = false;
    }
}

$o = new Flag();
$p = new Flag(false);
$q = new Flag();

$r = new SwitchableFlag();

echo "Compare des instances cr&eacute;&eacute;es avec les m&ecirc;mes param&egrave;tres\n";
compareObjects($o, $q);

echo "\nCompare des instances cr&eacute;&eacute;es avec diff&eacute;rents param&egrave;tres\n";
compareObjects($o, $p);

echo "\nCompare une instance d'un parent avec celle d'une sous-classe\n";
compareObjects($o, $r);
]]>
    </programlisting>
   </example>
   Cet exemple va afficher : 
   <screen>
Compare des instances cr&eacute;&eacute;es avec les m&ecirc;mes param&egrave;tres
o1 == o2 : TRUE
o1 != o2 : FALSE
o1 === o2 : TRUE
o1 !== o2 : FALSE

Compare des instances cr&eacute;&eacute;es avec diff&eacute;rents param&egrave;tres
o1 == o2 : FALSE
o1 != o2 : TRUE
o1 === o2 : FALSE
o1 !== o2 : TRUE

Compare une instance d'un parent avec celle d'une sous-classe
o1 == o2 : FALSE
o1 != o2 : TRUE
o1 === o2 : FALSE
o1 !== o2 : TRUE
   </screen>
   Ce qui est le r&eacute;sultat que nous attendions, au vue des r&egrave;gles &eacute;dict&eacute;es.
   Seules deux instances avec les m&ecirc;mes valeurs d'attributs, et issues de la m&ecirc;me
   classe sont consid&eacute;r&eacute;es comme &eacute;gales.
  </para>
  <para>
   M&ecirc;me lorsque nous avons une composition d'objet, la m&ecirc;me r&egrave;gle de comparaison
   s'applique. Dans l'exemple ci-dessous, nous allons cr&eacute;er une classer conteneur,
   qui stocke un tableau associatif <classname>Flag</classname>.
   <example>
    <title>Comparaison d'objets compos&eacute;s en &php; 4</title>
    <programlisting role='php'>
<![CDATA[
class FlagSet {
    var $set;

    function FlagSet($flagArr = array()) {
        $this->set = $flagArr;
    }

    function addFlag($name, $flag) {
        $this->set[$name] = $flag;
    }

    function removeFlag($name) {
        if (array_key_exists($name, $this->set)) {
            unset($this->set[$name]);
        }
    }
}


$u = new FlagSet();
$u->addFlag('flag1', $o);
$u->addFlag('flag2', $p);
$v = new FlagSet(array('flag1'=>$q, 'flag2'=>$p));
$w = new FlagSet(array('flag1'=>$q));

echo "\nObjects compos&eacute;s u(o,p) et v(q,p)\n";
compareObjects($u, $v);

echo "\nu(o,p) et w(q)\n";
compareObjects($u, $w);
     
]]>
    </programlisting>
   </example>
   Qui va donner l'affichage suivant : 
   <screen>
Objects compos&eacute;s u(o,p) et v(q,p)
o1 == o2 : TRUE
o1 != o2 : FALSE
o1 === o2 : TRUE
o1 !== o2 : FALSE

u(o,p) et w(q)
o1 == o2 : FALSE
o1 != o2 : TRUE
o1 === o2 : FALSE
o1 !== o2 : TRUE
   </screen>
  </para>
 </sect1>

  <sect1 id="language.oop.object-comparison-php5">
   <title>Comparer des objets en &php; 5</title>
   &warn.experimental;
   <para>
    En &php; 5, la comparaison d'objets et plus compliqu&eacute;e qu'en &php; 4,
    afin d'&ecirc;tre plus proche du comportement des langages orient&eacute; objet 
    (bien que &php; n'en soit pas un).
   </para>
   <para>
    Lors de l'utilisation de l'op&eacute;rateur de comparaison <literal>==</literal>, 
    les objets sont compar&eacute;es de mani&egrave;re simple, &agrave; savoir : 
    deux objets sont &eacute;gaux si ils ont les m&ecirc;mes attributs et valeurs, et qu'ils
    sont des instances de la m&ecirc;me classe.
   </para>
   <para>
    D'un autre cot&eacute;, lors de l'utilisation de l'op&eacute;rateur d'identit&eacute; 
    (<literal>===</literal>), les objets sont identiques uniquement si ils
    font r&eacute;f&eacute;rence au m&ecirc;me objet de la m&ecirc;me classe.
   </para>
   <para>
    Un exemple va illustrer ces r&egrave;gles.
    <example>
     <title>Exemple de comparaison d'objets en &php; 5</title>
     <programlisting role='php'>
<![CDATA[
function bool2str($bool) {
    if ($bool === false) {
            return 'FALSE';
    } else {
            return 'TRUE';
    }
}

function compareObjects(&$o1, &$o2) {
    echo 'o1 == o2 : '.bool2str($o1 == $o2)."\n";
    echo 'o1 != o2 : '.bool2str($o1 != $o2)."\n";
    echo 'o1 === o2 : '.bool2str($o1 === $o2)."\n";
    echo 'o1 !== o2 : '.bool2str($o1 !== $o2)."\n";
}

class Flag {
    var $flag;

    function Flag($flag=true) {
            $this->flag = $flag;
    }
}


class OtherFlag {
    var $flag;

    function OtherFlag($flag=true) {
            $this->flag = $flag;
    }
}


$o = new Flag();
$p = new Flag();
$q = $o;
$r = new OtherFlag();

echo "Deux instances de la m&ecirc;me classe\n";
compareObjects($o, $p);

echo "\nDeux r&eacute;f&eacute;rences sur le m&ecirc;me objet\n";
compareObjects($o, $q);

echo "\nInstances de classes diff&eacute;rentes\n";
compareObjects($o, $r);
]]>
     </programlisting>
    </example>
    Cet exemple va afficher : 
    <screen>
Deux instances de la m&ecirc;me classe
o1 == o2 : TRUE
o1 != o2 : FALSE
o1 === o2 : FALSE
o1 !== o2 : TRUE

Deux r&eacute;f&eacute;rences sur le m&ecirc;me objet
o1 == o2 : TRUE
o1 != o2 : FALSE
o1 === o2 : TRUE
o1 !== o2 : FALSE

Instances de classes diff&eacute;rentes
o1 == o2 : FALSE
o1 != o2 : TRUE
o1 === o2 : FALSE
o1 !== o2 : TRUE
    </screen>
   </para>
 </sect1>
 </chapter>
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
indent-tabs-mode:nil
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
