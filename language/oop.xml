 <chapter id="oop">
  <title>Classes et objets</title>
  <sect1 id="keyword.class">
   <title>Les classes : <literal>class</literal></title>
   <para>
     Une classe est une collection de variables et de fonctions qui
     fonctionnent avec ces variables. Une classe est d&eacute;finie
     en utilisant la syntaxe suivante :
    <informalexample>
     <programlisting role="php">
&lt;?php
class Caddie {
    var $items;  // El&eacute;ments de notre panier
    // Ajout de $num articles de type $artnr au panier
    function add_item ($artnr, $num) {
        $this->items[$artnr] += $num;
    }
    // Suppression de $num articles du type $artnr du panier
    function remove_item ($artnr, $num) {
        if ($this->items[$artnr] &gt; $num) {
            $this->items[$artnr] -= $num;
            return <literal>TRUE</literal>;
        } else {
            return <literal>FALSE</literal>;
        }
    }
}
?&gt;
     </programlisting>
    </informalexample>
   </para>
   <para>
    L'exemple ci-dessus d&eacute;finit la classe Caddie qui est compos&eacute;e d'un
    tableau associatif contenant les articles du panier et de deux fonctions,
    une pour ajouter et une pour enlever des &eacute;l&eacute;ments au panier.
   </para>
   <note>
    <simpara>
     En PHP 4, seuls les initialiseurs constants pour les variables
     <literal>var</literal> sont autoris&eacute;s. Utilisez les
     constructeurs pour les initialisations variables, ou utilisant
     des expressions.
    </simpara>
    <informalexample>
     <programlisting role="php">
&lt;?php
/* Aucune de ces syntaxes ne fonctionnera en PHP 4 */
class Caddie {
    var $date_du_jour = date("d/m/Y");
    var $name = $firstname;
    var $owner = 'Fred ' . 'Jones';
}
/* Voici comment cela doit se faire d&eacute;sormais. */
class Caddie {
    var $date_du_jour;
    var $name;
    var $owner;
    function Caddie() {
        $this->date_du_jour = date("d/m/Y");
        $this->name = $GLOBALS['firstname'];
        /* etc... */
    }
}
?&lt;
     </programlisting>
    </informalexample>
   </note>
   <para>
    Les classes forment un type de variable. Pour cr&eacute;er une variable
    du type d&eacute;sir&eacute;, vous devez utiliser l'op&eacute;rateur new.
   </para>
   <informalexample>
    <programlisting role="php">
&lt;?php
 $cart = new Caddie;
 $cart->add_item("10", 1);
?&gt;
    </programlisting>
   </informalexample>
   <para>
    L'instruction ci-dessus cr&eacute;e l'objet $cart de la class Caddie.
    La fonction add_idem() est appel&eacute;e afin d'ajouter l'article
    num&eacute;ro 10 dans la panier.
   </para>
   <para>
    Une classe peut &ecirc;tre une extension d'une autre classe.
    Les classes "extended" ou "derived" h&eacute;ritent de toutes
    les variables et de toutes les fonctions de la classe p&egrave;re
    plus toutes les d&eacute;finitions que vous rajoutez &agrave; cette
    classe. Cela se fait avec le mot clef "extends".
    L'h&eacute;ritage multiple n'est pas support&eacute;.
   </para>
   <informalexample>
    <programlisting role="php">
&lt;?php
class Caddie_nomme extends Caddie {
    var $owner;
    function set_owner ($name) {
        $this->owner = $name;
    }
}
?&gt;
    </programlisting>
   </informalexample>
   <para>
     L'exemple ci-desssus d&eacute;finit la classe Caddie_nomme qui
     poss&egrave;de les m&ecirc;me variables que la classe Caddie et
     la variable $owner en plus, ainsi que la fonction set_owner().
     Vous cr&eacute;ez un panier nominatif de la m&ecirc;me
     mani&egrave;re que pr&eacute;c&eacute;demment, et vous pouvez alors
     affecter un nom au panier ou en conna&icirc;tre le nom. Vous pouvez de
     toutes les fa&ccedil;ons utiliser les m&ecirc;me fonctions que sur un
     panier classique.
   </para>
   <informalexample>
    <programlisting role="php">
&lt;?php
$ncart = new Caddie_nomme;    // Cr&eacute;ation d'un panier nominatif
$ncart->set_owner ("kris"); // Affectation du nom du panier
print $ncart->owner;        // Affichage du nom du panier
$ncart->add_item ("10", 1); // (h&eacute;ritage des fonctions de la classe p&egrave;re)
?&gt;
    </programlisting>
   </informalexample>
   <para>
     Dans les fonctions d'une classe, la variable $this est
     &eacute;gale &agrave; l'objet de la classe. Vous pouvez
     utilisez la forme "$this->quelquechose" pour acc&eacute;der aux
     fonctions ou aux variables de l'objet courant. Aussi bien
     depuis l'objet lui-m&ecirc;me que de l'ext&eacute;rieur, vous n'avez pas
     besoin de <literal>$</literal> pour acc&eacute;der aux
     propri&eacute;t&eacute;s d'un objet.
   </para>
   <informalexample>
    <programlisting role="php">
&lt;?php
$ncart->owner  = "chris"; // pas de '$'
$ncart->$owner = "chris";
// Ceci est invalide, car $ncart->$owner &eacute;quivaut &agrave; $ncart->""
$myvar = 'owner';
$ncart->$myvar = "chris";
// Ceci est valide, car $ncart->$owner &eacute;quivaut &agrave; $ncart->owner
    </programlisting>
   </informalexample>
   <para>
    Le constructeur est la fonction qui est appel&eacute;e
    automatiquement par la classe lorsque vous cr&eacute;ez
    une nouvelle instance d'une classe. La fonction constructeur a
    le m&ecirc;me nom que la classe.
   </para>
   <informalexample>
    <programlisting role="php">
&lt;?php
class Auto_Caddie extends Caddie {
    function Auto_Caddie () {
        $this->add_item ("10", 1);
    }
}
?&gt;
    </programlisting>
   </informalexample>
   <para>
     L'exemple ci-dessus d&eacute;finit la classe Auto_Caddie qui
     h&eacute;rite de la classe Caddie et d&eacute;finit le construteur
     de la classe. Ce dernier initialise le panier avec 1 article de
     type num&eacute;ro 10 d&egrave;s que l'instruction "new" est
     appel&eacute;e. La fonction constructeur peut prendre ou non,
     des param&egrave;tres optionnels, ce qui la rend
     beaucoup plus pratique.
   </para>
   <informalexample>
    <programlisting role="php">
&lt;?php
class Constructor_Caddie extends Caddie {
    function Constructor_Caddie ($item = "10", $num = 1) {
        $this->add_item ($item, $num);
    }
}
// Place dans le caddie toujours la m&ecirc;me chose...
$default_cart   = new Constructor_Caddie;
// Place dans le caddie des objets diff&eacute;rents, comme dans la
// r&eacute;alit&eacute;
$different_cart = new Constructor_Caddie ("20", 17);
?&gt;
    </programlisting>
   </informalexample>
   <caution>
    <simpara>
     Pour les classes qui utilisent l'h&eacute;ritage,
     le constructeur de la classe p&egrave;re n'est pas
     automatiquement appel&eacute; lorsque le constructeur de la classe
     d&eacute;riv&eacute;e est appel&eacute;.
    </simpara>
   </caution>
  </sect1>
 </chapter>
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
