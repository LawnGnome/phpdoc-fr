 <chapter id="language.references">
  <title>Les r&eacute;f&eacute;rences</title>
  <sect1 id="language.references.whatare">
   <title>Qu'est ce qu'une r&eacute;f&eacute;rence?</title>
   <simpara>
    En PHP, les r&eacute;f&eacute;rences sont destin&eacute;es &agrave;
    appeler le contenu d'une variable avec un autre nom. Ce n'est pas
    comme en C : ici, les r&eacute;f&eacute;rences sont des alias dans
    la table des symboles. Le nom de la variable et son contenu ont des
    noms diff&eacute;rents, ce qui fait que l'on peut donner
    plusieurs noms au m&ecirc;me contenu. On peut faire
    l'analogie avec les fichiers sous Unix, et leur nom de
    fichier : les noms des variables sont les entr&eacute;es dans un
    repertoire, tandis que le contenu de la variable est le contenu
    m&ecirc;me du fichier. Faire des r&eacute;f&eacute;rences en PHP
    revient alors &agrave; faire des liens sous Unix.
   </simpara>
  </sect1>
  <sect1 id="language.references.whatdo">
   <title>Que font les r&eacute;f&eacute;rences ?</title>
   <para>
    Les r&eacute;f&eacute;rences vous permettent de faire pointer
    deux variables sur le m&ecirc;me contenu. Par exemple, lorsque
    vous faites :
    <informalexample>
     <programlisting role="php">
&lt;?php
$a =&amp; $b
?&gt;
     </programlisting>
    </informalexample>
    cela signifie que <varname>$a</varname> et <varname>$b</varname>
    pointent sur la m&ecirc;me variable.
    <note>
     <para>
      <varname>$a</varname> et <varname>$b</varname> sont compl&egrave;tement
      &eacute;gales ici :  ce n'est pas <varname>$a</varname> qui pointe sur
      <varname>$b</varname>, ou vice versa. C'est bien <varname>$a</varname>
      et <varname>$b</varname> qui pointent sur le m&ecirc;me contenu.
     </para>
    </note>
    La m&ecirc;me syntaxe peut &ecirc;tre utilis&eacute;e avec les fonctions qui retournent des
    r&eacute;f&eacute;rences, et avec l'op&eacute;rateur <literal>new</literal>
    (PHP 4.0.4 et plus r&eacute;cent):
    <informalexample>
     <programlisting role="php">
&lt;?php
  $bar =&amp; new fooclass();
  $foo =&amp; find_var ($bar);
?&gt;
     </programlisting>
    </informalexample>
    </para>
    <note>
     <para>
      A moins d'utiliser la syntaxe ci-dessus, le r&eacute;sultat de
      <literal>$bar = new fooclass()</literal> ne sera pas la m&ecirc;me variable
      que <literal>$this</literal> dans le constructeur, ce qui signifie
      que si vous avez utilis&eacute; la r&eacute;f&eacute;rence <literal>$this</literal> dans le
      constructeur, vous devez assigner la r&eacute;f&eacute;rence, ou bien obtenir deux
      objets diff&eacute;rents.
     </para>
   </note>
   <para>
    Le deuxi&egrave;me int&eacute;r&ecirc;t des r&eacute;f&eacute;rences est de
    pouvoir passer des variables par r&eacute;f&eacute;rence. On
    r&eacute;alise ceci en faisant pointer des variables locales vers
    le contenu des variables de fonction. Exemple :
    <informalexample>
     <programlisting role="php">
&lt;?php
  function foo(&amp;$var) {
    $var++;
  }
  $a=5;
  foo($a);
?&gt;
     </programlisting>
    </informalexample>
    <varname>$a</varname> vaut 6. Cela provient du fait que dans la fonction
    <varname>foo</varname>, la variable <varname>$var</varname> pointe sur
    le m&ecirc;me contenu que <varname>$a</varname>. Voir aussi les explications
    d&eacute;taill&eacute;es dans
    <link linkend="language.references.pass">passage par r&eacute;f&eacute;rence</link>.
   </para>
   <simpara>
    Le troisi&egrave;me int&eacute;r&ecirc;t des r&eacute;f&eacute;rences est de
    <link linkend="language.references.return">retourner des valeurs par
    r&eacute;f&eacute;rence</link>.
   </simpara>
  </sect1>
  <sect1 id="language.references.arent">
   <title>Ce que les r&eacute;f&eacute;rences ne sont pas</title>
   <para>
    Comme pr&eacute;cis&eacute; ci-dessus, les r&eacute;f&eacute;rences ne
    sont pas des pointeurs. Cela signifie que le script suivant ne fera pas
    ce &agrave; quoi on peut s'attendre :
    <informalexample>
     <programlisting role="php">
&lt;?php
  function foo(&amp;$var) {
    $var =&amp; $GLOBALS["baz"];
  }
  foo($bar);
?&gt;
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Il va se passer que <varname>$var</varname> dans foo() sera li&eacute; &agrave;
    <varname>$bar</varname>, mais il sera aussi reli&eacute; &agrave;
    <varname>$GLOBALS["baz"]</varname>. Il n'y a pas moyen de lier
    <varname>$bar</varname>  &agrave; quelque chose d'autre en utilisant
    le m&eacute;canisme de r&eacute;f&eacute;rence, car <varname>$bar</varname>
    n'est pas accessible dans la fonction foo() (certes, il est repr&eacute;sent&eacute;
    par <varname>$var</varname> et <varname>$var</varname> poss&egrave;de la
    m&ecirc;me valeur, mais n'est pas reli&eacute; par la table des symboles).
   </simpara>
  </sect1>
  <sect1 id="language.references.pass">
   <title>Passage par r&eacute;f&eacute;rence</title>
   <para>
    Vous pouvez passer des variables par r&eacute;f&eacute;rence, de mani&egrave;re &agrave; ce que la
    fonction modifie ses arguments. La syntaxe est la suivante :
    <informalexample>
     <programlisting role="php">
&lt;?php
  function foo(&amp;$var) {
    $var++;
  }
  $a=5;
  foo ($a);
// $a vaut 6 maintenant
?&gt;
     </programlisting>
    </informalexample>
    Notez qu'il n'y a pas de signe de r&eacute;f&eacute;rence dans l'appel de la fonction,
    uniquement sur sa d&eacute;finition. La d&eacute;finition de la fonction est suffisante
    pour passer correctement des arguments par r&eacute;f&eacute;rence.
  </para>
  <para>
   Les objets suivants peuvent &ecirc;tre pass&eacute;s par r&eacute;f&eacute;rence :
   <itemizedlist>
    <listitem>
     <simpara>
       Une variable, i.e. <literal>foo($a)</literal>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Un nouvel objet, i.e. <literal>foo(new foobar())</literal>
     </simpara>
    </listitem>
    <listitem>
     <para>
      Une r&eacute;f&eacute;rence, retourn&eacute;e par une fonction :
    <informalexample>
     <programlisting role="php">
&lt;?php
  function &amp;bar() {
   $a = 5;
   return $a;
  }
  foo(bar());
?&gt;
     </programlisting>
    </informalexample>
    Voir aussi des d&eacute;tails dans
    <link linkend="language.references.return">retourner des r&eacute;f&eacute;rences</link>.
     </para>
    </listitem>
  </itemizedlist>
  </para>
  <para>
   Toutes les autres expressions ne doivent pas &ecirc;tre pass&eacute;es par
   r&eacute;f&eacute;rence, car le r&eacute;sultat sera ind&eacute;fini. Par exemple, les passages
   par r&eacute;f&eacute;rence suivants sont invalides :
    <informalexample>
     <programlisting role="php">
&lt;?php
  function bar() // Notez l'absence de &amp;
  {
        $a = 5;
        return $a;
  }
  foo(bar);
  foo($a = 5) // Expression, pas une variable
  foo(5) // Constante, pas une variable
?&gt;
     </programlisting>
    </informalexample>
    Ces fonctionnalit&eacute;s sont valables &agrave; partir de PHP 4.0.4.
   </para>
  </sect1>
  <sect1 id="language.references.return">
   <title>Retourner des r&eacute;f&eacute;rences</title>
   <para>
    Retourner des r&eacute;f&eacute;rences est toujours utile lorsque vous
    voulez utiliser une fonction pour savoir &agrave; quoi est li&eacute;e
    une variable. Lorsque vous retournez une variable par param&egrave;tre,
    utilisez le code suivant
        <informalexample>
     <programlisting role="php">
&lt;?php
  function &amp;find_var($param) {
  //    ...code...
    return $found_var;
  }
  $foo =&amp; find_var ($bar);
  $foo-&gt;x = 2;
?&gt;
     </programlisting>
    </informalexample>
    Dans cet exemple, la propri&eacute;t&eacute; de l'objet est retourn&eacute;e
    dans <varname>find_var</varname> et lui sera affect&eacute;e, et non
    pas &agrave; la copie, comme cela sera le cas avec une syntaxe par
    r&eacute;f&eacute;rence.
   </para>
   <note>
    <simpara>
     Contrairement au passage de param&egrave;tre, vous devez utiliser
     <literal>&amp;</literal> aux deux endroits, &agrave; la fois pour
     indiquer que vous retournez par r&eacute;f&eacute;rence (pas une
     copie habituelle), et pour indiquer que vous assignez aussi par
     r&eacute;f&eacute;rence (pas la copie habituelle).
    </simpara>
   </note>
  </sect1>
  <sect1 id="language.references.unset">
   <title>D&eacute;truire une r&eacute;f&eacute;rence</title>
   <para>
    Lorsque vous d&eacute;truisez une r&eacute;f&eacute;rence, vous ne
    faites que casser le lien entre le nom de la variable et son contenu.
    Cela ne signifie pas que le contenu est d&eacute;truit. Par exemple,
    <informalexample>
     <programlisting role="php">
&lt;?php
$a = 1;
$b =&amp; $a;
unset ($a);
?&gt;
     </programlisting>
    </informalexample>
    Cet exemple ne d&eacute;truira pas <varname>$b</varname>, mais juste
    <varname>$a</varname>.
   </para>
   <simpara>
    Encore une fois, on peut comparer cette action avec la fonction
    unlink d'Unix.
   </simpara>
  </sect1>
  <sect1 id="language.references.spot">
   <title>Rep&eacute;rer une r&eacute;f&eacute;rence</title>
   <simpara>
    De nombreuses syntaxes de PHP sont impl&eacute;ment&eacute;es via le
    m&eacute;canisme de r&eacute;f&eacute;rence, et tout ce qui a
    &eacute;t&eacute; vu concernant les liaisons entre variables
    s'applique &agrave; ces syntaxes. Par exemple, le passage et
    le retour d'arguments par r&eacute;f&eacute;rence.
    Quelques autres exemples de syntaxes :
   </simpara>
   <sect2 id="references.global">
    <title>R&eacute;f&eacute;rences globales</title>
    <para>
     Lorsque vous d&eacute;clarez une variable <command>global $var</command>,
     vous cr&eacute;ez en fait une r&eacute;f&eacute;rence sur une variable
     globale. Ce qui signifie que
     <informalexample>
      <programlisting role="php">
&lt;?php
$var =&amp; $GLOBALS["var"];
?&gt;
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     Et que, si vous d&eacute;truisez la variable <varname>$var</varname>,
     la variable globale ne sera pas d&eacute;truite.
    </simpara>
   </sect2>
   <sect2 id="references.this">
    <title><literal>$this</literal></title>
    <simpara>
     Dans une m&eacute;thode d'objet <varname>$this</varname> est
     toujours une r&eacute;f&eacute;rence sur l'objet courant.
    </simpara>
   </sect2>
  </sect1>
 </chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
