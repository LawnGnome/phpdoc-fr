<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 311989 Maintainer: jpauli Status: ready -->
<!-- Reviewed: no -->

<chapter xml:id="language.references" xmlns="http://docbook.org/ns/docbook">
 <title>Les références</title>
 <sect1 xml:id="language.references.whatare">
  <title>Qu'est ce qu'une référence ?</title>
  <simpara>
   En PHP, les références sont destinées à
   appeler le contenu d'une variable avec un autre nom. Ce n'est pas
   comme en C ; vous ne pouvez pas effectuer des opérations arithmétiques
   comme sur des pointeurs, ce ne sont pas des adresses mémoires.
   Voyez
   <xref linkend="language.references.arent" /> pour plus d'informations.    
   Les références sont des alias dans
   la table des symboles. Le nom de la variable et son contenu ont des
   noms différents, ce qui fait que l'on peut donner
   plusieurs noms au même contenu. On peut faire
   l'analogie avec les fichiers sous Unix, et leur nom de
   fichier : les noms des variables sont les entrées dans un
   répertoire, tandis que le contenu de la variable est le contenu
   même du fichier. Faire des références en PHP
   revient alors à faire des liens sous Unix.
  </simpara>
 </sect1>
 
 <sect1 xml:id="language.references.whatdo">
  <title>Que font les références ?</title>
  <para>
   Il y a 3 utilisations principales des références:
   <link linkend="language.references.whatdo.assign">assignation par
    référence</link>, <link linkend="language.references.whatdo.pass">passage
   par référence</link>,
   et <link linkend="language.references.whatdo.return">retourner par
   référence</link>. Cette section introduit ces opérations, avec des liens
   vers plus de précision.
  </para>
  <sect2 xml:id="language.references.whatdo.assign">
   <title>Assignation par référence</title>
   <para>
    Dans ce premier cas, les références PHP vous permettent de faire en
    sorte que 2 variables référencent le même contenu. Ainsi :
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a =& $b;
?>
]]>
     </programlisting>
    </informalexample>
    cela signifie que <varname>$a</varname> et <varname>$b</varname>
    pointent sur le même contenu.
    <note>
     <para>
      <varname>$a</varname> et <varname>$b</varname> sont complètement
      égales ici : ce n'est pas <varname>$a</varname> qui pointe sur
      <varname>$b</varname>, ou vice-versa. C'est bien <varname>$a</varname>
      et <varname>$b</varname> qui pointent sur le même contenu.
     </para>
    </note>
   </para>
   <note>
    <para>
     Si vous assignez, passez ou retournez une variable indéfinie par référence,
     elle sera créée automatiquement.
     <example>
      <title>Utilisation des références avec des variables indéfinies</title>
      <programlisting role="php">
<![CDATA[
<?php
function foo(&$var) { }

foo($a); // $a est "créée" et assignée à NULL

$b = array();
foo($b['b']);
var_dump(array_key_exists('b', $b)); // bool(true)

$c = new StdClass;
foo($c->d);
var_dump(property_exists($c, 'd')); // bool(true)
?>
]]>
      </programlisting>
     </example>
    </para>
   </note>
   <para>
    La même syntaxe peut être utilisée avec les fonctions qui
    retournent des références, et avec l'opérateur
    <literal>new</literal> (depuis PHP 4.0.4 et avant PHP 5.0.0) :
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$foo =& find_var($bar);
?>
]]>
     </programlisting>
    </informalexample>
    Depuis PHP 5, <link linkend="language.oop5.basic.new">new</link> retourne
    une référence automatiquement, donc, l'utilisation de <literal>=&amp;</literal>
    dans ce contexte est obsolète et produit un message de niveau <constant>E_DEPRECATED</constant>
    à partir de PHP 5.3, et un message <constant>E_STRICT</constant> dans les versions
    antérieures. (Techniquement, la difference est qu'en PHP 5, les objets comme les
    ressources sont des pointeurs vers la donnée réelle. La notion de "référence" ici
    est donc un peu différente (alias). Pour plus d'informations, voyez
    <link linkend="language.oop5.references">Les objects et les références</link>.)
    
   </para>
   <warning>
    <para>
     Si vous assignez une référence à une variable déclarée <literal>global</literal>
     dans une fonction, la référence ne sera visible qu'au sein de la fonction.
     Vous pouvez éviter cela en utilisant le tableau <varname>$GLOBALS</varname>.
     <example>
      <title>Référencer des variables globales depuis fonction</title>
      <programlisting role="php">
<![CDATA[
<?php
$var1 = "Variable Exemple";
$var2 = "";

function global_references($use_globals)
{
    global $var1, $var2;
    if (!$use_globals) {
        $var2 =& $var1; // visible uniquement dans la fonction
    } else {
        $GLOBALS["var2"] =& $var1; // visible également dans un contexte global
    }
}

global_references(false);
echo "var2 est défini à '$var2'\n"; // var2 est défini à ''
global_references(true);
echo "var2 est défini à '$var2'\n"; // var2 est défini à 'Variable Exemple'
?>
]]>
      </programlisting>
     </example>
     Voyez <literal>global $var;</literal> comme un raccourci pour <literal>$var
     =&amp; $GLOBALS['var'];</literal>. De ce fait assignant d'autres références à
     <literal>$var</literal> changeant uniquement la référence locale de la variable.
    </para>
   </warning>
   <note>
    <para>
     Si vous assignez des valeurs par références dans une structure
     &foreach;, les références seront également modifiées.
     <example>
      <title>Références et structure foreach</title>
      <programlisting role="php">
<![CDATA[
<?php
$ref = 0;
$row =& $ref;
foreach (array(1, 2, 3) as $row) {
    // faites quelque chose
}
echo $ref; // 3 - le dernier élément du tableau itéré
?>
]]>
      </programlisting>
     </example>
    </para>
   </note>
   <para>
    Même si ce n'est pas strictement une assignation par référence, les expressions
    créees avec la structure de langage
    <link linkend="function.array"><literal>array()</literal></link> peuvent aussi
    se comporter comme tel en préfixant par <literal>&amp;</literal> l'élément du tableau.
    Exemple:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = 1;
$b = array(2, 3);
$arr = array(&$a, &$b[0], &$b[1]);
$arr[0]++; $arr[1]++; $arr[2]++;
/* $a == 2, $b == array(3, 4); */
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Notez par contre que les références à l'intérieur des tableaux peuvent s'avérer
    dangereuses. Utiliser une assignation normale (pas par référence) avec une
    référence à droite de l'opérateur ne transforme pas la partie gauche de l'expression
    en référence, mais les références dans les tableaux sont préservées. Ceci
    s'applique aussi aux appels de fonctions avec un tableau passé par valeur.
    Exemple:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* Assignation de variables scalaires */
$a = 1;
$b =& $a;
$c = $b;
$c = 7; //$c n'est pas une référence; pas de changement à $a ou $b

/* Assignation de variables de type tableau */
$arr = array(1);
$a =& $arr[0]; //$a et $arr[0] sont des références vers la même valeur
$arr2 = $arr; //PAS une assignation par référence!
$arr2[0]++;
/* $a == 2, $arr == array(2) */
/* Les contenus de $arr sont changés même si ce n'était pas une référence! */
?>
]]>
     </programlisting>
    </informalexample>
    In other words, the reference behavior of arrays is defined in an
    element-by-element basis; the reference behavior of individual elements
    is dissociated from the reference status of the array container.
   </para>
  </sect2>
  <sect2 xml:id="language.references.whatdo.pass">
   <title>Passage par référence</title>
   <para>
    Le deuxième intérêt des références est de
    pouvoir passer des variables par référence. On
    réalise ceci en faisant pointer des variables locales vers
    le contenu des variables de fonction. Exemple :
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
function foo(&$var) {
  $var++;
}
$a=5;
foo($a);
?>
]]>
     </programlisting>
    </informalexample>
    <varname>$a</varname> vaut 6. Cela provient du fait que dans la fonction
    <varname>foo</varname>, la variable <varname>$var</varname> pointe sur
    le même contenu que <varname>$a</varname>. Voir aussi les explications
    détaillées dans
    <link linkend="language.references.pass">passage par
     référence</link>.
   </para>
  </sect2>
  <sect2 xml:id="language.references.whatdo.return">
   <title>Retourner par référence</title>
   <para>
    Le troisième intérêt des références est de
    <link linkend="language.references.return">retourner des valeurs par
     référence</link>.
   </para>
  </sect2>
 </sect1>
 
 <sect1 xml:id="language.references.arent">
  <title>Ce que les références ne sont pas</title>
  <para>
   Comme précisé ci-dessus, les références ne
   sont pas des pointeurs. Cela signifie que le script suivant ne fera pas
   ce à quoi on peut s'attendre :
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
function foo(&$var) {
  $var =& $GLOBALS["baz"];
}
foo($bar);
?>
]]>
    </programlisting>
   </informalexample>
  </para>
  <simpara>
   Il va se passer que <varname>$var</varname> dans <varname>foo</varname> sera lié
   à <varname>$bar</varname>, mais il sera aussi relié à
   <varname>$GLOBALS["baz"]</varname>. Il n'y a pas moyen de lier
   <varname>$bar</varname> à quelque chose d'autre en utilisant
   le mécanisme de référence, car <varname>$bar</varname>
   n'est pas accessible dans la fonction <varname>foo</varname> (certes, il est
   représenté par <varname>$var</varname> et
   <varname>$var</varname> possède la même valeur, mais n'est pas
   relié par la table des symboles).
   Vous pouvez utiliser les <link linkend="language.references.return">références
   arrières</link> pour référencer les variables sélectionnées par la fonction.
  </simpara>
 </sect1>
 
 <sect1 xml:id="language.references.pass">
  <title>Passage par référence</title>
  <para>
   Vous pouvez passer des variables par référence, de
   manière à ce que la fonction modifie ces variables.
   La syntaxe est la suivante :
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
function foo(&$var) {
  $var++;
}
$a=5;
foo ($a);
// $a vaut 6 maintenant
?>
]]>
    </programlisting>
   </informalexample>
   <note>
    <simpara>
     Il n'y a pas de signe de référence dans l'appel de la
     fonction, uniquement sur sa définition. La définition de la
     fonction est suffisante pour passer correctement des arguments par
     référence. Dans les versions récentes de PHP, vous devriez recevoir une alerte
     disant que "Call-time pass-by-reference" est obsolète lorsque vous utilisez
     un &amp; dans <literal>foo(&amp;$a);</literal>.
    </simpara>
   </note>
  </para>
  <para>
   Les objets suivants peuvent être passés par référence :
   <itemizedlist>
    <listitem>
     <simpara>
      Une variable, i.e. <literal>foo($a)</literal>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Un nouvel objet, i.e. <literal>foo(new foobar())</literal>
     </simpara>
    </listitem>
    <listitem>
     <para>
      Une référence, retournée par une fonction :
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
function foo(&$var)
{
    $var++;
}
function &bar()
{
 $a = 5;
 return $a;
}
foo(bar());
?>
]]>
       </programlisting>
      </informalexample>
      Voir aussi des détails dans
      <link linkend="language.references.return">retourner des
       références</link>.
     </para>
    </listitem>
   </itemizedlist>
  </para>
  <para>
   Toutes les autres expressions ne doivent pas être passées par
   référence, car le résultat sera indéfini. Par exemple,
   les passages par référence suivants sont invalides :
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
function foo(&$var)
{
    $var++;
}
function bar() // Notez l'absence de &
{
   $a = 5;
   return $a;
}
foo(bar());    // Produit une erreur fatale depuis PHP 5.0.5

foo($a = 5);    // Expression, pas une variable
foo(5);         // Produit une erreur fatale
?>
]]>
    </programlisting>
   </informalexample>
   Ces fonctionnalités sont valables à partir de PHP 4.0.4.
  </para>
 </sect1>
 
 <sect1 xml:id="language.references.return">
  <title>Retourner des références</title>
  <para>
   Retourner des références est toujours utile lorsque vous
   voulez utiliser une fonction pour savoir à quoi est liée
   une variable. N'utilisez <emphasis>pas</emphasis>
   le retour par référence pour améliorer les performances,
   le moteur est suffisamment robuste pour optimiser cela
   en interne. Retournez uniquement des références
   lorsque vous avez techniquement une bonne raison
   de le faire ! Pour retourner des références, utilisez cette syntaxe :
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class foo {
    public $value = 42;

    public function &getValue() {
        return $this->value;
    }
}

$obj = new foo;
$myValue = &$obj->getValue(); // $myValue est une référence de $obj->value, qui vaut 42.
$obj->value = 2;
echo $myValue;                // affiche la nouvelle valeur de $obj->value, i.e. 2.
?>
]]>
    </programlisting>
   </informalexample>
   Dans cet exemple, on affecte une valeur à la propriété de l'objet
   retourné par la fonction <varname>getValue</varname>, et non à sa copie,
   comme ce serait le cas si on n'avait pas utilisé la syntaxe de référence.
  </para>
  <note>
   <simpara>
    Contrairement au passage de paramètre, vous devez utiliser
    <literal>&amp;</literal> aux deux endroits, à la fois pour
    indiquer que vous retournez par référence (pas une
    copie habituelle), et pour indiquer que vous assignez aussi par
    référence (pas la copie habituelle) pour la variable <varname>$myValue</varname>.
   </simpara>
  </note>
  <note>
   <simpara>
    Si vous tentez de retourner une référence depuis une fonction
    avec la syntaxe :<literal>return ($this->value);</literal>,
    cela ne fonctionnera <emphasis>pas</emphasis> comme
    vous l'attendez et retournera le résultat de l'<emphasis>expression</emphasis>,
    mais pas de la variable, par référence. Vous ne pouvez retourner
    des variables par référence que depuis une fonction - rien d'autre.
    Depuis PHP 4.4.0 et PHP 5.1.0, une alerte <constant>E_NOTICE</constant>
    est envoyée si le code tente de retourner une expression dynamique
    ou un résultat de l'opérateur <literal>new</literal>.
   </simpara>
  </note>
  <para>
   Pour utiliser la référence retournée, vous devez utiliser l'assignement
   par référence :
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
function &collector() {
  static $collection = array();
  return $collection;
}
$collection = &collector();
$collection[] = 'foo';
?>
]]>
    </programlisting>
   </informalexample>
   Pour passer la référence retournée à une autre fonction attendant une référence,
   vous pouvez utiliser la syntaxe suivante :
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
function &collector() {
  static $collection = array();
  return $collection;
}
array_push(collector(), 'foo');
?>
]]>
    </programlisting>
   </informalexample>
  </para>
  <note>
   <simpara>
    Notez que <literal>array_push(&amp;collector(), 'foo');</literal>
    <emphasis>ne fonctionnera pas</emphasis>, et résultera en une erreur
    fatale.
   </simpara>
  </note>
 </sect1>
 
 <sect1 xml:id="language.references.unset">
  <title>Détruire une référence</title>
  <para>
   Lorsque vous détruisez une référence, vous ne
   faites que casser le lien entre le nom de la variable et son contenu.
   Cela ne signifie pas que le contenu est détruit. Par exemple :
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$a = 1;
$b =& $a;
unset($a);
?>
]]>
    </programlisting>
   </informalexample>
   Cet exemple ne détruira pas <varname>$b</varname>, mais juste
   <varname>$a</varname>.
  </para>
  <simpara>
   Encore une fois, on peut comparer cette action avec la fonction
   <command>unlink</command> d'Unix.
  </simpara>
 </sect1>
 
 <sect1 xml:id="language.references.spot">
  <title>Repérer une référence</title>
  <simpara>
   De nombreuses syntaxes de PHP sont implémentées via le
   mécanisme de référence, et tout ce qui a
   été vu concernant les liaisons entre variables
   s'applique à ces syntaxes. Par exemple, le passage et
   le retour d'arguments par référence.
   Quelques autres exemples de syntaxes :
  </simpara>
  
  <sect2 xml:id="references.global">
   <title>Références globales</title>
   <para>
    Lorsque vous déclarez une variable <command>global $var</command>,
    vous créez en fait une référence sur une variable
    globale. Ce qui signifie que
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$var =& $GLOBALS["var"];
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Et que, si vous détruisez la variable <varname>$var</varname>,
    la variable globale ne sera pas détruite.
   </simpara>
  </sect2>
  
  <sect2 xml:id="references.this">
   <title><literal>$this</literal></title>
   <simpara>
    Dans une méthode d'objet, <varname>$this</varname> est
    toujours une référence sur l'objet courant.
   </simpara>
  </sect2>
 </sect1>
 
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
