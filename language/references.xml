<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.30 $ -->
<!-- EN-Revision: 1.44 Maintainer: dams Status: ready -->
 <chapter id="language.references">
  <title>Les références</title>
  <sect1 id="language.references.whatare">
   <title>Qu'est ce qu'une référence?</title>
   <simpara>
    En &php;, les références sont destinées à
    appeler le contenu d'une variable avec un autre nom. Ce n'est pas
    comme en C ; à la place, les références sont des alias dans
    la table des symboles. Le nom de la variable et son contenu ont des
    noms différents, ce qui fait que l'on peut donner
    plusieurs noms au même contenu. On peut faire
    l'analogie avec les fichiers sous Unix, et leur nom de
    fichier : les noms des variables sont les entrées dans un
    répertoire, tandis que le contenu de la variable est le contenu
    même du fichier. Faire des références en &php;
    revient alors à faire des liens sous Unix.
   </simpara>
  </sect1>
  <sect1 id="language.references.whatdo">
   <title>Que font les références ?</title>
   <para>
    Les références vous permettent de faire pointer
    deux variables sur le même contenu. Par exemple, lorsque
    vous faites :
    <example>
     <title>Les références</title>
     <programlisting role="php">
<![CDATA[
<?php
$a =& $b;
?>
]]>
     </programlisting>
    </example>
    cela signifie que <varname>$a</varname> et <varname>$b</varname>
    pointent sur le même contenu.
    <note>
     <para>
      <varname>$a</varname> et <varname>$b</varname> sont complètement
      égales ici :  ce n'est pas <varname>$a</varname> qui pointe sur
      <varname>$b</varname>, ou vice versa. C'est bien <varname>$a</varname>
      et <varname>$b</varname> qui pointent sur le même contenu.
     </para>
    </note>
   </para>
   <note>
    <para>
     Si un tableau par référence est copié, ses valeurs ne sont pas déréférencées.
     Cela est valide également pour les tableaux passés par valeur aux fonctions.
    </para>
   </note>
   <para>
    La même syntaxe peut être utilisée avec les fonctions qui
    retournent des références, et avec l'opérateur
    <literal>new</literal> (&php; 4.0.4 et plus récent):
    <example>
     <title>Les références et <literal>new()</literal></title>
     <programlisting role="php">
<![CDATA[
<?php
$bar =& new fooclass();
$foo =& find_var($bar);
?>
]]>
     </programlisting>
    </example>
    </para>
    <note>
     <para>
      A moins d'utiliser la syntaxe ci-dessus, le résultat de
      <literal>$bar = new fooclass()</literal> ne sera pas la même
      variable que <literal>$this</literal> dans le constructeur, ce qui
      signifie que si vous avez utilisé la référence
      <literal>$this</literal> dans le constructeur, vous devez assigner la
      référence, ou bien obtenir deux objets différents.
     </para>
     <para>
      Même si vous pouvez utiliser l'opérateur <literal>@</literal> pour
      <emphasis>supprimer</emphasis> les messages d'erreurs du constructeur
      avec la syntaxe <literal>@new</literal>, cela ne fonctionnera pas avec
      la syntaxe <literal>&amp;new</literal>. C'est une limitation du 
      moteur Zend, et cela conduit à une erreur d'analyse.
     </para>
   </note>
   <warning>
    <para>
     Si vous assignez une référence à une variable définie en tant que 
     <literal>global</literal> dans une fonction, la référence sera visible uniquement 
     à l'intérieure de la fonction. Vous pouvez éviter cela en utilisant le tableau 
     <varname>$GLOBALS</varname>.
     <example>
      <title>Référencer une variable globale à l'intérieure d'une fonction</title>
      <programlisting role="php">
<![CDATA[
<?php
$var1 = "Variable Exemple";
$var2 = "";

function global_references($use_globals)
{
    global $var1, $var2;
    if (!$use_globals) {
        $var2 =& $var1; // visible uniquement dans la fonction
    } else {
        $GLOBALS["var2"] =& $var1; // visible également dans un contexte global
    }
}

global_references(false);
echo "var2 est défini à '$var2'\n"; // var2 est défini à ''
global_references(true);
echo "var2 est défini à '$var2'\n"; // var2 est défini à 'Variable Exemple'
?>
]]>
      </programlisting>
     </example>
     Voyez <literal>global $var;</literal> comme un raccourci pour <literal>$var
     =&amp; $GLOBALS['var'];</literal>. De ce fait assignant d'autres références à
     <literal>$var</literal> changeant uniquement la référence local de la variable.
    </para>
   </warning>
   <note>
    <para>
     Si vous assignez des valeurs par références dans une structure 
     <link linkend="control-structures.foreach">foreach</link>,
     les références seront également modifiées.
     <example>
      <title>Références et structure foreach</title>
      <programlisting role="php">
<![CDATA[
<?php
$ref = 0;
$row =& $ref;
foreach (array(1, 2, 3) as $row) {
    // faîte quelque chose
}
echo $ref; // 3 - le dernier élément du tableau itéré
?>
]]>
      </programlisting>
     </example>
    </para>
   </note>
   <warning>
    <para>
     Les tableaux complexes sont parfois plutôt copiés que référencés. De ce fait, l'exemple 
     suivant ne fonctionnera pas comme prévu :
     <example>
      <title>Références avec un tableau complexe</title>
      <programlisting role="php">
<![CDATA[
<?php
$top = array(
    'A' => array(),
    'B' => array(
        'B_b' => array(),
    ),
);

$top['A']['parent'] = &$top;
$top['B']['parent'] = &$top;
$top['B']['B_b']['data'] = 'test';
print_r($top['A']['parent']['B']['B_b']); // array()
?>
]]>
      </programlisting>
     </example>
    </para>
   </warning>
   <para>
    Le deuxième intérêt des références est de
    pouvoir passer des variables par référence. On
    réalise ceci en faisant pointer des variables locales vers
    le contenu des variables de fonction. Exemple :
    <example>
     <title>Passage de paramètre par références</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo(&$var) {
  $var++;
}
$a=5;
foo($a);
?>
]]>
     </programlisting>
    </example>
    <varname>$a</varname> vaut 6. Cela provient du fait que dans la fonction
    <varname>foo</varname>, la variable <varname>$var</varname> pointe sur
    le même contenu que <varname>$a</varname>. Voir aussi les explications
    détaillées dans
    <link linkend="language.references.pass">passage par
    référence</link>.
   </para>
   <simpara>
    Le troisième intérêt des références est de
    <link linkend="language.references.return">retourner des valeurs par
    référence</link>.
   </simpara>
  </sect1>
  <sect1 id="language.references.arent">
   <title>Ce que les références ne sont pas</title>
   <para>
    Comme précisé ci-dessus, les références ne
    sont pas des pointeurs. Cela signifie que le script suivant ne fera pas
    ce à quoi on peut s'attendre :
    <example>
     <title>Les références ne sont pas des pointeurs</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo(&$var) {
  $var =& $GLOBALS["baz"];
}
foo($bar);
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Il va se passer que <varname>$var</varname> dans <literal>foo()</literal> sera lié
    à <varname>$bar</varname>, mais il sera aussi relié à
    <varname>$GLOBALS["baz"]</varname>. Il n'y a pas moyen de lier
    <varname>$bar</varname>  à quelque chose d'autre en utilisant
    le mécanisme de référence, car <varname>$bar</varname>
    n'est pas accessible dans la fonction <literal>foo()</literal> (certes, il est
    représenté par <varname>$var</varname> et
    <varname>$var</varname> possède la même valeur, mais n'est pas
    relié par la table des symboles).
   </simpara>
  </sect1>
  <sect1 id="language.references.pass">
   <title>Passage par référence</title>
   <para>
    Vous pouvez passer des variables par référence, de
    manière à ce que la fonction modifie ses arguments. 
    La syntaxe est la suivante :
    <example>
     <title>Passage par référence</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo(&$var) {
  $var++;
}
$a=5;
foo ($a);
// $a vaut 6 maintenant
?>
]]>
     </programlisting>
    </example>
    Notez qu'il n'y a pas de signe de référence dans l'appel de la
    fonction, uniquement sur sa définition. La définition de la
    fonction est suffisante pour passer correctement des arguments par
    référence. Dans les versions récentes de &php;, vous devriez recevoir une alerte
    disant que "Call-time pass-by-reference" est déprécié lorsque vous utilisez
    un &amp; dans <literal>foo(&amp;$a);</literal>.
  </para>
  <para>
   Les objets suivants peuvent être passés par référence :
   <itemizedlist>
    <listitem>
     <simpara>
       Une variable, i.e. <literal>foo($a)</literal>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Un nouvel objet, i.e. <literal>foo(new foobar())</literal>
     </simpara>
    </listitem>
    <listitem>
     <para>
      Une référence, retournée par une fonction :
    <example>
     <title>Retour d'une référence par une fonction</title>
     <programlisting role="php">
<![CDATA[
<?php
function &bar() {
 $a = 5;
 return $a;
}
foo(bar());
?>
]]>
     </programlisting>
    </example>
    Voir aussi des détails dans
    <link linkend="language.references.return">retourner des
    références</link>.
     </para>
    </listitem>
  </itemizedlist>
  </para>
  <para>
   Toutes les autres expressions ne doivent pas être passées par
   référence, car le résultat sera indéfini. Par exemple, 
   les passages par référence suivants sont invalides :
    <example>
     <title>Passage par référence invalides</title>
     <programlisting role="php">
<![CDATA[
<?php
function bar() // Notez l'absence de &
{
   $a = 5;
   return $a;
}
foo(bar());    // Produit une erreur fatale depuis PHP 5.1.0

foo($a = 5);    // Expression, pas une variable
foo(5);         // Produit une erreur fatale
?>
]]>
     </programlisting>
    </example>
    Ces fonctionnalités sont valables à partir de &php; 4.0.4.
   </para>
  </sect1>

  <sect1 id="language.references.return">
   <title>Retourner des références</title>
   <para>
    Retourner des références est toujours utile lorsque vous
    voulez utiliser une fonction pour savoir à quoi est liée
    une variable. N'utilisez <emphasis>pas</emphasis>
    le retour par référence pour améliorer les performances,
    le moteur est suffisamment robuste pour optimiser cela
    en interne. Retourner uniquement des références
    lorsque vous avez techniquement une bonne raison
    de le faire ! Pour retourner des références, utilisez cette syntaxe :
    <example>
     <title>Retourner des références</title>
     <programlisting role="php">
<![CDATA[
<?php
function &find_var($param) {
  /*  ...code... */
  return $found_var;
}
$foo =& find_var ($bar);
$foo->x = 2;
?>
]]>
     </programlisting>
    </example>
    Dans cet exemple, on affecte une valeur à la propriété de l'objet
    retourné par la fonction <varname>find_var</varname>, et non à sa copie,
    comme ce serait le cas si on n'avait pas utilisé la syntaxe de référence.
   </para>
   <note>
    <simpara>
     Contrairement au passage de paramètre, vous devez utiliser
     <literal>&amp;</literal> aux deux endroits, à la fois pour
     indiquer que vous retournez par référence (pas une
     copie habituelle), et pour indiquer que vous assignez aussi par
     référence (pas la copie habituelle).
    </simpara>
   </note>
   <note>
    <simpara>
     Si vous tentez de retourner une référence depuis une fonction
     avec la syntaxe :<literal>return ($found_var);</literal>,
     cela ne fonctionnera <emphasis>pas</emphasis> comme
     vous l'attendez et retournera le résultat de l'<emphasis>expression</emphasis>,
     mais pas de la variable, par référence. Vous ne pouvez retourner
     des variables par référence que depuis une fonction - rien d'autre.
     L'erreur <constant>E_NOTICE</constant> est envoyée depuis
     &php; 4.4.0 et &php; 5.1.0 si le code tente de retourner une expression dynamique
     ou un résultat de l'opérateur <literal>new</literal>.
    </simpara>
   </note>
  </sect1>

  <sect1 id="language.references.unset">
   <title>Détruire une référence</title>
   <para>
    Lorsque vous détruisez une référence, vous ne
    faites que casser le lien entre le nom de la variable et son contenu.
    Cela ne signifie pas que le contenu est détruit. Par exemple : 
    <example>
     <title>Détruire une référence</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 1;
$b =& $a;
unset($a);
?>
]]>
     </programlisting>
    </example>
    Cet exemple ne détruira pas <varname>$b</varname>, mais juste
    <varname>$a</varname>.
   </para>
   <simpara>
    Encore une fois, on peut comparer cette action avec la fonction
    <command>unlink</command> d'Unix.
   </simpara>
  </sect1>
  <sect1 id="language.references.spot">
   <title>Repérer une référence</title>
   <simpara>
    De nombreuses syntaxes de &php; sont implémentées via le
    mécanisme de référence, et tout ce qui a
    été vu concernant les liaisons entre variables
    s'applique à ces syntaxes. Par exemple, le passage et
    le retour d'arguments par référence.
    Quelques autres exemples de syntaxes :
   </simpara>
   <sect2 id="references.global">
    <title>Références globales</title>
    <para>
     Lorsque vous déclarez une variable <literal>global $var</literal>,
     vous créez en fait une référence sur une variable
     globale. Ce qui signifie que
     <example>
      <title>Références sur les variables globales</title>
      <programlisting role="php">
<![CDATA[
<?php
$var =& $GLOBALS["var"];
?>
]]>
      </programlisting>
     </example>
    </para>
    <simpara>
     Et que, si vous détruisez la variable <varname>$var</varname>,
     la variable globale ne sera pas détruite.
    </simpara>
   </sect2>

   <sect2 id="references.this">
    <title><literal>$this</literal></title>
    <simpara>
     Dans une méthode d'objet, <varname>$this</varname> est
     toujours une référence sur l'objet courant.
    </simpara>
   </sect2>
  </sect1>
 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
