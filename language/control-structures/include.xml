<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.1 $ -->
<!-- EN-Revision: 1.2 Maintainer: yannick Status: ready -->
<!-- Reviewed: no -->

<sect1 xml:id="function.include" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title><function>include</function></title>
 <simpara>
  La fonction <function>include</function> inclut et exécute
  le fichier spécifié en argument.
 </simpara>
 <simpara>
  Cette documentation s'applique aussi à la fonction
  <function>require</function>. Les deux structures de langage sont identiques,
  hormis dans leur gestion des erreurs. Ils produisent tous les deux une
  <link linkend="errorfunc.constants.errorlevels.e-warning">Alerte</link> mais
  <function>require</function> génère une
  <link linkend="errorfunc.constants.errorlevels.e-error">erreur fatale</link>.
  En d'autres termes, n'hésitez pas à utiliser <function>require</function> si
  vous voulez qu'un fichier d'inclusion manquant interrompe votre script.
  <function>include</function> ne se comporte pas de cette façon, et le script
  continuera son exécution. Assurez-vous d'avoir bien configuré le
  <link linkend="ini.include-path"><option>include_path</option></link> aussi.
  Soyez prévenus qu'une erreur d'analyse dans un fichier inclut ne cause pas
  l'arrêt du script en PHP dans les versions antérieures à 4.3.5. Depuis ces
  versions, il le peut.
 </simpara>
 <simpara>
  Les fichiers à inclure sont d'abord recherchés dans chaque dossier de
  <option>include_path</option>, relativement au dossier courant, puis dans le
  dossier de travail du script. Par exemple, si <option>include_path</option>
  est <literal>.</literal>, que le dossier de travail est
  <filename class="directory">/www/</filename>, et que vous incluez le fichier
  <filename>include/a.php</filename> et qu'il y a une instruction
  <literal>include "b.php"</literal> dans ce fichier, alors
  <filename>b.php</filename> est d'abord recherché dans
  <filename class="directory">/www/libraries/</filename>, puis dans
  <filename class="directory">/www/include/</filename>.
  Si le nom du fichier commence par <literal>./</literal> ou
  <literal>../</literal>, il est cherché uniquement dans le dossier courant
  d'exécution.
 </simpara>
 <simpara>
  Lorsqu'un fichier est inclus, le code le composant hérite de la
  <link linkend="language.variables.scope">portée des variables</link>
  de la ligne où l'inclusion apparaît. Toutes les variables disponibles à cette
  ligne dans le fichier appelant seront disponibles dans le fichier appelé, à
  partir de ce point. Cependant, toutes les fonctions et classes définies dans
  le fichier inclus ont une portée globale.
 </simpara>
 <para>
  <example>
   <title>Exemple avec <function>include</function></title>
   <programlisting role="php">
<![CDATA[
vars.php
<?php

$color = 'verte';
$fruit = 'pomme';

?>

test.php
<?php

echo "Une $couleur $fruit"; // Une

include 'vars.php';

echo "Une $couleur $fruit"; // Une verte pomme

?>
]]>
   </programlisting>
  </example>
 </para>
 <simpara>
  Si l'inclusion intervient à l'intérieure d'une fonction,
  le code inclus sera alors considéré comme faisant partie de la
  fonction. Cela modifie donc le contexte de variables accessibles.
  Une exception à cette règle : les <link
  linkend="language.constants.predefined">constantes magiques</link> sont analysées
  par l'analyseur avant que l'inclusion n'intervienne.
 </simpara>
 <para>
  <example>
   <title>Inclusion de fichiers dans une fonction</title>
   <programlisting role="php">
<![CDATA[
<?php

function foo()
{
    global $color;

    include 'vars.php';

    echo "Une $couleur $fruit";
}

/* vars.php est dans le contexte de foo()     *
 * donc $fruit n'est pas disponibles hors de  *
 * cette fonction. $couleur l'est, car c'est  *
 * une variable globale                       */

foo();                      // Une verte pomme
echo "Une $couleur $fruit"; // Une verte

?>
]]>
   </programlisting>
  </example>
 </para>
 <simpara>
  Il est important de noter que lorsqu'un fichier est
  <function>include</function> ou <function>require</function>,
  les erreurs d'analyse apparaîtront en HTML tout
  au début du fichier, et l'analyse du fichier
  parent ne sera pas interrompue. Pour cette raison, le code
  qui est dans le fichier doit être placé entre
  <link linkend="language.basic-syntax.phpmode">les balises
  habituelles de PHP</link>.
 </simpara>
 <simpara>
  Si les <link linkend="ini.allow-url-fopen">Gestionnaires d'URL</link>
  sont activés dans PHP (ce qui est le cas par défaut),
  vous pouvez localiser le fichier avec une URL (via HTTP ou
  bien avec un gestionnaire adapté : voir <xref linkend="wrappers"/>
  pour une liste des protocoles), au lieu d'un simple chemin
  local. Si le serveur distant interprète le fichier comme du code
  PHP, des variables peuvent être transmises au serveur distant
  via l'URL et la méthode GET. Ce n'est pas, à strictement
  parler, la même chose que d'hériter du contexte de variable.
  Le fichier inclus est en fait un script exécuté à distance,
  et son résultat est inclus dans le code courant.
 </simpara>
 &warn.no-win32-fopen-wrapper;
 <para>
  <example>
   <title>Utiliser <function>include</function> via HTTP</title>
   <programlisting role="php">
<![CDATA[
<?php

/* Cet exemple suppose que www.example.com est configuré pour traiter
 * les fichiers .php et non pas les fichiers .txt. De plus,
 * 'Work' signifie ici que les variables
 * $foo et $bar sont disponibles dans le fichier inclus
 */

// Ne fonctionne pas : file.txt n'a pas été traité par www.example.com comme du PHP
include 'http://www.example.com/file.txt?foo=1&bar=2';

// Ne fonctionne pas : le script cherche un fichier nommé
// 'file.php?foo=1&bar=2' sur le système local
include 'file.php?foo=1&bar=2';

// Réussi
include 'http://www.example.com/file.php?foo=1&bar=2';

$foo = 1;
$bar = 2;
include 'file.txt';  // Ok.
include 'file.php';  // Ok.

?>
]]>
   </programlisting>
  </example>
 </para>
 <warning>
  <title>Alerte de sécurité</title>
  <para>
   Un fichier distant peut être traité sur le serveur distant
   (dépendemment de l'extension du fichier et si le serveur distant
   exécute PHP ou non) mais il doit toujours produire un script PHP valide
   parce qu'il sera traité sur le serveur local. Si le fichier du serveur
   distant doit être traité sur place et affiché seulement,
   <function>readfile</function> est une fonction beaucoup plus appropriée.
   Autrement, vous devriez bien faire attention à sécuriser le script distant
   afin qu'il produise un code valide et désiré.
   </para>
 </warning>
 <para>
  Voir aussi
  <link linkend="features.remote-files">travailler avec les fichiers distants</link>,
  <function>fopen</function> et
  <function>file</function> pour des informations reliées.
 </para>
 <simpara>
  Gestion du retour : il est possible d'exécuter une commande
  <function>return</function> dans un fichier inclus pour en
  terminer le traitement et retourner au fichier appelant. De plus,
  il est possible de retourner des valeurs des fichiers inclus.
  Vous pouvez prendre et traiter la valeur retournée par la
  fonction, comme toute autre fonction. Ce n'est cependant pas possible
  lors de l'inclusion de fichier distant à moins que le fichier distant
  a des <link linkend="language.basic-syntax.phpmode">balises valides de
  début et de fin de script PHP</link> (comme avec les fichiers locaux).
  Vous pouvez déclarer les variables nécessaire dans ces tags et elles seront
  introduites à l'endroit où le fichier a été inclus.
 </simpara>
 <para>
  Comme <function>include</function> est une structure de langage particulière,
  les parenthèses ne sont pas nécessaires autour de l'argument. Faites attention
  lorsque vous comparez la valeur retournée.
  <example>
   <title>Comparaison de la valeur de retour d'un include</title>
   <programlisting role="php">
<![CDATA[
<?php
// Ne fonctionne pas, évaluer comme include(('vars.php') == 'OK'), i.e. include('')
if (include('vars.php') == 'OK') {
    echo 'OK';
}

// Fonctionne
if ((include 'vars.php') == 'OK') {
    echo 'OK';
}
?>
]]>
   </programlisting>
  </example>
 </para>
 <para>
  <example>
   <title><function>include</function> et <function>return</function></title>
   <programlisting role="php">
<![CDATA[
return.php
<?php

$var = 'PHP';

return $var;

?>

noreturn.php
<?php

$var = 'PHP';

?>

testreturns.php
<?php

$foo = include 'return.php';

echo $foo; // affiche 'PHP'

$bar = include 'noreturn.php';

echo $bar; // affiche 1

?>
]]>
   </programlisting>
  </example>
 </para>
 <simpara>
  <literal>$bar</literal> a la valeur de &one; car
  l'inclusion était réussie. Notez la différence entre les deux
  exemples ci-dessus. Le premier utilise la commande <function>return</function>
  dans le fichier inclus, alors que le second ne le fait pas.
  Si le fichier ne peut être inclus, &false; est retourné et une erreur
  de niveau <literal>E_WARNING</literal> est envoyée.
 </simpara>
 <para>
  S'il y a des fonctions de définies dans le fichier inclus, elles peuvent être
  utilisées dans le fichier principal si elles sont avant le
  <function>return</function> ou après. Si le fichier est inclus deux fois,
  PHP 5 enverra une erreur fatale car les fonctions seront déjà déclarées,
  tandis que PHP 4 ne se plaindra pas des fonctions définies après
  <function>return</function>. Il est recommandé d'utiliser
  <function>include_once</function> au lieu de vérifier si le fichier a déjà été
  inclus et donc de retourner conditonnellement l'inclusion du fichier.
 </para>
 <simpara>
  Une autre façon d'inclure un fichier PHP dans une variable est de capturer
  la sortie en utilisant les fonctions de
  <link linkend="ref.outcontrol">contrôle de sortie</link> avec
  <function>include</function>. Par exemple :
 </simpara>
 <para>
  <example>
   <title>Utilisation de la sortie du buffer pour inclure un fichier PHP dans
   une chaîne</title>
   <programlisting role="php">
<![CDATA[
<?php
$string = get_include_contents('somefile.php');

function get_include_contents($filename) {
    if (is_file($filename)) {
        ob_start();
        include $filename;
        $contents = ob_get_contents();
        ob_end_clean();
        return $contents;
    }
    return false;
}

?>
]]>
   </programlisting>
  </example>
 </para>
 <para>
  Pour automatiquement inclure des fichiers dans vos scripts, voyez également
  les options de configuration
  <link linkend="ini.auto-prepend-file">auto_prepend_file</link> et
  <link linkend="ini.auto-append-file">auto_append_file</link>
  du &php.ini;.
 </para>

 &note.language-construct;

 <simpara>
  Voir aussi
  <function>require</function>, <function>require_once</function>,
  <function>include_once</function>, <function>get_included_files</function>,
  <function>readfile</function>, <function>virtual</function>, et
  <link linkend="ini.include-path">include_path</link>.
 </simpara>
</sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
