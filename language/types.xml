  <chapter id="language.types">
	<title>Types</title>

   <para>
    PHP supporte les types suivants :

   <itemizedlist>
    <listitem>
     <simpara>
      <link linkend="language.types.array">tableau</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.types.double">nombre &agrave; virgule flottante</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.types.integer">entier</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.types.object">objet</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.types.string">cha&icirc;ne</link>
     </simpara>
    </listitem>
   </itemizedlist>
  </para>

  <simpara>
     Habituellement, le type d'une variable n'est pas d&eacute;clar&eacute; par le programmeur. 
     Il est d&eacute;cid&eacute; au moment de l'ex&eacute;cution par le PHP, en fonction du contexte dans 
     lequel la variable est utilis&eacute;e. 
  </simpara>

  <simpara>
      Si vous voulez forcer une variable &agrave; &ecirc;tre convertie en un certain type, vous 
      devez transtyper (<link linkend="language.types.typecasting">cast</link>) la 
      variable ou utiliser la fonction <function>settype</function>. 
  </simpara>

  <simpara>
      Il est &agrave; noter qu'une variable peut se comporter de mani&egrave;re diff&eacute;rente suivant 
      les situations, en fonction du type qui lui est affect&eacute;. 
      Pour plus d'informations, voir le paragraphe 
      <link linkend="language.types.type-juggling">transtypage</link>.
  </simpara>

  <sect1 id="language.types.integer">
   <title>Entiers</title>
   <para>
    Il est possible de sp&eacute;cifier les nombres entiers (integers) de la mani&egrave;re suivante : 
    <informalexample>
     <programlisting role="php">
$a = 1234; # nombre entier en base 10
$a = -123; # nombre entier n&eacute;gatif
$a = 0123; # nombre entier en base 8, octale (&eacute;quivalent &agrave; 83 en base 10)
$a = 0x12; # nombre entier en base 16, hexad&eacute;cimale (&eacute;quivalent &agrave; 18 en base 10)
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 id="language.types.double">
   <title>Les nombres &agrave; virgule flottante</title>
   <para>
    Les nombres &agrave; virgule flottante ("double") peuvent &ecirc;tres sp&eacute;cifi&eacute;s 
    en utilisant la syntaxe suivante: 
    <informalexample>
     <programlisting role="php"> 
$a = 1.234; 
$a = 1.2e3;
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 id="language.types.string">
   <title>Les cha&icirc;nes de caract&egrave;res</title>
   <para>
    Les cha&icirc;nes de caract&egrave;res peuvent &ecirc;tre d&eacute;finies en utilisant deux types de 
    d&eacute;limiteurs.
   </para>
   <para>
    Si la cha&icirc;ne de caract&egrave;res est d&eacute;limit&eacute;e par des guillemets doubles ("), les 
    variables &agrave; l'int&eacute;rieur de la cha&icirc;ne seront &eacute;valu&eacute;es, et remplac&eacute;es par 
    leur valeur. Comme en C ou en Perl, le caract&egrave;re backslash (\) est utilis&eacute; pour 
    prot&eacute;ger (&eacute;chapper) un caract&egrave;re sp&eacute;cial. 
    <table>
     <title>Les caract&egrave;res sp&eacute;ciaux</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>s&eacute;quence</entry>
        <entry>valeur</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>\n</literal></entry>
        <entry>Nouvelle ligne</entry>
       </row>
       <row>
        <entry><literal>\r</literal></entry>
        <entry>Retour &agrave; la ligne</entry>
       </row>
       <row>
        <entry><literal>\t</literal></entry>
        <entry>Tabulation horizontale</entry>
       </row>
       <row>
        <entry><literal>\\</literal></entry>
        <entry>Backslash</entry>
       </row>
       <row>
        <entry><literal>\$</literal></entry>
        <entry>Caract&egrave;re $</entry>
       </row>
       <row>
        <entry><literal>\"</literal></entry>
        <entry>Guillemet double</entry>
       </row>
       <row>
        <entry><literal>\[0-7]{1,3}</literal></entry>
        <entry>
	Une s&eacute;quence de caract&egrave;re qui permet de rechercher un nombre en notation octale.
        </entry>
       </row>
       <row>
        <entry><literal>\x[0-9A-Fa-f]{1,2}</literal></entry>
        <entry>
	 Une s&eacute;quence de caract&egrave;re qui permet de rechercher un nombre en notation 
         hexad&eacute;cimale.
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table></para>
   <para>
    Vous pouvez utiliser le caract&egrave;re d'&eacute;chappement backslash sur n'importe quel autre 
    caract&egrave;re, mais cela produira une alerte (si le niveau d’alerte maximal a &eacute;t&eacute; fix&eacute;).
   </para>

   <para>
    Le deuxi&egrave;me moyen de d&eacute;limiter une cha&icirc;ne de caract&egrave;re est d'utiliser les 
    guillemets simples ('). Dans une telle cha&icirc;ne de caract&egrave;res, les variables 
    <emphasis>ne seront pas</emphasis> &eacute;valu&eacute;es, et le caract&egrave;re backslash n'aura 
    aucun effet (&agrave; deux exceptions pr&egrave;s, pour "\\" et "\'", afin de pouvoir utiliser 
    les caract&egrave;res guillemets simples, et backslash dans la cha&icirc;ne de caract&egrave;res).
   </para>

   <para>
    Another way to delimit strings is by using here doc syntax
    ("&lt;&lt;&lt;").  One should provide an identifier after
    <literal>&lt;&lt;&lt;</literal>, then the string, and then the
    same identifier to close the quotation. The closing identifier
    <emphasis>must</emphasis> begin in the first column of the line.
    <example> 
     <title>Here doc string quoting example</title>
     <programlisting>
$str = &lt;&lt;&lt;EOD
Example of string
spanning multiple lines
using heredoc syntax.
EOD;
     </programlisting>
    </example>
   </para>
   <note>
    <para>
     Here doc support was added in PHP 4.
    </para>
   </note>

   <para>
    Strings may be concatenated using the '.' (dot) operator. Note
    that the '+' (addition) operator will not work for this. Please
    see <link linkend="language.operators.string">String
    operators</link> for more information.
   </para>

   <para>
    Characters within strings may be accessed by treating the string
    as a numerically-indexed array of characters, using C-like
    syntax. See below for examples.
   </para>

   <para>
    <example>
     <title>Some string examples</title>
     <programlisting role="php">
&lt;?php
/* Assigning a string. */
$str = "This is a string";

/* Appending to it. */
$str = $str . " with some more text";

/* Another way to append, includes an escaped newline. */
$str .= " and a newline at the end.\n";

/* This string will end up being '&lt;p&gt;Number: 9&lt;/p&gt;' */
$num = 9;
$str = "&lt;p&gt;Number: $num&lt;/p&gt;";

/* This one will be '&lt;p&gt;Number: $num&lt;/p&gt;' */
$num = 9;
$str = '&lt;p&gt;Number: $num&lt;/p&gt;';

/* Get the first character of a string  */
$str = 'This is a test.';
$first = $str[0];

/* Get the last character of a string. */
$str = 'This is still a test.';
$last = $str[strlen($str)-1];
?&gt;	  
     </programlisting>
    </example>
   </para>

   <sect2 id="language.types.string.conversion">
    <title>Conversion de type</title>

    <simpara>
Lorsqu'une cha&icirc;ne de caract&egrave;re est &eacute;valu&eacute;e comme une valeur num&eacute;rique, le r&eacute;sultat et le type de la variable sont d&eacute;termin&eacute;s comme suit.</simpara>

    <simpara>
La cha&icirc;ne de caract&egrave;res est de type "double" si elle contient un des caract&egrave;re '.', 'e' ou 'E'. Sinon, elle est de type entier ("integer").</simpara>
     
    <para>
La valeur est d&eacute;finie par la premi&egrave;re partie de la cha&icirc;ne. Si la cha&icirc;ne de caract&egrave;res d&eacute;bute par une valeur num&eacute;rique cette valeur sera celle utilis&eacute;e. Sinon, la valeur sera &eacute;gale &agrave; 0 (z&eacute;ro).</para>

    <simpara>
Lorsque la premi&egrave;re expression est une cha&icirc;ne de caract&egrave;res, le type de la variable d&eacute;pend de la seconde expression.
    </simpara>

    <informalexample>
     <programlisting role="php">
$foo = 1 + "10.5";              // $foo est du type  double (11.5)
$foo = 1 + "-1.3e3";            // $foo est du type  double (-1299)
$foo = 1 + "bob-1.3e3";         // $foo est du type  integer (1)
$foo = 1 + "bob3";              // $foo est du type  integer (1)
$foo = 1 + "10 Small Pigs";     // $foo est du type  integer (11)
$foo = 1 + "10 Little Piggies"; // $foo est du type  integer (11)
$foo = "10.0 pigs " + 1;        // $foo est du type  integer (11)
$foo = "10.0 pigs " + 1.0;      // $foo est du type  double (11)     
     </programlisting>
    </informalexample>

    <simpara>
Pour plus d'informations sur les conversions de type, voir les pages de man &agrave; propos de la fonction strtod(3).
    </simpara>

    <para>
     If you would like to test any of the examples in this section,
     you can cut and paste the examples and insert the following line
     to see for yourself what's going on:
     <informalexample>
      <programlisting role="php">
echo "\$foo==$foo; type is " . gettype( $foo ) . "&lt;br&gt;\n";
      </programlisting>
     </informalexample>
    </para>

   </sect2>
  </sect1>

  <sect1 id="language.types.array">
   <title>Les tableaux</title>

   <para>
Les tableaux ressemblent aux tables de hashage (tableaux associatifs) et aux tableaux index&eacute;s (vecteurs).</para>

   <sect2 id="language.types.array.single-dim">
    <title>Tableaux &agrave; une dimension</title>

    <para>
PHP supporte les tableaux scalaires et les tableaux associatifs. En fait, il n'y a aucune diff&eacute;rence entre les deux. Vous pouvez cr&eacute;er un tableau en utilisant les fonctions 
<function>list</function> ou <function>array</function>, ou bien en affectant explicitement chacune des valeurs. 

     <informalexample>
      <programlisting role="php"> 
$a[0] = "abc"; 
$a[1] = "def"; 
$b["foo"] = 13;
      </programlisting>
     </informalexample>
    </para>

    <para>
Vous pouvez aussi cr&eacute;er un tableau en ajoutant simplement les valeurs &agrave; ce tableau. 

     <informalexample>
      <programlisting role="php"> 
$a[] = "hello"; // $a[2] == "hello"
$a[] = "world"; // $a[3] == "world" 
      </programlisting>
     </informalexample></para>
    
    <para>
Un tableau peut &ecirc;tre tri&eacute; en utilisant les fonctions <function>asort</function>,
     <function>arsort</function>, <function>ksort</function>,
     <function>rsort</function>, <function>sort</function>,
     <function>uasort</function>, <function>usort</function>, ou
     <function>uksort</function> en fonction du type de classement que vous voulez.
</para>

    <para>
Vous pouvez compter le nombre d'&eacute;l&eacute;ments qu'il y a dans un tableau en utilisant la fonction <function>count</function>.
</para>

    <para>
Vous pouvez vous d&eacute;placer &agrave; l'int&eacute;rieur d'un tableau en utilisant les fonctions <function>next</function> et
      <function>prev</function>. Un autre moyen de se d&eacute;placer dans un tableau est d'utiliser la fonction <function>each</function>.
    </para>
   </sect2>

   <sect2 id="language.types.array.multi-dim">
    <title>Tableaux &agrave; plusieurs dimensions</title>

    <para>
Les tableaux &agrave; plusieurs dimensions sont extr&ecirc;mement simples. Pour chaque dimension du tableau, vous ajouter une nouvelle [clef] &agrave; la fin: 

     <informalexample>
      <programlisting role="php"> 
$a[1]      = $f;               # tableau &agrave; une dimension
$a["foo"]  = $f;   

$a[1][0]     = $f;             # tableau &agrave; deux dimensions
$a["foo"][2] = $f;             # (vous pouvez m&eacute;langer les indices associatifs et num&eacute;riques)
$a[3]["bar"] = $f;             # (vous pouvez m&eacute;langer les indices associatifs et num&eacute;riques)

$a["foo"][4]["bar"][0] = $f;   # tableau &agrave; quatre dimensions
      </programlisting>
     </informalexample></para>

    <para>
     En PHP3 il n'est pas possible de r&eacute;f&eacute;rencer un tableau 
&agrave; l'int&eacute;rieur d'une cha&icirc;ne. Par exemple, ceci ne fonctionne pas : 
     <informalexample>
      <programlisting role="php"> 
$a[3]['bar'] = 'Bob';
echo "Cela ne marche pas : $a[3][bar]";
      </programlisting>
     </informalexample>

     En PHP3, l'exemple ci dessu va afficher : <computeroutput>Cela ne marche pas : 
     Array[bar]</computeroutput>. L'op&eacute;rateur de concat&eacute;nation,
     peut &ecirc;tre utilis&eacute; pour corriger cela : 
	 
     <informalexample>
      <programlisting role="php">
$a[3]['bar'] = 'Bob';
echo "Cela ne marche pas : " . $a[3][bar];
      </programlisting>
     </informalexample>
	  
    </para>

    <para>
     En PHP4, cependant, le probl&egrave;me peut &ecirc;tre contourn&eacute; en entourant le tableau
par des accolades : 

     <informalexample>
      <programlisting role="php">
$a[3]['bar'] = 'Bob';
echo "Cela marche  : {$a[3][bar]}";
      </programlisting>
     </informalexample>
    </para>

    <para>
Vous pouvez remplir un tableau &agrave; plusieurs dimensions par de nombreux moyens mais la m&eacute;thode la plus simple &agrave; comprendre est l'utilisation de la fonction <function>array</function>. Les deux exemples suivants montre comment remplir un tableau &agrave; une dimension: 

     <informalexample>
      <programlisting role="php"> 
# Exemple 1:

$a["color"]	= "red";
$a["taste"]	= "sweet";
$a["shape"]	= "round";
$a["name"]	= "apple";
$a[3]		= 4;

# Exemple 2:
$a = array(
     "color" => "red",
     "taste" => "sweet",
     "shape" => "round",
     "name"  => "apple",
     3       => 4
);
      </programlisting>
     </informalexample></para>

    <para>
     La fonction <function>array</function> peut &ecirc;tre embo&icirc;t&eacute;e pour remplir un tableau &agrave; plusieurs dimensions : 

     <informalexample>
      <programlisting role="php"> 
&lt;?
$a = array(
     "apple"  => array(
          "color"  => "red",
          "taste"  => "sweet",
          "shape"  => "round"
     ),
     "orange"  => array(
          "color"  => "orange",
          "taste"  => "tart",
          "shape"  => "round"
     ),
     "banana"  => array(
          "color"  => "yellow",
          "taste"  => "paste-y",
          "shape"  => "banana-shaped"
     )
);

echo $a["apple"]["taste"];    # will output "sweet"
?>
      </programlisting>
     </informalexample></para></sect2></sect1>

  <sect1 id="language.types.object">
   <title>Les objets</title>

   <sect2 id="language.types.object.init">
    <title>Initialisation d'un objet</title>

    <para>
Pour initialiser un objet, vous devez utiliser la commande "new" afin de cr&eacute;er l’instance de l'objet. 

     <informalexample>
       <programlisting role="php">
class foo {
    function do_foo () { 
        echo "Doing foo."; 
    }
}

$bar = new foo;
$bar->do_foo();
      </programlisting>
     </informalexample>
    </para>
   </sect2>
  </sect1>

  <sect1 id="language.types.type-juggling">
   <title>D&eacute;finition du type</title>

   <simpara>
PHP ne n&eacute;cessite pas de d&eacute;claration explicite du type d'une variable. 
Le type d'une variable est d&eacute;termin&eacute; par le contexte d'utilisation. 
Par exemple, si vous assignez une cha&icirc;ne de caract&egrave;res &agrave; la variable <parameter>var</parameter>,
 var devient une cha&icirc;ne de caract&egrave;re. Si vous assignez un nombre entier &agrave; <parameter>var</parameter>,
 elle devient un entier. 
   </simpara>

   <para>
Un exemple de convertisseur automatique de type est l'op&eacute;rateur '+'. Si un des op&eacute;randes est de type double, alors tous les op&eacute;randes sont &eacute;valu&eacute;s comme des variables de type double et le r&eacute;sultat est de type double. Sinon, tous les op&eacute;randes sont &eacute;valu&eacute;s comme des variables de type entier et le r&eacute;sultat sera du type entier. Il est &agrave; noter que cela NE CHANGE PAS le type des op&eacute;randes. Le seul changement est la mani&egrave;re dont les op&eacute;randes sont &eacute;valu&eacute;es. 

    <informalexample>
     <programlisting role="php">
$foo = "0";  // $foo est une cha&icirc;ne de caract&egrave;res (ASCII 48)
$foo++;      // $foo est la cha&icirc;ne de caract&egrave;res "1" (ASCII 49)
$foo += 1;   // $foo est maintenant du type entier (2)
$foo = $foo + 1.3;  // $foo est maintenant du type double (3.3)
$foo = 5 + "10 Little Piggies"; // $foo est du type entier (15)
$foo = 5 + "10 Small Pigs";     // $foo est du type entier (15)
     </programlisting>
    </informalexample>
   </para>

   <simpara>
Si les deux derniers exemples vous semblent obscurs ou si vous voulez forcer une variable a &ecirc;tre &eacute;valu&eacute;e avec un certain type, reportez vous au paragraphe Conversion de type ci-dessous. Si vous voulez changer le type d'une variable, int&eacute;ressez vous &agrave; la fonction 
<link linkend="language.types.string.conversion">Conversion de cha&icirc;nes</link>.
   </simpara>

   <simpara>
	Si vous voulez forcer le type d'une variable, vous pouvez
vous reporter &agrave; la section <link linkend="language.types.typecasting">Transtypage
</link>. SI vous voulez changer le type d'une variable, utilisez <function>settype</function>.
   </simpara>

   <para>
    If you would like to test any of the examples in this section, you
    can cut and paste the examples and insert the following line to
    see for yourself what's going on:
    <informalexample>
     <programlisting role="php">
echo "\$foo==$foo; type is " . gettype( $foo ) . "&lt;br&gt;\n";
     </programlisting>
    </informalexample>
   </para>


   <note>
    <para>
     The behaviour of an automatic conversion to array is currently
     undefined.
	 
     <informalexample>
      <programlisting role="php">
$a = 1;       // $a is an integer
$a[0] = "f";  // $a becomes an array, with $a[0] holding "f"
      </programlisting>
     </informalexample>
    </para>

    <para>
     While the above example may seem like it should clearly result in
     $a becoming an array, the first element of which is 'f', consider
     this:

     <informalexample>
      <programlisting role="php">
$a = "1";     // $a is a string
$a[0] = "f";  // What about string offsets? What happens?
      </programlisting>
     </informalexample>
    </para>

    <para>
     Since PHP supports indexing into strings via offsets using the
     same syntax as array indexing, the example above leads to a
     problem: should $a become an array with its first element being
     "f", or should "f" become the first character of the string $a?
    </para>

    <para>
     For this reason, as of PHP 3.0.12 and PHP 4.0b3-RC4, the result
     of this automatic conversion is considered to be undefined. Fixes
     are, however, being discussed.
    </para>
   </note>

   <sect2 id="language.types.typecasting">
    <title>Transtypage</title>

    <para>
La conversion de type en PHP fonctionne de la m&ecirc;me mani&egrave;re qu'en C: le nom du type d&eacute;sir&eacute; est &eacute;crit entre parenth&egrave;ses devant la variable &agrave; transtyper ("cast"). 

     <informalexample>
      <programlisting role="php">
$foo = 10;   // $foo is an integer
$bar = (double) $foo;   // $bar est un double
      </programlisting>
     </informalexample></para>
    
    <para>
     Les conversions autoris&eacute;es sont: 
     <itemizedlist>
      <listitem>
       <simpara>(int), (integer) - type entier</simpara>
      </listitem>
      <listitem>
       <simpara>(real), (double), (float) - type double</simpara>
      </listitem>
      <listitem>
       <simpara>(string) - ctype cha&icirc;ne</simpara>
      </listitem>
      <listitem>
       <simpara>(array) - type tableau</simpara>
      </listitem>
      <listitem>
       <simpara>(object) - type objet</simpara>
      </listitem>
     </itemizedlist>
    </para>

    <para>
Il est &agrave; noter que les tabulations et les espaces sont autoris&eacute;s &agrave; l'int&eacute;rieur des parenth&egrave;ses, donc les lignes suivantes sont &eacute;quivalentes: 

     <informalexample>
      <programlisting role="php">
$foo = (int) $bar;
$foo = ( int ) $bar;
      </programlisting>
     </informalexample>
    </para>

    <para>
Le transtypage n'a pas toujours le r&eacute;sultat attendu. Par exemple :
    </para>

    <para>
	Lorsque vous transtypez un scalaire ou une cha&icirc;ne en tableau,
la variable verra son contenu affect&eacute; au premier &eacute;l&eacute;ment du tableau.
     <informalexample>
      <programlisting role="php">
$var = 'ciao';
$arr = (array) $var;
echo $arr[0];  // outputs 'ciao'  
      </programlisting>
     </informalexample>
    </para>

    <para>
     Lorsque vous transtypez un scalaire ou une cha&icirc;ne en objet, la valeur de
la variable sera transform&eacute;e en attribut de l'objet : 
l'attribut s'appellera 'scalar':
     <informalexample>
      <programlisting role="php">
$var = 'ciao';
$obj = (object) $var;
echo $obj-&gt;scalar;  // outputs 'ciao'
      </programlisting>
     </informalexample>
    </para>

   </sect2>
  </sect1>

 </chapter>
 
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
