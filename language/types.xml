<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.75 $ -->
<!-- EN-Revision: 1.154 Maintainer: dams Status: ready -->
<chapter id="language.types">
 <title>Les types</title>

 <sect1 id="language.types.intro">
  &reftitle.intro;

  <simpara>
   &php; supporte les huit types basiques suivants :
  </simpara>

  <para>
   &php; supporte quatre types scalaires :

   <itemizedlist>

    <listitem>
     <simpara>
      &boolean;
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      &integer;
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      &float;
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      &string;
     </simpara>
    </listitem>

   </itemizedlist>

   &php; supporte deux types composés :

   <itemizedlist>

    <listitem>
     <simpara>
      &array;
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      &object;
     </simpara>
    </listitem>

   </itemizedlist>

   &php; supporte deux types spéciaux :

   <itemizedlist>

    <listitem>
     <simpara>
      &resource;
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      &null;
     </simpara>
    </listitem>

   </itemizedlist>

   Ce manuel introduit également quelques
   <link linkend="language.pseudo-types">pseudo-types</link>
   pour des raisons de lisibilités :

   <itemizedlist>

    <listitem>
     <simpara>
      <type>mixed</type>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <type>nombre</type>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <type>callback</type>
     </simpara>
    </listitem>

   </itemizedlist>
   Vous pouvez également trouver quelques références au type "double".
   Considérez le type "double" comme le type "float" (nombres décimaux), les deux noms
   existent uniquement pour des raisons historiques.
  </para>

  <simpara>
   Habituellement, le type d'une variable n'est pas déclaré
   par le programmeur. Il est décidé au moment de
   l'exécution par &php;, en fonction du contexte dans
   lequel la variable est utilisée.
  </simpara>
  <note>
   <simpara>
    Si vous voulez vérifier le type et la valeur d'une variable
    ou d'une <link linkend="language.expressions">expression</link>, utilisez
    la fonction <function>var_dump</function>.
   </simpara>
   <para>
    Si vous souhaitez simplement une représentation lisible pour du débogage,
    utilisez la fonction <function>gettype</function>. Pour vérifier la présence
    de certains types, <emphasis>n'utilisez pas</emphasis>
    <function>gettype</function>, mais plutôt les fonctions
    <literal>is_<replaceable>type</replaceable></literal>.
    Par exemple :
    <example>
     <title>Exemples de vérification de type de variable</title>
     <programlisting role="php">
<![CDATA[
<?php
$bool = TRUE;   // un booléen
$str  = 'foo';  // une chaîne de caractères
$int  = 12;     // un entier

echo gettype($bool); // affiche "boolean"
echo gettype($str);  // affiche "string"

// Ceci est un entier, on l'incrémente de 4
if (is_int($int)) {
    $int += 4;
}

// Si $bool est une chaîne, l'afficher
// (Ne pas imprimer n'importe quoi).
if (is_string($bool)) {
    echo 'Chaîne : ' . $bool;
}
?>
]]>
     </programlisting>
    </example>
   </para>
  </note>
  <simpara>
   Si vous voulez forcer une variable à être convertie
   en un certain type, vous devez transtyper
   (<link linkend="language.types.typecasting">cast</link>) la
   variable ou utiliser la fonction <function>settype</function>.
  </simpara>
  <simpara>
   Il est à noter qu'une variable peut se comporter de
   manière différente suivant les situations, en
   fonction du type qui lui est affectée.
   Pour plus d'informations, voir le paragraphe sur le
   <link linkend="language.types.type-juggling">transtypage</link>.
   Vous pouvez également être intéressé par la
   <link linkend="types.comparisons">table de comparaison des types</link>,
   qui vous montrent des exemples variés concernant les relations de 
   comparaisons des types.
  </simpara>
 </sect1>

 <sect1 id="language.types.boolean">
  <title>Booléens</title>

  <simpara>
   C'est le type le plus simple. Un &boolean; exprime une valeur de
   vérité. Il peut prendre comme valeur soit &true; soit &false;.
  </simpara>

  <note>
   <simpara>
    Le type &boolean; a été introduit en &php; 4.
   </simpara>
  </note>

  <sect2 id="language.types.boolean.syntax">
   <title>Syntaxe</title>
   <para>
    Vous pouvez utiliser les mots-clés '&true;' et
    '&false;' pour spécifier une valeur de type
    &boolean;. Ces mots-clés sont insensibles
    à la casse.
    <example>
     <title>Utilisation des mots-clés &true; et &false;</title>
     <programlisting role="php">
<![CDATA[
<?php
$foo = True; // assigne la valeur TRUE à la variable $foo
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Généralement, vous les créerez
    avec un des <link linkend="language.operators">opérateurs</link>
    qui retourne une valeur <type>bool</type>, pour les passer
    à une <link linkend="language.control-structures">structure de
    contrôle</link>.
    <example>
     <title>
      Utilisation des constantes &true; et &false; avec une structure de
      contrôle
     </title>
     <programlisting role="php">
<![CDATA[
<?php
// == est un opérateur d'égalité
// qui retourne un booléen
if ($action == 'show_version') {
    echo 'La version est la 1.23';
}

// Ceci n'est pas nécessaire
if ($show_separators == TRUE) {
    echo "<hr />\n";
}

// car vous pouvez simplement utiliser
if ($show_separators) {
    echo "<hr />\n";
}
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect2>

  <sect2 id="language.types.boolean.casting">
   <title>Conversion en &boolean;</title>
   <simpara>
    Pour explicitement convertir une valeur en &boolean;, utilisez les
    opérateurs de transtypage <literal>(bool)</literal> ou
    <literal>(boolean)</literal>.
    Cependant, dans la plupart des cas, vous n'avez pas besoin d'utiliser
    ces opérateurs de transtypage, car une valeur sera automatiquement
    convertie si un opérateur, une fonction ou une structure de contrôle
    requièrent un argument de type &boolean;.
   </simpara>
   <simpara>
    Voir aussi le chapitre <link linkend="language.types.type-juggling">
    Définition du type</link>.
   </simpara>

   <para>
    Lors des conversions de valeurs de type <type>bool</type>, les valeurs
    suivantes sont considérées comme fausses (&false;) :

    <itemizedlist>
     <listitem>
      <simpara>
       Le &boolean; &false; lui-même
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       L'&integer; 0 (zéro)
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       La &string; 0.0 (zéro)
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       La &string; vide et la &string; "0"
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Le &array; vide (aucun élément)
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       L'&object; vide (aucun élément) (&php; 4 uniquement)
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Le type spécial &null;
      </simpara>
     </listitem>
    </itemizedlist>
    Toutes les autres valeurs sont considérées comme vraies (&true;) (y compris
    les &resource;s).
    <warning>
     <simpara>
      <literal>-1</literal> est considéré comme vrai, tout comme
      les nombres autres que zéro (aussi bien positifs que négatifs) !
     </simpara>
    </warning>

    <example>
     <title>Conversion en &boolean;</title>
     <programlisting role="php">
<![CDATA[
<?php
var_dump((bool) "");        // bool(false)
var_dump((bool) 1);         // bool(true)
var_dump((bool) -2);        // bool(true)
var_dump((bool) "foo");     // bool(true)
var_dump((bool) 2.3e5);     // bool(true)
var_dump((bool) array(12)); // bool(true)
var_dump((bool) array());   // bool(false)
var_dump((bool) "false");   // bool(true)
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect2>
 </sect1>

 <sect1 id="language.types.integer">
  <title>Entiers</title>

  <simpara>
   Un entier est un nombre de l'ensemble des entiers naturels Z :
   <literal>Z = {...., -2, -1, 0, 1, 2, ...}</literal>.
  </simpara>

  <para>
   Voir aussi :
   <link linkend="ref.gmp">Longueur arbitraire des entiers / GMP</link>,
   les &float; et les
   <link linkend="ref.bc">précisions arbitraires / BCMath</link>.
  </para>

  <sect2 id="language.types.integer.syntax">
   <title>Syntaxe</title>
   <simpara>
    Les entiers peuvent être spécifiés en base décimale (dite aussi
    base 10), en hexadécimale (base 16) ou octale (base 8).
    Les entiers peuvent être optionnellement précédés par le signe
    plus ou moins (- ou +).
   </simpara>

   <para>
    Pour utiliser la notation octale, vous devez préfixer le nombre avec
    un zéro; pour utiliser la notation hexadécimale, vous devez
    préfixer le nombre avec <literal>0x</literal>.
    <example>
     <title>Notations entières</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 1234; // nombre entier en base 10
$a = -123; // nombre entier négatif
$a = 0123; // nombre entier en base 8, octale (équivalent à 83 en base 10)
$a = 0x1A; // nombre entier en base 16, hexadécimale
           // (équivalent à 26 en base 10)
?>
]]>
     </programlisting>
    </example>
    Techniquement, la structure d'un entier suit les règles suivantes :
    <example>
     <title>Structure d'un entier</title>
     <programlisting>
<![CDATA[
decimal     : [1-9][0-9]*
            | 0

hexadecimal : 0[xX][0-9a-fA-F]+

octal       : 0[0-7]+

integer     : [+-]?decimal
            | [+-]?hexadecimal
            | [+-]?octal
]]>
     </programlisting>
    </example>
    La taille des entiers dépend de la plate-forme de support, mais
    la valeur maximale est généralement de 2 milliards et des
    poussières (c'est un entier signé de 32 bits). &php; ne supporte
    pas les entiers non signés.
   </para>
   <warning>
    <para>
     Si un caractère invalide est utilisé dans un entier octal
     (par exemple, 8 ou 9), le reste du nombre est ignoré.
     <example>
      <title>Interprétation des nombres octaux</title>
      <programlisting role="php">
<![CDATA[
<?php
var_dump(01090); // 010 octal = 8 decimal
?>
]]>
      </programlisting>
     </example>
    </para>
   </warning>
  </sect2>

  <sect2 id="language.types.integer.overflow">
   <title>Dépassement de capacité des entiers</title>
   <para>
    Si un nombre est hors de l'intervalle de validité
    des entiers, il sera interprété comme un <type>float</type>.
    De même, si vous effectuez une opération qui retourne un nombre
    hors de l'intervalle de validité des entiers, un <type>float</type>
    sera retourné.
    <example>
     <title>Dépassement de capacité des entiers</title>
     <programlisting role="php">
<![CDATA[
<?php
$large_number =  2147483647;
var_dump($large_number);
// affiche : int(2147483647)

$large_number =  2147483648;
var_dump($large_number);
// affiche : float(2147483648)

// cette méthode ne convient pas pour les entiers hexadécimaux :
var_dump( 0x100000000 );
// affiche : int(2147483647)

$million = 1000000;
$large_number =  50000 * $million;
var_dump($large_number);
// affiche : float(50000000000)
?>
]]>
     </programlisting>
    </example>
    <warning>
     <simpara>
      Malheureusement, il y a un bogue dans le moteur (corrigé en 4.1.0),
      qui fait que &php; ne fonctionne pas toujours bien lorsque des nombres
      négatifs sont utilisés. Lorsque les deux opérandes
      sont positifs, il n'y a pas de problèmes. Par exemple :
      <literal>-50000 * $million</literal>, conduit à
      <literal>-429496728</literal>. Cependant, lorsque les deux opérateurs
      sont positifs, il n'y a aucun problème.
     </simpara>
     <simpara>
      Ceci a été résolu en &php; 4.1.0.
     </simpara>
    </warning>
   </para>
   <para>
    Il n'existe pas de division entière en &php;.
    <literal>1/2</literal> générera le <type>float</type>
    <literal>0.5</literal>. Vous pouvez forcer la valeur
    au format entier pour faire l'arrondi ou bien utiliser
    la fonction <function>round</function>.
    <example>
     <title>Divisions entières</title>
     <programlisting role="php">
<![CDATA[
<?php
var_dump(25/7); // float(3.5714285714286)
var_dump((int) (25/7)); // int(3)
var_dump(round(25/7)); // float(4)
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect2>

  <sect2 id="language.types.integer.casting">
   <title>Conversion en entiers</title>
   <simpara>
    Pour explicitement convertir une valeur en &integer;,
    utilisez les opérateurs de transtypage <literal>(int)</literal>
    ou <literal>(integer)</literal>. Cependant, dans la plupart des
    situations, vous n'en aurez pas besoin, car une valeur sera
    automatiquement convertie si un opérateur, une fonction ou tout
    autre élément du langage requiert un <type>entier</type>.
    Vous pouvez également convertir une valeur en entier avec la fonction
    <function>intval</function>.
   </simpara>
   <simpara>
    Voir aussi la section sur les
    <link linkend="language.types.type-juggling">définitions de types</link>.
   </simpara>

   <sect3 id="language.types.integer.casting.from-boolean">
    <title>Depuis un &boolean;</title>
    <simpara>
     &false; devient 0 (zéro), et &true; devient 1 (un).
    </simpara>
   </sect3>

   <sect3 id="language.types.integer.casting.from-float">
    <title>Depuis un &float;</title>
    <simpara>
     Lors de conversion entre un nombre décimal et
     un entier, le nombre sera arrondi à la valeur inférieure
     s'il est positif, et supérieure s'il est négatif
     (conversion dite 'vers zéro').
    </simpara>

    <para>
     Si le nombre est hors de l'intervalle de validité
     des entiers, (généralement
     <literal>+/- 2.15e+9 = 2^31</literal>),
     le résultat est indéfini, car les nombres à
     virgule flottante n'ont pas assez de précision pour fournir une
     valeur exacte pour un entier.
     Aucune alerte, même pas le plus petit message ne
     sera affiché dans ce cas !
    </para>

    <warning>
     <para>
      Ne transformez jamais une fraction inconnue en entier, car cela
      peut conduire à des résultats irrationnels.
      <example>
       <title>Attention aux erreurs de fractions</title>
       <programlisting role="php">
<![CDATA[
<?php
  echo (int) ( (0.1+0.7) * 10 );
// affiche 7!
?>
]]>
       </programlisting>
      </example>
      Pour plus d'informations, reportez-vous aux
      <link linkend="warn.float-precision">alertes</link> liées
      aux nombres décimaux.
     </para>
    </warning>
   </sect3>

   <sect3 id="language.types.integer.casting.from-string">
    <title>A partir de chaînes de caractères</title>
    <simpara>
     Reportez-vous à la section des
     <link linkend="language.types.string.conversion">conversions de
     chaînes</link>.
    </simpara>
   </sect3>

   <sect3 id="language.types.integer.casting.from-other">
    <title>Conversion d'autres types</title>
    <para>
     La conversion d'autres types en entier est indéfinie.
     En fait, &php; convertit d'abord la valeur en
     &boolean;.
     <caution>
      <simpara>
       Le comportement de la conversion en un entier est indéfini
       pour les autres types. En fait, le comportement est le même
       que si la valeur a d'abord été
       <link linkend="language.types.boolean.casting">convertie en
       booléen</link>. Cependant, <emphasis>ne vous fiez pas</emphasis> à ce
       comportement car il peut changer à tout moment.
      </simpara>
     </caution>
    </para>
   </sect3>
  </sect2>
 </sect1>

 <sect1 id="language.types.float">
  <title>Les nombres décimaux</title>
  <para>
   Les nombres décimaux (connus aussi sous le
   vocable de "<literal>double</literal>", "<literal>float</literal>" ou
   "<literal>nombre réels</literal>") peuvent être
   spécifiés en utilisant la syntaxe suivante :
   <example>
    <title>Exemple de nombres décimaux</title>
    <programlisting role="php">
<![CDATA[
<?php
$a = 1.234;
$b = 1.2e3;
$c = 7E-10;
?>
]]>
    </programlisting>
    <para>
     Formellement :
    </para>
    <programlisting role="php">
<![CDATA[
LNUM          [0-9]+
DNUM          ([0-9]*[\.]{LNUM}) | ({LNUM}[\.][0-9]*)
EXPONENT_DNUM ( ({LNUM} | {DNUM}) [eE][+-]? {LNUM})
]]>
    </programlisting>
    <para>
     La taille des nombres décimaux dépend de la plate-forme.
     Un maximum de ~1.8e308 avec une précision de 14 décimales
     est une configuration répandue : c'est le format 64 bits IEEE.
    </para>
   </example>
  </para>

  <warning id="warn.float-precision">
   <title>Précision des nombres décimaux</title>
   <para>
    Il est fréquent que de simples fractions décimales telles que
    <literal>0.1</literal> ou <literal>0.7</literal> ne puissent
    être converties au format interne binaire sans une légère perte
    de précision. Cela peut conduire à des résultats étonnants :
    par exemple, <literal>floor((0.1+0.7)*10)</literal> retournera
    <literal>7</literal> au lieu de <literal>8</literal>
    car le résultat de la représentation interne est
    <literal>7.9999999999...</literal>.
   </para>
   <para>
    Tout ceci est lié au fait qu'il est impossible d'exprimer
    certaines fractions en un nombre fini de chiffres. Par exemple
    <literal>1/3</literal> s'écrira <literal>0.3333333...</literal>
    en mode décimal.
   </para>
   <para>
    Ne faites donc jamais confiance aux nombres à virgule
    jusqu'à leur dernière décimale et ne comparez
    jamais ces nombres avec l'opérateur d'égalité.
    Si vous avez besoin d'une précision particulière,
    reportez-vous au traitement des nombres de grande taille avec les
    bibliothèques <link linkend="ref.bc">BC</link> ou <link linkend="ref.gmp">GMP</link>.
   </para>
  </warning>

  <sect2 id="language.types.float.casting">
   <title>Conversion d'un nombre décimal</title>

   <para>
    Pour savoir quand et comment des chaînes sont converties en
    nombres à virgules flottantes, voyez la section
    "<link linkend="language.types.string.conversion">Conversion de chaînes de caractères</link>".
    Pour les valeurs d'autres types, la conversion est la même
    que si la valeur était d'abord convertie en entier, puis en
    nombre décimal.
    Voyez la section "<link linkend="language.types.integer.casting">Conversion d'un entier"</link>.
    Depuis &php; 5, une alerte est affichée si vous convertissez un 
    objet en nombre décimal.
   </para>
  </sect2>
 </sect1>

 <sect1 id="language.types.string">
  <title>Les chaînes de caractères</title>
  <para>
   Les chaînes de caractères sont des séquences de caractères.
   En &php;, un caractère est un octet et il y en 256 de possibles.
   &php; n'a pas (encore?) de support natif d'Unicode. Voir les fonctions
   <function>utf8_encode</function>
   et <function>utf8_decode</function> pour un support Unicode.
  </para>

  <note>
   <simpara>
    La taille n'est pas un problème majeur pour une chaîne.
    Elle peut devenir très grande sans problème. Il n'y a
    pas à s'en faire pour cela.
   </simpara>
  </note>

  <sect2 id="language.types.string.syntax">
   <title>Syntaxe</title>
   <para>
    Une chaîne peut être spécifiée de trois manières
    différentes :
    <itemizedlist>

     <listitem>
      <simpara>
       <link linkend="language.types.string.syntax.single">guillemets simples</link>
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       <link linkend="language.types.string.syntax.double">guillemets doubles</link>
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       <link linkend="language.types.string.syntax.heredoc">syntaxe
       <literal>HereDoc</literal></link>
      </simpara>
     </listitem>

    </itemizedlist>
   </para>

   <sect3 id="language.types.string.syntax.single">
    <title>Guillemets simples</title>
    <para>
     Le moyen le plus simple de spécifier une &string;
     est d'utiliser les guillemets simples : <literal>'</literal>.
    </para>
    <para>
     Pour spécifier un guillemet simple littéral, vous devez
     l'échapper avec un anti-slash (<literal>\</literal>), comme dans de nombreux
     langages. Si un anti-slash doit apparaître dans votre chaîne ou bien
     en fin de chaîne, il faudra le doubler. Notez que si vous essayez d'échapper n'importe
     quel autre caractère, l'anti-slash sera conservé! Il n'y a pas
     besoin d'échapper d'autres caractères que le guillemet lui-même.
     <note>
      <simpara>
       En &php; 3, une alerte sera affichée si cela arrive avec un
       niveau de rapport d'erreur de <literal>E_NOTICE</literal>.
      </simpara>
     </note>
     <note>
      <simpara>
       Contrairement aux autres syntaxes, les <link
       linkend="language.variables">variables</link> présentes dans la
       chaîne ne seront <emphasis>PAS</emphasis> remplacées par leurs
       valeurs.
      </simpara>
     </note>
     <example>
      <title>Exemples d'interpolation des chaînes de caractères</title>
      <programlisting role="php">
<![CDATA[
<?php
echo 'Ceci est une chaîne simple';

echo 'Vous pouvez inclure des nouvelles
lignes dans une chaîne,
comme ceci.';

echo 'Arnold a coutume de dire : "I\'ll be back"';
// affiche : "I'll be back"

echo 'Êtes-vous sûr de vouloir effacer le dossier C:\\*.*?';
// affiche : Êtes-vous sûr de vouloir effacer le dossier C:\*.*?

echo 'Êtes-vous sûr de vouloir effacer le dossier C:\*.*?';
// affiche : Êtes-vous sûr de vouloir effacer le dossier C:\*.*?

echo 'Je suis en train de mettre une nouvelle ligne comme ceci : \n';
// affiche : Je suis en train de mettre une nouvelle ligne comme ceci : \n

echo 'Les variables ne seront pas $afficher $ici';
// affiche : Les variable ne seront pas $afficher $ici
?>
]]>
      </programlisting>
     </example>
    </para>
   </sect3>

   <sect3 id="language.types.string.syntax.double">
    <title>Guillemets doubles</title>
    <para>
     Si la chaîne est entourée de guillemets doubles (<literal>"</literal>), &php;
     va comprendre certaines séquences de caractères :
    </para>
    <table>
     <title>Les caractères spéciaux</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Séquence</entry>
        <entry>Valeur</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>\n</literal></entry>
        <entry>Nouvelle ligne (<literal>linefeed</literal>, LF ou 0x0A (10) en ASCII)</entry>
       </row>
       <row>
        <entry><literal>\r</literal></entry>
        <entry>Retour à la ligne (<literal>carriage return</literal>, CR ou 0x0D (13)
        en ASCII)</entry>
       </row>
       <row>
        <entry><literal>\t</literal></entry>
        <entry>Tabulation horizontale (HT ou 0x09 (9) en ASCII)</entry>
       </row>
       <row>
        <entry><literal>\\</literal></entry>
        <entry>Anti-slash</entry>
       </row>
       <row>
        <entry><literal>\$</literal></entry>
        <entry>Caractère $</entry>
       </row>
       <row>
        <entry><literal>\"</literal></entry>
        <entry>Guillemets doubles</entry>
       </row>
       <row>
        <entry><literal>\[0-7]{1,3}</literal></entry>
        <entry>
         Une séquence de caractères qui permet de
         rechercher un nombre en notation octale.
        </entry>
       </row>
       <row>
        <entry><literal>\x[0-9A-Fa-f]{1,2}</literal></entry>
        <entry>
         Une séquence de caractères qui permet de
         rechercher un nombre en notation hexadécimale.
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   <para>
    Si vous essayez d'utiliser l'anti-slash sur n'importe quelle
    autre séquence, l'anti-slash sera affiché dans votre chaîne.
   </para>
   <para>
    Le plus important pour les chaînes à guillemets doubles est le fait
    que les variables qui s'y trouvent seront remplacées par leur valeur.
    Voir la section sur le <link linkend="language.types.string.parsing">traitement des
    variables dans les chaînes</link> pour plus de détails.
   </para>
  </sect3>

  <sect3 id="language.types.string.syntax.heredoc">
   <title>Syntaxe <literal>Heredoc</literal></title>
   <simpara>
    Un autre moyen de délimiter les chaînes est d'utiliser
    la syntaxe dite "<literal>Heredoc</literal>"
    (en français, documentation ici): &lt;&lt;&lt;,
    suivi d'un identifiant arbitraire, puis de la chaîne,
    puis l'identifiant initial pour terminer la séquence.
   </simpara>
   <simpara>
    L'identifiant fermant <emphasis>doit</emphasis> commencer
    à la première colonne de la ligne.
    L'identifiant utilisé doit suivre les mêmes règles que les étiquettes 
    &php; : il ne doit contenir uniquement que des caractères alpha-numériques,
    et des soulignés ("_"), et enfin, commencer par un
    caractère alphabétique ou un souligné.
   </simpara>

   <warning>
    <simpara>
     Il est très important de noter que la ligne qui contient
     l'identifiant de fermeture ne doit contenir aucun autre
     caractère, hormis, éventuellement, un point-virgule (<literal>;</literal>).
     Cela signifie notamment que l'identifiant <emphasis>ne doit
     pas être indenté</emphasis> et qu'il n'y a aucun caractère
     d'espacement ou de tabulation avant ou après le point virgule.
     Il est également important de noter que le premier caractères
     avant l'identifiant de fermeture doit être une nouvelle ligne,
     tel que définie par votre système. Par exemple, ce sera
     <literal>\r</literal> sous Macintosh.
    </simpara>
    <simpara>
     Si cette règle n'est pas respectée et que l'identifiant de fermeture
     n'est pas correct, alors, il ne sera pas considéré comme un
     identifiant fermant et &php; continuera d'en chercher un.
     Si dans ce cas aucun identifiant de fermeture n'est trouvé,
     une erreur d'analyse sera émise, contenant comme numéro de ligne
     la fin du script.
    </simpara>
    <para>
     Il n'est pas autorisé d'utiliser la syntaxe "<literal>Heredoc</literal>"
     lors de l'initialisation des membres d'une classe.
     Utilisez une autre syntaxe pour les chaînes à la place.
     <example>
      <title>Exemple incorrect</title>
      <programlisting role="php">
<![CDATA[
<?php
class foo {
  public $bar = <<<EOT
bar
EOT;
}
?>
]]>
      </programlisting>
     </example>
    </para>
   </warning>

   <para>
    La syntaxe <literal>Heredoc</literal> se comporte exactement comme une chaîne à
    guillemets doubles, sans les guillemets doubles. Cela signifie
    que vous n'avez pas à échapper les guillemets (simples ou doubles)
    dans cette syntaxe. Les variables sont remplacées par leur valeur et
    le même soin doit leur être apporté que dans les chaînes
    à guillemets doubles.
    <example>
     <title>Exemple de chaîne <literal>HereDoc</literal></title>
     <programlisting role="php">
<![CDATA[
<?php
$str = <<<EOD
  Exemple de chaîne
  s'étalant sur
  plusieurs lignes
  avec la syntaxe heredoc
EOD;

/* Exemple plus complexe, avec des variables. */
class foo {
    var $foo;
    var $bar;
    function foo() {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'MonNom';

echo <<<EOT
  Mon nom est "$name". J'affiche des $foo->foo.
  Maintenant, j'affiche un {$foo->bar[1]}.
  Ceci se traduit par un 'A' majuscule : \x41
EOT;
?>
]]>
     </programlisting>
    </example>
   </para>

   <note>
    <para>
     Le support <literal>Here doc</literal> a été ajouté en &php; 4.
    </para>
   </note>

   </sect3>

   <sect3 id="language.types.string.parsing">
     <title>Traitement des variables dans les chaînes</title>
     <simpara>
      Lorsqu'une chaîne est spécifiée avec des guillemets doubles
      ou en utilisant la syntaxe <literal>heredoc</literal>,
      les variables qu'elle contient sont remplacées par leur valeur.
     </simpara>
     <simpara>
      Il y a deux types de syntaxe, une
      <link linkend="language.types.string.parsing.simple">simple</link>
      et une
      <link linkend="language.types.string.parsing.complex">complexe</link>.
      La syntaxe simple est la plus courante et la plus pratique : elle fournit
      un moyen d'utiliser les variables, que ce soient des chaînes, des tableaux
      ou des membres d'objets.
     </simpara>
     <simpara>
      La syntaxe complexe a été introduite en &php; 4
      et peut être reconnue grâce aux accolades entourant les expressions.
     </simpara>

     <sect4 id="language.types.string.parsing.simple">
      <title>Syntaxe simple</title>
      <simpara>
       Dès qu'un signe dollar <literal>$</literal> est rencontré, l'analyseur
       &php; va lire autant de caractères qu'il peut pour former un nom de
       variable valide. Entourez le nom de la variable avec des accolades
       pour indiquer explicitement son nom.
      </simpara>
      <example>
       <title>Utilisation des accolades <literal>{}</literal> dans les chaînes</title>
       <programlisting role="php">
 <![CDATA[
<?php
$boisson = 'vin';
echo "Du $boisson, du pain et du fromage!";
 // Correct, car "," n'est pas autorisé dans les noms de variables

echo 'Il a goûté plusieurs ' . $boissons;
 // Pas correct, car 's' peut faire partie d'un nom de variable, et PHP recherchera alors $boissons

echo "Il a goûté plusieurs ${boisson}s";
 // Correct
?>
]]>
       </programlisting>
      </example>
      <simpara>
       De la même façon, vous pouvez utiliser un élément
       de tableau ou un membre d'objet. Pour les éléments
       de tableau, le crochet fermant '<literal>]</literal>'
       marquera la fin du nom de la variable. Pour les
       membres d'objets, les mêmes règles que ci-dessus
       s'appliquent. Cependant, il n'existe pas d'astuce comme cela
       pour les variables simples.
      </simpara>
      <example>
       <title>Utilisation des accolades <literal>{}</literal> dans les chaînes pour les tableaux</title>
       <programlisting role="php">
<![CDATA[
<?php
// Ces exemples sont spécifiques à l'utilisation de tableaux dans une chaîne.
// Lorsque vous êtes hors d'une chaîne, utilisez toujours des guillemets
// autour des index de tableau, et n'utilisez pas d'{accolades}.

// Affichons toutes les erreurs
error_reporting(E_ALL);

$fruits = array('fraise' => 'rouge', 'banane' => 'jaune');

// Fonctionne mais notez que cela fonctionne pas comme
// si cela était hors d'une chaîne
echo "Une banane est $fruits[banane].";

// Fonctionne
echo "Une banane est {$fruits['banane']}.";

// Fonctionne mais PHP cherche une constante appelée banane
// tel que décrit ci-dessous
echo "Une banane est {$fruits[banane]}.";

// Ne fonctionne pas, il manque les accolades. Cela donne une erreur d'analyse
echo "Une banane est  $fruits['banane'].";

// Fonctionne
echo "Une banane est " . $fruits['banane'] . ".";

// Fonctionne
echo "Ce carré a un coté de $square->width mètres de large.";

// Ne fonctionne pas. Pour une solution, voyez la syntaxe complexe.
echo "Ce carré a un coté de $square->width00 centimètres.";
?>
]]>
       </programlisting>
      </example>
      <simpara>
       Pour tout ce qui sera plus compliqué, voyez la syntaxe complexe.
      </simpara>
     </sect4>

     <sect4 id="language.types.string.parsing.complex">
      <title>Syntaxe complexe</title>
      <simpara>
       La syntaxe est dite "complexe" car elle permet l'utilisation d'
       expressions complexes et non pas parce qu'elle serait obscure.
     </simpara>
     <simpara>
      En fait, vous pouvez inclure n'importe quelle valeur qui est
      dans l'espace de nom avec cette syntaxe. Il suffit d'écrire une
      expression exactement comme si elle était hors de la chaîne,
      puis de l'entourer d'accolades <literal>{}</literal>. Puisque
      vous ne pouvez pas échapper les accolades, cette syntaxe ne commence
      qu'à partir du signe dollar, qui suit immédiatement l'accolade
      ouvrante. Vous pouvez utiliser <literal>"{\$"</literal> ou
      <literal>"\{$"</literal> pour obtenir un <literal>"{$"</literal> littéral.
      Voici quelques exemples :
     </simpara>
     <example>
     <title>Syntaxe complexe de chaîne</title>
      <programlisting role="php">
<![CDATA[
<?php
// Affichons toutes les erreurs
error_reporting(E_ALL);

$super = 'fantastique';

// Ne fonctionne pas. Affiche : Ceci est { fantastique}
echo "Ceci est { $super}";

// Fonctionne. Affiche Ceci est fantastique
echo "This is {$super}";
echo "This is ${super}";

// Fonctionne
echo "Ce carré a un coté de {$square->width}00 centimètres.";

// Fonctionne
echo "Ceci fonctionne : {$arr[4][3]}";

// Ceci est faut pour la même raison que $foo[bar] est faux
// hors d'une chaîne. En d'autres terme, cela va fonctionne
// car PHP recherche d'abord une constante appelée foo, mais
// il générera une note E_NOTICE (undefined constant).
echo "Ceci est faux : {$arr[foo][3]}";

// Fonctionne. Lorsque vous utilisez un tableau multidimensionnel dans
// une chaîne, n'oubliez jamais les accolades.
echo "Ceci fonctionne : {$arr['foo'][3]}";

// Fonctionne
echo "Ceci fonctionne : " . $arr['foo'][3];

echo "Vous pouvez même écrire {$obj->values[3]->name}";

echo "Ceci est une valeur de variable variable : {${$name}}";
?>
]]>
       </programlisting>
      </example>
     </sect4>
    </sect3>

    <sect3 id="language.types.string.substr">
     <title>Accès et modification des caractères d'une chaîne</title>
     <para>
      Les caractères d'une chaîne sont accessibles et modifiables en spécifiant
      leur offset (le premier caractère est d'offset 0) entre
      accolade, après le nom de la variable.
     </para>
     <note>
      <simpara>
       Pour assurer la compatibilité ascendante, vous pouvez
       toujours accéder aux caractères avec des crochets.
       Mais cette syntaxe est obsolète en &php; 4.
      </simpara>
     </note>
     <para>
      <example>
       <title>Exemples de chaînes</title>
       <programlisting role="php">
<![CDATA[
<?php
// Lit le premier caractère de la chaîne
$str = 'Ceci est un test.';
$first = $str{0};

// Lit le troisième caractère de la chaîne
$third = $str{2};

// Lit le dernier caractère de la chaîne
$str = 'Ceci est un test.';
$last = $str{strlen($str)-1};

// Modifie le dernier caractère de la chaîne
$str = 'Ceci est un test.';
$str{strlen($str)-1} = '!';

?>
]]>
       </programlisting>
      </example>
     </para>
    </sect3>

   </sect2>

   <sect2 id="language.types.string.useful-funcs">
    <title>Fonctions et opérateurs pratiques</title>
    <para>
     Les chaînes peuvent être concaténées avec l'opérateur '.' (point).
     Notez que l'opérateur d'addition '+' (plus) ne fonctionnera pas.
     Reportez-vous à la section
     <link linkend="language.operators.string">opérateurs de chaînes</link>
     pour plus de détails.
    </para>
    <para>
     Il y a une grande quantité de fonctions pratiques pour modifier
     les chaînes.
    </para>
    <simpara>
     Reportez-vous à la section <link linkend="ref.strings">chaînes de caractères</link>
     pour les fonctions les plus générales, à <link linkend="ref.pcre">Expressions
     rationnelles Perl</link> et <link linkend="ref.regex">Expressions rationnelles
     POSIX étendues</link> pour les recherches et remplacements.
    </simpara>
    <simpara>
     Il y a aussi les fonctions sur les <link linkend="ref.url">URL</link>,
     ainsi que des fonctions de chiffrage (<link linkend="ref.mcrypt">mcrypt</link> et
     <link linkend="ref.mhash">mhash</link>).
    </simpara>
    <simpara>
     Finalement, si vous ne trouvez toujours pas votre bonheur, il y a les
     fonctions de <link linkend="ref.ctype">types de caractères</link>.
    </simpara>
   </sect2>

   <sect2 id="language.types.string.casting">
    <title>Conversion en une &string;</title>

    <para>
     Vous pouvez convertir une valeur en une &string; en utilisant l'opérateur
     <literal>(string)</literal> ou bien la fonction <function>strval</function>.
     La conversion en &string; est automatiquement faite dans
     toutes les situations qui nécessitent une &string;.
     Cela arrive lorsque vous utilisez des fonctions comme <function>echo</function>
     ou <function>print</function> ou encore lorsque vous comparez une valeur
     avec une &string;. Lisez les sections du manuel sur les <link
     linkend="language.types">types</link> et la <link
     linkend="language.types.type-juggling">définition du type</link>
     pour comprendre plus facilement ce qui va suivre. Voir aussi la fonction
     <function>settype</function>.
    </para>

    <para>
     Le &boolean; &true; est converti en la &string; <literal>"1"</literal>,
     et le &boolean; &false; est représenté par la &string; vide
     &emptystring;. De cette façon, vous pouvez convertir des
     booléens en &string; et vice-versa.
    </para>
    <para>
     Un &integer; ou un &float; est converti en une
     &string; qui représente ce nombre en décimal (y compris
     l'exposant des nombres décimaux).
    </para>
    <para>
     Les tableaux sont toujours convertis en la &string; <literal>"Array"</literal>,
     ce qui fait que vous ne pouvez pas afficher le contenu d'un tableau avec la fonction
     <function>echo</function> ou <function>print</function>.
     Pour voir un seul élément, vous devriez faire quelque chose comme : <literal>
     echo $arr['foo']</literal>. Voyez les informations ci-dessous pour plus de conseils.
    </para>
    <para>
     Les objets sont automatiquement convertis en la &string;
     <literal>"Object"</literal>. Si vous souhaitez afficher le membre
     d'un objet, lisez le paragraphe ci-dessous. Si vous voulez connaître
     le nom de la classe de cet objet, utilisez la fonction
     <function>get_class</function>.
     Depuis &php; 5, la méthode __toString() est utilisée si elle existe.
   </para>
    <para>
     Les ressources sont toujours converties en &string;
     <literal>"Resource id #1"</literal> où &one; est
     le nombre unique représentant la &resource;, assigné par &php; au moment
     de l'exécution. Si vous souhaitez connaître le type d'une ressource,
     utilisez <function>get_resource_type</function>.
    </para>
    <para>
     &null; est toujours converti en une &string; vide.
    </para>

    <para>
     Comme vous pouvez le voir, afficher des tableaux, des objets ou des ressources
     n'est pas pertinent par cette méthode. Reportez-vous aux fonctions
     <function>print_r</function> et <function>var_dump</function> pour
     avoir des outils plus pratiques.
    </para>

    <para>
     Vous pouvez aussi convertir des valeurs &php; en chaînes pour les
     sauver dans un stockage. Cette méthode est appelée la linéarisation
     et peut être exploitée avec la fonction <function>serialize</function>.
     Vous pouvez aussi linéariser des valeurs &php; en structure
     XML si vous avez le support <link linkend="ref.wddx">WDDX</link>
     dans votre configuration de &php;.
    </para>
   </sect2>

   <sect2 id="language.types.string.conversion">
    <title>Conversion de chaînes de caractères</title>

    <simpara>
     Lorsqu'une &string; est évaluée comme une valeur numérique,
     le résultat et le type de la variable sont déterminés comme suit.
    </simpara>
    <simpara>
     La &string; est de type "double" si
     elle contient un des caractères '.', 'e' ou 'E'. Sinon,
     elle est de type entier (<literal>"integer"</literal>).
    </simpara>
    <para>
     La valeur est définie par la première partie
     de la chaîne. Si la &string;
     débute par une valeur numérique cette valeur
     sera celle utilisée. Sinon, la valeur sera égale
     à 0 (zéro). Les données numériques valides ont un signe optionnel, suivies
     par un ou plusieurs digits (optionnellement, contenant un point de décimal),
     suivies par un exponentiel optionnel. L'exponentiel peut être un 'e' ou
     un 'E' suivi par un ou plusieurs digits.
    </para>
    <example>
     <title>Exemples de conversions automatiques</title>
     <programlisting role="php">
<![CDATA[
<?php
$foo = 1 + "10.5";                // $foo est du type  float (11.5)
$foo = 1 + "-1.3e3";              // $foo est du type  float (-1299)
$foo = 1 + "bob-1.3e3";           // $foo est du type  integer (1)
$foo = 1 + "bob3";                // $foo est du type  integer (1)
$foo = 1 + "10 petits cochons";       // $foo est du type  integer (11)
$foo = 4 + "10.2 gros cochons"; // $foo est du type  float (14.2)
$foo = "10.0 cochons " + 1;          // $foo est du type  float (11)
$foo = "10.0 cochons " + 1.0;        // $foo est du type  float (11)
?>
]]>
     </programlisting>
    </example>
    <simpara>
     Pour plus d'informations sur les conversions de type, voir les
     pages de man Unix à propos de la fonction <literal>strtod(3)</literal>.
    </simpara>
    <para>
     Si vous voulez tester l'un des exemples de cette section,
     vous pouvez faire un copier/coller et l'insérer dans un script
     pour voir comment il se comporte :
     <example>
      <title>Exemples de conversions</title>
      <programlisting role="php">
<![CDATA[
<?php
echo "\$foo==$foo; type is " . gettype( $foo ) . "<br />\n";
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Ne vous attendez pas à récupérer le code d'un caractère en le convertissant
     en un entier (comme vous pourriez le faire en C par exemple). Utilisez
     les fonctions <function>ord</function> et <function>chr</function>
     pour convertir les caractères en leurs codes.
    </para>
   </sect2>
  </sect1>

  <sect1 id="language.types.array">
   <title>Les tableaux</title>
   <para>
    Un tableau &php; est en fait une association ordonnée (littéralement,
    une <literal>map</literal>). Une
    association est un type qui fait correspondre des valeurs
    à des <emphasis>clés</emphasis>. Ce type est optimisé
    de diverses façons, qui font que vous pouvez le manipuler comme
    un tableau à indices réels, une liste (vecteur), ou un table
    de hachage (qui est une implémentation d'association),
    dictionnaire, collection, pile, queue et encore d'autres.
    Comme une valeur peut elle-même être un tableau, vous pouvez
    simuler facilement un arbre.
   </para>
   <para>
    Les détails d'implémentation de ces structures sont hors du
    champ de ce manuel, mais vous trouverez ici un exemple
    de toutes ces structures.
   </para>

   <sect2 id="language.types.array.syntax">
    <title>Syntaxe</title>

    <sect3 id="language.types.array.syntax.array-func">
     <title>Créer un tableau <function>array</function></title>
     <para>
      Un tableau <type>array</type> peut être créé avec la fonction
      <function>array</function>. Cette fonction prend en argument
      des structures <literal><replaceable>key</replaceable> =&gt;
      <replaceable>value</replaceable></literal>, séparées par des virgules.
     </para>
     <para>
      <synopsis>
array( <optional> <replaceable>key</replaceable> =&gt; </optional>
<replaceable>value</replaceable> , ... )
// <replaceable>key</replaceable> est soit une &string;
soit un &integer; positif
// <replaceable>value</replaceable> peut être n'importe quoi
      </synopsis>
     </para>
     <para>
      <example>
       <title>Affectations de tableaux</title>
       <programlisting role="php">
<![CDATA[
<?php
$arr = array("foo" => "bar", 12 => true);

echo $arr["foo"]; // bar
echo $arr[12];    // 1
?>
]]>
       </programlisting>
      </example>
     </para>
     <para>
      Une clé <varname>key</varname> est soit un &integer;
      soit une &string;.
      Si une clé est la représentation standard d'un &integer; positif,
      elle sera interprétée comme tel. (i.e. <literal>'8'</literal> sera
      interprété comme <literal>8</literal>, tandis que <literal>'08'</literal>
      sera interprété comme <literal>'08'</literal>). 
      Les nombres à virgule flottante dans <varname>key</varname>
      seront transtypés en &integer;.
      Il n'y a aucune différence entre les tableaux indexés et les tableaux associatifs 
      en &php; ; il n'y a qu'un type <type>array</type>, qui peut contenir
      soit des entiers, soit des chaînes en guise d'index.
     </para>
     <para>
      Une valeur de tableau peut être de n'importe quel type.
      <example>
       <title>Création d'un tableau associatif</title>
       <programlisting role="php">
<![CDATA[
<?php
$arr = array("untableau" => array(6 => 5, 13 => 9, "a" => 42));

echo $arr["untableau"][6];    // 5
echo $arr["untableau"][13];   // 9
echo $arr["untableau"]["a"];  // 42
?>
]]>
       </programlisting>
      </example>
     </para>
     <para>
      Si vous omettez une clé lors de la spécification d'un tableau,
      l'indice maximum + 1 sera utilisé comme clé par défaut. Si aucun
      indice numérique n'a été généré, ce sera 0.
      Si vous en spécifiez une qui a déjà été assignée,
      la nouvelle valeur écrasera la précédente.
      <example>
       <title>Indexation automatique de tableau</title>
       <programlisting role="php">
<![CDATA[
<?php
// Ce tableau est identique à
array(5 => 43, 32, 56, "b" => 12);

// Celui ci
array(5 => 43, 6 => 32, 7 => 56, "b" => 12);
?>
]]>
       </programlisting>
      </example>
     </para>
     <warning>
      <simpara>
       Depuis &php; 4.3.0, le comportement de la génération des index
       décrit plus haut a changé. Maintenant, si vous ajoutez une rangée à un tableau
       dans lequel la clé maximale est négative, alors, la prochaine clé créée sera zéro
       (&zero;). Avant, le nouvel index était défini à l'index maximal plus un,
       le même comportement que lorsque l'indice est positif.
      </simpara>
     </warning>
     <para>
      Utiliser &true; comme clé revient à utiliser le type
      &integer; de valeur &one;.
      Utiliser &false; comme clé revient à utiliser le type
      &integer; de valeur &zero;.
      Utiliser &null; comme clé revient à utiliser le type
      &string; de valeur &emptystring;.
      Utiliser la chaîne vide comme index va créer cet index,
      et ce n'est pas la même chose que d'utiliser des
      crochets vides.
     </para>
     <para>
      Il n'est pas possible d'utiliser des tableaux ou des objets comme
      clés. Ce faisant, vous généreriez une alerte :
      <literal>Illegal offset type</literal>.
     </para>
    </sect3>

    <sect3 id="language.types.array.syntax.modifying">
     <title>La syntaxe à crochets</title>
     <para>
      Vous pouvez aussi modifier un tableau existant en lui assignant
      simplement des valeurs.
     </para>
     <para>
      L'assignation de valeurs de tableau se fait en spécifiant la clé
      entre crochets. Si vous omettez la clé ("<literal>$tableau[]</literal>"),
      la valeur sera ajoutée à la fin du tableau.
      <synopsis>
$arr[<replaceable>key</replaceable>] = <replaceable>value</replaceable>;
$arr[] = <replaceable>value</replaceable>;
// <replaceable>key</replaceable> est soit une &string;, soit un &integer;
// <replaceable>value</replaceable> peut être n'importe quoi
      </synopsis>
      Si <varname>$arr</varname> n'existe pas, il sera créé. Cela
      en fait une alternative pour créer un tableau. Pour modifier une
      valeur, assignez-lui une nouvelle valeur. Pour supprimer une
      valeur, utilisez la fonction <function>unset</function>.
      <example>
       <title>Manipuler des éléments de tableau</title>
       <programlisting role="php">
<![CDATA[
<?php
$arr = array(5 => 1, 12 => 2);

$arr[] = 56;    // Ceci revient à $arr[13] = 56;
                // à ce moment du script

$arr["x"] = 42; // Ceci ajoute un nouvel élément
                // avec l'index "x"

unset($arr[5]); // Ceci efface un élément du tableau

unset($arr);    // Ceci efface tout le tableau
?>
]]>
       </programlisting>
      </example>
     </para>
     <note>
      <para>
       Comme indiqué ci-dessus, si vous fournissez des crochets
       sans spécifier de clé, le plus grand index entier existant
       est recherché et la nouvelle clé générée est cette valeur
       maximum + 1. Si aucune clé entière n'existe, la valeur sera
       alors &zero;. Si vous spécifiez une clé qui est
       déjà existante, vous écraserez le contenu précédent.
      </para>
      <para>
       <warning>
        <simpara>
         Depuis &php; 4.3.0, la génération d'index a changé. Si vous ajoutez
         un élément et que la valeur maximale de la clé est négative,
         alors la prochaine clé générée est &zero;. Auparavant,
         c'était la plus grande valeur + 1, négative ou pas.
         Cela reste le comportement pour les clés positives.
        </simpara>
       </warning>
      </para>
      <para>
       Notez que le maximum théorique <emphasis>n'a pas besoin
       d'exister au moment de la génération</emphasis>. Il peut simplement
       avoir existé dans le tableau à un moment depuis la dernière fois
       où le tableau a été ré-indexé. L'exemple suivant illustre bien ceci :
      </para>

      <example>
       <title>La génération automatique de clé peut utiliser un ancien maximum</title>
       <programlisting role="php">
<![CDATA[
<?php
// Crée un simple tableau
$array = array(1, 2, 3, 4, 5);
print_r($array);

// On efface tous les éléments, mais on conserve le tableau
foreach ($array as $i => $value) {
    unset($array[$i]);
}
print_r($array);

// On ajoute une valeur : notez que la nouvelle clé est 5
// et non pas 0, comme on l'attendrait.
$array[] = 6;
print_r($array);

// Re-indexation :
$array = array_values($array);
$array[] = 7;
print_r($array);
?>
]]>
       </programlisting>
       &example.outputs;
       <screen>
<![CDATA[
Array
(
    [0] => 1
    [1] => 2
    [2] => 3
    [3] => 4
    [4] => 5
)
Array
(
)
Array
(
    [5] => 6
)
Array
(
    [0] => 6
    [1] => 7
)
]]>
       </screen>
      </example>

     </note>
    </sect3>
   </sect2>

   <sect2 id="language.types.array.useful-funcs">
    <title>Fonctions pratiques</title>
    <para>
     Il y a toute une panoplie de fonctions pratiques pour travailler
     avec <link linkend="ref.array">les tableaux</link>.
    </para>
    <note>
     <para>
      La fonction <function>unset</function> permet d'effacer des
      index dans un tableau. Sachez bien que le tableau ne sera PAS
      ré-indexé. Si vous utilisez uniquement des index numériques
      (commençant à zéro et incrémentés de un), vous pouvez effectuer
      la ré-indexation en utilisant <function>array_values</function>.
      <example>
       <title>Manipuler des éléments de tableau</title>
       <programlisting role="php">
<![CDATA[
<?php
$a = array(1 => 'un', 2 => 'deux', 3 => 'trois');
unset($a[2]);

/* Cela va produire un tableau qui aurait été
   $a = array(1 => 'un', 3 => 'trois');
   et non pas
   $a = array(1 => 'un', 2 =>'trois');
*/

$b = array_values($a);
// Maintenant b est le tableau array(1 => 'un', 2 =>'trois')
?>
]]>
       </programlisting>
      </example>
     </para>
    </note>
    <para>
     L'élément de langage <link linkend="control-structures.foreach">foreach</link>
     est spécifiquement dédié aux tableaux : il permet de passer en
     revue simplement les valeurs d'un tableau.
    </para>
   </sect2>

   <sect2 id="language.types.array.donts">
    <title>A faire et à ne pas faire avec les tableaux</title>

    <sect3 id="language.types.array.foo-bar">
     <title>Pourquoi est-ce que <literal>$foo[bar]</literal> est invalide ?</title>
     <para>
      Vous devez toujours utiliser les guillemets autour de la chaîne de caractères placée
      en tant qu'index du tableau. Par exemple, utilisez <literal>$foo['bar']</literal>
      et non pas <literal>$foo[bar]</literal>. Mais, pourquoi <literal>$foo[bar]</literal>
      est faux ? Vous pourriez avoir vu la syntaxe suivante en vos vieux scripts :
      <example>
       <title>Accès aux index de tableaux, ancienne méthode</title>
       <programlisting role="php">
<![CDATA[
<?php
$foo[bar] = 'ennemi';
echo $foo[bar];
// etc.
?>
]]>
       </programlisting>
      </example>
      Cela est mauvais, mais ça marche. Pourquoi est-ce mauvais? La raison
      est que &php; attend une constante entre crochets (bar) plutôt qu'une chaîne
      ('bar', notez les guillemets). Or, &php; pourrait définir dans le futur des
      constantes qui, malheureusement pour votre code, auront ce nom. En fait,
      cela fonctionne car la constante indéfinie est transformée en chaîne ayant la
      même valeur.
     </para>
     <note>
      <simpara>
       Cela ne signifie pas que vous devez <emphasis>toujours</emphasis>
       mettre les clés entre guillemets. Vous n'allez pas
       utiliser les guillemets avec les clés qui sont des
       <link linkend="language.constants">constantes</link> ou des
       <link linkend="language.variables">variables</link>, car cela
       empêchera &php; de les interpréter correctement.
      </simpara>
      <example>
       <title>Ne pas mettre les clés de tableaux entre guillemets</title>
       <programlisting role="php">
<![CDATA[
<?php
error_reporting(E_ALL);
ini_set('display_errors', true);
ini_set('html_errors', false);
// Tableau simple :
$array = array(1, 2);
$count = count($array);
for ($i = 0; $i < $count; $i++) {
    echo "\nChecking $i : \n";
    echo "Mauvais : " . $array['$i'] . "\n";
    echo "Bon : " . $array[$i] . "\n";
    echo "Mauvais : {$array['$i']}\n";
    echo "Bon : {$array[$i]}\n";
}
?>
]]>
       </programlisting>
       &example.outputs;
       <screen>
<![CDATA[
Checking 0:
Notice: Undefined index:  $i in /Users/iboom/Desktop/CVS/docs/mysql/mysql.fr/- on line 10
Mauvais :
Bon : 1
Notice: Undefined index:  $i in /Users/iboom/Desktop/CVS/docs/mysql/mysql.fr/- on line 12
Mauvais :
Bon : 1

Checking 1:
Notice: Undefined index:  $i in /Users/iboom/Desktop/CVS/docs/mysql/mysql.fr/- on line 10
Mauvais :
Bon : 2
Notice: Undefined index:  $i in /Users/iboom/Desktop/CVS/docs/mysql/mysql.fr/- on line 12
Mauvais :
Bon : 2
]]>
       </screen>
      </example>
     </note>
     <para>
      D'autres exemples :
      <example>
       <title>Exemples de conflits de constantes indéfinies</title>
       <programlisting role="php">
<![CDATA[
<?php
// Affichons toutes les erreurs
error_reporting(E_ALL);

$arr = array('fruit' => 'pomme', 'legume' => 'carotte');

// Correct
print $arr['fruit'];  // pomme
print $arr['legume']; // carotte

// Incorrect.  Cela fonctionne mais PHP affiche une alerte car
// il y a utilisation d'une constante indéfinie appelée fruit
//
// Notice: Use of undefined constant fruit - assumed 'fruit' in...
print $arr[fruit];    // pomme

// Définissons une constante pour illustrer le problème.
// Nous créons une constante appelée fruit, qui vaut 'legume'.
define('fruit','legume');

// Notez la différence
print $arr['fruit'];  // pomme
print $arr[fruit];    // carotte

// La suite est correcte si cela se passe dans une chaîne.
// Les constantes ne sont pas remplacées par leur valeur dans une chaîne
print "Bonjour $arr[fruit]";      // Bonjour pomme

// A une exception, les accolades entourant un tableau dans une chaîne
// permettent d'utiliser les constantes
print "Bonjour {$arr[fruit]}";    // Bonjour carotte
print "Bonjour {$arr['fruit']}";  // Bonjour pomme

// Ceci ne fonctionnera pas et donnera une erreur d'analyse
// Parse error: parse error, expecting T_STRING' or T_VARIABLE' or T_NUM_STRING'
// Cela s'applique aussi aux autoglobales dans les chaînes
print "Bonjour $arr['fruit']";
print "Bonjour $_GET['foo']";

// La concaténation est une alternative
print "Bonjour " . $arr['fruit']; // Bonjour pomme
?>
]]>
       </programlisting>
      </example>
     </para>
     <para>
      Lorsque vous activez l'<function>error_reporting</function> pour afficher
      les erreurs de niveau <constant>E_NOTICE</constant> (en utilisant
      le niveau <constant>E_ALL</constant>) alors, vous verrez ces erreurs.
      Par défaut, <link linkend="ini.error-reporting">error_reporting</link>
      est trop faible pour les afficher.
     </para>
     <para>
      Comme indiqué dans la section <link linkend="language.types.array.syntax">syntaxe</link>,
      il doit y avoir une expression entre les crochets
      ('<literal>[</literal>' et '<literal>]</literal>').
      Cela signifie que vous pouvez écrire ceci :
      <example>
       <title>Utilisation d'une expression dans un index de tableau</title>
       <programlisting role="php">
<![CDATA[
<?php
echo $arr[somefunc($bar)];
?>
]]>
       </programlisting>
      </example>
      Ceci est un exemple d'utilisation de retour de fonction comme
      index de tableau. &php; reconnaît aussi les constantes, comme
      la famille des <literal>E_*</literal>.

      <example>
       <title>Utilisation d'une constante dans un index de tableau</title>
       <programlisting role="php">
<![CDATA[
<?php
$error_descriptions[E_ERROR]   = 'Une erreur fatale est survenue';
$error_descriptions[E_WARNING] = 'PHP émet une alerte';
$error_descriptions[E_NOTICE]  = 'Ceci est juste une alerte informelle';
?>
]]>
       </programlisting>
      </example>
      Notez que <constant>E_ERROR</constant> est aussi un identifiant valide,
      tout comme <literal>bar</literal> dans le premier exemple. Mais le dernier
      exemple est identique à ceci :
      <example>
       <title>Utilisation d'une constante dans un index de tableau(2)</title>
       <programlisting role="php">
<![CDATA[
<?php
$error_descriptions[1] = 'Une erreur fatale est survenue';
$error_descriptions[2] = 'PHP émet une alerte';
$error_descriptions[8] = 'Ceci est juste une alerte informationnelle';
?>
]]>
       </programlisting>
      </example>
      car <literal>E_ERROR</literal> vaut &one;, etc.
     </para>
     <para>
      Comme nous l'avons déjà expliqué dans les exemples ci-dessus,
      <literal>$foo[bar]</literal> fonctionne mais est dangereux.
      Cela fonctionne car <literal>bar</literal> est identifié comme une
      constante. Mais si la constante n'existe pas, &php; suppose
      que vous souhaitez utiliser <literal>bar</literal> littéralement,
      sous la forme <literal>"bar"</literal>, mais que vous avez oublié les
      guillemets.
     </para>
     <sect4>
      <title>Pourquoi est-ce aussi dangereux?</title>
      <para>
       A l'avenir, le groupe &php; peut décider d'ajouter une constante ou
       un autre mot clé, ou bien vous souhaiterez aussi ajouter une
       constante dans votre application et vous serez bloqué. Par exemple,
       vous ne pouvez pas utiliser des mots comme <literal>empty</literal> et
       <literal>default</literal> de cette manière, car ils sont déjà
       <link linkend="reserved">réservés</link>.
      </para>
      <note>
       <simpara>
        Pour insister, à l'intérieur d'une &string;
        (&string;) à guillemets doubles, il est correct de ne pas utiliser
        les guillemets simples dans les index et donc <literal>"$foo[bar]"</literal> est valide.
        Voyez les exemples ci-dessus pour plus de détails sur la syntaxe des
        <link linkend="language.types.string.parsing">variables dans les chaînes</link>.
       </simpara>
      </note>
     </sect4>
    </sect3>
   </sect2>

   <sect2 id="language.types.array.casting">
    <title>Conversion en tableau</title>

    <para>
     Pour les types scalaires (&integer;, &float;,
     &string;, &boolean; et &resource;),
     convertir une valeur en tableau retourne un tableau qui contient un
     élément (à l'index 0) qui est la valeur originale.
    </para>

    <para>
     Si vous convertissez un tableau en objet, vous obtiendrez des propriétés
     ou bien cet objet comme élément de tableau. Les clés créées sont les
     noms des membres.
    </para>

    <para>
     Si vous convertissez la valeur &null; en tableau, vous obtiendrez un
     tableau vide.
    </para>
   </sect2>

   <sect2 id="language.types.array.comparing">
    <title>Comparaisons de tableaux</title>
    <para>
     Il est possible de comparer des tableaux grâce à
     la fonction <function>array_diff</function> et aux
     <link linkend="language.operators.array">opérateurs de tableaux</link>.
    </para>
   </sect2>

   <sect2 id="language.types.array.examples">
    &reftitle.examples;
    <para>
     Le type tableau de &php; est très souple. Voici quelques exemples
     d'utilisation :
    </para>
    <para>
     <example>
      <title>Utilisation des tableaux</title>
      <programlisting role="php">
<![CDATA[
<?php
// ceci
$a = array( 'couleur' => 'rouge',
             'gout' => 'sucre',
             'forme' => 'rond',
             'nom'  => 'pomme',
                        4        // cette clé sera 0
          );

// est complètement équivalent à
$a['couleur'] = 'rouge';
$a['gout'] =    'sucre';
$a['forme'] =   'rond';
$a['nom'] =     'pomme';
$a[]        = 4;        // cette clé sera 0

$b[] = 'a';
$b[] = 'b';
$b[] = 'c';
// va créer le tableau array( 0 => 'a' , 1 => 'b' , 2 => 'c' )
// ou plus simplement array('a' , 'b' , 'c' )
?>
]]>
      </programlisting>
     </example>
    </para>

    <example>
     <title>Utilisation de <function>array</function></title>
     <programlisting role="php">
<![CDATA[
<?php
// Array comme correspondance
$map = array( 'version'    => 4,
               'OS'         => 'Linux',
               'langue'       => 'français',
               'short_tags' => TRUE
             );
// valeur strictement numériques
$array = array( 7,
                 8,
                 0,
                 156,
                 -10
                );
// ceci est la même chose que array( 0 => 7, 1 => 8, ...)
$switching = array(         10, // clé = 0
                     5    =>  6,
                     3    =>  7,
                     'a'  =>  4,
                             11, // clé = 6 (index maximum : 5)
                     '8'  =>  2, // clé = 8 (entier!)
                     '02' => 77, // clé = '02'
                     0    => 12 // la valeur de la clé 10 sera remplacée par 12
                    );

// empty array
$empty = array();
?>
]]>
     </programlisting>
    </example>

    <example id="language.types.array.examples.loop">
     <title>Collection</title>
     <programlisting role="php">
<![CDATA[
<?php
$couleurs = array('rouge', 'bleue', 'verte', 'jaune');

foreach ( $couleurs as $couleur ){
    echo "Aimez-vous la couleur $couleur?\n";
}

?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Aimez-vous la couleur rouge?
Aimez-vous la couleur bleue?
Aimez-vous la couleur verte?
Aimez-vous la couleur jaune?
]]>
     </screen>
    </example>

    <para>
     Changer les valeur du tableau directement est possible depuis &php; 5 en les
     passant par références. Les versions précédentes nécessitent cette solution :
     <example id="language.types.array.examples.changeloop">
      <title>Collection</title>
      <programlisting role="php">
<![CDATA[
<?php
// PHP 5
foreach ($colors as &$color) {
  $color = strtoupper($color);
}
unset($color); /* s'assure que l'écriture suivante
à $color ne modifie pas le dernier élément du tableau */

// Solution pour les anciennes versions de PHP
foreach ($colors as $key => $color) {
$colors[$key] = strtoupper($color);
}

print_r($colors);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Array
(
    [0] => ROUGE
    [1] => BLEU
    [2] => VERT
    [3] => JAUNE
)
]]>
      </screen>
     </example>
    </para>
    <para>
     Cet exemple crée un tableau d'index minimal 1.
     <example>
      <title>Tableau en 1</title>
      <programlisting role="php">
<![CDATA[
<?php
$firstquarter  = array(1 => 'Janvier', 'Février', 'Mars');
print_r($firstquarter);
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Array
(
    [1] => 'Janvier'
    [2] => 'Février'
    [3] => 'Mars'
)
]]>
      </screen>
     </example>
    </para>
    <example>
     <title>Remplissage d'un tableau</title>
     <programlisting role="php">
<![CDATA[
<?php
// remplit un tableau avec les noms de fichiers d'un dossier
$handle = opendir('.');
  while ( $file = readdir($handle) ) {
    $files[] = $file;
}
closedir($handle);
?>
]]>
     </programlisting>
    </example>
    <para>
     Les tableaux sont ordonnés. Vous pouvez modifier l'ordre des
     valeurs avec de nombreuses fonctions de classement. Voyez les
     fonctions de <link linkend="ref.array">tableaux</link> pour plus
     d'informations. Vous pouvez compter le nombre d'éléments d'un tableau
     en utilisant la fonction <function>count</function>.
    </para>
    <example>
     <title>Tri de tableaux</title>
     <programlisting role="php">
<![CDATA[
<?php
sort($files);
print_r($files);
?>
]]>
     </programlisting>
    </example>
    <para>
     Comme une valeur de tableau peut être n'importe quoi, elle
     peut aussi être un autre tableau. Comme cela, vous pouvez
     avoir des tableaux multidimensionnels et récursifs.
    </para>
    <example>
     <title>Tableaux multidimensionnels, et récursifs</title>
     <programlisting role="php">
<![CDATA[
<?php
$fruits = array ( "fruits"  => array ( "a" => "orange",
                                       "b" => "banane",
                                       "c" => "pomme"
                                     ),
                  "nombre" => array ( 1,
                                       2,
                                       3,
                                       4,
                                       5,
                                       6,
                                     ),
                  "trou"   => array (      "premier",
                                       5 => "second",
                                            "troisième"
                                     )
                );

// Exemples d'utilisations des tableaux ci-dessus
echo $fruits["trou"][5];    // affiche "second"
echo $fruits["fruits"]["a"]; // affiche "orange"
unset($fruits["trou"][0]);  // supprime "premier"

// Créer un tableau multidimensionnel
$jus["pomme"]["vert"] = 'bon';
?>
]]>
     </programlisting>
    </example>
    <para>
     Soyez conscient que l'assignation de valeurs dans un tableau
     entraîne automatiquement la copie de ces valeurs. Vous devez utiliser
     l'opérateur de référence pour copier un tableau par référence.
     <example>
      <title>Copie dans un tableau par référence</title>
      <programlisting role="php">
<![CDATA[
<?php
$arr1 = array(2, 3);
$arr2 = $arr1;
$arr2[] = 4; // $arr2 est modifié,
             // $arr1 vaut toujours array(2, 3)

$arr3 = &$arr1;
$arr3[] = 4; // maintenant $arr1 et $arr3 sont identiques
?>
]]>
      </programlisting>
     </example>
    </para>
   </sect2>
  </sect1>

  <sect1 id="language.types.object">
   <title>Les objets</title>

   <sect2 id="language.types.object.init">
    <title>Initialisation d'un objet</title>

    <para>
     Pour initialiser un objet, vous devez utiliser la commande "new"
     afin de créer l'instance de l'objet.

     <example>
      <title>Création d'un objet</title>
      <programlisting role="php">
<![CDATA[
<?php
class foo
{
    function faire_foo()
    {
        echo "Faisant foo.";
    }
}

$bar = new foo;
$bar->faire_foo();
?>
]]>
      </programlisting>
     </example>
    </para>
    <simpara>
     Pour une discussion complète, lisez la section sur les <link
     linkend="language.oop">classes et les objets</link>.
    </simpara>
   </sect2>

   <sect2 id="language.types.object.casting">
    <title>Conversion en objet</title>

    <para>
     Si un objet est converti en objet, il n'est pas modifié. Si une
     valeur d'un autre type est convertie en objet, une nouvelle instance
     de la classe <literal>stdClass</literal> sera créée. Si la valeur
     était &null;, la nouvelle instance sera vide. Pour les autres valeurs,
     un membre de l'objet appelé <literal>scalar</literal> contiendra la valeur.
     <example>
      <title>Transtypage</title>
      <programlisting role="php">
<![CDATA[
<?php
$obj = (object) 'au revoir';
echo $obj->scalar;  // affiche 'au revoir'
?>
]]>
      </programlisting>
     </example>
    </para>
   </sect2>

  </sect1>

  <sect1 id="language.types.resource">
   <title>Ressources</title>

   <para>
    Une ressource (<literal>"resource"</literal> en anglais), est un type
    spécial, qui représente une référence sur une ressource externe. Les
    ressources sont créées par des fonctions dédiées. Reportez-vous 
    à l'annexe <link linkend="resource">Types des ressources &php;</link>
    pour une liste exhaustive des fonctions créant et utilisant
    ces ressources.
   </para>

   <note>
    <simpara>
     Le type de données <literal>"resource"</literal> a été introduit en 
     &php; 4.
    </simpara>
   </note>
   
   <para>
    Voir aussi la fonction <function>get_resource_type</function>.
    </para>

   <sect2 id="language.types.resource.casting">
    <title>Conversion en ressource</title>

    <para>
     Comme les ressources contiennent des valeurs très spéciales,
     comme des fichiers ouverts, des connexions aux bases de données,
     des images ou n'importe quoi d'autre, vous ne pouvez pas
     convertir une valeur en ressource.
    </para>
   </sect2>

   <sect2 id="language.types.resource.self-destruct">
    <title>Libérer des ressources</title>
    <para>
     Grâce au système de comptabilisation des références
     introduit en &php; 4 (avec le moteur Zend), &php; détecte automatiquement
     qu'une ressource n'est plus utilisée (comme Java). Dans ce cas,
     toutes les ressources systèmes utilisées par cette
     ressource sont libérées automatiquement.
     Pour cette raison, il est rarement nécessaire de libérer
     la mémoire manuellement en utilisant les fonctions
     <literal>free_result</literal> associées.
     <note>
      <simpara>
       Les connexions persistantes représentent un cas
       particulier, elles ne seront <emphasis>PAS</emphasis>
       détruites. Voyez la section concernant les
       <link linkend="features.persistent-connections">connexions persistantes</link>.
      </simpara>
     </note>
    </para>

   </sect2>
  </sect1>

  <sect1 id="language.types.null">
   <title>La valeur &null;</title>

   <para>
    La valeur spéciale &null; représente
    l'absence de valeur. Une variable avec la valeur &null; n'a
    pas de valeur.
   </para>
   <note>
    <simpara>
     Le type &null; a été introduit en &php; 4.
    </simpara>
   </note>
   <para>
    Une variable est considérée comme &null; si :
    <itemizedlist>
     <listitem>
      <para>
       elle a eu d'assigner la constante &null;.
      </para>
     </listitem>
     <listitem>
      <para>
       elle n'a été définie à aucune valeur en fait.
      </para>
     </listitem>
     <listitem>
      <para>
       elle a été détruite par la fonction <function>unset</function>.
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <sect2 id="language.types.null.syntax">
    <title>Syntaxe</title>
    <para>
     Il y a seulement une valeur de type &null; et c'est le mot-clé
     &null;, insensible à la casse.
     <example>
      <title>La valeur &null;</title>
      <programlisting role="php">
<![CDATA[
<?php
$var = NULL;
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Voir aussi
     <function>is_null</function> et
     <function>unset</function>.
    </para>
   </sect2>
  </sect1>

  <sect1 id="language.pseudo-types">
   <title>Pseudo-types utilisés dans cette documentation</title>

   <sect2 id="language.types.mixed">
    <title><literal>mixed</literal></title>
    <para>
     <literal>mixed</literal> indique qu'un paramètre accepte
     plusieurs types, mais pas forcément tous les types.
    </para>
    <para>
     <function>gettype</function> par exemple, accepte tous les types de variables
     &php;, mais <function>str_replace</function> n'accepte que des
     chaînes de caractères et des tableaux.
    </para>
   </sect2>

   <sect2 id="language.types.number">
    <title><literal>number</literal></title>
    <para>
     <literal>number</literal> indique qu'un paramètre peut être du type
     &integer; ou &float;.
    </para>
   </sect2>

   <sect2 id="language.types.callback">
    <title><literal>callback</literal></title>
    <para>
     Certaines fonctions comme <function>call_user_function</function>
     ou <function>usort</function> acceptent une fonction définie par
     l'utilisateur comme fonction de callback. Les fonctions de
     callback peuvent être des fonctions simples, mais aussi des
     objets ou des méthodes statiques de classes.
    </para>
    <para>
     Une fonction &php; est passée simplement en indiquant son nom, sous
     forme de &string;. Vous pouvez passer une fonction
     intégrée au langage ou une fonction définie par vos soins, à
     l'exception de
     <function>array</function>,
     <function>echo</function>,
     <function>empty</function>,
     <function>eval</function>,
     <function>exit</function>,
     <function>isset</function>,
     <function>list</function>,
     <function>print</function> et
     <function>unset</function>.
    </para>
    <para>
     Une méthode d'un objet instancié est passée sous forme de &array;,
     contenant un objet comme élément d'index 0 et un nom de méthode comme
     élément 1.
    </para>
    <para>
     Les méthodes statiques de classe peuvent aussi être passées dans l'objet
     instancié, mais en passant le nom de la classe comme valeur de
     l'index 0.
    </para>

    <para>
     <example>
      <title>Exemple de fonction de callback</title>
      <programlisting role="php">
<![CDATA[
<?php
// Exemple de fonction de callback
function ma_fonction_callback() {
    echo 'Bonjour le monde!';
}

// Exemple de méthode de callback
class MaClasse {
  function MaMethodeCallback() {
    echo 'Bonjour le monde!';
  }
}

// Type 1: Callback simple
call_user_func('ma_fonction_callback'); 

// Type 2: Appel d'une méthode statique de la classe
call_user_func(array('MyClass', 'MaMethodeCallback')); 

// Type 3: Appel d'une méthode objet
$obj = new MaClasse();
call_user_func(array(&$obj, 'MaMethodeCallback'));
?>
]]>
      </programlisting>
     </example>
    </para>

   </sect2>
  </sect1>

  <sect1 id="language.types.type-juggling">
   <title>Définition du type</title>

   <simpara>
    &php; ne nécessite pas de déclaration explicite
    du type d'une variable. Le type d'une variable est
    déterminé par le contexte d'utilisation.
    Par exemple, si vous assignez une &string;
    à la variable <parameter>$var</parameter>,
    <parameter>$var</parameter> devient une
    chaîne de caractère. Si vous assignez un nombre
    entier à <parameter>$var</parameter>, elle devient un entier.
   </simpara>
   <para>
    Un exemple de convertisseur automatique de type est l'opérateur
    '<literal>+</literal>'. Si un des opérandes est de type double, alors tous les
    opérandes sont évalués comme des variables de
    type double et le résultat est de type double. Sinon, tous
    les opérandes sont évalués comme des variables
    de type entier et le résultat sera du type entier. Il est
    à noter que cela NE CHANGE PAS le type des opérandes.
    Le seul changement est la manière dont les opérandes
    sont évalués.
    <example>
     <title>Conversion automatique</title>
     <programlisting role="php">
<![CDATA[
<?php
$foo = "0";  // $foo est une chaîne de caractères (ASCII 48)
$foo += 2;   // $foo est maintenant du type entier (2)
$foo = $foo + 1.3;  // $foo est maintenant du type double (3.3)
$foo = 5 + "10 Petits cochons"; // $foo est du type entier (15)
$foo = 5 + "10 cochonnets";     // $foo est du type entier (15)
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Si les deux derniers exemples vous semblent obscurs ou si vous
    voulez forcer une variable a être évaluée
    avec un certain type, reportez-vous au paragraphe "<link
    linkend="language.types.string.conversion"> Conversion de
    types</link>".
   </simpara>
   <simpara>
    Si vous voulez forcer le type d'une variable, vous pouvez
    vous reporter à la section concernant le
    <link linkend="language.types.typecasting">transtypage</link>. Si
    vous voulez changer le type d'une variable, utilisez la fonction
    <function>settype</function>.
   </simpara>
   <note>
    <para>
     Le comportement de la conversion automatique en tableau
     est en fait indéfini.
    </para>
    <para>
     <example>
      <title>Conversion automatique indéfinie</title>
      <programlisting role="php">
<![CDATA[
<?php
$a = '1';     // $a est une chaîne
$a[0] = 'f';  // Mais que sont les index de chaîne?
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Étant donné que &php; supporte l'indexation de chaîne avec des
     positions identiques à celles des tableaux, l'exemple ci-dessus
     conduit à un problème : est ce que <varname>$a</varname> est un tableau,
     dont le premier élément est "<literal>f</literal>", ou bien est ce que
     "<literal>f</literal>" est le premier élément de la chaîne de
     caractères <varname>$a</varname>?
    </para>
    <para>
     Les versions courantes de &php; interprètent la seconde assignation
     comme un index de chaîne, et donc <varname>$a</varname> devient
     "<literal>f</literal>" et le résultat de cette conversion automatique
     doit être considéré comme indéfini. &php; 4 a introduit la syntaxe
     avec les accolades pour accéder aux caractères d'une chaîne.
     Utilisez plutôt le code ci-dessous :
     <example>
      <title>Conversion automatique indéfinie(2)</title>
      <programlisting role="php">
<![CDATA[
<?php
$a    = 'abc'; // $a est une chaîne
$a{1} = 'f';   // $a vaut maintenant "afc"
?>
]]>
      </programlisting>
     </example>
     Voyez la section concernant
     l'<link linkend="language.types.string.substr">accès aux caractères d'une chaîne</link>
     pour plus de détails.
    </para>
   </note>

   <sect2 id="language.types.typecasting">
    <title>Transtypage</title>

    <para>
     La conversion de type en &php; fonctionne de la même
     manière qu'en C : le nom du type désiré
     est écrit entre parenthèses devant la variable
     à transtyper ("cast").
     <example>
      <title>Transtypage</title>
      <programlisting role="php">
<![CDATA[
<?php
$foo = 10;   // $foo est un entier
$bar = (double) $foo;   // $bar est un double
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Les conversions autorisées sont :
     <itemizedlist>
      <listitem>
       <simpara><literal>(int)</literal>, <literal>(integer)</literal> - type entier</simpara>
      </listitem>
      <listitem>
       <simpara><literal>(bool)</literal>, <literal>(boolean)</literal> - &boolean;</simpara>
      </listitem>
      <listitem>
       <simpara><literal>(double)</literal>, <literal>(float)</literal>, <literal>(real)</literal> -
       type double</simpara>
      </listitem>
      <listitem>
       <simpara><literal>(string)</literal> - type chaîne de caractère</simpara>
      </listitem>
      <listitem>
       <simpara><literal>(array)</literal> - type tableau</simpara>
      </listitem>
      <listitem>
       <simpara><literal>(object)</literal> - type objet</simpara>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     Il est à noter que les tabulations et les espaces
     sont autorisés à l'intérieur des
     parenthèses, donc les lignes suivantes sont équivalentes :
     <example>
      <title>Transtypage et espaces</title>
      <programlisting role="php">
<![CDATA[
<?php
$foo = (int) $bar;
$foo = ( int ) $bar;
?>
]]>
      </programlisting>
     </example>
    </para>
    <note>
     <para>
      Au lieu de transtyper une variable en chaîne, vous pouvez aussi
      l'insérer entre deux guillemets doubles :
      <example>
       <title>Transtypage en chaîne</title>
       <programlisting role="php">
<![CDATA[
<?php
$foo = 10;            // $foo est un entier
$str = "$foo";        // $str est une chaîne
$fst = (string) $foo; // $fst est aussi une chaîne

// Ceci affiche : "Identique"
if ($fst === $str) {
    echo 'Identique';
}
?>
]]>
       </programlisting>
      </example>
     </para>
    </note>

    <para>
     Le transtypage n'a pas toujours un résultat prévisible lors du
     transtypage entre certains types.
     Pour plus d'informations, lisez :

     <itemizedlist>
      <listitem>
       <simpara><link linkend="language.types.boolean.casting">Conversion en
       booléen</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.integer.casting">Conversion en
       entier</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.float.casting">Conversion en
       nombre décimal</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.string.casting">Conversion en
       &string;</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.array.casting">Conversion en
       tableau</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.object.casting">Conversion en
       objet</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.resource.casting">Conversion en
       ressource</link></simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="types.comparisons">Le tableau de comparaison de types</link>
       </simpara>
      </listitem>
     </itemizedlist>
    </para>
   </sect2>
  </sect1>

 </chapter>
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
indent-tabs-mode:nil
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
