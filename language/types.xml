<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.29 $ -->
  <chapter id="language.types">
	<title>Les types</title>
  <sect1 id="language.types.intro">
  <title>Introduction</title>
   <simpara>
    PHP supporte les huit types basiques suivants :
   </simpara>
   <para>
    PHP supporte quatre types scalaires :
    <itemizedlist>
     <listitem>
      <simpara>
       <link linkend="language.types.boolean">bool&eacute;en</link>
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       <link linkend="language.types.integer">entier</link>
      </simpara>
     </listitem>
     <listitem>
       <simpara>
       <link linkend="language.types.float">nombre &agrave; virgule
       flottante</link>
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       <link linkend="language.types.string">cha&icirc;ne de
       caract&egrave;res</link>
      </simpara>
    </listitem>
   </itemizedlist>
  </para>
  <para>
   PHP supporte deux types compos&eacute;s :
   <itemizedlist>
    <listitem>
     <simpara>
      <link linkend="language.types.array">tableau</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.types.object">objet</link>
     </simpara>
    </listitem>
   </itemizedlist>
  </para>
  <para>
   PHP supporte deux types sp&eacute;ciaux :
   <itemizedlist>
    <listitem>
     <simpara>
      <link linkend="language.types.resource">ressource</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.types.null">null</link>
     </simpara>
    </listitem>
   </itemizedlist>
  </para>
  <note>
   <simpara>
    Dans ce manuel, vous rencontrerez souvent le type <literal>mixed</literal>.
    C'est un pseudo-type, qui indique que le param&egrave;tre peut
    indiff&eacute;remment prendre plusieurs types.
   </simpara>

  </note>
  <simpara>
   Habituellement, le type d'une variable n'est pas d&eacute;clar&eacute;
   par le programmeur. Il est d&eacute;cid&eacute; au moment de
   l'ex&eacute;cution par le PHP, en fonction du contexte dans
   lequel la variable est utilis&eacute;e.
  </simpara>
  <note>
   <simpara>
    Si vous voulez v&eacute;rifier le type et la valeur d'une variable
    ou d'une <link linkend="language.expressions">expression</link>, utilisez
    la fonction <function>var_dump</function>.
   </simpara>
   <para>
    Si vous souhaitez simplement une repr&eacute;sentation lisible pour du d&eacute;bogage,
    utilisez la fonction <function>gettype</function>. Pour v&eacute;rifier la pr&eacute;sence
    de certains types, <emphasis>n'utilisez pas</emphasis> <function>gettype</function>, 
    mais plut&ocirc;t les fonctions <literal>is_<replaceable>type</replaceable></literal>. 
    Par exemple : 
    <example>
    <title>Exemples de v&eacute;rification de type de variable</title>
     <programlisting role="php">
<![CDATA[
<?php
$bool = TRUE;   // un booléen
$str  = "foo";  // une chaîne de caractères
$int  = 12;     // un entier

echo gettype($bool); // affiche "boolean"
echo gettype($str);  // affiche "string"

// Ceci est un engier, on l'incrémente de 4
if (is_int($int)) {
    $int += 4;
}

// Si $bool est une chaîne, l'afficher
// (Ne pas imprimer n'importe quoi).
if (is_string($bool)) {
    echo "Chaine : $bool";
}
?>
]]>
     </programlisting>
    </example>
   </para>
  </note>
  <simpara>
   Si vous voulez forcer une variable &agrave; &ecirc;tre convertie
   en un certain type, vous devez transtyper
   (<link linkend="language.types.typecasting">cast</link>) la
   variable ou utiliser la fonction <function>settype</function>.
  </simpara>
  <simpara>
   Il est &agrave; noter qu'une variable peut se comporter de
   mani&egrave;re diff&eacute;rente suivant les situations, en
   fonction du type qui lui est affect&eacute;.
   Pour plus d'informations, voir le paragraphe
   <link linkend="language.types.type-juggling">transtypage</link>.
  </simpara>
 </sect1>
   <sect1 id="language.types.boolean">
    <title>Bool&eacute;ens</title>
    <simpara>
     C'est le type le plus simple. Un bool&eacute;en exprime les valeurs
      de &true; ou &false;.
    </simpara>
    <sect2 id="language.types.boolean.syntax">
     <title>Syntaxe</title>
     <para>
     Vous pouvez utiliser les constantes '&true;' et
     '&false;' pour sp&eacute;cifier une valeur de type
      <type>bool</type>. Ces constantes sont insensibles
      &agrave; la casse.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
  $foo = True; 
  // assigne la valeur TRUE à la variable $foo
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      G&eacute;n&eacute;ralement, vous les cr&eacute;erez
      avec un des <link linkend="language.operators">op&eacute;rateurs</link>
      qui retourne une valeur <type>bool</type>, pour le passer
      &agrave; une <link linkend="control-structures">structure de contr&ocirc;le</link>.
      <informalexample>
       <programlisting role="php">
<![CDATA[
// == est un opérateur d'égalité
// qui retourne un booléen
if ($action == "show_version") {
    echo "La version est la 1.23";
}

// Ceci n'est pas nécessaire
if ($show_separators == TRUE) {
    echo "<hr>\n";
}

// car vous pouvez simplement utiliser
if ($show_separators) {
    echo "<hr>\n";
}
]]>
       </programlisting>
      </informalexample>
     </para>
    </sect2>

    <sect2 id="language.types.boolean.casting">
     <title>Conversion en bool&eacute;en</title>
      <simpara>
       Reportez-vous au chapitre
       "<link linkend="language.types.type-juggling">D&eacute;finition du type</link>"
       pour plus d'informations sur les conversions.
      </simpara>
      <para>
       Lors des conversions de valeurs de type <type>bool</type>, les valeurs
       suivantes sont consid&eacute;r&eacute;es comme fausse (&false;) :
       <itemizedlist>
        <listitem>
         <simpara>
          Le <link linkend="language.types.boolean">bool&eacute;en</link>FALSE
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          L'<link linkend="language.types.integer">entier</link> 0 (z&eacute;ro)
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          Le <link linkend="language.types.float">nombre &agrave; virgule flottante</link> 0.0 (z&eacute;ro)
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          La <link linkend="language.types.string">cha&icirc;ne</link> vide,
          et la <link linkend="language.types.string">cha&icirc;ne</link> "0"
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          Le <link linkend="language.types.array">tableau</link> vide
          (aucun &eacute;l&eacute;ment)
         </simpara>
        </listitem>
        <listitem>
         <simpara>
         L'<link linkend="language.types.object">objet</link> vide
         (aucun &eacute;l&eacute;ment)
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          La constante sp&eacute;ciale <link linkend="language.types.null">NULL</link>
         </simpara>
        </listitem>
       </itemizedlist>
       Toutes les autres valeurs sont consid&eacute;r&eacute;es comme
       vraies (&true; (y compris les
       <link linkend="language.types.resource">ressources</link>).
       <warning>
        <simpara>
         <literal>-1</literal> est consid&eacute;r&eacute; comme vrai!
        </simpara>
       </warning>
       <example>
        <title>Conversion en bool&eacute;en</title>
        <programlisting role="php">
<![CDATA[
<?php
echo gettype((bool) "");        // bool(false)
echo gettype((bool) 1);         // bool(true)
echo gettype((bool) -2);        // bool(true)
echo gettype((bool) "foo");     // bool(true)
echo gettype((bool) 2.3e5);     // bool(true)
echo gettype((bool) array(12)); // bool(true)
echo gettype((bool) array());   // bool(false)
?>
]]>
        </programlisting>
       </example>
      </para>
    </sect2>
  </sect1>
  <sect1 id="language.types.integer">
   <title>Entiers</title>
   <para>
    Un entier est un nombre de l'ensemble des entiers naturels Z :
    <literal>Z = {...., -2, -1, 0, 1, 2, ...}</literal>. Il est possible de sp&eacute;cifier
    les nombres entiers (integers) de toutes les mani&egrave;res suivantes :
    d&eacute;cimale (base 10), hexad&eacute;cimale (base 16), octale (base 8)
    &eacute;ventuellement pr&eacute;c&eacute;d&eacute; du signe moins
    (<literal>-</literal>).
   </para>
    <sect2 id="language.types.integer.syntax">
     <title>Syntaxe</title>
     <simpara>
      Les entiers peuvent &ecirc;tre sp&eacute;cifi&eacute;s en base d&eacute;cimale (dite aussi
      base 10), en hexad&eacute;cimale (base 16) ou octale (base 8).
      Les entiers peuvent &ecirc;tre optionnellement pr&eacute;c&eacute;d&eacute;s par le signe
      plus ou moins (- or +).
     </simpara>
     <para>
    Pour utiliser la notation octale, vous devez pr&eacute;fixer le nombre avec
    un z&eacute;ro; pour utiliser la notation hexad&eacute;cimale, vous devez
    pr&eacute;fixer le nombre avec <literal>0x</literal>.
      <example>
       <title>Integer literals</title>
       <programlisting role="php">
<![CDATA[
$a = 1234; // nombre entier en base 10
$a = -123; // nombre entier négatif
$a = 0123; // nombre entier en base 8, octale (équivalent à 83 en base 10)
$a = 0x1A; // nombre entier en base 16, hexadécimale
           // (équivalent à 26 en base 10)
]]>
       </programlisting>
      </example>
     Techniquement, la structure d'un entier suit les r&egrave;gles suivantes :
      <example>
      <title>Structure d'un entier</title>
       <programlisting>
<![CDATA[
decimal     : [1-9][0-9]*
            | 0

hexadecimal : 0[xX][0-9a-fA-F]+

octal       : 0[0-7]+

integer     : [+-]?decimal
            | [+-]?hexadecimal
            | [+-]?octal
]]>
       </programlisting>
      </example> 
      La taille des entiers d&eacute;pend de la plate-forme de support, mais
      la valeur maximale est g&eacute;n&eacute;ralement de 2 milliards et des
      poussi&egrave;res (c'est un entier sign&eacute; de 32 bits). PHP ne supporte
      pas les entiers non sign&eacute;s.
     </para>
    </sect2>

    <sect2 id="language.types.integer.overflow">
     <title>D&eacute;passement de capacit&eacute; des entiers</title>
     <para>
      Si un nombre est hors de l'intervalle de validit&eacute;
      des entiers, il sera interpr&eacute;t&eacute; comme un <type>float</type>.
      <example>
      <title>D&eacute;passement de capacit&eacute; des entiers</title>
       <programlisting role="php">
<![CDATA[
<?php
$large_number =  2147483647;
var_dump($large_number);
// affiche : int(2147483647)

$large_number =  2147483648;
var_dump($large_number);
// affiche : float(2147483648)

// this goes also for hexadecimal specified integers:
var_dump( 0x80000000 );
// affiche : float(2147483648)

$million = 1000000;
$large_number =  50000 * $million;
var_dump($large_number);
// affiche : float(50000000000)
?>
]]>
       </programlisting>
      </example>
      De m&ecirc;me, si une fonction ou un op&eacute;rateur retourne un entier qui
      est hors des limites de validit&eacute; des entiers, il sera aussi
      automatiquement converti en <type>float</type>.
     </para>
     <para>
      En PHP, il n'y a pas de division enti&egrave;re. <literal>1/2</literal> 
      sera un nombre &agrave; virgule flottante (<type>float</type>)
      de valeur <literal>0.5</literal>. 
      <!-- See ??? for more information. (with the
      operators, or with type-jug) -->
     </para>
      <warning>
       <simpara>
        Malheureusement, il y a un bug dans le moteur (corrig&eacute; en 4.1.0), 
        qui fait que PHP ne fonctionne pas toujours bien lorsque des nombres 
        n&eacute;gatifs sont utilis&eacute;s. Lorsque les deux op&eacute;randes 
        sont positifs, il n'y a pas de probl&egrave;mes. Par exemple :
        <literal>-50000 * $million</literal>, conduit &agrave;
        <literal>-429496728</literal>.
       </simpara>
      </warning>
     <para>
      Il n'existe pas de division enti&egrave;re en PHP.
      <literal>1/2</literal> g&eacute;n&egrave;rera le <type>float</type>
      <literal>0.5</literal>. Vous pouvez forcer la valeur
      au format entier pour faire l'arrondi, ou bien utiliser
      les fonctions <function>round</function>,
      <function>floor</function> ou <function>ceil</function>.
      <example>
       <title>Divisions enti&egrave;res</title>
       <programlisting role="php">
<![CDATA[
<?php
var_dump(25/7);         
  // float(3.5714285714286) 
var_dump((int) (25/7)); 
  // int(3)
var_dump(round(25/7));  
  // float(4) 
?>
]]>
       </programlisting>
      </example>
     </para>
    </sect2>
    <sect2 id="language.types.integer.casting">
     <title>Conversion en entiers</title>
      <simpara>
       Pour explicitement convertir une valeur en &integer;,
       utilisez les op&eacute;rateurs de transtypage <literal>(int)</literal>
       ou <literal>(integer)</literal>. Cependant, dans la plupart des
       situations, vous n'en aurez pas besoin, car une valeur sera
       automatiquement convertie si un op&eacute;rateur, une fonction ou tout
       autre &eacute;l&eacute;ment du langage requiert un <type>entier</type>.
      </simpara>
      <simpara>
       Reportez-vous &agrave; la section
       <link linkend="language.types.type-juggling">d&eacute;finition de
       type</link> pour plus d'informations sur les conversions.
      </simpara>
      <sect3 id="language.types.integer.casting.from-boolean">
       <title>
        Depuis un <link 
        linkend="language.types.boolean">bool&eacute;en</link>
       </title>
       <simpara>
        <link linkend="language.types.boolean">FALSE</link> devient 0
        (z&eacute;ro), et <link linkend="language.types.boolean">TRUE</link>
        devient 1 (un).
       </simpara>
      </sect3>
      <sect3 id="language.types.integer.casting.from-float">
       <title>
        Depuis un <link linkend="language.types.float">nombre &agrave; virgule
        flottante</link>
       </title>
       <simpara>
        Lors de conversion entre un nombre &agrave; virgule flottante et
        un entier, le nombre sera arrondi &agrave; la valeur inf&eacute;rieure
        s'il est positif, et sup&eacute;rieure s'il est n&eacute;gatif
        (conversion dite 'vers z&eacute;ro').
       </simpara>
       <para>
        Si le nombre est hors de l'intervalle de validit&eacute;
        des entiers, (g&eacute;n&eacute;ralement 
        <literal>+/- 2.15e+9 = 2^31</literal>),
        le r&eacute;sultat est ind&eacute;fini, car les nombres &agrave;
        virgule flottante n'ont pas assez de pr&eacute;cision pour fournir une
        valeur exacte pour un entier.
        <warning>
         <simpara>
          Aucune alerte, m&ecirc;me pas le plus petit message ne
          sera affich&eacute; dans ce cas.
         </simpara>
        </warning>
       </para>
       <warning>
        <para>
         Ne transformez jamais une fraction inconnue en entier, car cela
         peut conduire &agrave; des r&eacute;sultats irrationnels.
         <informalexample>
          <programlisting role="php">
<![CDATA[
<?php
  echo (int) ( (0.1+0.7) * 10 );
// affiche 7!
?>
]]>
         </programlisting>
        </informalexample>
        Pour plus d'informations, reportez-vous aux
        <link linkend="warn.float-precision">alertes</link> li&eacute;es
        aux nombres &agrave; virgule flottante.
       </para>
      </warning>
      </sect3>
      <sect3 id="language.types.integer.casting.from-string">
       <title>A partir de cha&icirc;nes</title>
       <simpara>
        Reportez-vous &agrave; la section des
        <link linkend="language.types.string.conversion">conversions de 
        cha&icirc;nes</link>.
       </simpara>
      </sect3>
      <sect3 id="language.types.integer.casting.from-other">
       <title>Conversion d'autres types</title>
       <para>
        La conversion d'autres types en entier est ind&eacute;finie.
        Actuellement, PHP convertit d'abord la valeur en
        <link linkend="language.types.boolean.casting">bool&eacute;en</link>.
        <caution>
         <simpara>
          Mais, ne vous fiez pas &agrave; ce comportement, car il
          est susceptible de changer sans pr&eacute;avis!
         </simpara>
        </caution>
       </para>
    <para>
     Voir aussi :
     <link linkend="ref.gmp">Nombres de grande taille</link> et
     <link linkend="language.types.float">Nombres &agrave; virgules flottantes</link>.
    </para>
       <!--
        IMO, it would more sense as (int) $arr returned the
        number of elements in $arr. This won't break anything,
        since this behaviour was never defined before, and
        (bool)(int) $arr will still behave the same.
        -->
    </sect3>
   </sect2>
  </sect1>
  <sect1 id="language.types.float">
   <title>Les nombres &agrave; virgule flottante</title>
   <para>
    Les nombres &agrave; virgule flottante (connus aussi sous le
    vocable de "<literal>double</literal>" ou "<literal>float</literal>"
    "<literal>nombre r&eacute;&eacute;ls</literal>") peuvent &ecirc;tre
    sp&eacute;cifi&eacute;s en utilisant la syntaxe suivante :
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
  $a = 1.234;
  $a = 1.2e3;
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <warning id="warn.float-precision">
    <title>Pr&eacute;cision des nombres &agrave; virgule flottante</title>
    <para>
     Il est fr&eacute;quent que de simples fractions d&eacute;cimales telles que
     <literal>0.1</literal> ou <literal>0.7</literal> ne puissent
     &ecirc;tre converties au format interne binaire sans une l&eacute;g&egrave;re perte
     de pr&eacute;cision. Cela peut conduire &agrave; des r&eacute;sultats &eacute;tonnants :
     par exemple, <literal>floor((0.1+0.7)*10)</literal> retournera
     <literal>7</literal> au lieu de <literal>8</literal>
     car le r&eacute;sultat de la repr&eacute;sentation interne est
     <literal>7.9999999999...</literal>.
    </para>
    <para>
     Tout ceci est li&eacute; au fait qu'il est impossible d'exprimer
     certaines fractions en un nombre fini de chiffres. Par exemple
     <literal>1/3</literal> s'&eacute;crira <literal>0.3333333...</literal>
     en mode d&eacute;cimal.
    </para>
    <para>
     Ne faites donc jamais confiance aux nombres &agrave; virgule
     jusqu'&agrave; leur derni&egrave;re d&eacute;cimale, et ne comparez
     jamais ces nombres avec l'op&eacute;rateur d'&eacute;galit&eacute;.
     Si vous avez besoin d'une pr&eacute;cision particuli&egrave;re,
     reportez-vous au traitement des nombres de grande taille avec les
     librairies <link linkend="ref.bc">BC</link> ou <link linkend="ref.gmp">GMP</link>.
    </para>
   </warning>
   <sect2 id="language.types.float.casting">
    <title>Conversion d'un nombre &agrave; virgule flottante</title>
    
    <para>
     Pour savoir quand et comment des cha&icirc;nes sont converties en
     nombre &agrave; virgule flottante, voyez la section 
     <link linkend="language.types.string.conversion">Conversion de cha&icirc;nes de caract&egrave;res</link>. 
     Pour les valeurs d'autres types, la conversion est la m&ecirc;me
     que si la valeur &eacute;tait d'abord convertie en entier, puis en 
     nombre d&eacute;cimal. Voyez la section <link linkend="language.types.integer.casting">Conversion d'un entier</link>.
    </para>
   </sect2>
  </sect1>
  <sect1 id="language.types.string">
   <title>Les cha&icirc;nes de caract&egrave;res</title>
   <para>
    Les cha&icirc;nes de caract&egrave;res sont des s&eacute;quences de caract&egrave;res.
    En PHP, un caract&egrave;re est un octet, et il y en 256 de possibles.
    PHP n'a pas (encore?) de support natif d'Unicode.
    <!-- how about unicode? will we support that eventually? Are
    there current any ways to work with unicode?
    -->
   </para>
   <note>
    <simpara>
     La taille n'est pas un probl&egrave;me majeur pour une cha&icirc;ne.
     Elle peut devenir tr&egrave;s grande sans probl&egrave;me. Il n'y a
     pas &agrave; s'en faire pour cela.
    </simpara>
   </note>
   <sect2 id="language.types.string.syntax">
    <title>Syntaxe</title>
    <para>
     Une cha&icirc;ne peut &ecirc;tre sp&eacute;cifi&eacute;e de trois mani&egrave;res
     diff&eacute;rentes :
     <itemizedlist>
      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.single">guillemets simples</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.double">guillemets doubles</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.heredoc">syntaxe HereDoc</link>
       </simpara>
      </listitem>
     </itemizedlist>
    </para>
    <sect3 id="language.types.string.syntax.single">
     <title>Guillemets simples</title>
     <para>
      Le moyen le plus simple de sp&eacute;cifier une cha&icirc;ne de caract&egrave;res
      est d'utiliser les guillemets simples : <literal>'</literal>.
     </para>
     <para>
      Pour sp&eacute;cifier un guillemet simple litt&eacute;ral, vous devez
      l'&eacute;chapper avec un anti-slash (<literal>\</literal>), comme dans de nombreux
      langages. Si un anti-slash doit appara&icirc;tre dans votre cha&icirc;ne ou bien
      en fin de cha&icirc;ne, il faudra le doubler. Notez que si vous essayez d'&eacute;chapper n'importe
      quel autre caract&egrave;re, l'anti-slash sera conserv&eacute;! Il n'y a pas
      besoin d'&eacute;chapper d'autres caract&egrave;res que le guillemet lui-m&ecirc;me.
      <note>
       <simpara>
        En PHP 3, une alerte sera affich&eacute;e si cela arrive avec un
        niveau de rapport d'erreur de <literal>E_NOTICE</literal>.
       </simpara>
      </note>
      <note>
       <simpara>
        Contrairement aux autres syntaxes, les variables pr&eacute;sentes dans la
        cha&icirc;ne ne seront <emphasis>PAS</emphasis> remplac&eacute;es par leurs
        valeurs.
       </simpara>
      </note>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
  echo 'Ceci est une chaîne simple';
  echo 'Vous pouvez inclure des nouvelles lignes dans une chaîne,
  comme ceci.';
  echo 'Arnold a coutume de dire : "I\'ll be back"';
// affiche : ... "I'll be back"
  echo 'Etes vous sûr de vouloir effacer le dossier C:\\*.*?';
// affiche : Etes vous sûr de vouloir effacer le dossier C:\*.*?
  echo 'Etes vous sûr de vouloir effacer le dossier C:\*.*?';
// affiche : Etes vous sûr de vouloir effacer le dossier C:\*.*?
  echo 'Je suis en train de mettre une nouvelle ligne comme ceci : \n';
// affiche : Je suis en train de mettre une nouvelle ligne comme ceci : \n
?>
]]>
       </programlisting>
      </informalexample>
     </para>
    </sect3>
    <sect3 id="language.types.string.syntax.double">
     <title>Guillemets doubles</title>
     <para>
      Si la cha&icirc;ne est entour&eacute;e de guillemets doubles, PHP
      va comprendre certaines s&eacute;quences de caract&egrave;res :
     </para>
    <table>
     <title>Les caract&egrave;res sp&eacute;ciaux</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>S&eacute;quence</entry>
        <entry>Valeur</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>\n</literal></entry>
        <entry>Nouvelle ligne (linefeed, LF ou 0x0A (10) en ASCII)</entry>
       </row>
       <row>
        <entry><literal>\r</literal></entry>
        <entry>Retour &agrave; la ligne (<literal>carriage return</literal>, CR ou 0x0D (13) en ASCII)</entry>
       </row>
       <row>
        <entry><literal>\t</literal></entry>
        <entry>Tabulation horizontale (HT ou 0x09 (9) en ASCII)</entry>
       </row>
       <row>
        <entry><literal>\\</literal></entry>
        <entry>Antislash</entry>
       </row>
       <row>
        <entry><literal>\$</literal></entry>
        <entry>Caract&egrave;re $</entry>
       </row>
       <row>
        <entry><literal>\"</literal></entry>
        <entry>Guillemets doubles</entry>
       </row>
       <row>
        <entry><literal>\[0-7]{1,3}</literal></entry>
        <entry>
          Une s&eacute;quence de caract&egrave;res qui permet de
          rechercher un nombre en notation octale.
        </entry>
       </row>
       <row>
        <entry><literal>\x[0-9A-Fa-f]{1,2}</literal></entry>
        <entry>
          Une s&eacute;quence de caract&egrave;res qui permet de
          rechercher un nombre en notation hexad&eacute;cimale.
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   <para>
    Si vous essayez d'utiliser l'anti-slash sur n'importe quelle
    autre s&eacute;quence, l'anti-slash sera affich&eacute; dans votre cha&icirc;ne.
   </para>
    <para>
     Le plus important pour les cha&icirc;nes &agrave; guillemets doubles est le fait
     que les variables qui s'y trouvent seront remplac&eacute;es par leur valeur. 
     Voir la section sur le <link linkend="language.types.string.parsing">traitement des
     variables dans les cha&icirc;nes</link> pour plus de d&eacute;tails.
    </para>
   </sect3>
    <sect3 id="language.types.string.syntax.heredoc">
     <title>Syntaxe Heredoc</title>
   <para>
    Un autre moyen de d&eacute;limiter les cha&icirc;nes est d'utiliser
    la syntaxe de "Here doc" (en fran&ccedil;ais, documentation ici): &lt;&lt;&lt;,
    suivi d'un identifiant arbitraire, puis de la cha&icirc;ne. Cette
    s&eacute;quence se termine par l'identifiant initial, plac&eacute; en
    premier sur une nouvelle ligne.
   </para>
   <para>
    L'identifiant utilis&eacute; doit suivre
    les m&ecirc;mes r&egrave;gles que les &eacute;tiquettes PHP : il ne
    doit contenir uniquement que des caract&egrave;res alpha-num&eacute;riques,
    et des soulign&eacute;s ("_"), et enfin, commencer par un
    caract&egrave;re alphab&eacute;tique ou un soulign&eacute;.
   </para>
     <warning>
      <simpara>
       Il est tr&egrave;s important de noter que la ligne qui contient
       l'identifiant de fermeture ne doit contenir aucun autre
       caract&egrave;re, hormis, &eacute;ventuellement, un point-virgule <literal>;</literal>.
       Cela signifie notamment que l'identifiant ne doit
       pas &ecirc;tre indent&eacute;, et qu'il n'y a aucun caract&egrave;re
       blanc entre le retour &agrave; la ligne et l'identifiant,
       ou bien entre l'identifiant et le <literal>;</literal>.
      </simpara>
      <simpara>
       Le plus dur est peut &ecirc;tre qu'il ne faut pas qu'il y ait
       un retour &agrave; la ligne ((<literal>\r</literal>) &agrave; la fin de cette
       ligne, mais seulement un form-feed (<literal>\n</literal>).
       Puisque Microsoft Windows utilise la s&eacute;quence
       <literal>\r\n</literal> comme terminaison de ligne,
       la syntaxe heredoc risque de ne pas fonctionner l&agrave;. Cependant,
       la plupart des &eacute;diteurs PHP fournissent une sauvegarde
       au format UNIX.
       <!--
       FTP will sometimes automatically convert \r\n to \n while
       transferring your files to your webserver (which
       is *nix, of course)
       -->
      </simpara>
     </warning>
   <para>
    La syntaxe Here doc se comporte exactement comme une cha&icirc;ne &agrave;
    guillemets doubles, sans les guillemets doubles. Cela signifie
    que vous n'avez pas &agrave; &eacute;chapper les guillemets (simples ou doubles)
    dans cette syntaxe. Les variables sont remplac&eacute;es par leur valeur, et
    le m&ecirc;me soin doit leur &ecirc;tre apport&eacute; que dans les cha&icirc;nes
    &agrave; guillemets doubles.
    <example>
     <title>Exemple de cha&icirc;ne HereDoc</title>
     <programlisting role="php">
<![CDATA[
<?php
  $str = <<<EOD
  Exemple de chaîne
  s'étalant sur
  plusieurs lignes
  avec la syntaxe heredoc
EOD;
/* Exemple plus complexe, avec des variables. */
  class foo {
    var $foo;
    var $bar;
    function foo() {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
  }
  $foo = new foo();
  $name = 'MonNom';
  echo <<<EOT
  Mon nom est "$name". J'affiche des $foo->foo.
  Maintenant, j'affiche un {$foo->bar[1]}.
  Ceci se traduit par un 'A' majuscule: \x41
EOT;
?>
]]>
     </programlisting>
    </example>
   </para>
   <note>
    <para>
     Le support Here doc a &eacute;t&eacute; ajout&eacute; en PHP 4.
    </para>
   </note>
   </sect3>
   <sect3 id="language.types.string.parsing">
     <title>Traitement des variables dans les cha&icirc;nes</title>
     <!-- Section originale par jeroen@a-es2.uu.nl -->
     <simpara>
      Lorsqu'une cha&icirc;ne est sp&eacute;cifi&eacute;e avec des guillemets doubles,
      ou en utilisant la syntaxe heredoc,
      les variables qu'elle contient sont remplac&eacute;es par leur valeur.
     </simpara>
     <simpara>
      Il y a deux types de syntaxe, une
      <link linkend="language.types.string.parsing.simple">simple</link>
      et une
      <link linkend="language.types.string.parsing.complex">complexe</link>.
      La syntaxe simple est la plus courante, et la plus pratique : elle fournit
      un moyen d'utiliser les variables, que ce soient des cha&icirc;nes, des tableaux
      ou des membres d'objets.
     </simpara>
     <simpara>
      La syntaxe complexe a &eacute;t&eacute; introduite en PHP 4
      <!-- XXX was it? and starting with what version exactly? -->
      et peut &ecirc;tre reconnue gr&acirc;ce aux accolades entourant les expressions.
     </simpara>
     <sect4 id="language.types.string.parsing.simple">
      <title>Syntaxe simple</title>
      <simpara>
       D&egrave;s qu'un signe dollar <literal>$</literal> est rencontr&eacute;, l'analyseur
       PHP va lire autant de caract&egrave;re qu'il peut pour former un nom de
       variable valide. Entourez le nom de la variable avec des accolades
       pour indiquer explicitement son nom.
      </simpara>
      <example>
      <title>Utilisation des accolades <literal>{}</literal> dans les cha&icirc;nes</title>
       <programlisting role="php">
 <![CDATA[
<?php
  $boisson = 'vin';
  echo "Du $boisson, du pain et du fromage!";
 // OK, car "," n'est pas autorisé dans les noms de variables
  echo "Il a goûté plusieurs $boissons";
 // Pas OK, car 's' peut faire partie d'un nom de variable, et PHP recherchera alors $boissons
  echo "Il a goûté plusieurs ${boisson}s";
 // OK
?>
]]>
       </programlisting>
      </example>
      <simpara>
       Similairement, vous pouvez aussi utiliser un &eacute;l&eacute;ment
       de tableau, ou un membre d'objet. Pour les &eacute;l&eacute;ments
       de tableau, le crochet fermant '<literal>]</literal>'
       marquera la fin du nom de la variable. Pour les
       membres d'objets, les m&ecirc;mes r&egrave;gles que ci-dessus
       s'appliquent. Cependant, il n'existe pas de truc comme
       pour les variables simples.
       <!-- XXX isn't TRUE :(, this would be the trick
       Also,
       the same trick with curly-braces works if you
       want to limit the greediness of parsers (aren't they
       paying them enough or something?).
       -->
      </simpara>
      <example>
      <title>Utilisation des accolades <literal>{}</literal> dans les cha&icirc;nes pour les tableaux</title>
       <programlisting role="php">
<![CDATA[
<?php
// Ces exemples sont spécifiques à l'utilisation de tableaux dans une chaîne.
// Lorsque vous êtes hors d'une chaîne, utilisez toujours des guillemets
// autour des index de tableau, et n'utilisez pas d'{accolades}.

// Affichons toutes les erreurs
error_reporting(E_ALL);

$fruits = array('fraise' => 'rouge', 'banane' => 'jaune');

// Fonctionne mais notez que cela fonctionne pas comme 
// si cela était hors d'une chaîne
echo "Une banane est $fruits[banane].";

// Fonctionne
echo "Une banane est {$fruits['banane']}.";

// Fonctionne mais PHP cherche une constante appelée banane
// tel que décrit ci-dessous
echo "Une banane est {$fruits[banane]}.";

// Ne fonctionne pas, il manque les accolades. Cela donne une erreur d'analyse
echo "Une banane est  $fruits['banane'].";

// Fonctionne
echo "Une banane est " . $fruits['banane'] . ".";

// Fonctionne
echo "Ce carré a un coté de $square->width mètres de large.";

// Ne fonctionne pas. Pour une solution, voyez la syntaxe complexe.
echo "Ce carré a un côté de $square->width00 centimètres.";
?>
]]>
       </programlisting>
      </example>
      <simpara>
       Pour tout ce qui sera plus compliqu&eacute;, voyez la syntaxe complexe.
      </simpara>
     </sect4>
     <sect4 id="language.types.string.parsing.complex">
      <title>Syntaxe complexe</title>
      <simpara>
       La syntaxe est dite "complexe" car elle permet l'utilisation d'
       expressions complexes, et non pas parcequ'elle serait obscure.
       Nuance.
     </simpara>
     <simpara>
      En fait, vous pouvez inclure n'importe quelle valeur qui est
      dans l'espace de nom avec cette syntaxe. Il suffit d'&eacute;crire une
      expression exactement comme si elle &eacute;tait hors de la cha&icirc;ne,
      puis de l'entourer d'accolades <literal>{}</literal>. Puisque
      vous ne pouvez pas &eacute;chapper les accolades, cette syntaxe ne commence
      qu'&agrave; partir du signe dollar, qui suit imm&eacute;diatement l'accolade
      ouvrante. Par exemple, vous pouvez utiliser <literal>"{\$"</literal>
      pour obtenir un <literal>"{$"</literal> litt&eacute;ral. Voici quelques
      exemples :
     </simpara>
     <example>
     <title>Syntaxe complexe de cha&icirc;ne</title>
      <programlisting role="php">
<![CDATA[
<?php
// Affichons toutes les erreurs
error_reporting(E_ALL);

$super = 'fantastique';

// Ne fonctionne pas. Affiche : Ceci est { fantastique}
echo "Ceci est { $super}";

// Fonctionne. Affiche Ceci est fantastique
echo "Ceci est {$super}";
echo "Ceci est ${super}";

// Fonctionne
echo "Ce carré a un coté de {$square->width}00 centimètres."; 

// Fonctionne
echo "Ceci fonctionne : {$arr[4][3]}";

// Ceci est faut pour la même raison que $foo[bar] est faux
// hors d'une chaîne. En d'autres terme, cela va fonctionne
// car PHP recherche d'abord une constante appelée foo, mais
// il générera une note E_NOTICE (undefined constant).
echo "Ceci est faux : {$arr[foo][3]}"; 

// Fonctionne. Lorsque vous utilisez un tableau multidimensionnel dans
// une chaîne, n'oubliez jamais les accolades.
echo "Ceci fonctionne : {$arr['foo'][3]}";

// Fonctionne
echo "Ceci fonctionne : " . $arr['foo'][3];

echo "Vous pouvez même écrire {$obj->values[3]->name}";

echo "Ceci est une valeur de variable variable : {${$name}}";
?>
]]>
       </programlisting>
      </example>
     </sect4>
    </sect3>
    <sect3 id="language.types.string.substr">
     <title>Acc&egrave;s aux caract&egrave;res d'une cha&icirc;ne</title>
     <para>
      Les caract&egrave;res d'une cha&icirc;ne sont accessibles en sp&eacute;cifiant
      leur offset (le premier caract&egrave;re est d'offset 0) entre
      accolade, apr&egrave;s le nom de la variable.
     </para>
     <note>
      <simpara>
       Pour assurer la compatibilit&eacute; ascendante, vous pouvez
       toujours acc&eacute;der aux caract&egrave;res avec des crochets.
       Mais cette syntaxe est obsol&egrave;te en PHP 4.
      </simpara>
     </note>
     <para>
      <example>
       <title>Exemples de cha&icirc;nes</title>
       <programlisting role="php">
<![CDATA[
<?php
// Lit le premier caractère de la chaîne
$str = 'Ceci est un test.';
$first = $str{0};

// Lit le troisième caractère de la chaîne
$third = $str{2};

// Lit le dernier caractère de la chaîne
$str = 'Ceci est un test.';
$last = $str{strlen($str)-1}; 
?>
]]>
       </programlisting>
      </example>
     </para>
    </sect3>
   </sect2><!-- end syntax -->
   <sect2 id="language.types.string.useful-funcs">
    <title>Fonctions et op&eacute;rateurs pratiques</title><!-- and operators -->
    <para>
     Les cha&icirc;nes peuvent &ecirc;tre concat&eacute;n&eacute;es avec l'op&eacute;rateur '.' (point).
     Notez que l'op&eacute;rateur d'addition '+' (plus) ne fonctionnera pas.
     Reportez-vous &agrave; la section
     <link linkend="language.operators.string">op&eacute;rateurs de cha&icirc;nes</link>.
    </para>
    <para>
     Il y a une grande quantit&eacute; de fonctions pratiques pour modifier
     les cha&icirc;nes.
    </para>
    <simpara>
     Reportez-vous &agrave; la section <link linkend="ref.strings">cha&icirc;nes de caract&egrave;res</link>
     pour les fonctions les plus g&eacute;n&eacute;rales, &agrave; <link linkend="ref.pcre">Expressions
     r&eacute;guli&egrave;res Perl</link> et <link linkend="ref.regex">Expressions r&eacute;guli&egrave;res
     POSIX &eacute;tendues</link> pour les recherches et remplacements.
    </simpara>
    <simpara>
     Il y a aussi les fonctions sur les <link linkend="ref.url">URL</link>,
     ainsi que des fonctions de chiffrage (<link linkend="ref.mcrypt">mcrypt</link> et
     <link linkend="ref.mhash">mhash</link>).
    </simpara>
    <simpara>
     Finalement, si vous ne trouvez toujours pas votre bonheur, il y a les
     fonctions de <link linkend="ref.ctype">types de caract&egrave;res</link>.
    </simpara>
   </sect2>
   <sect2 id="language.types.string.casting">
    <title>Conversion en une cha&icirc;ne de caract&egrave;res</title>
    
    <para>
     Vous pouvez convertir une valeur en une cha&icirc;ne de caract&egrave;res en utilisant l'op&eacute;rateur
     <literal>(string)</literal>, ou bien la fonction <function>strval</function>.
     La conversion en cha&icirc;ne de caract&egrave;res est automatiquement faite dans
     toutes les situations qui n&eacute;cessitent une cha&icirc;ne de caract&egrave;res.
     Cela arrive lorsque vous utilisez des fonctions comme <function>echo</function>
     ou <function>print</function>, ou encore lorsque vous comparez une valeur
     avec une cha&icirc;ne de caract&egrave;res.
    </para>
    
    <para>
     Le bool&eacute;en &true; est converti en la cha&icirc;ne de caract&egrave;res <literal>"1"</literal>,
     et le bool&eacute;en &false; est repr&eacute;sent&eacute; par la cha&icirc;ne de caract&egrave;res vide 
     <literal>""</literal>. De cette fa&ccedil;on, vous pouvez convertir des 
     bool&eacute;ens en cha&icirc;ne de caract&egrave;res et vice-versa.
    </para>
    <para> 
     Un entier ou un nombre &agrave; virgule flottante est converti en une
     cha&icirc;ne de caract&egrave;res qui repr&eacute;sente ce nombre en d&eacute;cimal (y compris
     l'exposant des nombres &agrave; virgule flottante).
    </para>
    <para>
     Les tableaux sont toujours convertis en la cha&icirc;ne de caract&egrave;res <literal>"Array"</literal>,
     ce qui fait que vous ne pouvez pas afficher le contenu d'un tableau avec la fonction
     <function>echo</function> ou <function>print</function>. Voyez 
     les informations ci-dessous pour plus de conseils.
    </para>
    <para>
     Les objets sont automatiquement convertis en la cha&icirc;ne de caract&egrave;res 
     <literal>"Object"</literal>. Si vous souhaitez afficher le membre
     d'un objet, lisez le paragraphe ci-dessous. Si vous voulez conna&icirc;tre
     le nom de la classe de cet objet, utilisez la fonction
     <function>get_class</function>.  
    </para>
    <para>
     Les ressources sont toujours converties en cha&icirc;ne de caract&egrave;res 
     <literal>"Resource id #1"</literal> o&ugrave; <literal>1</literal> est
     le nombre unique repr&eacute;sentant la ressource, assign&eacute; par &php; au moment
     de l'ex&eacute;cution. Si vous souhaitez conna&icirc;tre le type d'une ressource,
     utilisez <function>get_resource_type</function>.
    </para>
    <para>
     &null; est toujours converti en une cha&icirc;ne de caract&egrave;res vide.
    </para>
    
    <para>
     Comme vous pouvez le voir, afficher des tableaux, des objets ou des ressources
     n'est pas pertinent par cette m&eacute;thode. Reportez-vous aux fonctions
     <function>print_r</function> et <function>var_dump</function> pour
     avoir des outils plus pratiques.
    </para>
    
    <para>
     Vous pouvez aussi convertir des valeurs &php; en cha&icirc;nes pour les
     sauver dans un stockage. Cette m&eacute;thode est appel&eacute;e la lin&eacute;arisation,
     et peut &ecirc;tre exploit&eacute;e avec la fonction <function>serialize</function>. 
     Vous pouvez aussi lin&eacute;ariser des valeurs &php; en structure 
     XML si vous avez le support <link linkend="ref.wddx">WDDX</link>.
    </para>
   </sect2>
   <sect2 id="language.types.string.conversion">
    <title>Conversion de cha&icirc;nes de caract&egrave;res</title>
    <simpara>
      Lorsqu'une cha&icirc;ne de caract&egrave;re est
      &eacute;valu&eacute;e comme une valeur num&eacute;rique,
      le r&eacute;sultat et le type de la variable sont
      d&eacute;termin&eacute;s comme suit.
    </simpara>
    <simpara>
      La cha&icirc;ne de caract&egrave;res est de type "double" si
      elle contient un des caract&egrave;res '.', 'e' ou 'E'. Sinon,
      elle est de type entier ("integer").
    </simpara>
    <para>
      La valeur est d&eacute;finie par la premi&egrave;re partie
      de la cha&icirc;ne. Si la cha&icirc;ne de caract&egrave;res
      d&eacute;bute par une valeur num&eacute;rique cette valeur
      sera celle utilis&eacute;e. Sinon, la valeur sera &eacute;gale
      &agrave; 0 (z&eacute;ro).
    </para>
    <simpara>
      Lorsque la premi&egrave;re expression est une cha&icirc;ne de
      caract&egrave;res, le type de la variable d&eacute;pend de la
      seconde expression.
    </simpara>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
  $foo = 1 + "10.5";              // $foo est du type  float (11.5)
  $foo = 1 + "-1.3e3";            // $foo est du type  float (-1299)
  $foo = 1 + "bob-1.3e3";         // $foo est du type  integer (1)
  $foo = 1 + "bob3";              // $foo est du type  integer (1)
  $foo = 1 + "10 petits cochons";     // $foo est du type  integer (11)
  $foo = 1 + "10 gros cochons"; // $foo est du type  integer (11)
  $foo = "10.0 cochons " + 1;        // $foo est du type  integer (11)
  $foo = "10.0 cochons " + 1.0;      // $foo est du type  float (11)
?>
]]>
     </programlisting>
    </informalexample>
    <simpara>
      Pour plus d'informations sur les conversions de type, voir les
      pages de manuel Unix &agrave; propos de la fonction strtod(3).
    </simpara>
    <para>
     Si vous voulez tester l'un des exemples de cette section,
     vous pouvez faire un copier/coller et l'ins&eacute;rer dans un script
     pour voir comment il se comporte.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
  echo "\$foo==$foo; type is " . gettype( $foo ) . "<br>\n";
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </sect2>
  </sect1>
  <sect1 id="language.types.array">
   <title>Les tableaux</title>
   <para>
    Un tableau PHP est en fait une association ordonn&eacute;e (map). Une
    association est un type qui fait correspondre des valeurs
    &agrave; des <emphasis>cl&eacute;s</emphasis>.  Ce type est optimis&eacute;
    de diverses fa&ccedil;ons, qui font que vous pouvez le manipuler comme
    un tableau &agrave; indices r&eacute;els, une liste (vecteur), ou un table
    de hachage (qui est une impl&eacute;mentation d'association),
    dictionnaire, collection, pile, queue et encore d'autres.
    Comme une valeur peut elle-m&ecirc;me &ecirc;tre un tableau, vous pouvez
    simuler facilement un arbre.
   </para>
    <para>
     Les d&eacute;tails d'impl&eacute;mentation de ces structures sont hors du
     champs de ce manuel, mais vous trouverez ici un exemple
     de toutes ces structures.
    </para>
   <sect2 id="language.types.array.syntax">
    <title>Syntaxe</title>
    <sect3 id="language.types.array.syntax.array-func">
     <title>Cr&eacute;er un tableau <function>array</function></title>
     <para>
      Un tableau <type>array</type> peut &ecirc;tre cr&eacute;&eacute; avec la fonction
      <function>array</function>. Cette fonction prend en argument
      des structures <literal><replaceable>key</replaceable> =>
      <replaceable>value</replaceable></literal>, s&eacute;par&eacute;es par des virgules.
     </para>
     <para>
      <synopsis>
array( <optional> <replaceable>key</replaceable> =&gt; </optional> 
<replaceable>value</replaceable> , ... )
// <replaceable>key</replaceable> est soit une <type>string</type> 
soit un <type>integer</type> positif
// <replaceable>value</replaceable> peut &ecirc;tre n'importe quoi
      </synopsis>
     </para>
     <para>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$arr = array("foo" => "bar", 12 => true);

echo $arr["foo"]; // bar
echo $arr[12];    // 1
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      Une cl&eacute; <varname>key</varname> est soit un entier
      ou bien une cha&icirc;ne.
      Si une cl&eacute; est la repr&eacute;sentation standard d'un entier positif,
      elle sera interpr&eacute;t&eacute;e comme tel. (i.e. <literal>'8'</literal> sera
      interpr&eacute;t&eacute; comme <literal>8</literal>, tandis que <literal>'08'</literal>
      sera interpr&eacute;t&eacute; comme <literal>'08'</literal>).
     </para>
     <para>
      Une valeur peut &ecirc;tre n'importe quoi.
      <example>
       <title>Cr&eacute;ation d'un tableau</title>
       <programlisting role="php">
<![CDATA[
<?php
  array("untableau" => array(6 => 5, 13 => 9, "a" => 43));

echo $arr["untableau"][6];    // 5
echo $arr["untableau"][13];   // 9
echo $arr["untableau"]["a"];  // 43
  
?>
]]>
       </programlisting>
      </example>
     </para>
      <para>
       Si vous omettez une cl&eacute; lors de la sp&eacute;cification d'un tableau,
       l'indice maximum + 1 sera utilis&eacute; comme cl&eacute; par d&eacute;faut. Si aucun
       indice num&eacute;rique n'a &eacute;t&eacute; g&eacute;n&eacute;r&eacute;, ce sera 0. 
       Si vous en sp&eacute;cifiez une qui a d&eacute;j&agrave; &eacute;t&eacute; assign&eacute;e,
       la nouvelle valeur &eacute;crasera la pr&eacute;c&eacute;dente.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// Ce tableau est identique à 
array(5 => 43, 32, 56, "b" => 12);

// Celui ci
array(5 => 43, 6 => 32, 7 => 56, "b" => 12);
?>
]]>
       </programlisting>
      </informalexample>
      </para>
     <para>
      Utiliser &true; comme cl&eacute; revient &agrave; utiliser le type
      <type>integer</type> de valeur <literal>1</literal>.
      Utiliser &false; comme cl&eacute; revient &agrave; utiliser le type
      <type>integer</type> de valeur <literal>0</literal>.
      Utiliser &null; comme cl&eacute; revient &agrave; utiliser le type
      <type>string</type> de valeur <literal>""</literal>.
      Utiliser la cha&icirc;ne vide comme index va cr&eacute;er cet index,
      et ce n'est pas la m&ecirc;me chose que d'utiliser des 
      crochets vides.
     </para>
     <para>
      Il n'est pas possible d'utiliser des tableaux ou des objets comme
      cl&eacute;s. Ce faisant, vous g&eacute;n&eacute;reriez une alerte : 
      <literal>Illegal offset type</literal>.
     </para>
    </sect3>
    <sect3 id="language.types.array.syntax.modifying">
     <title>La syntaxe &agrave; crochets</title>
     <para>
      Vous pouvez aussi modifier un tableau existant en lui assignant
      simplement des valeurs.
     </para>
     <para>
      L'assignation de valeurs de tableau se fait en sp&eacute;cifiant la cl&eacute;
      entre crochets. Si vous omettez la cl&eacute; ("<literal>$tableau[]</literal>"),
      la valeur sera ajout&eacute;e &agrave; la fin du tableau.
      <synopsis>
$arr[<replaceable>key</replaceable>] = <replaceable>value</replaceable>;
$arr[] = <replaceable>value</replaceable>;
// <replaceable>key</replaceable> est soit une cha&icirc;ne, soit un entier
// <replaceable>value</replaceable> peut &ecirc;tre n'importe quoi
      </synopsis>
      Si <varname>$arr</varname> n'existe pas, il sera cr&eacute;&eacute;. Cela
      en fait une alternative pour cr&eacute;er un tableau. Pour modifier une
      valeur, assignez-lui une nouvelle valeur. Pour supprimer une
      valeur, utilisez la fonction <function>unset</function>.
      <example>
       <title>Manipuler des &eacute;l&eacute;ments de tableau</title>
       <programlisting role="php">
<![CDATA[
<?php
$arr = array(5 => 1, 12 => 2);

$arr[] = 56;    // Ceci revient à $arr[13] = 56;
                // à ce moment du script

$arr["x"] = 42; // Ceci ajoute un nouvel élément
                // avec l'index "x"
                
unset($arr[5]); // Ceci efface un élément du tableau

unset($arr);    // Ceci efface tout le tableau
?>
]]> 
       </programlisting>
      </example>
     </para>
    </sect3>
   </sect2><!-- end syntax -->
   <sect2 id="language.types.array.useful-funcs">
    <title>Fonctions pratiques</title>
    <para>
     Il y a toute une panoplie de fonctions pratiques pour travailler
     avec les tableau : <link linkend="ref.array">array-functions</link>.
    </para>
    <note>
     <para>
      La fonction <function>unset</function> permet d'effacer des 
      index dans un tableau. Sachez bien que le tableau ne sera PAS
      r&eacute;index&eacute;. Si vous utilisez uniquement des index num&eacute;riques
      (commen&ccedil;ant &agrave; z&eacute;ro, et incr&eacute;ment&eacute;s de un), vous pouvez effectuer
      la r&eacute;indexation en utilisant <function>array_values</function>.
      <example>
       <title>Manipuler des &eacute;l&eacute;ments de tableau</title>
       <programlisting role="php">
<![CDATA[
<?php
$a = array(1 => 'un', 2 => 'deux', 3 => 'trois');
unset($a[2]);
/* Cela va produire un tableau qui aurait été 
   $a = array(1 => 'un', 3 => 'trois');
   et non pas
   $a = array(1 => 'un', 2 =>'trois');
*/

$b = array_values($a);
// Maintenant b est le tableau array(1 => 'un', 2 =>'trois')
?>
]]>
      </programlisting>
     </example>
     </para>    
    </note> 
    <para>
     L'&eacute;l&eacute;ment de langage <link linkend="control-structures.foreach">foreach</link>
     est sp&eacute;cifiquement d&eacute;di&eacute; aux tableaux : il permet de passer en
     revue simplement les valeurs d'un tableau.
    </para>
   </sect2>
   <sect2 id="language.types.array.donts">
    <title>Attention aux tableaux</title>
    <sect3 id="language.types.array.foo-bar">
     <title>Pourquoi est ce que <literal>$foo[bar]</literal> est invalide?</title>
     <para>
      Dans vos vieux scripts, vous pouvez avoir utilis&eacute; la syntaxe suivante :
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
  $foo[bar] = 'ennemi';
  echo $foo[bar];
?>
]]>
       </programlisting>
      </informalexample>
      Cela est mauvais, mais ca marche. Pourquoi est-ce mauvais? La raison
      est que PHP attend une constante entre crochets (bar) plut&ocirc;t qu'une cha&icirc;ne
      ('bar', notez les guillemets). Or, PHP pourrait d&eacute;finir dans le futur des
      constantes qui, malheureusement pour votre code, auront ce nom. Actuellement,
      cela fonctionne car la constante ind&eacute;finie est transform&eacute;e en cha&icirc;ne ayant la
      m&ecirc;me valeur.
     </para>
     <para>
      D'autres exemples : 
      <example>
      <title>Exemples de conflits de constantes ind&eacute;finies</title>
       <programlisting role="php">
<![CDATA[
<?php
// Affichons toutes les erreurs
error_reporting(E_ALL);

$arr = array('fruit' => 'pomme', 'légume' => 'carotte');

// Correct
print $arr['fruit'];  // pomme
print $arr['légume']; // carotte

// Incorrect.  Cela fonctionne mais PHP affiche une alerte car
// il y a utilisation d'une constante indéfinie appelée fruit
// 
// Notice: Use of undefined constant fruit - assumed 'fruit' in...
print $arr[fruit];    // pomme

// Définissons une constante pour illustrer le problème.
// Nous créons une constante appelée fruit, qui vaut 'légume'.
define('fruit','légume');

// Notez la différence
print $arr['fruit'];  // pomme
print $arr[fruit];    // carotte

// La suite est correcte si cela se passe dans une chaîne. 
// Les constantes ne sont pas remplacées par leur valeur dans une chaîne
print "Bonjour $arr[fruit]";      // Bonjour pomme

// A une exception, les accolades entourant un tableau dans une chaîne
// permettent d'utiliser les constantes
print "Bonjour {$arr[fruit]}";    // Bonjour carotte
print "Bonjour {$arr['fruit']}";  // Bonjour pomme

// Ceci ne fonctionnera pas, et donnera une erreur d'analyse
// Parse error: parse error, expecting T_STRING' or T_VARIABLE' or T_NUM_STRING'
// Cela s'applique aussi aux autoglobales dans les chaînes
print "Bonjour $arr['fruit']";
print "Bonjour $_GET['foo']";

// La concatenation est une alternative
print "Bonjour " . $arr['fruit']; // Bonjour pomme
?>
]]>
       </programlisting>
      </example>
     </para>
     <para>
      Lorsque vous activez le <function>error_reporting</function> pour afficher
      les erreurs de niveau <constant>E_NOTICE</constant> (en utilisant
      le niveau <constant>E_ALL</constant>) alors, vous verrez ces erreurs.
      Par d&eacute;faut, <link linkend="ini.error-reporting">error_reporting</link> 
      est trop faible pour les afficher.
     </para>
     <para>
      Comme indiqu&eacute; dans la section <link linkend="language.types.array.syntax">syntaxe</link>,
      il doit y avoir une expression entre les crochets 
      ('<literal>[</literal>' et '<literal>]</literal>').
      Cela signifie que vous pouvez &eacute;crire ceci : 
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
echo $arr[somefunc($bar)];
?>
]]>
       </programlisting>
      </informalexample>
      Ceci est un exemple d'utilisation de retour de fonction comme
      index de tableau. &php; reconnait aussi les constantes, comme
      la famille des <literal>E_*</literal>.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$error_descriptions[E_ERROR]   = "Une erreur fatale est survenue";
$error_descriptions[E_WARNING] = "PHP émet une alerte";
$error_descriptions[E_NOTICE]  = "Ceci est juste une alerte informationnelle";
?>
]]>
       </programlisting>
      </informalexample>
      Notez que <literal>E_ERROR</literal> est aussi un identifiant valide,
      tout comme <literal>bar</literal> dans le premier exemple. Mais le dernier
      exemple est identique &agrave; ceci : 
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$error_descriptions[1] = "Une erreur fatale est survenue";
$error_descriptions[2] = "PHP émet une alerte";
$error_descriptions[8] = "Ceci est juste une alerte informationnelle";
?>
]]>
       </programlisting>
      </informalexample>
      car <literal>E_ERROR</literal> vaut <literal>1</literal>, etc...
     </para>
     <para>
      Comme nous l'avons d&eacute;j&agrave; expliqu&eacute; dans les exemples ci-dessus,
      <literal>$foo[bar]</literal> fonctionne mais est dangereux.
      Cela fonctionne car <literal>bar</literal> est identifi&eacute; comme une
      constante. Mais, si la constante n'existe pas, &php; suppose
      que vous souhaitez utiliser <literal>bar</literal> litteralement,
      sous la forme <literal>"bar"</literal>, mais que vous avez oubli&eacute; les
      guillemets.
     </para>
     <sect4>
      <title>Pourquoi est-ce aussi dangereux?</title>
      <para>
       A l'avenir, le groupe &php; peut d&eacute;cider d'ajouter une constante ou
       un autre mot cl&eacute;, ou bien vous souhaiterez aussi ajouter une
       constante dans votre application, et vous serez bloqu&eacute;. Par exemple,
       vous ne pouvez pas utiliser des mots comme <literal>empty</literal> et 
       <literal>default</literal> de cette mani&egrave;re, car il sont d&eacute;j&agrave; 
       <link linkend="reserved">r&eacute;serv&eacute;s</link>.
      </para>
      <note>
       <simpara>
        Pour insister, &agrave; l'int&eacute;rieur d'une cha&icirc;ne de caract&egrave;res 
	(<type>string</type>) &agrave; guillemets doubles, il est correct de ne pas utiliser
	les guillemets simples dans les index, et <literal>"$foo[bar]"</literal> est valide.
	Voyez les exemples ci-dessus pour plus de d&eacute;tails sur la syntaxe des
        <link linkend="language.types.string.parsing">variables dans les cha&icirc;nes</link>.
       </simpara>
      </note>
     </sect4>
    </sect3>
   </sect2>
   <sect2 id="language.types.array.casting">
    <title>Conversion en tableau</title>
    
    <para>
     Pour les types scalaires (<type>integer</type>, <type>float</type>, 
     <type>string</type>, <type>boolean</type> et <type>resource</type>),
     convertir une valeur en tableau retourne un tableau qui contient un
     &eacute;l&eacute;ment (&agrave; l'index 0) qui est la valeur originale.
    </para>
    
    <para>
     Si vous convertissez un tableau en objet, vous obtiendrez des propri&eacute;t&eacute;s
     ou bien cet objet comme &eacute;l&eacute;ments de tableau. Les cl&eacute;s cr&eacute;&eacute;es sont les
     noms des membres.
    </para>
    
    <para>
     Si vous convertissez la valeur &null; en tableau, vous obtiendrez un
     tableau vide.
    </para>
   </sect2>
   <sect2 id="language.types.array.examples">
    <title>Exemples</title>
    <para>
     Le type tableau de PHP est tr&egrave;s souple. Voici quelques exemples d'utilisation :
    </para>
    <para>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// ceci
  $a = array( 'couleur' => 'rouge'
            , 'gout' => 'sucre'
            , 'forme' => 'rond'
            , 'nom'  => 'pomme'
            ,            4        // cette clé sera 0
          );
// est complétement équivalent à
  $a['couleur'] = 'rouge';
  $a['gout'] =    'sucre';
  $a['forme'] =   'rond';
  $a['nom'] =     'pomme';
  $a[]        = 4;        // cette clé sera 0
  $b[] = 'a';
  $b[] = 'b';
  $b[] = 'c';
// va créer le tableau array( 0 => 'a' , 1 => 'b' , 2 => 'c' )
// ou plus simplement array('a' , 'b' , 'c' )
?>
]]>
       </programlisting>
      </informalexample>
     </para>
    <example>
     <title>Utilisation de <function>array</function></title>
     <programlisting role="php">
<![CDATA[
<?php
// Array comme correspondance
  $map = array( 'version'    => 4
              , 'OS'         => 'Linux'
              , 'langue'       => 'français'
              , 'short_tags' => TRUE             );
// valeur strictement numériques
  $array = array( 7
                , 8
                , 0
                , 156
                , -10
                );
// ceci est la même chose que array( 0 => 7, 1 => 8, ...)
  $switching = array(         10 // clé = 0
                    , 5    =>  6
                    , 3    =>  7
                    , 'a'  =>  4
                    ,         11 // clé = 6 (index maximum : 5)
                    , '8'  =>  2 // clé = 8 (entier!)
                    , '02' => 77 // clé = '02'
                    , 0    => 12 // la valeur de la clé 10 sera remplacée par 12
                    );
// empty array
$empty = array();
?>
]]>
     </programlisting>
    </example>
    <example id="language.types.array.examples.loop">
     <title>Collection</title>
     <programlisting role="php">
<![CDATA[
<?php
  $couleurs = array('rouge','bleu','vert','jaune');
  foreach ( $couleurs as $couleur ){
    echo "Aimez-vous la couleur $couleur?\n";
  }
/* Affiche :
Aimez-vous la couleur rouge?
Aimez-vous la couleur bleu?
Aimez-vous la couleur vert?
Aimez-vous la couleur jaune?
*/
?>
]]>
     </programlisting>
    </example>
    <para>
     Notez qu'il n'est pas possible actuellement de modifier les
     valeurs d'un tableau avec une telle boucle.
      <!--
       Should be made possible, if you write:
       foreach ( $colors as &amp;$color )
       See bug#3074
      -->
     Une solution pour cela est :
     <example id="language.types.array.examples.changeloop">
      <title>Collection</title>
      <programlisting role="php">
<![CDATA[
<?php
  foreach( $couleurs as $cle => $couleur ){
// ne marche pas
//$couleur = strtoupper($couleur);
//marche :
    $couleurs[$cle] = strtoupper($couleur);
  }
  print_r($couleur);
/* Affiche :
Array
(
    [0] => ROUGE
    [1] => BLEU
    [2] => VERT
    [3] => JAUNE
)
*/
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Cet exemple cr&eacute;e un tableau d'index minimal 1.
     <example>
      <title>Tableau en 1</title>
      <programlisting role="php">
<![CDATA[
<?php
  $firstquarter  = array(1 => 'Janvier', 'Février', 'Mars');
  print_r($firstquarter);
/* Affiche:
Array
(
    [1] => 'Janvier'
    [2] => 'Février'
    [3] => 'Mars'
)
*/
?>
]]>
      </programlisting>
     </example>
    </para>
    <example>
     <title>Remplissage d'un tableau</title>
     <programlisting role="php">
<![CDATA[
<?php
// remplit un tableau avec les noms de fichiers d'un dossier
  $handle = opendir('.');
  while ( $file = readdir($handle) ){
    $files[] = $file;
  }
  closedir($handle);
?>
]]>
     </programlisting>
    </example>
    <para>
     Les tableaux sont ordonn&eacute;s. Vous pouvez modifier l'ordre des
     valeurs avec de nombreuses fonctions de classement. Voyez les
     fonctions de <link linkend="ref.array">tableaux</link>.
    </para>
    <example>
     <title>Tri de tableaux</title>
     <programlisting role="php">
<![CDATA[
<?php
  sort($files);
  print_r($files);
?>
]]>
     </programlisting>
    </example>
    <para>
     Comme une valeur de tableau peut &ecirc;tre n'importe quoi, elle
     peut aussi &ecirc;tre un autre tableau. Comme cela, vous pouvez
     avoir des tableaux multi-dimensionnels, ou r&eacute;cursifs.
    </para>
    <example>
     <title>Tableaux multi-dimensionnels, et r&eacute;cursifs</title>
     <programlisting role="php">
<![CDATA[
<?php
$fruits = array ( "fruits"  => array ( "a" => "orange",
                                       "b" => "banane",
                                       "c" => "pomme"
                                     ),
                  "nombre" => array ( 1,
                                       2,
                                       3,
                                       4,
                                       5,
                                       6,
                                     ),
                  "trou"   => array (      "premier",
                                       5 => "second",
                                            "troisième"
                                     )
                );

// Exemples d'utilisations des tableaux ci-dessus 
echo $fruits["trou"][5];    // affiche "second"
echo $fruits["fruits"]["a"]; // affiche "orange"
unset($fruits["trou"][0]);  // supprime "premier"

// Créer un tableau multidimensionnel
$juices["pomme"]["vert"] = "bon"; 
?>
]]>
     </programlisting>
    </example>
   </sect2>
  </sect1>
  <sect1 id="language.types.object">
   <title>Les objets</title>
   <sect2 id="language.types.object.init">
    <title>Initialisation d'un objet</title>
    <para>
      Pour initialiser un objet, vous devez utiliser la commande "new"
      afin de cr&eacute;er l'instance de l'objet.
     <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
class foo
{
    function faire_foo()
    {
        echo "Faisant foo."; 
    }
}

$bar = new foo;
$bar->faire_foo();
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </sect2>
   <sect2 id="language.types.object.casting">
    <title>Conversion en objet</title>
    
    <para>
     Si un objet est converti en objet, il n'est pas modifi&eacute;. Si une
     valeur d'un autre type est convertie en objet, une nouvelle instance
     de la classe <literal>stdClass</literal> sera cr&eacute;&eacute;e. Si la valeur
     &eacute;tait &null; la nouvelle instance sera vide. Pour les autres valeurs,
     un membre de l'objet appel&eacute; <literal>scalar</literal> contiendra la valeur.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
  $obj = (object) 'au revoir';
  echo $obj->scalar;  // affiche 'au revoir'
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </sect2>
  </sect1>
  <sect1 id="language.types.resource">
   <title>Ressources</title>
    <para>
     Une ressource (<literal>"resource"</literal> en anglais), est un type sp&eacute;cial,
     qui repr&eacute;sente une r&eacute;f&eacute;rence sur une ressource externe. Les
     ressources sont cr&eacute;&eacute;es par des fonctions d&eacute;di&eacute;es. Reportez
     vous &agrave; l'annexe <link linkend="resource">Types des ressources PHP</link>
     pour une liste exhaustive des fonctions cr&eacute;ant et utilisant
     ces ressources.
    </para>
    <note>
     <simpara>
      Le type de donn&eacute;es <literal>"resource"</literal> a &eacute;t&eacute; introduit en PHP 4.
     </simpara>
    </note>
   <sect2 id="language.types.resource.casting">
    <title>Conversion en ressource</title>
    
    <para>
     Comme les ressources contiennent des valeurs tr&egrave;s sp&eacute;ciales,
     comme des fichiers ouverts, des connexions aux bases de donn&eacute;es,
     des images ou n'importe quoi d'autre, vous ne pouvez pas
     convertir une valeur en ressource.
    </para>
    </sect2>
    <sect2 id="language.types.resource.self-destruct">
     <title>Lib&eacute;rer des ressources</title>
    <para>
     Gr&acirc;ce au syst&egrave;me de comptabilisation des r&eacute;f&eacute;rences
     introduit en PHP 4 (avec le moteur Zend), PHP d&eacute;tecte automatiquement
     qu'une ressource n'est plus utilis&eacute;e (comme Java). Dans ce cas,
     toutes les ressources syst&egrave;mes utilis&eacute;es par cette
     ressource sont lib&eacute;r&eacute;es automatiquement.
     <note>
      <simpara>
       Les connexions persistantes repr&eacute;sentent un cas
       particulier, elles ne seront <emphasis>PAS</emphasis>
       d&eacute;truites. Voyez
       <link linkend="features.persistent-connections">connexions persistantes</link>.
      </simpara>
     </note>
    </para>
   </sect2>
  </sect1>
  <sect1 id="language.types.null">
   <title>La valeur NULL</title>
   <para>
    La valeur sp&eacute;ciale <literal>NULL</literal> repr&eacute;sente
    l'absence de valeur. Une variable avec la valeur NULL n'a
    pas de valeur.
   </para>
   <sect2 id="language.types.null.syntax">
    <title>Syntaxe</title>
    <para>
     Il y a seulement une valeur de type NULL, et c'est la constante
     <literal>NULL</literal>, insensible &agrave; la casse.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
  $var = Null;
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <note>
     <simpara>
      La valeur NULL a &eacute;t&eacute; introduite en PHP 4.
     </simpara>
    </note>
   </sect2>
  </sect1>
  <sect1 id="language.pseudo-types">
   <title>Pseudo-types utilis&eacute;s dans cette documentation</title> 

   <sect2 id="language.types.mixed">
    <title><literal>mixed</literal></title>
    <para>
     <literal>mixed</literal> indique qu'un param&egrave;tre accepte
     plusieurs types, mais pas forc&eacute;ment tous les types.
    </para>
    <para>
     <function>gettype</function> par exemple, accepte tous les types de variables
     &php;, mais <function>str_replace</function> n'accepte que des
     &string; et des &array;.
    </para>
   </sect2>
  
   <sect2 id="language.types.number">
    <title><literal>number</literal></title>
    <para>
     <literal>number</literal> indique qu'un param&egrave;tre peut &ecirc;tre du type
     &integer; ou &float;.
    </para>
   </sect2>

   <sect2 id="language.types.callback">
    <title><literal>callback</literal></title>
    <para>
     Certaines fonctions comme par exemple <function>call_user_function</function> 
     ou <function>usort</function> accepte une fonction d&eacute;finie par 
     l'utilisateur comme fonction de callback. Les fonctions de
     callback peuvent &ecirc;tre des fonctions simples, mais aussi des
     objets ou des m&eacute;thodes statiques de classe.
    </para>
    <para>
     Une fonction &php; est pass&eacute;e simplement en indiquant son nom, sous
     forme de cha&icirc;ne de caract&egrave;res. Vous pouvez passer une fonction
     int&eacute;gr&eacute;e au langage, ou une fonction d&eacute;finie par vos soins, &agrave;
     l'exception de 
     <function>array</function>, 
     <function>echo</function>, 
     <function>empty</function>, 
     <function>eval</function>, 
     <function>exit</function>, 
     <function>isset</function>, 
     <function>list</function>, 
     <function>print</function> et
     <function>unset</function>.
    </para>
    <para>
     Une m&eacute;thode d'un objet instanci&eacute; est pass&eacute;e sous forme de &array;,
     contenat un objet comme &eacute;l&eacute;ment d'index 0, et un nom de m&eacute;thode comme
     &eacute;l&eacute;ment 1.
    </para>
    <para>
     Les m&eacute;thodes statiques de classe peuvent aussi &ecirc;tre pass&eacute;es dans l'objet
     instanci&eacute;, mais en passant le nom de la classe comme valeur de 
     l'index 0.
    </para>

    <para>
     <example>
      <title>Exemple de fonction de callback</title>
      <programlisting role="php">
<![CDATA[
<?php 

// simple callback example
function foobar() {
    echo "hello world!";
}
call_user_function("foobar"); 

// method callback examples
class foo {
  function bar() {
    echo "hello world!";
  }
}

$foo = new foo;

call_user_function(array($foo, "bar")); // object method call

call_user_function(array("foo", "bar")); // static class method call

?>
]]>
      </programlisting>
     </example>
    </para>  
   </sect2>
  </sect1>

  <sect1 id="language.types.type-juggling">
   <title>D&eacute;finition du type</title>
   <simpara>
     PHP ne n&eacute;cessite pas de d&eacute;claration explicite
     du type d'une variable. Le type d'une variable est
     d&eacute;termin&eacute; par le contexte d'utilisation.
     Par exemple, si vous assignez une cha&icirc;ne de caract&egrave;res
     &agrave; la variable <parameter>var</parameter>, var devient une
     cha&icirc;ne de caract&egrave;re. Si vous assignez un nombre
     entier &agrave; <parameter>var</parameter>, elle devient un entier.
   </simpara>
   <para>
     Un exemple de convertisseur automatique de type est l'op&eacute;rateur
     '+'. Si un des op&eacute;randes est de type double, alors tous les
     op&eacute;randes sont &eacute;valu&eacute;s comme des variables de
     type double et le r&eacute;sultat est de type double. Sinon, tous
     les op&eacute;randes sont &eacute;valu&eacute;s comme des variables
     de type entier et le r&eacute;sultat sera du type entier. Il est
     &agrave; noter que cela NE CHANGE PAS le type des op&eacute;randes.
     Le seul changement est la mani&egrave;re dont les op&eacute;randes
     sont &eacute;valu&eacute;es.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
  $foo = "0";  // $foo est une chaîne de caractères (ASCII 48)
  $foo += 2;   // $foo est maintenant du type entier (2)
  $foo = $foo + 1.3;  // $foo est maintenant du type double (3.3)
  $foo = 5 + "10 Petits cochons"; // $foo est du type entier (15)
  $foo = 5 + "10 cochonnets";     // $foo est du type entier (15)
?>
]]>
<!--
TODO: explain ++/- - behaviour with strings
examples:
 ++'001' = '002'
 ++'abc' = 'abd'
 ++'xyz' = 'xza'
 ++'9.9' = '9.0'
 ++'-3'  = '-4'
 - -'9'   = 8 (integer!)
 - -'5.5' = '5.5'
 - -'-9'  = -10 (integer)
 - -'09'  = 8 (integer)
 - -'abc' = 'abc'
-->
     </programlisting>
    </informalexample>
   </para>
   <simpara>
     Si les deux derniers exemples vous semblent obscurs ou si vous
     voulez forcer une variable a &ecirc;tre &eacute;valu&eacute;e
     avec un certain type, reportez-vous au paragraphe Conversion de
     type ci-dessous. Si vous voulez changer le type d'une variable,
     int&eacute;ressez-vous &agrave; aux fonctions de
     <link linkend="language.types.string.conversion">conversion de cha&icirc;nes</link>.
   </simpara>
   <simpara>
	Si vous voulez forcer le type d'une variable, vous pouvez
	vous reporter &agrave; la section
	<link linkend="language.types.typecasting">transtypage</link>. Si
	vous voulez changer le type d'une variable, utilisez
	<function>settype</function>.
   </simpara>
   <para>
    Pour tester les exemples de cette section, il suffit d'en faire
    un copier/coller, et d'ins&eacute;rer les lignes dans un script PHP.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
  echo "\$foo==$foo; le type est " . gettype( $foo ) . "<br>\n";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <para>
     Le comportement de la conversion automatique est actuellement
     ind&eacute;finie.
    </para>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$a = "1";     // $a est une chaîne
$a[0] = "f";  // Mais que sont les index de chaîne?
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Etant donn&eacute; que PHP supporte l'indexation de cha&icirc;ne avec des
     offsets identiques &agrave; celles des tableaux, l'exemple ci-dessus
     conduit &agrave; un probl&egrave;me : est ce que $a est un tableau,
     dont le premier &eacute;l&eacute;ment est "f", ou bien est ce que
     "f" est le premier &eacute;l&eacute;ment de la cha&icirc;ne de
     caract&egrave;res $a?
    </para>
    <para>
     Les versions courantes de &php; interpr&ecirc;te le second assignement
     comme un index de cha&icirc;ne, et donc $a devient "f", et le
     r&eacute;sultat de cette conversion automatique doit &ecirc;tre consid&eacute;r&eacute; comme
     ind&eacute;fini. &php; 4 a introduit la syntaxe avec les accolades pour
     acc&eacute;der aux caract&egrave;res d'une cha&icirc;ne. Utilisez plut&ocirc;t le code
     ci-dessous : 
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$a    = "abc"; // $a est une chaîne
$a{1} = "f";   // $a vaut maintenant "afc"
?>
]]>
      </programlisting>
     </informalexample>
     Voyez la section <link linkend="language.types.string.substr">Acc&egrave;s aux caract&egrave;res d'une cha&icirc;ne</link>
     pour plus de d&eacute;tails.
    </para>
   </note>
   <sect2 id="language.types.typecasting">
    <title>Transtypage</title>
    <para>
      La conversion de type en PHP fonctionne de la m&ecirc;me
      mani&egrave;re qu'en C: le nom du type d&eacute;sir&eacute;
      est &eacute;crit entre parenth&egrave;ses devant la variable
      &agrave; transtyper ("cast").
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
  $foo = 10;   // $foo est un entier
  $bar = (double) $foo;   // $bar est un double
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Les conversions autoris&eacute;es sont:
     <itemizedlist>
      <listitem>
       <simpara>(int), (integer) - type entier</simpara>
      </listitem>
      <listitem>
       <simpara>(bool), (boolean) - bool&eacute;en</simpara>
      </listitem>
      <listitem>
       <simpara>(real), (double), (float) - type double</simpara>
      </listitem>
      <listitem>
       <simpara>(string) - ctype cha&icirc;ne</simpara>
      </listitem>
      <listitem>
       <simpara>(array) - type tableau</simpara>
      </listitem>
      <listitem>
       <simpara>(object) - type objet</simpara>
      </listitem>
     </itemizedlist>
    </para>
    <para>
      Il est &agrave; noter que les tabulations et les espaces
      sont autoris&eacute;s &agrave; l'int&eacute;rieur des
      parenth&egrave;ses, donc les lignes suivantes sont &eacute;quivalentes:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
  $foo = (int) $bar;
  $foo = ( int ) $bar;
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <note>
     <para>
      Au lieu de transtyper une variable en cha&icirc;ne, vous pouvez aussi
      l'ins&eacute;rer entre deux guillemets doubles : 
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$foo = 10;            // $foo est un entier
$str = "$foo";        // $str est une chaîne
$fst = (string) $foo; // $fst est aussi une chaîne

// Ceci affiche : "Identique"
if ($fst === $str) {
    echo "Identique";
}
?>
]]>
      </programlisting>
     </informalexample>
     </para>
    </note>
    <para>
     Le transtypage n'a pas toujours de r&eacute;sultat pr&eacute;visible.
     Pour plus d'informations, voyez :
     <itemizedlist>
      <listitem>
       <simpara><link linkend="language.types.boolean.casting">Conversion en
        bool&eacute;en</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.integer.casting">Conversion en
        entier</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.float.casting">Conversion en
        nombre &agrave; virgule flottante</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.string.casting">Conversion en
        cha&icirc;ne de caract&egrave;res</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.array.casting">Conversion en
        tableau</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.object.casting">Conversion en
        objet</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.resource.casting">Conversion en
        ressource</link></simpara>
      </listitem>
      <!-- don't exist yet
      <listitem>
       <simpara><link linkend="language.types.null.casting">Conversion en
        &null;</link></simpara>
      </listitem>
      -->
     </itemizedlist>
    </para>
   </sect2>
  </sect1>

 </chapter>
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
indent-tabs-mode:nil
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
