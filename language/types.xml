<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.45 $ -->
<!-- EN-Revision: 1.137 Maintainer: dams Status: ready -->
  <chapter id="language.types">
  <title>Les types</title>
  <sect1 id="language.types.intro">
  <title>Introduction</title>
   <simpara>
    &php; supporte les huit types basiques suivants :
   </simpara>
   <para>
    &php; supporte quatre types scalaires :
    <itemizedlist>
     <listitem>
      <simpara>
       <link linkend="language.types.boolean">booléen</link>
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       <link linkend="language.types.integer">entier</link>
      </simpara>
     </listitem>
     <listitem>
       <simpara>
       <link linkend="language.types.float">nombre à virgule
       flottante</link>
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       <link linkend="language.types.string">chaîne de
       caractères</link>
      </simpara>
    </listitem>
   </itemizedlist>
  </para>
  <para>
   &php; supporte deux types composés :
   <itemizedlist>
    <listitem>
     <simpara>
      <link linkend="language.types.array">tableau</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.types.object">objet</link>
     </simpara>
    </listitem>
   </itemizedlist>
  </para>
  <para>
   &php; supporte deux types spéciaux :
   <itemizedlist>
    <listitem>
     <simpara>
      <link linkend="language.types.resource">ressource</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.types.null">null</link>
     </simpara>
    </listitem>
   </itemizedlist>
  </para>
  <note>
   <simpara>
    Dans ce manuel, vous rencontrerez souvent le type <literal>mixed</literal>.
    C'est un pseudo-type, qui indique que le paramètre peut
    indifféremment prendre plusieurs types.
   </simpara>

  </note>
  <simpara>
   Habituellement, le type d'une variable n'est pas déclaré
   par le programmeur. Il est décidé au moment de
   l'exécution par le &php;, en fonction du contexte dans
   lequel la variable est utilisée.
  </simpara>
  <note>
   <simpara>
    Si vous voulez vérifier le type et la valeur d'une variable
    ou d'une <link linkend="language.expressions">expression</link>, utilisez
    la fonction <function>var_dump</function>.
   </simpara>
   <para>
    Si vous souhaitez simplement une représentation lisible pour du débogage,
    utilisez la fonction <function>gettype</function>. Pour vérifier la présence
    de certains types, <emphasis>n'utilisez pas</emphasis> <function>gettype</function>, 
    mais plutôt les fonctions <literal>is_<replaceable>type</replaceable></literal>. 
    Par exemple : 
    <example>
    <title>Exemples de vérification de type de variable</title>
     <programlisting role="php">
<![CDATA[
<?php
$bool = TRUE;   // un booléen
$str  = "foo";  // une chaîne de caractères
$int  = 12;     // un entier

echo gettype($bool); // affiche "boolean"
echo gettype($str);  // affiche "string"

// Ceci est un engier, on l'incrémente de 4
if (is_int($int)) {
    $int += 4;
}

// Si $bool est une chaîne, l'afficher
// (Ne pas imprimer n'importe quoi).
if (is_string($bool)) {
    echo "Chaine : $bool";
}
?>
]]>
     </programlisting>
    </example>
   </para>
  </note>
  <simpara>
   Si vous voulez forcer une variable à être convertie
   en un certain type, vous devez transtyper
   (<link linkend="language.types.typecasting">cast</link>) la
   variable ou utiliser la fonction <function>settype</function>.
  </simpara>
  <simpara>
   Il est à noter qu'une variable peut se comporter de
   manière différente suivant les situations, en
   fonction du type qui lui est affecté.
   Pour plus d'informations, voir le paragraphe
   <link linkend="language.types.type-juggling">transtypage</link>.
  </simpara>
 </sect1>
   <sect1 id="language.types.boolean">
    <title>Booléens</title>
    <simpara>
     C'est le type le plus simple. Un booléen exprime les valeurs
      de &true; ou &false;.
    </simpara>
    <sect2 id="language.types.boolean.syntax">
     <title>Syntaxe</title>
     <para>
     Vous pouvez utiliser les constantes '&true;' et
     '&false;' pour spécifier une valeur de type
      <type>bool</type>. Ces constantes sont insensibles
      à la casse.
      <example>
       <title>Utilisation des constantes &true; et &false;</title>
       <programlisting role="php">
<![CDATA[
<?php
  $foo = True; 
  // assigne la valeur TRUE à la variable $foo
?>
]]>
       </programlisting>
      </example>
     </para>
     <para>
      Généralement, vous les créerez
      avec un des <link linkend="language.operators">opérateurs</link>
      qui retourne une valeur <type>bool</type>, pour le passer
      à une <link linkend="language.control-structures">structure de contrôle</link>.
      <example>
       <title>Utilisation des constantes &true; et &false; avec une structure de contrôle</title>
       <programlisting role="php">
<![CDATA[
// == est un opérateur d'égalité
// qui retourne un booléen
if ($action == "show_version") {
    echo "La version est la 1.23";
}

// Ceci n'est pas nécessaire
if ($show_separators == TRUE) {
    echo "<hr>\n";
}

// car vous pouvez simplement utiliser
if ($show_separators) {
    echo "<hr>\n";
}
]]>
       </programlisting>
      </example>
     </para>
    </sect2>

    <sect2 id="language.types.boolean.casting">
     <title>Conversion en booléen</title>
      <simpara>
       Reportez-vous au chapitre
       "<link linkend="language.types.type-juggling">Définition du type</link>"
       pour plus d'informations sur les conversions.
      </simpara>
      <para>
       Lors des conversions de valeurs de type <type>bool</type>, les valeurs
       suivantes sont considérées comme fausse (&false;) :
       <itemizedlist>
        <listitem>
         <simpara>
          Le <link linkend="language.types.boolean">booléen</link> &false;
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          L'<link linkend="language.types.integer">entier</link> 0 (zéro)
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          Le <link linkend="language.types.float">nombre à virgule flottante</link> 0.0 (zéro)
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          La <link linkend="language.types.string">chaîne</link> vide,
          et la <link linkend="language.types.string">chaîne</link> "0"
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          Le <link linkend="language.types.array">tableau</link> vide
          (aucun élément)
         </simpara>
        </listitem>
        <listitem>
         <simpara>
         L'<link linkend="language.types.object">objet</link> vide
         (aucun élément)
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          La constante spéciale <link linkend="language.types.null">&null;</link>
         </simpara>
        </listitem>
       </itemizedlist>
       Toutes les autres valeurs sont considérées comme
       vraies (&true; (y compris les
       <link linkend="language.types.resource">ressources</link>).
       <warning>
        <simpara>
         <literal>-1</literal> est considéré comme vrai!
        </simpara>
       </warning>
       <example>
        <title>Conversion en booléen</title>
        <programlisting role="php">
<![CDATA[
<?php
echo gettype((bool) "");        // bool(false)
echo gettype((bool) 1);         // bool(true)
echo gettype((bool) -2);        // bool(true)
echo gettype((bool) "foo");     // bool(true)
echo gettype((bool) 2.3e5);     // bool(true)
echo gettype((bool) array(12)); // bool(true)
echo gettype((bool) array());   // bool(false)
?>
]]>
        </programlisting>
       </example>
      </para>
    </sect2>
  </sect1>
  <sect1 id="language.types.integer">
   <title>Entiers</title>
   <para>
    Un entier est un nombre de l'ensemble des entiers naturels Z :
    <literal>Z = {...., -2, -1, 0, 1, 2, ...}</literal>. Il est possible de spécifier
    les nombres entiers (<literal>integer</literal>) de toutes les manières suivantes :
    décimale (base 10), hexadécimale (base 16), octale (base 8)
    éventuellement précédé du signe moins
    (<literal>-</literal>).
   </para>
    <sect2 id="language.types.integer.syntax">
     <title>Syntaxe</title>
     <simpara>
      Les entiers peuvent être spécifiés en base décimale (dite aussi
      base 10), en hexadécimale (base 16) ou octale (base 8).
      Les entiers peuvent être optionnellement précédés par le signe
      plus ou moins (- or +).
     </simpara>
     <para>
    Pour utiliser la notation octale, vous devez préfixer le nombre avec
    un zéro; pour utiliser la notation hexadécimale, vous devez
    préfixer le nombre avec <literal>0x</literal>.
      <example>
       <title>Notations entières</title>
       <programlisting role="php">
<![CDATA[
$a = 1234; // nombre entier en base 10
$a = -123; // nombre entier négatif
$a = 0123; // nombre entier en base 8, octale (équivalent à 83 en base 10)
$a = 0x1A; // nombre entier en base 16, hexadécimale
           // (équivalent à 26 en base 10)
]]>
       </programlisting>
      </example>
     Techniquement, la structure d'un entier suit les règles suivantes :
      <example>
      <title>Structure d'un entier</title>
       <programlisting>
<![CDATA[
decimal     : [1-9][0-9]*
            | 0

hexadecimal : 0[xX][0-9a-fA-F]+

octal       : 0[0-7]+

integer     : [+-]?decimal
            | [+-]?hexadecimal
            | [+-]?octal
]]>
       </programlisting>
      </example> 
      La taille des entiers dépend de la plate-forme de support, mais
    la valeur maximale est généralement de 2 milliards et des
    poussières (c'est un entier signé de 32 bits). &php; ne supporte
    pas les entiers non signés.
     </para>
    </sect2>

    <sect2 id="language.types.integer.overflow">
     <title>Dépassement de capacité des entiers</title>
     <para>
      Si un nombre est hors de l'intervalle de validité
      des entiers, il sera interprèté comme un <type>float</type>.
      <example>
      <title>Dépassement de capacité des entiers</title>
       <programlisting role="php">
<![CDATA[
<?php
$large_number =  2147483647;
var_dump($large_number);
// affiche : int(2147483647)

$large_number =  2147483648;
var_dump($large_number);
// affiche : float(2147483648)

// cette méthode spécifie un entier hexadécimal :
var_dump( 0x80000000 );
// affiche : float(2147483648)

$million = 1000000;
$large_number =  50000 * $million;
var_dump($large_number);
// affiche : float(50000000000)
?>
]]>
       </programlisting>
      </example>
      De même, si une fonction ou un opérateur retourne un entier qui
      est hors des limites de validité des entiers, il sera aussi
      automatiquement converti en <type>float</type>.
     </para>
     <para>
      En &php;, il n'y a pas de division entière. <literal>1/2</literal> 
      sera un nombre à virgule flottante (<type>float</type>)
      de valeur <literal>0.5</literal>. 
      <!-- See ??? for more information. (with the
      operators, or with type-jug) -->
     </para>
      <warning>
       <simpara>
        Malheureusement, il y a un bug dans le moteur (corrigé en 4.1.0), 
        qui fait que &php; ne fonctionne pas toujours bien lorsque des nombres 
        négatifs sont utilisés. Lorsque les deux opérandes 
        sont positifs, il n'y a pas de problèmes. Par exemple :
        <literal>-50000 * $million</literal>, conduit à
        <literal>-429496728</literal>.
       </simpara>
      </warning>
     <para>
      Il n'existe pas de division entière en &php;.
      <literal>1/2</literal> générera le <type>float</type>
      <literal>0.5</literal>. Vous pouvez forcer la valeur
      au format entier pour faire l'arrondi, ou bien utiliser
      les fonctions <function>round</function>,
      <function>floor</function> ou <function>ceil</function>.
      <example>
       <title>Divisions entières</title>
       <programlisting role="php">
<![CDATA[
<?php
var_dump(25/7);         
  // float(3.5714285714286) 
var_dump((int) (25/7)); 
  // int(3)
var_dump(round(25/7));  
  // float(4) 
?>
]]>
       </programlisting>
      </example>
     </para>
    </sect2>
    <sect2 id="language.types.integer.casting">
     <title>Conversion en entiers</title>
      <simpara>
       Pour explicitement convertir une valeur en &integer;,
       utilisez les opérateurs de transtypage <literal>(int)</literal>
       ou <literal>(integer)</literal>. Cependant, dans la plupart des
       situations, vous n'en aurez pas besoin, car une valeur sera
       automatiquement convertie si un opérateur, une fonction ou tout
       autre élément du langage requiert un <type>entier</type>.
      </simpara>
      <simpara>
       Reportez-vous à la section
       <link linkend="language.types.type-juggling">définition de
       type</link> pour plus d'informations sur les conversions.
      </simpara>
      <sect3 id="language.types.integer.casting.from-boolean">
       <title>
        Depuis un <link 
        linkend="language.types.boolean">booléen</link>
       </title>
       <simpara>
        <link linkend="language.types.boolean">&false;</link> devient 0
        (zéro), et <link linkend="language.types.boolean">&true;</link>
        devient 1 (un).
       </simpara>
      </sect3>
      <sect3 id="language.types.integer.casting.from-float">
       <title>
        Depuis un <link linkend="language.types.float">nombre à virgule
        flottante</link>
       </title>
       <simpara>
        Lors de conversion entre un nombre à virgule flottante et
        un entier, le nombre sera arrondi à la valeur inférieure
        s'il est positif, et supérieure s'il est négatif
        (conversion dite 'vers zéro').
       </simpara>
       <para>
        Si le nombre est hors de l'intervalle de validité
        des entiers, (généralement 
        <literal>+/- 2.15e+9 = 2^31</literal>),
        le résultat est indéfini, car les nombres à
        virgule flottante n'ont pas assez de précision pour fournir une
        valeur exacte pour un entier.
        <warning>
         <simpara>
          Aucune alerte, même pas le plus petit message ne
          sera affiché dans ce cas.
         </simpara>
        </warning>
       </para>
       <warning>
        <para>
         Ne transformez jamais une fraction inconnue en entier, car cela
         peut conduire à des résultats irrationnels.
      <example>
       <title>Attention aux erreurs de fractions</title>
          <programlisting role="php">
<![CDATA[
<?php
  echo (int) ( (0.1+0.7) * 10 );
// affiche 7!
?>
]]>
         </programlisting>
        </example>
        Pour plus d'informations, reportez-vous aux
        <link linkend="warn.float-precision">alertes</link> liées
        aux nombres à virgule flottante.
       </para>
      </warning>
      </sect3>
      <sect3 id="language.types.integer.casting.from-string">
       <title>A partir de chaînes de caractères</title>
       <simpara>
        Reportez-vous à la section des
        <link linkend="language.types.string.conversion">conversions de 
        chaînes</link>.
       </simpara>
      </sect3>
      <sect3 id="language.types.integer.casting.from-other">
       <title>Conversion d'autres types</title>
       <para>
        La conversion d'autres types en entier est indéfinie.
        Actuellement, &php; convertit d'abord la valeur en
        <link linkend="language.types.boolean.casting">booléen</link>.
        <caution>
         <simpara>
          Mais, ne vous fiez pas à ce comportement, car il
          est susceptible de changer sans préavis!
         </simpara>
        </caution>
       </para>
    <para>
     Voir aussi :
     <link linkend="ref.gmp">Nombres de grande taille</link> et
     <link linkend="language.types.float">Nombres à virgules flottantes</link>.
    </para>
       <!--
        IMO, it would more sense as (int) $arr returned the
        number of elements in $arr. This won't break anything,
        since this behaviour was never defined before, and
        (bool)(int) $arr will still behave the same.
        -->
    </sect3>
   </sect2>
  </sect1>
  <sect1 id="language.types.float">
   <title>Les nombres à virgule flottante</title>
   <para>
    Les nombres à virgule flottante (connus aussi sous le
    vocable de "<literal>double</literal>" ou "<literal>float</literal>"
    "<literal>nombre rééls</literal>") peuvent être
    spécifiés en utilisant la syntaxe suivante :
      <example>
       <title>Exemple de nombres à virgule flottante</title>
     <programlisting role="php">
<![CDATA[
<?php
  $a = 1.234;
  $b = 1.2e3;
  $c = 7E-10;
?>
]]>
     </programlisting>
     <para>
      Formellement :
     </para>
     <programlisting role="php">
LNUM          [0-9]+
DNUM          ([0-9]*[\.]{LNUM}) | ({LNUM}[\.][0-9]*)
EXPONENT_DNUM ( ({LNUM} | {DNUM}) [eE][+-]? {LNUM})
     </programlisting>
    <para>
    La taille des nombres décimaux dépend de la plate-forme.
    Un maximum de ~1.8e308 avec une précision de 14 décimales
    est une configuration répandue : c'est le format 64 bits IEEE.
   </para>
    </example>
   </para>
   <warning id="warn.float-precision">
    <title>Précision des nombres à virgule flottante</title>
    <para>
     Il est fréquent que de simples fractions décimales telles que
     <literal>0.1</literal> ou <literal>0.7</literal> ne puissent
     être converties au format interne binaire sans une légère perte
     de précision. Cela peut conduire à des résultats étonnants :
     par exemple, <literal>floor((0.1+0.7)*10)</literal> retournera
     <literal>7</literal> au lieu de <literal>8</literal>
     car le résultat de la représentation interne est
     <literal>7.9999999999...</literal>.
    </para>
    <para>
     Tout ceci est lié au fait qu'il est impossible d'exprimer
     certaines fractions en un nombre fini de chiffres. Par exemple
     <literal>1/3</literal> s'écrira <literal>0.3333333...</literal>
     en mode décimal.
    </para>
    <para>
     Ne faites donc jamais confiance aux nombres à virgule
     jusqu'à leur dernière décimale, et ne comparez
     jamais ces nombres avec l'opérateur d'égalité.
     Si vous avez besoin d'une précision particulière,
     reportez-vous au traitement des nombres de grande taille avec les
     librairies <link linkend="ref.bc">BC</link> ou <link linkend="ref.gmp">GMP</link>.
    </para>
   </warning>
   <sect2 id="language.types.float.casting">
    <title>Conversion d'un nombre à virgule flottante</title>
    
    <para>
     Pour savoir quand et comment des chaînes sont converties en
     nombre à virgule flottante, voyez la section 
     <link linkend="language.types.string.conversion">Conversion de chaînes de caractères</link>. 
     Pour les valeurs d'autres types, la conversion est la même
     que si la valeur était d'abord convertie en entier, puis en 
     nombre décimal. Voyez la section <link linkend="language.types.integer.casting">Conversion d'un entier</link>.
    </para>
   </sect2>
  </sect1>
  <sect1 id="language.types.string">
   <title>Les chaînes de caractères</title>
   <para>
    Les chaînes de caractères sont des séquences de caractères.
    En &php;, un caractère est un octet, et il y en 256 de possibles.
    &php; n'a pas (encore?) de support natif d'Unicode.
    <!-- how about unicode? will we support that eventually? Are
    there current any ways to work with unicode?
    -->
   </para>
   <note>
    <simpara>
     La taille n'est pas un problème majeur pour une chaîne.
     Elle peut devenir très grande sans problème. Il n'y a
     pas à s'en faire pour cela.
    </simpara>
   </note>
   <sect2 id="language.types.string.syntax">
    <title>Syntaxe</title>
    <para>
     Une chaîne peut être spécifiée de trois manières
     différentes :
     <itemizedlist>
      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.single">guillemets simples</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.double">guillemets doubles</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.heredoc">syntaxe <literal>HereDoc</literal></link>
       </simpara>
      </listitem>
     </itemizedlist>
    </para>
    <sect3 id="language.types.string.syntax.single">
     <title>Guillemets simples</title>
     <para>
      Le moyen le plus simple de spécifier une chaîne de caractères
      est d'utiliser les guillemets simples : <literal>'</literal>.
     </para>
     <para>
      Pour spécifier un guillemet simple littéral, vous devez
      l'échapper avec un anti-slash (<literal>\</literal>), comme dans de nombreux
      langages. Si un anti-slash doit apparaître dans votre chaîne ou bien
      en fin de chaîne, il faudra le doubler. Notez que si vous essayez d'échapper n'importe
      quel autre caractère, l'anti-slash sera conservé! Il n'y a pas
      besoin d'échapper d'autres caractères que le guillemet lui-même.
      <note>
       <simpara>
        En &php; 3, une alerte sera affichée si cela arrive avec un
        niveau de rapport d'erreur de <literal>E_NOTICE</literal>.
       </simpara>
      </note>
      <note>
       <simpara>
        Contrairement aux autres syntaxes, les variables présentes dans la
        chaîne ne seront <emphasis>PAS</emphasis> remplacées par leurs
        valeurs.
       </simpara>
      </note>
      <example>
       <title>Exemples d'interpolation des chaînes de caractères</title>
       <programlisting role="php">
<![CDATA[
<?php
  echo 'Ceci est une chaîne simple';
  echo 'Vous pouvez inclure des nouvelles lignes dans une chaîne,
  comme ceci.';
  echo 'Arnold a coutume de dire : "I\'ll be back"';
// affiche : ... "I'll be back"
  echo 'Etes vous sûr de vouloir effacer le dossier C:\\*.*?';
// affiche : Etes vous sûr de vouloir effacer le dossier C:\*.*?
  echo 'Etes vous sûr de vouloir effacer le dossier C:\*.*?';
// affiche : Etes vous sûr de vouloir effacer le dossier C:\*.*?
  echo 'Je suis en train de mettre une nouvelle ligne comme ceci : \n';
// affiche : Je suis en train de mettre une nouvelle ligne comme ceci : \n
?>
]]>
       </programlisting>
      </example>
     </para>
    </sect3>
    <sect3 id="language.types.string.syntax.double">
     <title>Guillemets doubles</title>
     <para>
      Si la chaîne est entourée de guillemets doubles, &php;
      va comprendre certaines séquences de caractères :
     </para>
    <table>
     <title>Les caractères spéciaux</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Séquence</entry>
        <entry>Valeur</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>\n</literal></entry>
        <entry>Nouvelle ligne (linefeed, LF ou 0x0A (10) en ASCII)</entry>
       </row>
       <row>
        <entry><literal>\r</literal></entry>
        <entry>Retour à la ligne (<literal>carriage return</literal>, CR ou 0x0D (13) en ASCII)</entry>
       </row>
       <row>
        <entry><literal>\t</literal></entry>
        <entry>Tabulation horizontale (HT ou 0x09 (9) en ASCII)</entry>
       </row>
       <row>
        <entry><literal>\\</literal></entry>
        <entry>Anti-slash</entry>
       </row>
       <row>
        <entry><literal>\$</literal></entry>
        <entry>Caractère $</entry>
       </row>
       <row>
        <entry><literal>\"</literal></entry>
        <entry>Guillemets doubles</entry>
       </row>
       <row>
        <entry><literal>\[0-7]{1,3}</literal></entry>
        <entry>
          Une séquence de caractères qui permet de
          rechercher un nombre en notation octale.
        </entry>
       </row>
       <row>
        <entry><literal>\x[0-9A-Fa-f]{1,2}</literal></entry>
        <entry>
          Une séquence de caractères qui permet de
          rechercher un nombre en notation hexadécimale.
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   <para>
    Si vous essayez d'utiliser l'anti-slash sur n'importe quelle
    autre séquence, l'anti-slash sera affiché dans votre chaîne.
   </para>
    <para>
     Le plus important pour les chaînes à guillemets doubles est le fait
     que les variables qui s'y trouvent seront remplacées par leur valeur. 
     Voir la section sur le <link linkend="language.types.string.parsing">traitement des
     variables dans les chaînes</link> pour plus de détails.
    </para>
   </sect3>
    <sect3 id="language.types.string.syntax.heredoc">
     <title>Syntaxe <literal>Heredoc</literal></title>
   <para>
    Un autre moyen de délimiter les chaînes est d'utiliser
    la syntaxe dite "<literal>Heredoc</literal>" 
    (en français, documentation ici): &lt;&lt;&lt;,
    suivi d'un identifiant arbitraire, puis de la chaîne. Cette
    séquence se termine par l'identifiant initial, placé en
    premier sur une nouvelle ligne.
   </para>
   <para>
    L'identifiant utilisé doit suivre
    les mêmes règles que les étiquettes &php; : il ne
    doit contenir uniquement que des caractères alpha-numériques,
    et des soulignés ("_"), et enfin, commencer par un
    caractère alphabétique ou un souligné.
   </para>
     <warning>
      <simpara>
       Il est très important de noter que la ligne qui contient
       l'identifiant de fermeture ne doit contenir aucun autre
       caractère, hormis, éventuellement, un point-virgule <literal>;</literal>.
       Cela signifie notamment que l'identifiant ne doit
       pas être indenté, et qu'il n'y a aucun caractère
       blanc entre le retour à la ligne et l'identifiant,
       ou bien entre l'identifiant et le <literal>;</literal>.
      </simpara>
      <simpara>
       Le plus dur est peut être qu'il ne faut pas qu'il y ait
       un retour à la ligne ((<literal>\r</literal>) à la fin de cette
       ligne, mais seulement un retour chariot (<literal>\n</literal>).
       Puisque Microsoft Windows utilise la séquence
       <literal>\r\n</literal> comme terminaison de ligne,
       la syntaxe <literal>heredoc</literal> risque de ne pas fonctionner là. Cependant,
       la plupart des éditeurs &php; fournissent une sauvegarde
       au format UNIX.
       <!--
       FTP will sometimes automatically convert \r\n to \n while
       transferring your files to your webserver (which
       is *nix, of course)
       -->
      </simpara>
     </warning>
   <para>
    La syntaxe <literal>Heredoc</literal> se comporte exactement comme une chaîne à
    guillemets doubles, sans les guillemets doubles. Cela signifie
    que vous n'avez pas à échapper les guillemets (simples ou doubles)
    dans cette syntaxe. Les variables sont remplacées par leur valeur, et
    le même soin doit leur être apporté que dans les chaînes
    à guillemets doubles.
    <example>
     <title>Exemple de chaîne <literal>HereDoc</literal></title>
     <programlisting role="php">
<![CDATA[
<?php
  $str = <<<EOD
  Exemple de chaîne
  s'étalant sur
  plusieurs lignes
  avec la syntaxe heredoc
EOD;
/* Exemple plus complexe, avec des variables. */
  class foo {
    var $foo;
    var $bar;
    function foo() {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
  }
  $foo = new foo();
  $name = 'MonNom';
  echo <<<EOT
  Mon nom est "$name". J'affiche des $foo->foo.
  Maintenant, j'affiche un {$foo->bar[1]}.
  Ceci se traduit par un 'A' majuscule : \x41
EOT;
?>
]]>
     </programlisting>
    </example>
   </para>
   <note>
    <para>
     Le support <literal>Here doc</literal> a été ajouté en &php; 4.
    </para>
   </note>
   </sect3>
   <sect3 id="language.types.string.parsing">
     <title>Traitement des variables dans les chaînes</title>
     <!-- Section originale par jeroen@a-es2.uu.nl -->
     <simpara>
      Lorsqu'une chaîne est spécifiée avec des guillemets doubles,
      ou en utilisant la syntaxe <literal>heredoc</literal>,
      les variables qu'elle contient sont remplacées par leur valeur.
     </simpara>
     <simpara>
      Il y a deux types de syntaxe, une
      <link linkend="language.types.string.parsing.simple">simple</link>
      et une
      <link linkend="language.types.string.parsing.complex">complexe</link>.
      La syntaxe simple est la plus courante, et la plus pratique : elle fournit
      un moyen d'utiliser les variables, que ce soient des chaînes, des tableaux
      ou des membres d'objets.
     </simpara>
     <simpara>
      La syntaxe complexe a été introduite en &php; 4
      <!-- XXX was it? and starting with what version exactly? -->
      et peut être reconnue grâce aux accolades entourant les expressions.
     </simpara>
     <sect4 id="language.types.string.parsing.simple">
      <title>Syntaxe simple</title>
      <simpara>
       Dès qu'un signe dollar <literal>$</literal> est rencontré, l'analyseur
       &php; va lire autant de caractère qu'il peut pour former un nom de
       variable valide. Entourez le nom de la variable avec des accolades
       pour indiquer explicitement son nom.
      </simpara>
      <example>
      <title>Utilisation des accolades <literal>{}</literal> dans les chaînes</title>
       <programlisting role="php">
 <![CDATA[
<?php
  $boisson = 'vin';
  echo "Du $boisson, du pain et du fromage!";
 // OK, car "," n'est pas autorisé dans les noms de variables
  echo "Il a goûté plusieurs $boissons";
 // Pas OK, car 's' peut faire partie d'un nom de variable, et PHP recherchera alors $boissons
  echo "Il a goûté plusieurs ${boisson}s";
 // OK
?>
]]>
       </programlisting>
      </example>
      <simpara>
       Similairement, vous pouvez aussi utiliser un élément
       de tableau, ou un membre d'objet. Pour les éléments
       de tableau, le crochet fermant '<literal>]</literal>'
       marquera la fin du nom de la variable. Pour les
       membres d'objets, les mêmes règles que ci-dessus
       s'appliquent. Cependant, il n'existe pas de truc comme
       pour les variables simples.
       <!-- XXX isn't TRUE :(, this would be the trick
       Also,
       the same trick with curly-braces works if you
       want to limit the greediness of parsers (aren't they
       paying them enough or something?).
       -->
      </simpara>
      <example>
      <title>Utilisation des accolades <literal>{}</literal> dans les chaînes pour les tableaux</title>
       <programlisting role="php">
<![CDATA[
<?php
// Ces exemples sont spécifiques à l'utilisation de tableaux dans une chaîne.
// Lorsque vous êtes hors d'une chaîne, utilisez toujours des guillemets
// autour des index de tableau, et n'utilisez pas d'{accolades}.

// Affichons toutes les erreurs
error_reporting(E_ALL);

$fruits = array('fraise' => 'rouge', 'banane' => 'jaune');

// Fonctionne mais notez que cela fonctionne pas comme 
// si cela était hors d'une chaîne
echo "Une banane est $fruits[banane].";

// Fonctionne
echo "Une banane est {$fruits['banane']}.";

// Fonctionne mais PHP cherche une constante appelée banane
// tel que décrit ci-dessous
echo "Une banane est {$fruits[banane]}.";

// Ne fonctionne pas, il manque les accolades. Cela donne une erreur d'analyse
echo "Une banane est  $fruits['banane'].";

// Fonctionne
echo "Une banane est " . $fruits['banane'] . ".";

// Fonctionne
echo "Ce carré a un coté de $square->width mètres de large.";

// Ne fonctionne pas. Pour une solution, voyez la syntaxe complexe.
echo "Ce carré a un coté de $square->width00 centimètres.";
?>
]]>
       </programlisting>
      </example>
      <simpara>
       Pour tout ce qui sera plus compliqué, voyez la syntaxe complexe.
      </simpara>
     </sect4>
     <sect4 id="language.types.string.parsing.complex">
      <title>Syntaxe complexe</title>
      <simpara>
       La syntaxe est dite "complexe" car elle permet l'utilisation d'
       expressions complexes, et non pas parcequ'elle serait obscure.
       Nuance.
     </simpara>
     <simpara>
      En fait, vous pouvez inclure n'importe quelle valeur qui est
      dans l'espace de nom avec cette syntaxe. Il suffit d'écrire une
      expression exactement comme si elle était hors de la chaîne,
      puis de l'entourer d'accolades <literal>{}</literal>. Puisque
      vous ne pouvez pas échapper les accolades, cette syntaxe ne commence
      qu'à partir du signe dollar, qui suit immédiatement l'accolade
      ouvrante. Par exemple, vous pouvez utiliser <literal>"{\$"</literal>
      pour obtenir un <literal>"{$"</literal> littéral. Voici quelques
      exemples :
     </simpara>
     <example>
     <title>Syntaxe complexe de chaîne</title>
      <programlisting role="php">
<![CDATA[
<?php
// Affichons toutes les erreurs
error_reporting(E_ALL);

$super = 'fantastique';

// Ne fonctionne pas. Affiche : Ceci est { fantastique}
echo "Ceci est { $super}";

// Fonctionne. Affiche Ceci est fantastique
echo "This is {$super}";
echo "This is ${super}";

// Fonctionne
echo "Ce carré a un coté de {$square->width}00 centimètres."; 

// Fonctionne
echo "Ceci fonctionne : {$arr[4][3]}";

// Ceci est faut pour la même raison que $foo[bar] est faux
// hors d'une chaîne. En d'autres terme, cela va fonctionne
// car PHP recherche d'abord une constante appelée foo, mais
// il générera une note E_NOTICE (undefined constant).
echo "Ceci est faux : {$arr[foo][3]}"; 

// Fonctionne. Lorsque vous utilisez un tableau multidimensionnel dans
// une chaîne, n'oubliez jamais les accolades.
echo "Ceci fonctionne : {$arr['foo'][3]}";

// Fonctionne
echo "Ceci fonctionne : " . $arr['foo'][3];

echo "Vous pouvez même écrire {$obj->values[3]->name}";

echo "Ceci est une valeur de variable variable : {${$name}}";
?>
]]>
       </programlisting>
      </example>
     </sect4>
    </sect3>
    <sect3 id="language.types.string.substr">
     <title>Accès et modification des caractères d'une chaîne</title>
     <para>
      Les caractères d'une chaîne sont accessibles et modifiables en spécifiant
      leur offset (le premier caractère est d'offset 0) entre
      accolade, après le nom de la variable.
     </para>
     <note>
      <simpara>
       Pour assurer la compatibilité ascendante, vous pouvez
       toujours accéder aux caractères avec des crochets.
       Mais cette syntaxe est obsolète en &php; 4.
      </simpara>
     </note>
     <para>
      <example>
       <title>Exemples de chaînes</title>
       <programlisting role="php">
<![CDATA[
<?php
// Lit le premier caractère de la chaîne
$str = 'Ceci est un test.';
$first = $str{0};

// Lit le troisième caractère de la chaîne
$third = $str{2};

// Lit le dernier caractère de la chaîne
$str = 'Ceci est un test.';
$last = $str{strlen($str)-1}; 

// Modifie le dernier caractère de la chaîne
$str = 'Ceci est un test.';
$str{strlen($str)-1} = '!';

?>
]]>
       </programlisting>
      </example>
     </para>
    </sect3>
   </sect2><!-- end syntax -->
   <sect2 id="language.types.string.useful-funcs">
    <title>Fonctions et opérateurs pratiques</title><!-- and operators -->
    <para>
     Les chaînes peuvent être concaténées avec l'opérateur '.' (point).
     Notez que l'opérateur d'addition '+' (plus) ne fonctionnera pas.
     Reportez-vous à la section
     <link linkend="language.operators.string">opérateurs de chaînes</link>.
    </para>
    <para>
     Il y a une grande quantité de fonctions pratiques pour modifier
     les chaînes.
    </para>
    <simpara>
     Reportez-vous à la section <link linkend="ref.strings">chaînes de caractères</link>
     pour les fonctions les plus générales, à <link linkend="ref.pcre">Expressions
     régulières Perl</link> et <link linkend="ref.regex">Expressions régulières
     POSIX étendues</link> pour les recherches et remplacements.
    </simpara>
    <simpara>
     Il y a aussi les fonctions sur les <link linkend="ref.url">URL</link>,
     ainsi que des fonctions de chiffrage (<link linkend="ref.mcrypt">mcrypt</link> et
     <link linkend="ref.mhash">mhash</link>).
    </simpara>
    <simpara>
     Finalement, si vous ne trouvez toujours pas votre bonheur, il y a les
     fonctions de <link linkend="ref.ctype">types de caractères</link>.
    </simpara>
   </sect2>
   <sect2 id="language.types.string.casting">
    <title>Conversion en une chaîne de caractères</title>
    
    <para>
     Vous pouvez convertir une valeur en une chaîne de caractères en utilisant l'opérateur
     <literal>(string)</literal>, ou bien la fonction <function>strval</function>.
     La conversion en chaîne de caractères est automatiquement faite dans
     toutes les situations qui nécessitent une chaîne de caractères.
     Cela arrive lorsque vous utilisez des fonctions comme <function>echo</function>
     ou <function>print</function>, ou encore lorsque vous comparez une valeur
     avec une chaîne de caractères.
    </para>
    
    <para>
     Le booléen &true; est converti en la chaîne de caractères <literal>"1"</literal>,
     et le booléen &false; est représenté par la chaîne de caractères vide 
     <literal>""</literal>. De cette façon, vous pouvez convertir des 
     booléens en chaîne de caractères et vice-versa.
    </para>
    <para> 
     Un entier ou un nombre à virgule flottante est converti en une
     chaîne de caractères qui représente ce nombre en décimal (y compris
     l'exposant des nombres à virgule flottante).
    </para>
    <para>
     Les tableaux sont toujours convertis en la chaîne de caractères <literal>"Array"</literal>,
     ce qui fait que vous ne pouvez pas afficher le contenu d'un tableau avec la fonction
     <function>echo</function> ou <function>print</function>. Voyez 
     les informations ci-dessous pour plus de conseils.
    </para>
    <para>
     Les objets sont automatiquement convertis en la chaîne de caractères 
     <literal>"Object"</literal>. Si vous souhaitez afficher le membre
     d'un objet, lisez le paragraphe ci-dessous. Si vous voulez connaître
     le nom de la classe de cet objet, utilisez la fonction
     <function>get_class</function>.  
    </para>
    <para>
     Les ressources sont toujours converties en chaîne de caractères 
     <literal>"Resource id #1"</literal> où <literal>1</literal> est
     le nombre unique représentant la ressource, assigné par &php; au moment
     de l'exécution. Si vous souhaitez connaître le type d'une ressource,
     utilisez <function>get_resource_type</function>.
    </para>
    <para>
     &null; est toujours converti en une chaîne de caractères vide.
    </para>
    
    <para>
     Comme vous pouvez le voir, afficher des tableaux, des objets ou des ressources
     n'est pas pertinent par cette méthode. Reportez-vous aux fonctions
     <function>print_r</function> et <function>var_dump</function> pour
     avoir des outils plus pratiques.
    </para>
    
    <para>
     Vous pouvez aussi convertir des valeurs &php; en chaînes pour les
     sauver dans un stockage. Cette méthode est appelée la linéarisation,
     et peut être exploitée avec la fonction <function>serialize</function>. 
     Vous pouvez aussi linéariser des valeurs &php; en structure 
     XML si vous avez le support <link linkend="ref.wddx">WDDX</link>.
    </para>
   </sect2>
   <sect2 id="language.types.string.conversion">
    <title>Conversion de chaînes de caractères</title>
    <simpara>
      Lorsqu'une chaîne de caractère est
      évaluée comme une valeur numérique,
      le résultat et le type de la variable sont
      déterminés comme suit.
    </simpara>
    <simpara>
      La chaîne de caractères est de type "double" si
      elle contient un des caractères '.', 'e' ou 'E'. Sinon,
      elle est de type entier (<literal>"integer"</literal>).
    </simpara>
    <para>
      La valeur est définie par la première partie
      de la chaîne. Si la chaîne de caractères
      débute par une valeur numérique cette valeur
      sera celle utilisée. Sinon, la valeur sera égale
      à 0 (zéro).
    </para>
    <simpara>
      Lorsque la première expression est une chaîne de
      caractères, le type de la variable dépend de la
      seconde expression.
    </simpara>
      <example>
       <title>Exemples de conversions automatiques</title>
     <programlisting role="php">
<![CDATA[
<?php
  $foo = 1 + "10.5";              // $foo est du type  float (11.5)
  $foo = 1 + "-1.3e3";            // $foo est du type  float (-1299)
  $foo = 1 + "bob-1.3e3";         // $foo est du type  integer (1)
  $foo = 1 + "bob3";              // $foo est du type  integer (1)
  $foo = 1 + "10 petits cochons";     // $foo est du type  integer (11)
  $foo = 1 + "10 gros cochons"; // $foo est du type  integer (11)
  $foo = "10.0 cochons " + 1;        // $foo est du type  integer (11)
  $foo = "10.0 cochons " + 1.0;      // $foo est du type  float (11)
?>
]]>
     </programlisting>
    </example>
    <simpara>
      Pour plus d'informations sur les conversions de type, voir les
      pages de man à propos de la fonction <literal>strtod(3)</literal>.
    </simpara>
    <para>
     Si vous voulez tester l'un des exemples de cette section,
     vous pouvez faire un copier/coller et l'insérer dans un script
     pour voir comment il se comporte.
      <example>
       <title>Exemples de conversions</title>
      <programlisting role="php">
<![CDATA[
<?php
  echo "\$foo==$foo; type is " . gettype( $foo ) . "<br>\n";
?>
]]>
      </programlisting>
     </example>
    </para>
   </sect2>
  </sect1>
  <sect1 id="language.types.array">
   <title>Les tableaux</title>
   <para>
    Un tableau &php; est en fait une association ordonnée (littéralement,
    une <literal>map</literal>). Une
    association est un type qui fait correspondre des valeurs
    à des <emphasis>clés</emphasis>.  Ce type est optimisé
    de diverses façons, qui font que vous pouvez le manipuler comme
    un tableau à indices réels, une liste (vecteur), ou un table
    de hachage (qui est une implémentation d'association),
    dictionnaire, collection, pile, queue et encore d'autres.
    Comme une valeur peut elle-même être un tableau, vous pouvez
    simuler facilement un arbre.
   </para>
    <para>
     Les détails d'implémentation de ces structures sont hors du
     champs de ce manuel, mais vous trouverez ici un exemple
     de toutes ces structures.
    </para>
   <sect2 id="language.types.array.syntax">
    <title>Syntaxe</title>
    <sect3 id="language.types.array.syntax.array-func">
     <title>Créer un tableau <function>array</function></title>
     <para>
      Un tableau <type>array</type> peut être créé avec la fonction
      <function>array</function>. Cette fonction prend en argument
      des structures <literal><replaceable>key</replaceable> =>
      <replaceable>value</replaceable></literal>, séparées par des virgules.
     </para>
     <para>
      <synopsis>
array( <optional> <replaceable>key</replaceable> =&gt; </optional> 
<replaceable>value</replaceable> , ... )
// <replaceable>key</replaceable> est soit une <type>string</type> 
soit un <type>integer</type> positif
// <replaceable>value</replaceable> peut être n'importe quoi
      </synopsis>
     </para>
     <para>
      <example>
       <title>Affectations de tableaux</title>
       <programlisting role="php">
<![CDATA[
<?php
$arr = array("foo" => "bar", 12 => true);

echo $arr["foo"]; // bar
echo $arr[12];    // 1
?>
]]>
       </programlisting>
      </example>
     </para>
     <para>
      Une clé <varname>key</varname> est soit un entier
      ou bien une chaîne.
      Si une clé est la représentation standard d'un entier positif,
      elle sera interprètée comme tel. (i.e. <literal>'8'</literal> sera
      interprèté comme <literal>8</literal>, tandis que <literal>'08'</literal>
      sera interprèté comme <literal>'08'</literal>).
     </para>
     <para>
      Une valeur de tableau peut être n'importe quoi.
      <example>
       <title>Création d'un tableau associatif</title>
       <programlisting role="php">
<![CDATA[
<?php
  array("untableau" => array(6 => 5, 13 => 9, "a" => 43));

echo $arr["untableau"][6];    // 5
echo $arr["untableau"][13];   // 9
echo $arr["untableau"]["a"];  // 43
  
?>
]]>
       </programlisting>
      </example>
     </para>
      <para>
       Si vous omettez une clé lors de la spécification d'un tableau,
       l'indice maximum + 1 sera utilisé comme clé par défaut. Si aucun
       indice numérique n'a été généré, ce sera 0. 
       Si vous en spécifiez une qui a déjà été assignée,
       la nouvelle valeur écrasera la précédente.
      <example>
       <title>Indexation automatique de tableau</title>
       <programlisting role="php">
<![CDATA[
<?php
// Ce tableau est identique à 
array(5 => 43, 32, 56, "b" => 12);

// Celui ci
array(5 => 43, 6 => 32, 7 => 56, "b" => 12);
?>
]]>
       </programlisting>
      </example>
      </para>
     <para>
      Utiliser &true; comme clé revient à utiliser le type
      <type>integer</type> de valeur <literal>1</literal>.
      Utiliser &false; comme clé revient à utiliser le type
      <type>integer</type> de valeur <literal>0</literal>.
      Utiliser &null; comme clé revient à utiliser le type
      <type>string</type> de valeur <literal>""</literal>.
      Utiliser la chaîne vide comme index va créer cet index,
      et ce n'est pas la même chose que d'utiliser des 
      crochets vides.
     </para>
     <para>
      Il n'est pas possible d'utiliser des tableaux ou des objets comme
      clés. Ce faisant, vous généreriez une alerte : 
      <literal>Illegal offset type</literal>.
     </para>
    </sect3>
    <sect3 id="language.types.array.syntax.modifying">
     <title>La syntaxe à crochets</title>
     <para>
      Vous pouvez aussi modifier un tableau existant en lui assignant
      simplement des valeurs.
     </para>
     <para>
      L'assignation de valeurs de tableau se fait en spécifiant la clé
      entre crochets. Si vous omettez la clé ("<literal>$tableau[]</literal>"),
      la valeur sera ajoutée à la fin du tableau.
      <synopsis>
$arr[<replaceable>key</replaceable>] = <replaceable>value</replaceable>;
$arr[] = <replaceable>value</replaceable>;
// <replaceable>key</replaceable> est soit une chaîne, soit un entier
// <replaceable>value</replaceable> peut être n'importe quoi
      </synopsis>
      Si <varname>$arr</varname> n'existe pas, il sera créé. Cela
      en fait une alternative pour créer un tableau. Pour modifier une
      valeur, assignez-lui une nouvelle valeur. Pour supprimer une
      valeur, utilisez la fonction <function>unset</function>.
      <example>
       <title>Manipuler des éléments de tableau</title>
       <programlisting role="php">
<![CDATA[
<?php
$arr = array(5 => 1, 12 => 2);

$arr[] = 56;    // Ceci revient à $arr[13] = 56;
                // à ce moment du script

$arr["x"] = 42; // Ceci ajoute un nouvel élément
                // avec l'index "x"
                
unset($arr[5]); // Ceci efface un élément du tableau

unset($arr);    // Ceci efface tout le tableau
?>
]]> 
       </programlisting>
      </example>
     </para>
     <note>
      <para>
       Comme indiqué ci-dessus, si vous fournissez des crochets
       sans spécifier de clé, le plus grand index existant et entier
       est recherché, et la nouvelle clé générée est cette valeur
       maximum + 1. Si aucune clé entière n'exist, la valeur sera
       alors <literal>0</literal>. Si vous spécifiez une clé qui est 
       déjà existante, vous écraserez le contenu précédent.
      </para>
      <para>
       <warning>
        <simpara>
         Depuis &php; 4.3.0, la génération d'index a changé. Si vous ajoutez
         un élément et que la valeur maximale de la clé est négative,
         alors la prochaine clé générée est <literal>0</literal>. Auparavant,
         c'était la plus grande valeur + 1, négative ou pas.
         Cela reste le comportement pour les clés positives.
        </simpara>
       </warning>
      </para>
      <para>
       Notez que le maximum théorique <emphasis>n'a pas besoin
       d'exister au moment de la génération</emphasis>. Il peut simplement
       avoir existé auparavant. 
      </para>

      <example>
       <title>La génération automatique de clé peut utiliser un ancien maximum</title>
       <programlisting role="php">
<![CDATA[
<?php
// Crée un simple tableau
$array = array(1, 2, 3, 4, 5);
print_r($array);

// On efface tous les éléments, mais on laisse le tableau
foreach ($array as $i => $value) {
    unset($array[$i]);
}
print_r($array);

// On ajoute une valeur : notez que la nouvelle clé est 5
// et non pas 0, comme on l'attendrait.
$array[] = 6;
print_r($array);

// Re-indexation :
$array = array_values($array);
$array[] = 7;
print_r($array);
?>
]]> 
       </programlisting>
       &example.outputs;
       <screen>
<![CDATA[
Array
(
    [0] => 1
    [1] => 2
    [2] => 3
    [3] => 4
    [4] => 5
)
Array
(
)
Array
(
    [5] => 6
)
Array
(
    [0] => 6
    [1] => 7
)
]]>
       </screen>
      </example>       

     </note>
    </sect3>
   </sect2><!-- end syntax -->
   <sect2 id="language.types.array.useful-funcs">
    <title>Fonctions pratiques</title>
    <para>
     Il y a toute une panoplie de fonctions pratiques pour travailler
     avec <link linkend="ref.array">les tableaux</link>.
    </para>
    <note>
     <para>
      La fonction <function>unset</function> permet d'effacer des 
      index dans un tableau. Sachez bien que le tableau ne sera PAS
      réindexé. Si vous utilisez uniquement des index numériques
      (commençant à zéro, et incrémentés de un), vous pouvez effectuer
      la réindexation en utilisant <function>array_values</function>.
      <example>
       <title>Manipuler des éléments de tableau</title>
       <programlisting role="php">
<![CDATA[
<?php
$a = array(1 => 'un', 2 => 'deux', 3 => 'trois');
unset($a[2]);
/* Cela va produire un tableau qui aurait été 
   $a = array(1 => 'un', 3 => 'trois');
   et non pas
   $a = array(1 => 'un', 2 =>'trois');
*/

$b = array_values($a);
// Maintenant b est le tableau array(1 => 'un', 2 =>'trois')
?>
]]>
      </programlisting>
     </example>
     </para>    
    </note> 
    <para>
     L'élément de langage <link linkend="control-structures.foreach">foreach</link>
     est spécifiquement dédié aux tableaux : il permet de passer en
     revue simplement les valeurs d'un tableau.
    </para>
   </sect2>
   <sect2 id="language.types.array.donts">
    <title>A faire et à ne pas faire avec les tableaux</title>
    <sect3 id="language.types.array.foo-bar">
     <title>Pourquoi est-ce que <literal>$foo[bar]</literal> est invalide?</title>
     <para>
      Dans vos vieux scripts, vous pouvez avoir utilisé la syntaxe suivante :
      <example>
       <title>Accès aux index de tableaux, ancienne méthode</title>
       <programlisting role="php">
<![CDATA[
<?php
  $foo[bar] = 'ennemi';
  echo $foo[bar];
?>
]]>
       </programlisting>
      </example>
      Cela est mauvais, mais ca marche. Pourquoi est-ce mauvais? La raison
      est que &php; attend une constante entre crochets (bar) plutôt qu'une chaîne
      ('bar', notez les guillemets). Or, &php; pourrait définir dans le futur des
      constantes qui, malheureusement pour votre code, auront ce nom. Actuellement,
      cela fonctionne car la constante indéfinie est transformée en chaîne ayant la
      même valeur.
     </para>
     <note>
      <simpara>
       Cela ne signifie pas que vous devez <emphasis>toujours</emphasis> 
       mettre les clés entre guillemets. Vous n'allez pas 
       utiliser les guillemets avec les clés qui sont des
       <link linkend="language.constants">constantes</link> ou des
       <link linkend="language.variables">variables</link>, car cela 
       empêchera &php; de les interprêter correctement.
      </simpara>
      <example>
       <title>Ne pas mettre les clés de tableaux entre guillemets</title>
       <programlisting role="php">
<![CDATA[
<?php
error_reporting(E_ALL);
ini_set('display_errors', true);
ini_set('html_errors', false);
// Tableau simple :
$array = array(1, 2);
$count = count($array);
for ($i = 0; $i < $count; $i++) {
    echo "\nChecking $i : \n";
    echo "Mauvais : " . $array['$i'] . "\n";
    echo "Bon : " . $array[$i] . "\n";
    echo "Mauvais : {$array['$i']}\n";
    echo "Bon : {$array[$i]}\n";
}
?>
]]>
       </programlisting>
      &example.outputs;
       <screen>
<![CDATA[
Checking 0: 

Notice: Undefined index:  $i in /Users/iboom/Desktop/CVS/docs/mysql/mysql.fr/- on line 10
Mauvais : 
Bon : 1

Notice: Undefined index:  $i in /Users/iboom/Desktop/CVS/docs/mysql/mysql.fr/- on line 12
Mauvais : 
Bon : 1

Checking 1: 

Notice: Undefined index:  $i in /Users/iboom/Desktop/CVS/docs/mysql/mysql.fr/- on line 10
Mauvais : 
Bon : 2

Notice: Undefined index:  $i in /Users/iboom/Desktop/CVS/docs/mysql/mysql.fr/- on line 12
Mauvais : 
Bon : 2
]]>        
       </screen>
      </example>
     </note>
     <para>
      D'autres exemples : 
      <example>
      <title>Exemples de conflits de constantes indéfinies</title>
       <programlisting role="php">
<![CDATA[
<?php
// Affichons toutes les erreurs
error_reporting(E_ALL);

$arr = array('fruit' => 'pomme', 'légume' => 'carotte');

// Correct
print $arr['fruit'];  // pomme
print $arr['légume']; // carotte

// Incorrect.  Cela fonctionne mais PHP affiche une alerte car
// il y a utilisation d'une constante indéfinie appelée fruit
// 
// Notice: Use of undefined constant fruit - assumed 'fruit' in...
print $arr[fruit];    // pomme

// Définissons une constante pour illustrer le problème.
// Nous créons une constante appelée fruit, qui vaut 'légume'.
define('fruit','légume');

// Notez la différence
print $arr['fruit'];  // pomme
print $arr[fruit];    // carotte

// La suite est correcte si cela se passe dans une chaîne. 
// Les constantes ne sont pas remplacées par leur valeur dans une chaîne
print "Bonjour $arr[fruit]";      // Bonjour pomme

// A une exception, les accolades entourant un tableau dans une chaîne
// permettent d'utiliser les constantes
print "Bonjour {$arr[fruit]}";    // Bonjour carotte
print "Bonjour {$arr['fruit']}";  // Bonjour pomme

// Ceci ne fonctionnera pas, et donnera une erreur d'analyse
// Parse error: parse error, expecting T_STRING' or T_VARIABLE' or T_NUM_STRING'
// Cela s'applique aussi aux autoglobales dans les chaînes
print "Bonjour $arr['fruit']";
print "Bonjour $_GET['foo']";

// La concatenation est une alternative
print "Bonjour " . $arr['fruit']; // Bonjour pomme
?>
]]>
       </programlisting>
      </example>
     </para>
     <para>
      Lorsque vous activez l'<function>error_reporting</function> pour afficher
      les erreurs de niveau <constant>E_NOTICE</constant> (en utilisant
      le niveau <constant>E_ALL</constant>) alors, vous verrez ces erreurs.
      Par défaut, <link linkend="ini.error-reporting"><option>error_reporting</option></link> 
      est trop faible pour les afficher.
     </para>
     <para>
      Comme indiqué dans la section <link linkend="language.types.array.syntax">syntaxe</link>,
      il doit y avoir une expression entre les crochets 
      ('<literal>[</literal>' et '<literal>]</literal>').
      Cela signifie que vous pouvez écrire ceci : 
      <example>
       <title>Utilisation d'une expression dans un index de tableau</title>
       <programlisting role="php">
<![CDATA[
<?php
echo $arr[somefunc($bar)];
?>
]]>
       </programlisting>
      </example>
      Ceci est un exemple d'utilisation de retour de fonction comme
      index de tableau. &php; reconnaît aussi les constantes, comme
      la famille des <literal>E_*</literal>.
      <example>
       <title>Utilisation d'une constante dans un index de tableau</title>
       <programlisting role="php">
<![CDATA[
<?php
$error_descriptions[E_ERROR]   = "Une erreur fatale est survenue";
$error_descriptions[E_WARNING] = "PHP émet une alerte";
$error_descriptions[E_NOTICE]  = "Ceci est juste une alerte informationnelle";
?>
]]>
       </programlisting>
      </example>
      Notez que <constant>E_ERROR</constant> est aussi un identifiant valide,
      tout comme <literal>bar</literal> dans le premier exemple. Mais le dernier
      exemple est identique à ceci : 
      <example>
       <title>Utilisation d'une constante dans un index de tableau(2)</title>
       <programlisting role="php">
<![CDATA[
<?php
$error_descriptions[1] = "Une erreur fatale est survenue";
$error_descriptions[2] = "PHP émet une alerte";
$error_descriptions[8] = "Ceci est juste une alerte informationnelle";
?>
]]>
       </programlisting>
      </example>
      car <literal>E_ERROR</literal> vaut <literal>1</literal>, etc.
     </para>
     <para>
      Comme nous l'avons déjà expliqué dans les exemples ci-dessus,
      <literal>$foo[bar]</literal> fonctionne mais est dangereux.
      Cela fonctionne car <literal>bar</literal> est identifié comme une
      constante. Mais, si la constante n'existe pas, &php; suppose
      que vous souhaitez utiliser <literal>bar</literal> littéralement,
      sous la forme <literal>"bar"</literal>, mais que vous avez oublié les
      guillemets.
     </para>
     <sect4>
      <title>Pourquoi est-ce aussi dangereux?</title>
      <para>
       A l'avenir, le groupe &php; peut décider d'ajouter une constante ou
       un autre mot clé, ou bien vous souhaiterez aussi ajouter une
       constante dans votre application, et vous serez bloqué. Par exemple,
       vous ne pouvez pas utiliser des mots comme <literal>empty</literal> et 
       <literal>default</literal> de cette manière, car il sont déjà 
       <link linkend="reserved">réservés</link>.
      </para>
      <note>
       <simpara>
        Pour insister, à l'intérieur d'une chaîne de caractères 
	(<type>string</type>) à guillemets doubles, il est correct de ne pas utiliser
	les guillemets simples dans les index, et <literal>"$foo[bar]"</literal> est valide.
	Voyez les exemples ci-dessus pour plus de détails sur la syntaxe des
        <link linkend="language.types.string.parsing">variables dans les chaînes</link>.
       </simpara>
      </note>
     </sect4>
    </sect3>
   </sect2>
   <sect2 id="language.types.array.casting">
    <title>Conversion en tableau</title>
    
    <para>
     Pour les types scalaires (<type>integer</type>, <type>float</type>, 
     <type>string</type>, <type>boolean</type> et <type>resource</type>),
     convertir une valeur en tableau retourne un tableau qui contient un
     élément (à l'index 0) qui est la valeur originale.
    </para>
    
    <para>
     Si vous convertissez un tableau en objet, vous obtiendrez des propriétés
     ou bien cet objet comme éléments de tableau. Les clés créées sont les
     noms des membres.
    </para>
    
    <para>
     Si vous convertissez la valeur &null; en tableau, vous obtiendrez un
     tableau vide.
    </para>
   </sect2>
   <sect2 id="language.types.array.comparing">
    <title>Comparaisons de tableaux</title>
    <para>
     Il est possible de comparer des tableaux grâce à 
     la fonctoin <function>array_diff</function> et aux
     <link linkend="language.operators.array">opérateurs de tableaux</link>.
    </para>
   </sect2>
   <sect2 id="language.types.array.examples">
    <title>Exemples</title>
    <para>
     Le type tableau de &php; est très souple. Voici quelques exemples d'utilisation :
    </para>
    <para>
      <example>
       <title>Utilisation des tableaux</title>
       <programlisting role="php">
<![CDATA[
<?php
// ceci
  $a = array( 'couleur' => 'rouge'
            , 'gout' => 'sucre'
            , 'forme' => 'rond'
            , 'nom'  => 'pomme'
            ,            4        // cette clé sera 0
          );
// est complétement équivalent à
  $a['couleur'] = 'rouge';
  $a['gout'] =    'sucre';
  $a['forme'] =   'rond';
  $a['nom'] =     'pomme';
  $a[]        = 4;        // cette clé sera 0
  $b[] = 'a';
  $b[] = 'b';
  $b[] = 'c';
// va créer le tableau array( 0 => 'a' , 1 => 'b' , 2 => 'c' )
// ou plus simplement array('a' , 'b' , 'c' )
?>
]]>
       </programlisting>
      </example>
     </para>
    <example>
     <title>Utilisation de <function>array</function></title>
     <programlisting role="php">
<![CDATA[
<?php
// Array comme correspondance
  $map = array( 'version'    => 4
              , 'OS'         => 'Linux'
              , 'langue'       => 'français'
              , 'short_tags' => TRUE             );
// valeur strictement numériques
  $array = array( 7
                , 8
                , 0
                , 156
                , -10
                );
// ceci est la même chose que array( 0 => 7, 1 => 8, ...)
  $switching = array(         10 // clé = 0
                    , 5    =>  6
                    , 3    =>  7
                    , 'a'  =>  4
                    ,         11 // clé = 6 (index maximum : 5)
                    , '8'  =>  2 // clé = 8 (entier!)
                    , '02' => 77 // clé = '02'
                    , 0    => 12 // la valeur de la clé 10 sera remplacée par 12
                    );
// empty array
$empty = array();
?>
]]>
     </programlisting>
    </example>
    <example id="language.types.array.examples.loop">
     <title>Collection</title>
     <programlisting role="php">
<![CDATA[
<?php
  $couleurs = array('rouge','bleu','vert','jaune');
  foreach ( $couleurs as $couleur ){
    echo "Aimez-vous la couleur $couleur?\n";
  }
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Aimez-vous la couleur rouge?
Aimez-vous la couleur bleu?
Aimez-vous la couleur vert?
Aimez-vous la couleur jaune?
]]>
     </screen>
    </example>
    <para>
     Notez qu'il n'est pas possible actuellement de modifier les
     valeurs d'un tableau avec une telle boucle.
      <!--
       Should be made possible, if you write:
       foreach ( $colors as &amp;$color )
       See bug#3074
      -->
     Une solution pour cela est :
     <example id="language.types.array.examples.changeloop">
      <title>Collection</title>
      <programlisting role="php">
<![CDATA[
<?php
  foreach( $couleurs as $cle => $couleur ){
// ne marche pas
//$couleur = strtoupper($couleur);
//marche :
    $couleurs[$cle] = strtoupper($couleur);
  }
  print_r($couleurs);
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Array
(
    [0] => ROUGE
    [1] => BLEU
    [2] => VERT
    [3] => JAUNE
)
]]>
      </screen>
     </example>
    </para>
    <para>
     Cet exemple crée un tableau d'index minimal 1.
     <example>
      <title>Tableau en 1</title>
      <programlisting role="php">
<![CDATA[
<?php
  $firstquarter  = array(1 => 'Janvier', 'Février', 'Mars');
  print_r($firstquarter);
]]>
      </programlisting>
      &example.outputs;
            <screen>
<![CDATA[
Array
(
    [1] => 'Janvier'
    [2] => 'Février'
    [3] => 'Mars'
)
]]>   
      </screen>
     </example>
    </para>
    <example>
     <title>Remplissage d'un tableau</title>
     <programlisting role="php">
<![CDATA[
<?php
// remplit un tableau avec les noms de fichiers d'un dossier
  $handle = opendir('.');
  while ( $file = readdir($handle) ){
    $files[] = $file;
  }
  closedir($handle);
?>
]]>
     </programlisting>
    </example>
    <para>
     Les tableaux sont ordonnés. Vous pouvez modifier l'ordre des
     valeurs avec de nombreuses fonctions de classement. Voyez les
     fonctions de <link linkend="ref.array">tableaux</link>.
    </para>
    <example>
     <title>Tri de tableaux</title>
     <programlisting role="php">
<![CDATA[
<?php
  sort($files);
  print_r($files);
?>
]]>
     </programlisting>
    </example>
    <para>
     Comme une valeur de tableau peut être n'importe quoi, elle
     peut aussi être un autre tableau. Comme cela, vous pouvez
     avoir des tableaux multi-dimensionnels, ou récursifs.
    </para>
    <example>
     <title>Tableaux multi-dimensionnels, et récursifs</title>
     <programlisting role="php">
<![CDATA[
<?php
$fruits = array ( "fruits"  => array ( "a" => "orange",
                                       "b" => "banane",
                                       "c" => "pomme"
                                     ),
                  "nombre" => array ( 1,
                                       2,
                                       3,
                                       4,
                                       5,
                                       6,
                                     ),
                  "trou"   => array (      "premier",
                                       5 => "second",
                                            "troisième"
                                     )
                );

// Exemples d'utilisations des tableaux ci-dessus 
echo $fruits["trou"][5];    // affiche "second"
echo $fruits["fruits"]["a"]; // affiche "orange"
unset($fruits["trou"][0]);  // supprime "premier"

// Créer un tableau multidimensionnel
$juices["pomme"]["vert"] = "bon"; 
?>
]]>
     </programlisting>
    </example>
    <para>
     Soyez conscients que l'assignation de valeur dans un tableau
     entraine automatiquement la copie de valeurs. Vous devez utiliser
     l'opérateur de référence pour copier un tableau par référence.
     <example>
      <title>Copie dans un tableau par référence</title>
      <programlisting role="php">
<![CDATA[
<?php
$arr1 = array(2, 3);
$arr2 = $arr1;
$arr2[] = 4; // $arr2 est modifié changed,
             // $arr1 vaut toujours array(2, 3)
             
$arr3 = &$arr1;
$arr3[] = 4; // maintenant $arr1 et $arr3 sont identiques
?>
]]>
      </programlisting>
     </example>
    </para>
   </sect2>
  </sect1>
  <sect1 id="language.types.object">
   <title>Les objets</title>
   <sect2 id="language.types.object.init">
    <title>Initialisation d'un objet</title>
    <para>
      Pour initialiser un objet, vous devez utiliser la commande "new"
      afin de créer l'instance de l'objet.
      <example>
       <title>Création d'un objet</title>
       <programlisting role="php">
<![CDATA[
<?php
class foo
{
    function faire_foo()
    {
        echo "Faisant foo."; 
    }
}

$bar = new foo;
$bar->faire_foo();
?>
]]>
      </programlisting>
     </example>
    </para>
   </sect2>
   <sect2 id="language.types.object.casting">
    <title>Conversion en objet</title>
    
    <para>
     Si un objet est converti en objet, il n'est pas modifié. Si une
     valeur d'un autre type est convertie en objet, une nouvelle instance
     de la classe <literal>stdClass</literal> sera créée. Si la valeur
     était &null; la nouvelle instance sera vide. Pour les autres valeurs,
     un membre de l'objet appelé <literal>scalar</literal> contiendra la valeur.
      <example>
       <title>Transtypage</title>
      <programlisting role="php">
<![CDATA[
<?php
  $obj = (object) 'au revoir';
  echo $obj->scalar;  // affiche 'au revoir'
?>
]]>
      </programlisting>
     </example>
    </para>
   </sect2>
  </sect1>
  <sect1 id="language.types.resource">
   <title>Ressources</title>
    <para>
     Une ressource (<literal>"resource"</literal> en anglais), est un type spécial,
     qui représente une référence sur une ressource externe. Les
     ressources sont créées par des fonctions dédiées. Reportez
     vous à l'annexe <link linkend="resource">Types des ressources &php;</link>
     pour une liste exhaustive des fonctions créant et utilisant
     ces ressources.
    </para>
    <note>
     <simpara>
      Le type de données <literal>"resource"</literal> a été introduit en &php; 4.
     </simpara>
    </note>
   <sect2 id="language.types.resource.casting">
    <title>Conversion en ressource</title>
    
    <para>
     Comme les ressources contiennent des valeurs très spéciales,
     comme des fichiers ouverts, des connexions aux bases de données,
     des images ou n'importe quoi d'autre, vous ne pouvez pas
     convertir une valeur en ressource.
    </para>
    </sect2>
    <sect2 id="language.types.resource.self-destruct">
     <title>Libérer des ressources</title>
    <para>
     Grâce au système de comptabilisation des références
     introduit en &php; 4 (avec le moteur Zend), &php; détecte automatiquement
     qu'une ressource n'est plus utilisée (comme Java). Dans ce cas,
     toutes les ressources systèmes utilisées par cette
     ressource sont libérées automatiquement.
     <note>
      <simpara>
       Les connexions persistantes représentent un cas
       particulier, elles ne seront <emphasis>PAS</emphasis>
       détruites. Voyez
       <link linkend="features.persistent-connections">connexions persistantes</link>.
      </simpara>
     </note>
    </para>
   </sect2>
  </sect1>
  <sect1 id="language.types.null">
   <title>La valeur &null;</title>
   <para>
    La valeur spéciale &null; représente
    l'absence de valeur. Une variable avec la valeur &null; n'a
    pas de valeur.
   </para>
   <sect2 id="language.types.null.syntax">
    <title>Syntaxe</title>
    <para>
     Il y a seulement une valeur de type &null;, et c'est la constante
     &null;, insensible à la casse.
      <example>
       <title>La valeur &null;</title>
      <programlisting role="php">
<![CDATA[
<?php
  $var = Null;
?>
]]>
      </programlisting>
     </example>
    </para>
    <note>
     <simpara>
      La valeur &null; a été introduite en &php; 4.
     </simpara>
    </note>
   </sect2>
  </sect1>
  <sect1 id="language.pseudo-types">
   <title>Pseudo-types utilisés dans cette documentation</title> 

   <sect2 id="language.types.mixed">
    <title><literal>mixed</literal></title>
    <para>
     <literal>mixed</literal> indique qu'un paramètre accepte
     plusieurs types, mais pas forcément tous les types.
    </para>
    <para>
     <function>gettype</function> par exemple, accepte tous les types de variables
     &php;, mais <function>str_replace</function> n'accepte que des
     &string; et des &array;.
    </para>
   </sect2>
  
   <sect2 id="language.types.number">
    <title><literal>number</literal></title>
    <para>
     <literal>number</literal> indique qu'un paramètre peut être du type
     &integer; ou &float;.
    </para>
   </sect2>

   <sect2 id="language.types.callback">
    <title><literal>callback</literal></title>
    <para>
     Certaines fonctions comme <function>call_user_function</function> 
     ou <function>usort</function> acceptent une fonction définie par 
     l'utilisateur comme fonction de callback. Les fonctions de
     callback peuvent être des fonctions simples, mais aussi des
     objets ou des méthodes statiques de classe.
    </para>
    <para>
     Une fonction &php; est passée simplement en indiquant son nom, sous
     forme de chaîne de caractères. Vous pouvez passer une fonction
     intégrée au langage, ou une fonction définie par vos soins, à
     l'exception de 
     <function>array</function>, 
     <function>echo</function>, 
     <function>empty</function>, 
     <function>eval</function>, 
     <function>exit</function>, 
     <function>isset</function>, 
     <function>list</function>, 
     <function>print</function> et
     <function>unset</function>.
    </para>
    <para>
     Une méthode d'un objet instancié est passée sous forme de &array;,
     contenant un objet comme élément d'index 0, et un nom de méthode comme
     élément 1.
    </para>
    <para>
     Les méthodes statiques de classe peuvent aussi être passées dans l'objet
     instancié, mais en passant le nom de la classe comme valeur de 
     l'index 0.
    </para>

    <para>
     <example>
      <title>Exemple de fonction de callback</title>
      <programlisting role="php">
<![CDATA[
<?php 

// Exemple simple de fonction de callback
function foobar() {
    echo "Bonjour le monde!";
}
call_user_function("foobar"); 

// Exemple de méthode de callback
class foo {
  function bar() {
    echo "Bonjour le monde!";
  }
}

$foo = new foo;

call_user_function(array($foo, "bar")); // appel d'une méthode d'objet

call_user_function(array("foo", "bar")); // appel d'une méthode statique de classe

?>
]]>
      </programlisting>
     </example>
    </para>  
   </sect2>
  </sect1>

  <sect1 id="language.types.type-juggling">
   <title>Définition du type</title>
   <simpara>
     &php; ne nécessite pas de déclaration explicite
     du type d'une variable. Le type d'une variable est
     déterminé par le contexte d'utilisation.
     Par exemple, si vous assignez une chaîne de caractères
     à la variable <parameter>var</parameter>, var devient une
     chaîne de caractère. Si vous assignez un nombre
     entier à <parameter>var</parameter>, elle devient un entier.
   </simpara>
   <para>
     Un exemple de convertisseur automatique de type est l'opérateur
     '+'. Si un des opérandes est de type double, alors tous les
     opérandes sont évalués comme des variables de
     type double et le résultat est de type double. Sinon, tous
     les opérandes sont évalués comme des variables
     de type entier et le résultat sera du type entier. Il est
     à noter que cela NE CHANGE PAS le type des opérandes.
     Le seul changement est la manière dont les opérandes
     sont évaluées.
      <example>
       <title>Conversion automatique</title>
     <programlisting role="php">
<![CDATA[
<?php
  $foo = "0";  // $foo est une chaîne de caractères (ASCII 48)
  $foo += 2;   // $foo est maintenant du type entier (2)
  $foo = $foo + 1.3;  // $foo est maintenant du type double (3.3)
  $foo = 5 + "10 Petits cochons"; // $foo est du type entier (15)
  $foo = 5 + "10 cochonnets";     // $foo est du type entier (15)
?>
]]>
<!--
TODO: explain ++/- - behaviour with strings
examples:
 ++'001' = '002'
 ++'abc' = 'abd'
 ++'xyz' = 'xza'
 ++'9.9' = '9.0'
 ++'-3'  = '-4'
 - -'9'   = 8 (integer!)
 - -'5.5' = '5.5'
 - -'-9'  = -10 (integer)
 - -'09'  = 8 (integer)
 - -'abc' = 'abc'
-->
     </programlisting>
    </example>
   </para>
   <simpara>
     Si les deux derniers exemples vous semblent obscurs ou si vous
     voulez forcer une variable a être évaluée
     avec un certain type, reportez-vous au paragraphe <link
    linkend="language.types.string.conversion"> Conversion de
     types</link>.
   </simpara>
   <simpara>
	Si vous voulez forcer le type d'une variable, vous pouvez
	vous reporter à la section
	<link linkend="language.types.typecasting">transtypage</link>. Si
	vous voulez changer le type d'une variable, utilisez
	<function>settype</function>.
   </simpara>
   <note>
    <para>
     Le comportement de la conversion automatique est actuellement
     indéfini.
    </para>
    <para>
      <example>
       <title>Conversion automatique indéfinie</title>
      <programlisting role="php">
<![CDATA[
<?php
$a = "1";     // $a est une chaîne
$a[0] = "f";  // Mais que sont les index de chaîne?
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Etant donné que &php; supporte l'indexation de chaîne avec des
     offsets identiques à celles des tableaux, l'exemple ci-dessus
     conduit à un problème : est ce que <varname>$a</varname> est un tableau,
     dont le premier élément est "<literal>f</literal>", ou bien est ce que
     "f" est le premier élément de la chaîne de
     caractères <varname>$a</varname>?
    </para>
    <para>
     Les versions courantes de &php; interprète la seconde assignation
     comme un index de chaîne, et donc <varname>$a</varname> devient 
     "<literal>f</literal>", et le
     résultat de cette conversion automatique doit être considéré comme
     indéfini. &php; 4 a introduit la syntaxe avec les accolades pour
     accéder aux caractères d'une chaîne. Utilisez plutôt le code
     ci-dessous : 
      <example>
       <title>Conversion automatique indéfinie(2)</title>
      <programlisting role="php">
<![CDATA[
<?php
$a    = "abc"; // $a est une chaîne
$a{1} = "f";   // $a vaut maintenant "afc"
?>
]]>
      </programlisting>
     </example>
     Voyez la section <link linkend="language.types.string.substr">Accès aux caractères d'une chaîne</link>
     pour plus de détails.
    </para>
   </note>
   <sect2 id="language.types.typecasting">
    <title>Transtypage</title>
    <para>
      La conversion de type en &php; fonctionne de la même
      manière qu'en C : le nom du type désiré
      est écrit entre parenthèses devant la variable
      à transtyper ("cast").
      <example>
       <title>Transtypage</title>
      <programlisting role="php">
<![CDATA[
<?php
  $foo = 10;   // $foo est un entier
  $bar = (double) $foo;   // $bar est un double
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Les conversions autorisées sont :
     <itemizedlist>
      <listitem>
       <simpara><literal>(int)</literal>, <literal>(integer)</literal> - type entier</simpara>
      </listitem>
      <listitem>
       <simpara><literal>(bool)</literal>, <literal>(boolean)</literal> - booléen</simpara>
      </listitem>
      <listitem>
       <simpara><literal>(real)</literal>, <literal>(double)</literal>, <literal>(float)</literal> - type double</simpara>
      </listitem>
      <listitem>
       <simpara><literal>(string)</literal> - type chaîne</simpara>
      </listitem>
      <listitem>
       <simpara><literal>(array)</literal> - type tableau</simpara>
      </listitem>
      <listitem>
       <simpara><literal>(object)</literal> - type objet</simpara>
      </listitem>
     </itemizedlist>
    </para>
    <para>
      Il est à noter que les tabulations et les espaces
      sont autorisés à l'intérieur des
      parenthèses, donc les lignes suivantes sont équivalentes :
      <example>
       <title>Transtypage et espaces</title>
      <programlisting role="php">
<![CDATA[
<?php
  $foo = (int) $bar;
  $foo = ( int ) $bar;
?>
]]>
      </programlisting>
     </example>
    </para>
    <note>
     <para>
      Au lieu de transtyper une variable en chaîne, vous pouvez aussi
      l'insérer entre deux guillemets doubles : 
      <example>
       <title>Transtypage en chaîne</title>
      <programlisting role="php">
<![CDATA[
<?php
$foo = 10;            // $foo est un entier
$str = "$foo";        // $str est une chaîne
$fst = (string) $foo; // $fst est aussi une chaîne

// Ceci affiche : "Identique"
if ($fst === $str) {
    echo "Identique";
}
?>
]]>
      </programlisting>
     </example>
     </para>
    </note>
    <para>
     Le transtypage n'a pas toujours de résultat prévisible.
     Pour plus d'informations, voyez :
     <itemizedlist>
      <listitem>
       <simpara><link linkend="language.types.boolean.casting">Conversion en
        booléen</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.integer.casting">Conversion en
        entier</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.float.casting">Conversion en
        nombre à virgule flottante</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.string.casting">Conversion en
        chaîne de caractères</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.array.casting">Conversion en
        tableau</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.object.casting">Conversion en
        objet</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.resource.casting">Conversion en
        ressource</link></simpara>
      </listitem>
      <!-- don't exist yet
      <listitem>
       <simpara><link linkend="language.types.null.casting">Conversion en
        &null;</link></simpara>
      </listitem>
      -->
     </itemizedlist>
    </para>
   </sect2>
  </sect1>

 </chapter>
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
indent-tabs-mode:nil
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
