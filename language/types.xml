<!-- $Revision: 1.13 $ -->
  <chapter id="language.types">
	<title>Les types</title>
  <sect1 id="language.types.intro">
  <title>Introduction</title>
   <simpara>
    PHP supporte les 8 types basiques suivants :
   </simpara>
   <para>
    PHP supporte quatres types scalaires :
    <itemizedlist>
     <listitem>
      <simpara>
       <link linkend="language.types.boolean">bool&eacute;en</link>
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       <link linkend="language.types.integer">entier</link>
      </simpara>
     </listitem>
     <listitem>
       <simpara>
       <link linkend="language.types.float">nombre &agrave; virgule flottante</link>
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       <link linkend="language.types.string">cha&icirc;ne de caract&egrave;res</link>
      </simpara>
    </listitem>
   </itemizedlist>
  </para>
  <para>
   PHP supporte deux types compos&eacute;s :
   <itemizedlist>
    <listitem>
     <simpara>
      <link linkend="language.types.array">tableau</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.types.object">objet</link>
     </simpara>
    </listitem>
   </itemizedlist>
  </para>
  <para>
   PHP supporte deux types sp&eacute;ciaux :
   <itemizedlist>
    <listitem>
     <simpara>
      <link linkend="language.types.resource">ressource</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.types.null">null</link>
     </simpara>
    </listitem>
   </itemizedlist>
  </para>
  <note>
   <simpara>
    Dans ce manuel, vous rencontrerez souvant le type <literal>mixed</literal>.
    C'est un pseudo-type, qui indique que le param&egrave;tre peut
    indiff&eacute;remment prendre plusieurs types.
   </simpara>
   <!--
   Just an idea, maybe useful for some func-defs?
   (at least it is for the operator-defs)
   <simpara>
    In parameter definitions you can also encouter the 'number' pseudo-type,
    that indicates a parameter that is either <type>integer</type> or
    <type>float</type>.
   </simpara>
   -->
  </note>
  <simpara>
   Habituellement, le type d'une variable n'est pas d&eacute;clar&eacute;
   par le programmeur. Il est d&eacute;cid&eacute; au moment de
   l'ex&eacute;cution par le PHP, en fonction du contexte dans
   lequel la variable est utilis&eacute;e.
  </simpara>
  <simpara>
   Si vous voulez forcer une variable &agrave; &ecirc;tre convertie
   en un certain type, vous devez transtyper
   (<link linkend="language.types.typecasting">cast</link>) la
   variable ou utiliser la fonction <function>settype</function>.
  </simpara>
  <simpara>
   Il est &agrave; noter qu'une variable peut se comporter de
   mani&egrave;re diff&eacute;rente suivant les situations, en
   fonction du type qui lui est affect&eacute;.
   Pour plus d'informations, voir le paragraphe
   <link linkend="language.types.type-juggling">transtypage</link>.
  </simpara>
 </sect1>
   <sect1 id="language.types.boolean">
    <title>Bool&eacute;ens</title>
    <simpara>
     C'est le type le plus simple. Un bool&eacute;en exprime les valeurs
      de vrai <literal>TRUE</literal> ou <literal>FALSE</literal>.
    </simpara>
    <para>
     Vous pouvez utiliser les constantes '<literal>TRUE</literal>' et
     '<literal>FALSE</literal>' pour sp&eacute;cifier une valeur de type
     <type>boolean</type>. G&eacute;n&eacute;ralement, vous les cr&eacute;erez avec un
     des <link linkend="language.operators">operateurs</link>
     qui retourne une valeur <type>boolean</type>, pour le passer
     &agrave; une <link linkend="control-structures">structure de contr&ocirc;le</link>.
      <informalexample>
       <programlisting role="php">
&lt;?php
  if ($action == "show_version"){
// == is an <link linkend="language.operators">operator</link>
// qui retourne un bool&eacute;en
    echo "La version est 1.23";
  }
// ceci n'est pas n&eacute;cessaire
  if ($show_separators == true){
    echo "&lt;hr&gt;\n";
  }
// ceci est plus pratique
  if ($show_separators){
    echo "&lt;hr&gt;\n";
  }
?&gt;
       </programlisting>
      </informalexample>
    </para>
    <!-- TODO: example of this -->
    <!-- TODO: example to show that if ( expr == TRUE ) is not really
         necessary... (i've seen this construct numerous times)
      -->
    <!-- TODO: how others vars are converted to boolean -->
    <note>
     <simpara>
      Le type boo&eacute;en a &eacute;t&eacute; introduit en PHP 4.
     </simpara>
    </note>
    <sect2 id="language.types.boolean.casting">
     <title>Conversion en bool&eacute;en</title>
      <simpara>
       Reportez-vous au chapitre
       "<link linkend="language.types.type-juggling">D&eacute;finition du type</link>"
       pour plus d'informations sur les conversions.
      </simpara>
      <para>
       Lors des conversions de valeurs de type <type>boolean</type>, les valeurs
       suivantes sont consid&eacute;r&eacute;es comme fausse (<literal>FALSE</literal>) :
       <itemizedlist>
        <listitem>
         <simpara>
          Le <link linkend="language.types.boolean">bool&eacute;en</link> FALSE           </simpara>
        </listitem>
        <listitem>
         <simpara>
          L'<link linkend="language.types.integer">entier</link> 0 (z&eacute;ro)
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          Le <link linkend="language.types.float">nombre &agrave; virgule flottante</link> 0.0 (z&eacute;ro)
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          La <link linkend="language.types.string">cha&icirc;ne</link> vide,
          et la <link linkend="language.types.string">cha&icirc;ne</link> "0"
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          Le <link linkend="language.types.array">tableau</link> vide
          (aucun &eacute;l&eacute;ment)
         </simpara>
        </listitem>
        <listitem>
         <simpara>
         L'<link linkend="language.types.object">objet</link> vide
         (aucun &eacute;l&eacute;ment)
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          La constante sp&eacute;ciale <link linkend="language.types.null">NULL</link>
         </simpara>
        </listitem>
       </itemizedlist>
       Toutes les autres valeurs sont consid&eacute;r&eacute;es comme
       vraies (<literal>TRUE</literal> (y compris les
       <link linkend="language.types.resource">ressources</link>).
       <warning>
        <simpara>
         -1 est consid&eacute;r&eacute; comme vrai!
        </simpara>
       </warning>
       <!-- and/or a few examples, for the people only looking at
            the examples... </XXX> -->
      </para>
    </sect2>
  </sect1>
  <sect1 id="language.types.integer">
   <title>Entiers</title>
   <para>
    Un entier est un nombre de l'ensemble des entiers naturels Z :
    Z = {...., -2, -1, 0, 1, 2, ...}. Il est possible de sp&eacute;cifier
    les nombres entiers (integers) de toutes les mani&egrave;res suivantes :
    d&eacute;cimale (base 10), hexad&eacute;cimale (base 16), octale (base 8) &eacute;ventuellement
    pr&eacute;c&eacute;d&eacute; du signe moins (-).
   </para>
   <para>
    Pour utiliser la notation octale, vous devez pr&eacute;fixer le nombre avec
    un z&eacute;ro; pour utiliser la notation hexad&eacute;cimale, vous devez pr&eacute;fixer
    le nombre avec <literal>0x</literal>.
    <informalexample>
     <programlisting role="php">
&lt;?php
  $a = 1234; # nombre entier en base 10
  $a = -123; # nombre entier n&eacute;gatif
  $a = 0123; # nombre entier en base 8, octale (&eacute;quivalent &agrave; 83 en base 10)
  $a = 0x12; # nombre entier en base 16, hexad&eacute;cimale
             # (&eacute;quivalent &agrave; 18 en base 10)
?&gt;
     </programlisting>
    </informalexample>
    La taille des entiers d&eacute;pend de la plate-forme de support, mais
    la valeur maximale est g&eacute;n&eacute;ralement de 2 milliards et des
    poussi&egrave;res (c'est un entier sign&eacute; de 32 bits). PHP ne supporte
    pas les entiers non sign&eacute;s.
   </para>
     <note>
      <simpara>
       En PHP, il n'existe pas de type fraction.
       <literal>1/2</literal> se transforme en nombre &agrave; virgule
       flottante <literal>0.5</literal>.
      </simpara>
     </note>
    <sect2 id="language.types.integer.overflow">
     <title>D&eacute;passement de capacit&eacute; des entiers</title>
     <para>
      Si un nombre est hors de l'intervalle de validit&eacute;
      des entiers, il sera interpr&eacute;t&eacute; comme un <type>float</type>.
      <informalexample>
       <programlisting role="php">
&lt;?php
  $large_number =  2147483647;
  var_dump($large_number);
// affiche : int(2147483647)
  $large_number =  2147483648;
  var_dump($large_number);
// affiche : float(2147483648)
?&gt;
       </programlisting>
      </informalexample>
      De m&ecirc;me, si une fonction ou un op&eacute;rateur retourne un entier qui
      est hors des limites de validit&eacute; des entiers, il sera aussi
      automatiquement converti en <type>float</type>.
      <informalexample>
       <programlisting role="php">
&lt;?php
  $million = 1000000;
  $large_number =  50000 * $million;
  var_dump($large_number);
// affiche : float(50000000000)
?&gt;
       </programlisting>
      </informalexample>
      <warning>
       <simpara>
        Malheureusement, il y a un bug dans le moteur (toujours pr&eacute;sent en
        4.0.6 et probablement r&eacute;solu en 4.0.7) ce qui fait que PHP que fonctionne
        pas toujours bien lorsque des nombres n&eacute;gatifs sont utilis&eacute;s. Lorsque les
        deux op&eacute;randes sont positifs, il n'y a pas de probl&egrave;mes. Par exemple :
        <literal>-50000 * $million</literal>, conduit &agrave; <literal>-429496728</literal>.
       </simpara>
      </warning>
     </para>
    </sect2>
    <sect2 id="language.types.integer.casting">
     <title>Conversion en entiers</title>
      <simpara>
       Pour explicitement convertir une valeur en <type>integer</type>,
       utilisez les op&eacute;rateurs de transtypage <literal>(int)</literal>
       ou <literal>(integer)</literal>. Cependant, dans la plupart des
       situations, vous n'en aurez pas besoin, car une valeur sera automatiquement
       convertie si un op&eacute;rateur, un fonction ou tout autre &eacute;l&eacute;ment du
       langage requiert un <type>entier</type>.
      </simpara>
      <simpara>
       Reportez-vous &agrave; la section
       <link linkend="language.types.type-juggling">d&eacute;finition de type</link>
       pour plus d'informations sur les conversions.
      </simpara>
      <sect3 id="language.types.integer.casting.from-boolean">
       <title>Depuis un <link linkend="language.types.boolean">bool&eacute;en</link></title>
       <simpara>
        <link linkend="language.types.boolean">FALSE</link> devient 0
        (z&eacute;ro), et <link linkend="language.types.boolean">TRUE</link>
        devient 1 (un).
       </simpara>
      </sect3>
      <sect3 id="language.types.integer.casting.from-float">
       <title>
        Depuis un <link linkend="language.types.float">nombre &agrave; virgule flottante</link>
       </title>
       <simpara>
        Lors de conversion entre nombre &agrave; virgule flottante et
        un entier, le nombre sera arrondi &agrave; la valeur inf&eacute;rieure
        s'il est positif, et sup&eacute;rieure s'il est n&eacute;gatif
        (conversion dite 'vers z&eacute;ro').
       </simpara>
       <para>
        Si le nombre est hors de l'intervalle de validit&eacute;
        des entiers, (g&eacute;n&eacute;ralement <literal>+/- 2.15e+9 = 2^31</literal>),
        le r&eacute;sultat est ind&eacute;finit, car les nombres &agrave; virgules
        flottante n'ont pas assez de pr&eacute;cision pour fournir une
        valeur exacte pour un entier.
        <warning>
         <simpara>
          Aucune alerte, m&ecirc;me pas le plus petit message ne
          sera affich&eacute; dans ce cas.
         </simpara>
        </warning>
       </para>
       <warning>
        <para>
         Ne transformez jamais une fraction inconnue en entier, car cela
         peut conduire &agrave; des r&eacute;sultats irrationnels.
         <informalexample>
          <programlisting role="php">
&lt;?php
  echo (int) ( (0.1+0.7) * 10 );
// affiche 7!
?&gt;
         </programlisting>
        </informalexample>
        Pour plus d'informations, reportez-vous aux
        <link linkend="language.types.float">alertes</link> li&eacute;es
        aux nombres &agrave; virgule flottante.
       </para>
      </warning>
      </sect3>
      <sect3 id="language.types.integer.casting.from-string">
       <title>From strings</title>
       <simpara>
        Reportez-vous &agrave; la section des
        <link linkend="language.types.string.conversion">conversions de cha&icirc;nes</link>.
       </simpara>
      </sect3>
      <sect3 id="language.types.integer.casting.from-other">
       <title>Conversion d'autres types</title>
       <para>
        La conversion d'autres types en entier est ind&eacute;finie.
        Actuellement, PHP convertit d'abord la valeur en
        <link linkend="language.types.boolean.casting">bool&eacute;en</link>.
        <caution>
         <simpara>
          Mais, ne vous fiez pas &agrave; ce comportement, car il
          est susceptible de changer sans pr&eacute;avis!
         </simpara>
        </caution>
       </para>
    <para>
     Voir aussi :
     <link linkend="ref.gmp">Nombres de grande taille</link> et
     <link linkend="language.types.float">Nombres &agrave; virgules flottantes</link>.
    </para>
       <!--
        IMO, it would more sense as (int) $arr returned the
        number of elements in $arr. This won't break anything,
        since this behaviour was never defined before, and
        (bool)(int) $arr will still behave the same.
        -->
    </sect3>
   </sect2>
  </sect1>
  <sect1 id="language.types.float">
   <title>Les nombres &agrave; virgule flottante</title>
   <para>
    Les nombres &agrave; virgule flottante (connus aussi sous le
    vocable de "<literal>double</literal>" ou "<literal>float</literal>"
    "<literal>nombre r&eacute;&eacute;ls</literal>") peuvent &ecirc;tre
    sp&eacute;cifi&eacute;s en utilisant la syntaxe suivante:
    <informalexample>
     <programlisting role="php">
&lt;?php
  $a = 1.234;
  $a = 1.2e3;
?&gt;
     </programlisting>
    </informalexample>
   </para>
   <warning>
    <title>Pr&eacute;cision des nombres &agrave; virgule flottante</title>
    <para>
     Il est fr&eacute;quent que de simples fractions d&eacute;cimales telles que
     <literal>0.1</literal> ou <literal>0.7</literal> ne puissent
     &ecirc;tre converties au format interne binaire sans une l&eacute;g&egrave;re perte
     de pr&eacute;cision. Cela peut conduire &agrave; des r&eacute;sultats &eacute;tonnants :
     par exemple, <literal>floor((0.1+0.7)*10)</literal> retournera
     <literal>7</literal> au lieu de <literal>8</literal>
     car le r&eacute;sultat de la repr&eacute;sentation interne est
     <literal>7.9999999999...</literal>.
    </para>
    <para>
     Tout ceci est li&eacute; au fait qu'il est impossible d'exprimer
     certaines fractions en un nombre fini de chiffres. Par exemple
     <literal>1/3</literal> s'&eacute;crira <literal>0.3333333...</literal>
     en mode d&eacute;cimal.
    </para>
    <para>
     Ne faites donc jamais confiance aux nombres &agrave; virgule
     jusqu'&agrave; leur derni&egrave;re d&eacute;cimale, et ne comparez
     jamais ces nombres avec l'op&eacute;rateur d'&eacute;galit&eacute;.
     Si vous avez besoin d'une pr&eacute;cision particuli&egrave;re,
     reportez-vous au traitement des nombres de grande taille avec les
     librairies <link linkend="ref.bc">BC</link> ou <link linkend="ref.gmp">GMP</link>.
    </para>
   </warning>
  </sect1>
  <sect1 id="language.types.string">
   <title>Les cha&icirc;nes de caract&egrave;res</title>
   <para>
    Les cha&icirc;nes de caract&egrave;res sont des s&eacute;quences de caract&egrave;res.
    En PHP, un caract&egrave;re est un octet, et il y en 256 de possibles.
    PHP n'a pas (encore?) de support natif d'Unicode.
    <!-- how about unicode? will we support that eventually? Are
    there current any ways to work with unicode?
    -->
   </para>
   <note>
    <simpara>
     La taille n'est pas un probl&egrave;me majeur pour une cha&icirc;ne.
     Elle peut devenir tr&egrave;s grande sans probl&egrave;me. Il n'y a
     a pas &agrave; s'en faire pour cela.
    </simpara>
   </note>
   <sect2 id="language.types.string.syntax">
    <title>Syntax</title>
    <para>
     Une cha&icirc;ne peut &ecirc;tre sp&eacute;cifi&eacute;e de trois mani&egrave;res
     diff&eacute;rentes :
     <itemizedlist>
      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.single">guillemets simples</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.double">guillemets doubles</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.heredoc">syntaxe HereDoc</link>
       </simpara>
      </listitem>
     </itemizedlist>
    </para>
    <sect3 id="language.types.string.syntax.single">
     <title>guillemets simples</title>
     <para>
      Le moyen le plus simple de sp&eacute;cifier une cha&icirc;ne de caract&egrave;res
      est d'utiliser les guillemets simples : <literal>'</literal>.
     </para>
     <para>
      Pour sp&eacute;cifier un guillemet simple litt&eacute;ral, vous devez
      l'&eacute;chapper avec un anti-slash (<literal>\</literal>), comme dans de nombreux
      langages. Si un anti-slash doit appara&icirc;tre dans votre cha&icirc;ne ou bien
      en fin de cha&icirc;ne, il faudra le doubler. Notez que si vous essayez d'&eacute;chapper n'importe
      quel autre caract&egrave;re, l'anti-slash sera conserv&eacute;! Il n'y a pas
      besoin d'&eacute;chapper d'autres caract&egrave;res que le guillemets lui-m&ecirc;me.
      <note>
       <simpara>
        En PHP 3, une alerte sera affich&eacute;e si cela arrive avec un
        niveau de rapport d'erreur de <literal>E_NOTICE</literal>.
       </simpara>
      </note>
      <note>
       <simpara>
        Contrairement aux autres syntaxes, les variables pr&eacute;sentes dans la
        cha&icirc;ne ne seront <emphasis>PAS</emphasis> remplac&eacute;es par leurs
        valeurs.
       </simpara>
      </note>
      <informalexample>
       <programlisting role="php">
&lt;?php
  echo 'Ceci est une cha&icirc;ne simple';
  echo 'Vous pouvez inclure des nouvelles lignes dans une cha&icirc;ne,
  comme ceci.';
  echo 'Arnold a coutume de dire : "I\'ll be back"';
// affiche : ... "I'll be back"
  echo 'Etes vous s&ucirc;r de vouloir effacer le dossier C:\\*.*?';
// affiche : Etes vous s&ucirc;r de vouloir effacer le dossier C:\*.*?
  echo 'Etes vous s&ucirc;r de vouloir effacer le dossier C:\*.*?';
// affiche : Etes vous s&ucirc;r de vouloir effacer le dossier C:\*.*?
  echo 'Je suis en train de mettre une nouvelle ligne comme ceci : \n';
// affiche : Je suis en train de mettre une nouvelle ligne comme ceci : \n
?&gt;
       </programlisting>
      </informalexample>
     </para>
    </sect3>
    <sect3 id="language.types.string.syntax.double">
     <title>Guillemets doubles</title>
     <para>
      Si la cha&icirc;ne est entour&eacute;s de guillemets doubles, PHP
      va comprendre certaines s&eacute;quences de caract&egrave;res :
     </para>
    <table>
     <title>Les caract&egrave;res sp&eacute;ciaux</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>S&eacute;quence</entry>
        <entry>Valeur</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>\n</literal></entry>
        <entry>Nouvelle ligne (linefeed, LF ou 0x0A (10) en ASCII)</entry>
       </row>
       <row>
        <entry><literal>\r</literal></entry>
        <entry>Retour &agrave; la ligne(carriage return, CR ou 0x0D (13) en ASCII)</entry>
       </row>
       <row>
        <entry><literal>\t</literal></entry>
        <entry>Tabulation horizontale (HT ou 0x09 (9) en ASCII)</entry>
       </row>
       <row>
        <entry><literal>\\</literal></entry>
        <entry>Antislash</entry>
       </row>
       <row>
        <entry><literal>\$</literal></entry>
        <entry>Caract&egrave;re $</entry>
       </row>
       <row>
        <entry><literal>\"</literal></entry>
        <entry>Guillemets doubles</entry>
       </row>
       <row>
        <entry><literal>\[0-7]{1,3}</literal></entry>
        <entry>
          Une s&eacute;quence de caract&egrave;res qui permet de
          rechercher un nombre en notation octale.
        </entry>
       </row>
       <row>
        <entry><literal>\x[0-9A-Fa-f]{1,2}</literal></entry>
        <entry>
          Une s&eacute;quence de caract&egrave;res qui permet de
          rechercher un nombre en notation hexad&eacute;cimale.
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   <para>
    Si vous essayez d'utiliser l'anti-slash sur n'importe quelle
    autre s&eacute;quence, l'anti-slash sera affich&eacute; dans votre cha&icirc;ne.
   </para>
    <para>
     Le plus important des cha&icirc;nes &agrave; guillemets doubles est le fait
     que les variables qui s'y trouvent seront remplac&eacute;es par leurs
     valeurs. Voir la section sur le
     <link linkend="language.types.string.parsing">traitement des
     variables dans les cha&icirc;nes</link> pour plus de d&eacute;tails.
    </para>
   </sect3>
    <sect3 id="language.types.string.syntax.heredoc">
     <title>Syntaxe Heredoc</title>
   <para>
    Un autre moyen de d&eacute;limiter les cha&icirc;nes est d'utiliser
    la syntaxe de "Here doc" (en fran&ccedil;ais, documentation ici): &lt;&lt;&lt;,
    suivi d'un identifiant arbitraire, puis de la cha&icirc;ne. Cette
    s&eacute;quence se termine par l'identifiant initial, plac&eacute; en
    premier sur une nouvelle ligne.
   </para>
   <para>
    L'identifiant utilis&eacute; doit suivre
    les m&ecirc;mes r&egrave;gles que les &eacute;tiquettes PHP : il ne
    doit contenir uniquement que des caract&egrave;res alpha-num&eacute;riques,
    et des soulign&eacute;s ("_"), et enfin, commencer par un
    caract&egrave;re alphab&eacute;tique ou un soulign&eacute;.
   </para>
     <warning>
      <simpara>
       Il est tr&egrave;s important de noter que la ligne qui contient
       l'identifiant de fermeture ne doit contenir aucun autre
       caract&egrave;re, hormis, &eacute;ventuellement, un point-virgule <literal>;</literal>.
       Cela signifie notamment que l'identifiant ne doit
       pas &ecirc;tre indent&eacute;, et qu'il n'y a aucun caract&egrave;re
       blanc entre le retour &agrave; la ligne et l'identifiant,
       ou bien entre l'identifiant et le <literal>;</literal>.
      </simpara>
      <simpara>
       Le plus dur est peut &ecirc;tre qu'il ne faut pas qu'il y ait
       un retour &agrave; la ligne ((<literal>\r</literal>) &agrave; la fin de cette
       ligne, mais seulement un form-feed (<literal>\n</literal>).
       Puisque Microsoft Windows utilise la s&eacute;quence
       <literal>\r\n</literal> comme terminaison de ligne,
       la syntaxe heredoc risque de ne pas fonctionner l&agrave;. Cependant,
       la plupart des &eacute;diteurs PHP fournissent une sauvegarde
       au format UNIX.
       <!--
       FTP will sometimes automatically convert \r\n to \n while
       transferring your files to your webserver (which
       is *nix, of course)
       -->
      </simpara>
     </warning>
   <para>
    La syntaxe Here doc se comporte exactement comme une cha&icirc;ne &agrave;
    guillemets doubles, sans les guillemets doubles. Cela signifie
    que vous n'avez pas &agrave; &eacute;chapper les guillemets (simples ou doubles)
    dans cette syntaxe. Les variables sont remplac&eacute;es par leur valeur, et
    le m&ecirc;me soin doit leur &ecirc;tre apport&eacute; que dans les cha&icirc;nes
    &agrave; guillemets doubles.
    <example>
     <title>Exemple de cha&icirc;ne HereDoc</title>
     <programlisting role="php">
&lt;?php
  $str = &lt;&lt;&lt;EOD
  Exemple de cha&icirc;ne
  s'&eacute;talant sur
  plusieurs lignes
  avec la syntaxe heredoc
EOD;
/* Exemple plus complexe, avec des variables. */
  class foo {
    var $foo;
    var $bar;
    function foo() {
        $this-&gt;foo = 'Foo';
        $this-&gt;bar = array('Bar1', 'Bar2', 'Bar3');
    }
  }
  $foo = new foo();
  $name = 'MonNom';
  echo &lt;&lt;&lt;EOT
  Mon nom est "$name". J'affiche des $foo->foo.
  Maintenant, j'affiche un {$foo-&gt;bar[1]}.
  Ceci se traduit par un 'A' majuscule: \x41
EOT;
?&gt;
     </programlisting>
    </example>
   </para>
   <note>
    <para>
     Le support Here doc a &eacute;t&eacute; ajout&eacute; en PHP 4.
    </para>
   </note>
   </sect3>
   <sect3 id="language.types.string.parsing">
     <title>Traitement des variables dans les cha&icirc;nes</title>
     <!-- Section originale par jeroen@a-es2.uu.nl -->
     <simpara>
      Lorsqu'une cha&icirc;ne est sp&eacute;cifi&eacute;e avec des guillemets doubles,
      ou en utilisant la syntaxe heredoc,
      les variables qu'elle contient sont remplac&eacute;es par leur valeur.
     </simpara>
     <simpara>
      Il y a deux types de syntaxe, une
      <link linkend="language.types.string.parsing.simple">simple</link>
      et une
      <link linkend="language.types.string.parsing.complex">complexe</link>.
      La syntaxe simple est la plus courante, et la plus pratique : elle fournit
      un moyen d'utiliser les variables, que ce soit des cha&icirc;nes, des tableaux
      ou des membres d'objets.
     </simpara>
     <simpara>
      La syntaxe complexe a &eacute;t&eacute; introduite en PHP 4
      <!-- XXX was it? and starting with what version exactly? -->
      et peut &ecirc;tre reconnue gr&acirc;ce aux accolades entourant les expressions.
     </simpara>
     <sect4 id="language.types.string.parsing.simple">
      <title>Syntaxe simple</title>
      <simpara>
       D&egrave;s qu'un signe dollar <literal>$</literal> est rencontr&eacute;, l'analyseur
       PHP va lire autant de caract&egrave;re qu'il peut pour former un nom de
       variable valide. Entourez le nom de la variable avec des accolades
       pour indiquer explicitement son nom.
      </simpara>
      <informalexample>
       <programlisting role="php">
&lt;?php
  $boisson = 'vin';
  echo "Du $boisson, du pain et du fromage!';
 // OK, car "," n'est pas autoris&eacute; dans les noms de variables
  echo "Il a go&ucirc;t&eacute; plusieurs $vins";
 // Pas OK, car 's' peut entrer dans un nom de variable, et PHP recherche $boissons
  echo "Il a go&ucirc;t&eacute; plusieurs ${vin}s";
 // OK
?&gt;
       </programlisting>
      </informalexample>
      <simpara>
       Similairement, vous pouvez aussi utiliser un &eacute;l&eacute;ment
       de tableau, ou un membre d'objet. Pour les &eacute;l&eacute;ments
       de tableau, le crochet fermant '<literal>]</literal>'
       marquera la fin du nom de la variable. Pour les
       membres d'objets, les m&ecirc;mes r&egrave;gles que ci-dessus
       s'appliquent. Cependant, il n'existe pas de truc comme
       pour les variables simples.
       <!-- XXX isn't TRUE :(, this would be the trick
       Also,
       the same trick with curly-braces works if you
       want to limit the greediness of parsers (aren't they
       paying them enough or something?).
       -->
      </simpara>
      <informalexample>
       <programlisting role="php">
 $fruits = array( 'fraise' => 'rouge' , 'banane' => 'jaune' );
 echo "Une banane est $fruits[banane].";
 // OK
 echo "Ce carr&eacute; est large de $carre-&gt;largeur m&egrave;tres.";
 // OK
 echo "Ce carr&eacute; est large de $carre-&gt;largeur00 m&egrave;tres..";
 // pas OK
 // pour r&eacute;soudre ce probl&egrave;me, voyez <link linkend="language.types.string.parsing.complex">syntaxe complexe</link>.
 <!-- XXX this won't work:
 echo "This square is $square->{width}00 centimeters broad.";
 // XXX: php developers: it would be consequent to make this work.
 // XXX: like the $obj->{expr} syntax outside a string works,
 // XXX: analogously to the ${expr} syntax for variable var's.
 -->
       </programlisting>
      </informalexample>
      <simpara>
       Pour tout ce qui sera plus compliqu&eacute;, voyez la syntaxe complexe.
      </simpara>
     </sect4>
     <sect4 id="language.types.string.parsing.complex">
      <title>Syntaxe complexe</title>
      <simpara>
       La syntaxe est dite "complexe" car elle permet l'utilisation d'
       expressions complexes, et non pas parcequ'elle serait obscure.
       Nuance.
     </simpara>
     <simpara>
      En fait, vous pouvez inclure n'importe quelle valeur qui est
      dans l'espace de nom avec cette syntaxe. Il suffit d'&eacute;crire une
      expression exactement comme si elle &eacute;tait hors de la cha&icirc;ne,
      puis de l'entourer d'accolades <literal>{}</literal>. Puisque
      vous ne pouvez pas &eacute;chapper les accolades, cette syntaxe ne commence
      qu'&agrave; partir du signe dollar, qui suit imm&eacute;diatement l'accolade
      ouvrante. Par exemple, vous pouvez utiliser <literal>"{\$"</literal>
      pour obtenir un <literal>"{$"</literal> litt&eacute;ral. Voici quelques
      exemples :
     </simpara>
     <informalexample>
      <programlisting role="php">
&lt;?php
  $super = 'fantastique';
  echo "C'est { $super}";
// ne fonctionne pas,
// affiche "C'est { fantastique}"
  echo "C'est {$super}";
// fonctionne,
// affiche "C'est fantastique"
  echo "Ce carr&eacute; a {$square-&gt;width}00 centim&egrave;tres de large.";
  echo "Ceci fonctionne : {$tableau[4][3]}";
  echo "Ceci &eacute;choue : {$tableau[foo][3]}";
// pour la m&ecirc;me raison que $tableau[bar] ne fonctionne pas hors d'une cha&icirc;ne
 <!-- XXX see the still-to-write explaination in the arrays-section. -->
  echo "Essayez plut&ocirc;t comme ceci : {$tableau['foo'][3]}";
  echo "Vous pouvez m&ecirc;me &eacute;crire {$objet-&gt;valeurs[3]-&gt;nom}";
  echo "Voici la valeur de la variable nomm&eacute;e $name: {${$name}}";
  <!-- <xxx> maybe it's better to leave this out?? -->
// cela fonctionne, mais c'est vivement d&eacute;conseill&eacute;.
// Et pour finir, on peut combiner avec des fonctions
  $inv = 'Bordeaux';
  echo "Je reprendrai bien un verre de cet excellent {${ strrev('niv') }}, hips";
 <!-- </xxx> -->
?&gt;
       </programlisting>
      </informalexample>
     </sect4>
    </sect3>
    <sect3 id="language.types.string.substr">
     <title>Acc&egrave;s aux caract&egrave;res d'une cha&icirc;ne</title>
     <para>
      Les caract&egrave;res d'une cha&icirc;ne sont accessibles en sp&eacute;cifiant
      leur offset (le premier caract&egrave;re est d'offset 0) entre
      accolade, apr&egrave;s le nom de la variable.
     </para>
     <note>
      <simpara>
       Pour assurer la compatibilit&eacute; ascendante, vous pouvez
       toujours acc&eacute;der aux caract&egrave;res avec des crochets.
       Mais cette syntaxe est obsol&egrave;te en PHP 4.
      </simpara>
     </note>
     <para>
      <example>
       <title>Exemples de cha&icirc;nes</title>
       <programlisting role="php">
<!-- TODO: either move these examples to a example section,
as with arrays, or distribute them under the applicable
sections. -->
&lt;?php
/* Affectation d'une cha&icirc;ne. */
  $str = "Ceci est une cha&icirc;ne";
/* Concat&eacute;nation. */
  $str = $str . " avec un peu plus de texte";
/* Une autre m&eacute;thode de concat&eacute;nation. */
  $str .= " et une nouvelle ligne &agrave; la fin.\n";
/*  Cette cha&icirc;ne finira comme : '&lt;p&gt;Nombre: 9&lt;/p&gt;' */
  $num = 9;
  $str = "&lt;p&gt;Nombre: $num&lt;/p&gt;";
/* Celle-ci sera '&lt;p&gt;Nombre: $num&lt;/p&gt;' */
  $num = 9;
  $str = '&lt;p&gt;Nombre: $num&lt;/p&gt;';
/* Premier caract&egrave;re d'une cha&icirc;ne */
  $str = 'Ceci est un test.';
  $first = $str{0};
/* Dernier caract&egrave;re d'une cha&icirc;ne. */
  $str = 'This is still a test.';
  $last = $str{strlen($str)-1};
?&gt;
       </programlisting>
      </example>
     </para>
    </sect3>
   </sect2><!-- end syntax -->
   <sect2 id="language.types.string.useful-funcs">
    <title>Fonctions et op&eacute;rateurs pratiques</title><!-- and operators -->
    <para>
     Les cha&icirc;nes peuvent &ecirc;tre concat&eacute;n&eacute;es avec l'op&eacute;rateur '.' (point).
     Notez que l'op&eacute;rateur d'addition '+' (plus) ne fonctionnera pas.
     Reportez-vous &agrave; la section
     <link linkend="language.operators.string">op&eacute;rateurs de cha&icirc;nes</link>.
    </para>
    <para>
     Il y a une grande quantit&eacute; de fonctions pratiques pour modifier
     les cha&icirc;nes.
    </para>
    <simpara>
     Reportez-vous &agrave; la section <link linkend="ref.strings">cha&icirc;nes de caract&egrave;res</link>
     pour les fonctions les plus g&eacute;n&eacute;rales, &agrave; <link linkend="ref.pcre">Expressions
     r&eacute;guli&egrave;res Perl</link> et <link linkend="ref.regex">Expressions r&eacute;guli&egrave;res
     POSIX extendues</link> pour les recherches et remplacements.
    </simpara>
    <simpara>
     Il y a aussi les fonctions sur les <link linkend="ref.url">URL</link>,
     ainsi que des fonctions de chiffrage (<link linkend="ref.mcrypt">mcrypt</link> et
     <link linkend="ref.mhash">mhash</link>).
    </simpara>
    <simpara>
     Finalement, si vous ne trouvez toujours pas votre bonheure, il y a les
     fonctions de <link linkend="ref.ctype">types de caract&egrave;res</link>.
    </simpara>
   </sect2>
   <sect2 id="language.types.string.conversion">
    <title>Conversion de type</title>
    <simpara>
      Lorsqu'une cha&icirc;ne de caract&egrave;re est
      &eacute;valu&eacute;e comme une valeur num&eacute;rique,
      le r&eacute;sultat et le type de la variable sont
      d&eacute;termin&eacute;s comme suit.
    </simpara>
    <simpara>
      La cha&icirc;ne de caract&egrave;res est de type "double" si
      elle contient un des caract&egrave;re '.', 'e' ou 'E'. Sinon,
      elle est de type entier ("integer").
    </simpara>
    <para>
      La valeur est d&eacute;finie par la premi&egrave;re partie
      de la cha&icirc;ne. Si la cha&icirc;ne de caract&egrave;res
      d&eacute;bute par une valeur num&eacute;rique cette valeur
      sera celle utilis&eacute;e. Sinon, la valeur sera &eacute;gale
      &agrave; 0 (z&eacute;ro).
    </para>
    <simpara>
      Lorsque la premi&egrave;re expression est une cha&icirc;ne de
      caract&egrave;res, le type de la variable d&eacute;pend de la
      seconde expression.
    </simpara>
    <informalexample>
     <programlisting role="php">
&lt;?php
  $foo = 1 + "10.5";              // $foo est du type  float (11.5)
  $foo = 1 + "-1.3e3";            // $foo est du type  float (-1299)
  $foo = 1 + "bob-1.3e3";         // $foo est du type  integer (1)
  $foo = 1 + "bob3";              // $foo est du type  integer (1)
  $foo = 1 + "10 Small Pigs";     // $foo est du type  integer (11)
  $foo = 1 + "10 Little Piggies"; // $foo est du type  integer (11)
  $foo = "10.0 pigs " + 1;        // $foo est du type  integer (11)
  $foo = "10.0 pigs " + 1.0;      // $foo est du type  float (11)
?&gt;
     </programlisting>
    </informalexample>
    <simpara>
      Pour plus d'informations sur les conversions de type, voir les
      pages de man &agrave; propos de la fonction strtod(3).
    </simpara>
    <para>
     Si vous voulez testez l'un des exemples de cette section,
     vous pouvez faire un copier/coller et l'ins&eacute;rer dans un script
     pour voir comment il se comporte.
     <informalexample>
      <programlisting role="php">
&lt;?php
  echo "\$foo==$foo; type is " . gettype( $foo ) . "&lt;br&gt;\n";
?&gt;
      </programlisting>
     </informalexample>
    </para>
   </sect2>
  </sect1>
  <sect1 id="language.types.array">
   <title>Les tableaux</title>
   <para>
    Un tableau PHP est en fait une association ordonn&eacute;e (map). Une
    association est un type qui fait correspondre des valeurs
    &agrave; des <emphasis>cl&eacute;s</emphasis>.  Ce type est optimis&eacute;
    de diverses fa&ccedil;ons, qui font que vous pouvez le manipuler comme
    un tableau &agrave; indices r&eacute;els, une liste (vecteur), ou un table
    de hachage (qui est une impl&eacute;mentation d'association),
    dictionnaire, collection, pile, queue et encore d'autres.
    Comme une valeur peut elle-m&ecirc;me &ecirc;tre un tableau, vous pouvez
    simuler facilement un arbre.
   </para>
    <para>
     Les d&eacute;tails d'impl&eacute;mentation de ces structures sont hors du
     champs de ce manuel, mais vous trouverez ici un exemple
     de toutes ces structures.
    </para>
   <sect2 id="language.types.array.syntax">
    <title>Syntaxe</title>
    <sect3 id="language.types.array.syntax.array-func">
     <title>Cr&eacute;er un tableau <function>array</function></title>
     <para>
      Un tableau <type>array</type> peut &ecirc;tre cr&eacute;&eacute; avec la fonction
      <function>array</function>. Cette fonction prend en argument
      des structures <literal><replaceable>key</replaceable> =&gt;
      <replaceable>value</replaceable></literal>, s&eacute;par&eacute;es par des virgules.
     </para>
     <para>
      Une cl&eacute; <varname>key</varname> est soit un entier positif
      ou bien une cha&icirc;ne.
      <!--
      Negative integers are also allowed, however, IMO it's best to not
      document that, or even disencourage it.
      Why?
      First, because it is very tricky. But the real reason is that the key
      '-1' will be interpreted as a string, and not as a integer. Therefore,
      the usage
      "the -1'st value of \$arr is $arr[-1]" is ambigious. By the way,
      it results in a parse-error anyway, which is another argument for
      not documenting it.
      -Jeroen
      -->
      Si une cl&eacute; est la repr&eacute;sentation standard d'un entier positif,
      elle sera interpr&eacute;t&eacute; comme tel. (i.e. <literal>'8'</literal> sera
      interpr&eacute;t&eacute; comme <literal>8</literal>, tandis que <literal>'08'</literal>
      sera interpr&eacute;t&eacute; comme <literal>'08'</literal>).
     </para>
     <para>
      Une valeur peut &ecirc;tre n'importe quoi.
     </para>
     <sect4 id="language.types.array.omit-key">
      <title>Omettre des cl&eacute;s</title>
      <para>
       Si vous omettez une cl&eacute; lors de la sp&eacute;cification d'un tableau,
       l'indice maximum + 1 sera utilis&eacute; comme cl&eacute; par d&eacute;faut. Si aucun
       indice num&eacute;rique n'a &eacute;t&eacute; g&eacute;n&eacute;r&eacute;, ce sera 0. Si vous sp&eacute;cifiez une
       qui a d&eacute;j&agrave; &eacute;t&eacute; assign&eacute;,
       la nouvelle valeur &eacute;crasera la pr&eacute;c&eacute;dente.
      </para>
      <para>
       <synopsis>
array( <optional><replaceable>key</replaceable> =&gt; </optional>
<replaceable>value</replaceable>
     , ...
     )
// <replaceable>key</replaceable> is either <type>string</type>
ou entier <type>integer</type> positif
// <replaceable>value</replaceable> peut &ecirc;tre n'importe quoi
       </synopsis>
      </para>
     </sect4>
    </sect3>
    <sect3 id="language.types.array.syntax.modifying">
     <title>La syntaxe &agrave; crochets</title>
     <para>
      Vous pouvez aussi modifier un tableau existant en lui assignant
      simplement des valeurs.
     </para>
     <para>
      L'assignement de valeurs de tableau se fait en sp&eacute;cifiant la cl&eacute;
      entre crochets. Si vous omettez la cl&eacute; ("<literal>$tableau[]</literal>"),
      la valeur sera ajout&eacute;e &agrave; la fin du tableau.
      <synopsis>
$arr[<replaceable>key</replaceable>] = <replaceable>value</replaceable>;
$arr[] = <replaceable>value</replaceable>;
// <replaceable>key</replaceable> est soit une cha&icirc;ne, soit un entier
// <replaceable>value</replaceable> peut &ecirc;tre n'importe quoi
      </synopsis>
      Si <varname>$arr</varname> n'existe pas, il sera cr&eacute;&eacute;. Cela
      en fait une alternative pour cr&eacute;er un tableau. Pour modifier une
      valeur, assignez lui une nouvelle valeur. Pour supprimer une
      valeur, utilisez la fonction <function>unset</function>.
     </para>
    </sect3>
   </sect2><!-- end syntax -->
   <sect2 id="language.types.array.useful-funcs">
    <title>Fonctions pratiques</title>
    <para>
     Il y a toute une panoplie de fonctions pratiques pour travailler
     avec les tableau : <link linkend="ref.array">array-functions</link>.
    </para>
    <para>
     L'&eacute;l&eacute;ment de langage <link linkend="control-structures.foreach">foreach</link>
     est sp&eacute;cifiquement d&eacute;di&eacute;e aux tableau : elle permet de passer en
     revue simplement les valeurs d'un tableau.
    </para>
   </sect2>
   <sect2 id="language.types.array.examples">
    <title>Exemples</title>
    <para>
     Le type tableau de PHP est tr&egrave;s souple. Voici quelques exemples d'utilisation :
    </para>
    <para>
      <informalexample>
       <programlisting role="php">
&lt;?php
// ceci
  $a = array( 'couleur' => 'rouge'
            , 'gout' => 'sucre'
            , 'forme' => 'rond'
            , 'nom'  => 'pomme'
            ,            4        // cette cl&eacute; sera 0
          );
// est compl&eacute;tement &eacute;quivalent &agrave;
  $a['couleur'] = 'rouge';
  $a['gout'] =    'sucre';
  $a['forme'] =   'rond';
  $a['nom'] =     'pomme';
  $a[]        = 4;        // cette cl&eacute; sera 0
  $b[] = 'a';
  $b[] = 'b';
  $b[] = 'c';
// va cr&eacute;er le tableau array( 0 => 'a' , 1 => 'b' , 2 => 'c' )
// ou plus simplement array('a' , 'b' , 'c' )
?&lt;
       </programlisting>
      </informalexample>
     </para>
    <example>
     <title>Utilisation de <function>array</function></title>
     <programlisting role="php">
&lt;?php
// Array comme correspondance
  $map = array( 'version'    =&gt; 4
              , 'OS'         =&gt; 'Linux'
              , 'langue'       =&gt; 'fran&ccedil;ais'
              , 'short_tags' =&gt; TRUE             );
// valeur strictement num&eacute;riques
  $array = array( 7
                , 8
                , 0
                , 156
                , -10
                );
// ceci est la m&ecirc;me chose que array( 0 =&gt; 7, 1 =&gt; 8, ...)
  $switching = array(         10 // cl&eacute; = 0
                    , 5    =&gt;  6
                    , 3    =&gt;  7
                    , 'a'  =&gt;  4
                    ,         11 // cl&eacute; = 6 (index maximum : 5)
                    , '8'  =&gt;  2 // cl&eacute; = 8 (entier!)
                    , '02' =&gt; 77 // cl&eacute; = '02'
                    , 0    =&gt; 12 // la valeur de la cl&eacute; 10 sera remplac&eacute;e par 12
                    );
<!-- TODO example of
- mixed keys
- overwriting keys
- integer keys as string
- using vars/functions as key/values
- mixed skipping
-->
// empty array
$empty = array();
?&lt;
     </programlisting>
    </example>
    <example id="language.types.array.examples.loop">
     <title>Collection</title>
     <programlisting role="php">
&lt;?php
  $couleurs = array('rouge','bleu','vert','jaune');
  foreach ( $couleurs as $couleur ){
    echo "Aimez-vous la couleur $couleur?\n";
  }
/* Affiche :
Aimez-vous la couleur rouge?
Aimez-vous la couleur bleu?
Aimez-vous la couleur vert?
Aimez-vous la couleur jaune?
*/
?&gt;
     </programlisting>
    </example>
    <para>
     Notez qu'il n'est pas possible actuellement de modifier les
     valeurs d'un tableau avec une telle boucle.
      <!--
       Should be made possible, if you write:
       foreach ( $colors as &amp;$color )
       See bug#3074
      -->
     Une solution pour cela est :
     <example id="language.types.array.examples.changeloop">
      <title>Collection</title>
      <programlisting role="php">
&lt;?php
  foreach( $couleurs as $cle => $couleur ){
// ne marche pas
//$couleur = strtoupper($couleur);
//marche :
    $couleurs[$cle] = strtoupper($couleur);
  }
  print_r($couleur);
/* Affiche :
Array
(
    [0] => ROUGE
    [1] => BLEU
    [2] => VERT
    [3] => JAUNE
)
*/
?&gt;
      </programlisting>
     </example>
    </para>
    <para>
     Cet exemple cr&eacute;e un tableau d'index minimal 1.
     <example>
      <title>Tableau en 1</title>
      <programlisting role="php">
&lt;?php
  $firstquarter  = array(1 => 'Janvier', 'F&eacute;vrier', 'Mars');
  print_r($firstquarter);
/* Affiche:
Array
(
    [1] => 'Janvier'
    [2] => 'F&eacute;vrier'
    [3] => 'Mars'
)
*/
?&gt;
      </programlisting>
     </example>
    </para>
    <example>
     <title>Remplissage d'un tableau</title>
     <programlisting role="php">
&lt;?php
// remplis un tableau avec les noms de fichiers d'un dossier
  $handle = opendir('.');
  while ( $file = readdir($handle) ){
    $files[] = $file;
  }
  closedir($handle);
?&gt;
     </programlisting>
    </example>
    <para>
     Les tableaux sont ordonn&eacute;s. Vous pouvez modifier l'ordre des
     valeurs avec de nombreuses fonctions de classement. Voyez les
     fonctions de <link linkend="ref.array">tableaux</link>.
    </para>
    <example>
     <title>Tri de tableaux</title>
     <programlisting role="php">
&lt;?php
  sort($files);
  print_r($files);
?&gt;
     </programlisting>
    </example>
    <para>
     Comme une valeur de tableau peut &ecirc;tre n'importe quoi, elle
     peut aussi &ecirc;tre un autre tableau. Comme cela, vous pouvez
     avoir des tableaux multi-dimensionnels, ou r&eacute;cursifs.
    </para>
    <example>
     <title>Tableaux multi-dimensionnels, et r&eacute;cursifs</title>
     <programlisting role="php">
&lt;?php
  $fruits = array ( "fruits"  =&gt; array ( "a" =&gt; "orange"
                                          , "b" =&gt; "banane"
                                          , "c" =&gt; "pomme"
                                          )
                   , "nombres" =&gt; array ( 1
                                           , 2
                                           , 3
                                           , 4
                                           , 5
                                           , 6
                                           )
                   , "trous"   =&gt; array ( "premier"
                                           , 5 =&gt; "second"
                                           , "troisi&egrave;me"
                                           )
                  );
<!-- quite duplicate...
$a = array(
     "apple"  => array(
          "color"  => "red",
          "taste"  => "sweet",
          "shape"  => "round"
     ),
     "orange"  => array(
          "color"  => "orange",
          "taste"  => "tart",
          "shape"  => "round"
     ),
     "banana"  => array(
          "color"  => "yellow",
          "taste"  => "paste-y",
          "shape"  => "banana-shaped"
     )
);
-->
?&gt;
     </programlisting>
    </example>
   </sect2>
   <sect2 id="language.types.array.donts">
    <title>Attention aux tableaux</title>
    <sect3 id="language.types.array.foo-bar">
     <title>Pourquoi est ce que <literal>$foo[bar]</literal> est invalide?</title>
     <para>
      Dans vos vieux scripts, vous pouvez avoir utilis&eacute; la syntaxe suivante :
      <informalexample>
       <programlisting role="php">
&lt;?php
  $foo[bar] = 'ennemi';
  echo $foo[bar];
?&gt;
       </programlisting>
      </informalexample>
      Cela est mauvais, mais ca marche. Pourquoi est-ce mauvais? La raison
      est que PHP r&eacute;clame une expression entre les crochets (comme
      indiqu&eacute; dans la section sur la
      <link linkend="language.types.array.syntax">syntaxe</link> des tableaux).
      Cela signifie que vous pouvez &eacute;crire quelque chose comme :
      <informalexample>
       <programlisting role="php">
&lt;?php
  echo $arr[ foo(true) ];
?&gt;
       </programlisting>
      </informalexample>
      Ceci est un exemple d'utilisation de retour de fonction dans un
      index de tableau. PHP reconnait aussi les constantes, et vous
      pouvez avoir d&eacute;j&agrave; rencontr&eacute; <literal>E_*</literal>.
      <informalexample>
       <programlisting role="php">
&lt;?php
  $error_descriptions[E_ERROR] = "Une erreur fatale est survenue";
  $error_descriptions[E_WARNING] = "PHP a g&eacute;n&eacute;r&eacute; une alerte";
  $error_descriptions[E_NOTICE] = "Ceci est juste une note gr&acirc;cieuse";
?&gt;
       </programlisting>
      </informalexample>
      Notez que <literal>E_ERROR</literal> est aussi un identifiant
      vlaide, tout comme <literal>bar</literal> dans le premier exemple.
      Mais le dernier exemple revient &agrave; &eacute;crire :
      <informalexample>
       <programlisting role="php">
&lt;?php
  $error_descriptions[1] = "Une erreur fatale est survenue";
  $error_descriptions[2] = "PHP a g&eacute;n&eacute;r&eacute; une alerte";
  $error_descriptions[8] = "Ceci est juste une note gr&acirc;cieuse";
?&gt;
       </programlisting>
      </informalexample>
      car <literal>E_ERROR</literal> &eacute;gale <literal>1</literal>, etc.
     </para>
     <para>
      Alors, comment se fait-tile que <literal>$foo[bar]</literal> fonctionne?
      C'est parce que <literal>bar</literal> est attendu comme une
      constante. Cependant, dans ce cas, aucune constante n'a pour nom
      <literal>bar</literal>. PHP suppose alors que vous voulez dire
      <literal>bar</literal> litt&eacute;ralement, c'est-&agrave;-dire la
      cha&icirc;ne <literal>"bar"</literal>, mais que vous avez oubli&eacute; les
      guillements.
     </para>
     <sect4 id="language.types.array.foo-bar.why">
      <title>Alors, pourquoi est-ce mal?</title>
      <para>
       Dans le futur, l'&eacute;quipe de d&eacute;veloppement peut vouloir ajouter une
       nouvelle constante et vous vous retrouverez dans la panade. Par
       exemple, vous ne pouvez d&eacute;j&agrave; pas utiliser les constantes
       <literal>empty</literal> et <literal>default</literal>, car ce
       sont des mots reserv&eacute;s.
       <!-- <jeroen>hmm... i'm doubting this myself. Finish it if you like</jeroen>
       But probably
       the most threatening
       thing is yourself, or whoever will maintain the script. You'll
       maybe get very strange behaviour, and
       -->
      </para>
      <para>
       Et, pour en mettre une autre couche, cette syntaxe est tout simplement
       obsol&egrave;te, et risque de ne plus fonctionner du tout un jour ou l'autre.
      </para>
      <note>
       <simpara>
        Lorsque vous activez le rapport d'erreur avec <function>error_reporting</function>
        avec <literal>E_ALL</literal>, PHP g&eacute;n&eacute;rera des notes &agrave; chaque fois que cette
        syntaxe est utilis&eacute;e. Essayez donc <literal>error_reporting(E_ALL);</literal>
        dans vos scripts, pour voir).
       </simpara>
      </note>
      <note>
       <simpara>
        Dans une cha&icirc;ne &agrave; guillements doubles, une autre syntaxe est
        valide. Voyez la section sur
        <link linkend="language.types.string.parsing">Traitement des variables
        dans les cha&icirc;nes</link> pour plus de d&eacute;tails.
        </simpara>
       </note>
     </sect4>
    </sect3>
   </sect2>
   <!-- TODO
   - example multi-dim with $arr[bla][bla] syntax
   - converting to array
   - warning about references
   - note that assigning is copy (usually...)
   -->
<!-- there is no such thing as multi/singel dim arrays (at least in PHP4)
    <sect2 id="language.types.array.single-dim">
     <title>Single Dimension Arrays</title>
     <para>
      PHP supports both scalar and associative arrays. In fact, there
      is no difference between the two.  You can create an array using
-     the <function>list</function> or <function>array</function>
     the
     <function>list</function>
     Nope
     or <function>array</function>
      functions, or you can explicitly set each array element value.
 ++++++++++++++++++++++++++++++++++++++++++++
   <para>
     Les tableaux ressemblent aux tableaux associatifs et
     aux tableaux index&eacute;s (vecteurs).</para>
   <sect2 id="language.types.array.single-dim">
    <title>Tableaux &agrave; une dimension</title>
    <para>
      PHP supporte les tableaux scalaires et les tableaux associatifs.
      En fait, il n'y a aucune diff&eacute;rence entre les deux. Vous
      pouvez cr&eacute;er un tableau en utilisant les fonctions
      <function>list</function> ou <function>array</function>, ou bien
      en affectant explicitement chacune des valeurs.
     <informalexample>
      <programlisting role="php">
&lt;?php
$a[0] = "abc";
$a[1] = "def";
$b["foo"] = 13;
?&gt;
      </programlisting>
     </informalexample>
    </para>
    <para>
      Vous pouvez aussi cr&eacute;er un tableau en ajoutant
      simplement les valeurs &agrave; ce tableau.
     <informalexample>
      <programlisting role="php">
&lt;?php
$a[] = "Bonjour"; // $a[2] == "Bonjour";
$a[] = "Monde"; // $a[3] == "Monde";
?&gt;
      </programlisting>
     </informalexample>
    </para>
    <para>
     Un tableau peut &ecirc;tre tri&eacute; en utilisant les fonctions
     <function>asort</function>,
     <function>arsort</function>, <function>ksort</function>,
     <function>rsort</function>, <function>sort</function>,
     <function>uasort</function>, <function>usort</function>, ou
     <function>uksort</function> en fonction du type de classement que vous voulez.
    </para>
    <para>
      Vous pouvez compter le nombre d'&eacute;l&eacute;ments qu'il y
      a dans un tableau en utilisant la fonction <function>count</function>.
    </para>
    <para>
      Vous pouvez-vous d&eacute;placer &agrave; l'int&eacute;rieur d'un
      tableau en utilisant les fonctions <function>next</function> et
      <function>prev</function>. Un autre moyen de se d&eacute;placer
      dans un tableau est d'utiliser la fonction <function>each</function>.
    </para>
   </sect2>
   <sect2 id="language.types.array.multi-dim">
    <title>Tableaux &agrave; plusieurs dimensions</title>
    <para>
      Les tableaux &agrave; plusieurs dimensions sont extr&ecirc;mement simples.
      Pour chaque dimension du tableau, vous ajouter une nouvelle [clef] &agrave;
      la fin:
     <informalexample>
      <programlisting role="php">
&lt;?php
$a[1]      = $f;               # tableau &agrave; une dimension
$a["foo"]  = $f;
$a[1][0]     = $f;             # tableau &agrave; deux dimensions
$a["foo"][2] = $f;             # vous pouvez m&eacute;langer les indices associatifs et num&eacute;riques
$a[3]["bar"] = $f;             # vous pouvez m&eacute;langer les indices associatifs et num&eacute;riques
$a["foo"][4]["bar"][0] = $f;   # tableau &agrave; quatre dimensions
?&gt;
      </programlisting>
     </informalexample>
    </para>
    <para>
     En PHP 3 il n'est pas possible de r&eacute;f&eacute;rencer un tableau
     &agrave; l'int&eacute;rieur d'une cha&icirc;ne. Par exemple, ceci ne
     fonctionne pas :
     <informalexample>
      <programlisting role="php">
&lt;?php
$a[3]['bar'] = 'Bob';
echo "Cela ne marche pas : $a[3][bar]";
?&gt;
      </programlisting>
     </informalexample>
     En PHP 3, l'exemple ci-dessus va afficher :
     <computeroutput>Cela ne marche pas : Array[bar]</computeroutput>.
     L'op&eacute;rateur de concat&eacute;nation,
     peut &ecirc;tre utilis&eacute; pour corriger cela :
     <informalexample>
      <programlisting role="php">
&lt;?php
$a[3]['bar'] = 'Bob';
echo "Cela ne marche pas : " . $a[3][bar];
?&gt;
      </programlisting>
     </informalexample>
    </para>
    <para>
     En PHP 4, cependant, le probl&egrave;me peut &ecirc;tre contourn&eacute;
     en entourant le tableau par des accolades :
     <informalexample>
      <programlisting role="php">
&lt;?php
$a[3]['bar'] = 'Bob';
echo "Cela marche  : {$a[3][bar]}";
?&gt;
      </programlisting>
     </informalexample>
    </para>
    <para>
      Vous pouvez remplir un tableau &agrave; plusieurs dimensions
      par de nombreux moyens mais la m&eacute;thode la plus simple
      &agrave; comprendre est l'utilisation de la fonction
      <function>array</function>. Les deux exemples suivants
      montre comment remplir un tableau &agrave; une dimension:
     <informalexample>
      <programlisting role="php">
&lt;?php
# Exemple 1:
$a["couleur"]	= "rouge";
$a["saveur"]	= "sucr&eacute;e";
$a["forme"]		= "rond";
$a["nom"]		= "pomme";
$a[3]			= 4;
# Exemple 2:
$a = array(
     "couleur" =&gt; "rouge",
     "saveur" =&gt; "sucr&eacute;e",
     "forme" =&gt; "rond",
     "nom"  =&gt; "pomme",
     3       =&gt; 4
);
?&gt;
      </programlisting>
     </informalexample>
    </para>
    <para>
     La fonction <function>array</function> peut &ecirc;tre
     embo&icirc;t&eacute;e pour remplir un tableau &agrave;
     plusieurs dimensions :
     <informalexample>
      <programlisting role="php">
&lt;?php
$a = array(
     "pomme"  =&gt; array(
          "couleur"  =&gt; "rouge",
          "saveur"  =&gt; "sucr&eacute;e",
          "forme"  =&gt; "rond"
     ),
     "orange"  =&gt; array(
          "couleur"  =&gt; "orange",
          "saveur"  =&gt; "am&egrave;re",
          "forme"  =&gt; "rond"
     ),
     "banane"  =&gt; array(
          "couleur"  =&gt; "jaune",
          "saveur"  =&gt; "paste-y",
          "forme"  =&gt; "banano&iuml;de"
     )
);
echo $a["pomme"]["saveur"];    # va afficher "sucr&eacute;e"
?&gt;
      </programlisting>
     </informalexample>
    </para>+
   </sect2>
   -->
  </sect1>
  <sect1 id="language.types.object">
   <title>Les objets</title>
   <sect2 id="language.types.object.init">
    <title>Initialisation d'un objet</title>
    <para>
      Pour initialiser un objet, vous devez utiliser la commande "new"
      afin de cr&eacute;er linstance de l'objet.
     <informalexample>
       <programlisting role="php">
&lt;?php
  class foo {
    function faire_foo () {
        echo "Faisant foo.";
    }
  }
  $bar = new foo;
  $bar-&gt;faire_foo();
?&gt;
      </programlisting>
     </informalexample>
    </para>
   </sect2>
  </sect1>
  <sect1 id="language.types.resource">
   <title>Ressources</title>
    <para>
     Une ressource (resource en anglais), est un type sp&eacute;cial,
     qui repr&eacute;sente une r&eacute;f&eacute;rence sur une ressource externe. Les
     ressources sont cr&eacute;&eacute;es par des fonctions d&eacute;di&eacute;es. Reportez
     vous &agrave; l'annexe <link linkend="resources">ressource</link>
     pour une liste exhaustive des fonctions cr&eacute;ant et utilisant
     ces ressources.
    </para>
    <note>
     <simpara>
      Le type ressource a &eacute;t&eacute; introduit en PHP 4.
     </simpara>
    </note>
    <sect2 id="language.types.resource.self-destruct">
     <title>Lib&eacute;rer des ressources</title>
    <para>
     Gr&acirc;ce au syst&egrave;me de comptabilisation des r&eacute;f&eacute;rences
     introduit en PHP 4 (avec le moteur Zend), PHP d&eacute;tecte automatiquement
     qu'une ressource n'est plus utilis&eacute;e (comme Java). Dans ce cas,
     toutes les ressources syst&egrave;mes utilis&eacute;es par cette
     ressource sont lib&eacute;r&eacute;es automatiquement.
     <note>
      <simpara>
       Les connexions persistantes repr&eacute;sentent un cas
       particulier, elles ne seront <emphasis>PAS</emphasis>
       d&eacute;truites. Voyez
       <link linkend="features.persistent-connections">connexions persistantes</link>.
      </simpara>
     </note>
    </para>
   </sect2>
  </sect1>
  <sect1 id="language.types.null">
   <title>La valeur NULL</title>
   <para>
    La valeur sp&eacute;ciale <literal>NULL</literal> repr&eacute;sente
    l'absence de valeur. Une variable avec la valeur NULL n'a
    pas de valeur.
   </para>
   <sect2 id="language.types.null.syntax">
    <title>Syntaxe</title>
    <para>
     Il y a seulement une valeur de type NULL, et c'est la constante
     <literal>NULL</literal>, insensible &agrave; la casse.
     <informalexample>
      <programlisting role="php">
&lt;?php
  $var = Null;
?&gt;
      </programlisting>
     </informalexample>
    </para>
    <note>
     <simpara>
      La valeur NULL a &eacute;t&eacute; introduite en PHP 4.
     </simpara>
    </note>
   </sect2>
  </sect1>
  <sect1 id="language.types.type-juggling">
   <title>D&eacute;finition du type</title>
   <simpara>
     PHP ne n&eacute;cessite pas de d&eacute;claration explicite
     du type d'une variable. Le type d'une variable est
     d&eacute;termin&eacute; par le contexte d'utilisation.
     Par exemple, si vous assignez une cha&icirc;ne de caract&egrave;res
     &agrave; la variable <parameter>var</parameter>, var devient une
     cha&icirc;ne de caract&egrave;re. Si vous assignez un nombre
     entier &agrave; <parameter>var</parameter>, elle devient un entier.
   </simpara>
   <para>
     Un exemple de convertisseur automatique de type est l'op&eacute;rateur
     '+'. Si un des op&eacute;randes est de type double, alors tous les
     op&eacute;randes sont &eacute;valu&eacute;s comme des variables de
     type double et le r&eacute;sultat est de type double. Sinon, tous
     les op&eacute;randes sont &eacute;valu&eacute;s comme des variables
     de type entier et le r&eacute;sultat sera du type entier. Il est
     &agrave; noter que cela NE CHANGE PAS le type des op&eacute;randes.
     Le seul changement est la mani&egrave;re dont les op&eacute;randes
     sont &eacute;valu&eacute;es.
    <informalexample>
     <programlisting role="php">
&lt;?php
  $foo = "0";  // $foo est une cha&icirc;ne de caract&egrave;res (ASCII 48)
  $foo += 2;   // $foo est maintenant du type entier (2)
  $foo = $foo + 1.3;  // $foo est maintenant du type double (3.3)
  $foo = 5 + "10 Petits cochons"; // $foo est du type entier (15)
  $foo = 5 + "10 cochonnets";     // $foo est du type entier (15)
?&gt;
<!--
TODO: explain ++/- - behaviour with strings
examples:
 ++'001' = '002'
 ++'abc' = 'abd'
 ++'xyz' = 'xza'
 ++'9.9' = '9.0'
 ++'-3'  = '-4'
 - -'9'   = 8 (integer!)
 - -'5.5' = '5.5'
 - -'-9'  = -10 (integer)
 - -'09'  = 8 (integer)
 - -'abc' = 'abc'
-->
     </programlisting>
    </informalexample>
   </para>
   <simpara>
     Si les deux derniers exemples vous semblent obscurs ou si vous
     voulez forcer une variable a &ecirc;tre &eacute;valu&eacute;e
     avec un certain type, reportez-vous au paragraphe Conversion de
     type ci-dessous. Si vous voulez changer le type d'une variable,
     int&eacute;ressez-vous &agrave; aux fonctions de
     <link linkend="language.types.string.conversion">conversion de cha&icirc;nes</link>.
   </simpara>
   <simpara>
	Si vous voulez forcer le type d'une variable, vous pouvez
	vous reporter &agrave; la section
	<link linkend="language.types.typecasting">transtypage</link>. Si
	vous voulez changer le type d'une variable, utilisez
	<function>settype</function>.
   </simpara>
   <para>
    Pour tester les exemples de cette section, il suffit d'en faire
    un copier/coller, et d'ins&eacute;rer les lignes dans un script PHP.
    <informalexample>
     <programlisting role="php">
&lt;?php
  echo "\$foo==$foo; le type est " . gettype( $foo ) . "&lt;br&gt;\n";
?&gt;
     </programlisting>
    </informalexample>
   </para>
   <note>
    <para>
     Le comportement de la conversion automatique est actuellement
     ind&eacute;finie.
     <informalexample>
      <programlisting role="php">
&lt;?php
  $a = 1;       // $a est un entier
  $a[0] = "f";  // $a devient un tableau, et $a[0] contient "f"
?&gt;
      </programlisting>
     </informalexample>
    </para>
    <para>
     Bien que dans l'exemple ci-dessus, il semble &eacute;vident que
     $a va devenir un tableau, dont le premier &eacute;l&eacute;ment
     est 'f', consid&eacute;rez l'exemple suivant :
     <informalexample>
      <programlisting role="php">
&lt;?php
  $a = "1";     // $a est une cha&icirc;ne
  $a[0] = "f";  // Qu'est ce qu'une position dans une cha&icirc;ne ? que se passe t il?
?&gt;
      </programlisting>
     </informalexample>
    </para>
    <para>
     Etant donn&eacute; que PHP supporte l'indexation de cha&icirc;ne avec des
     offsets identiques &agrave; celles des tableaux, l'exemple ci-dessus
     conduit &agrave; un probl&egrave;me : est ce que $a est un tableau,
     dont le premier &eacute;l&eacute;ment est "f", ou bien est ce que
     "f" est le premier &eacute;l&eacute;ment de la cha&icirc;ne de
     caract&egrave;res $a?
    </para>
    <para>
     Pour cette raison, aussi bien pour PHP 3.0.12 que PHP 4.0b3-RC4,
     le r&eacute;sultat de la conversion automatique est
     consid&eacute;r&eacute; comme ind&eacute;finie. Des solutions
     sont en cours de discussion.
     </para>
   </note>
   <sect2 id="language.types.typecasting">
    <title>Transtypage</title>
    <para>
      La conversion de type en PHP fonctionne de la m&ecirc;me
      mani&egrave;re qu'en C: le nom du type d&eacute;sir&eacute;
      est &eacute;crit entre parenth&egrave;ses devant la variable
      &agrave; transtyper ("cast").
     <informalexample>
      <programlisting role="php">
&lt;?php
  $foo = 10;   // $foo est un entier
  $bar = (double) $foo;   // $bar est un double
?&gt;
      </programlisting>
     </informalexample>
    </para>
    <para>
     Les conversions autoris&eacute;es sont:
     <itemizedlist>
      <listitem>
       <simpara>(int), (integer) - type entier</simpara>
      </listitem>
      <listitem>
       <simpara>(bool), (boolean) - bool&eacute;en</simpara>
      </listitem>
      <listitem>
       <simpara>(real), (double), (float) - type double</simpara>
      </listitem>
      <listitem>
       <simpara>(string) - ctype cha&icirc;ne</simpara>
      </listitem>
      <listitem>
       <simpara>(array) - type tableau</simpara>
      </listitem>
      <listitem>
       <simpara>(object) - type objet</simpara>
      </listitem>
     </itemizedlist>
    </para>
    <para>
      Il est &agrave; noter que les tabulations et les espaces
      sont autoris&eacute;s &agrave; l'int&eacute;rieur des
      parenth&egrave;ses, donc les lignes suivantes sont &eacute;quivalentes:
     <informalexample>
      <programlisting role="php">
&lt;?php
  $foo = (int) $bar;
  $foo = ( int ) $bar;
?&gt;
      </programlisting>
     </informalexample>
    </para>
    <para>
     Le transtypage n'a pas toujours de r&eacute;sultat pr&eacute;visible.
     Pour plus d'informations, voyez :
    </para>
     <itemizedlist>
      <listitem>
       <simpara>
        <link linkend="language.types.boolean.casting">Conversion en bool&eacute;en</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.integer.casting">Conversion en entier</link>
       </simpara>
      </listitem>
      <!-- don't exist yet
      <listitem>
       <simpara>
        <link linkend="language.types.float.casting">Conversion en nombre &agrave;
        virgule flottante</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.string.casting">Conversion en
        cha&icirc;ne de caract&egrave;res</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.array.casting">Conversion en tableau</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.object.casting">Conversion en objet</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.resource.casting">Conversion en ressource</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.null.casting">Conversion en NULL</link>
       </simpara>
      </listitem>
      -->
     </itemizedlist>
    <warning>
     <simpara>
      Pour transformer facilement une variable en cha&icirc;ne,
      entourez la simplement de guillements doubles.
     </simpara>
    </warning>
    <para>
     Lors de la conversion d'un tableau en cha&icirc;ne, le r&eacute;sultat sera
     le mot <literal>Array</literal> (tableau, en anglais). Lors de la
     conversion d'un objet en cha&icirc;ne, le r&eacute;sultat sera le mot
     <literal>Object</literal> (objet, en anglais). Dans les deux cas,
     une alerte sera affich&eacute;e.
    </para>
    <para>
	  Lorsque vous transtypez un scalaire ou une cha&icirc;ne en tableau,
	  la variable verra son contenu affect&eacute; au premier
	  &eacute;l&eacute;ment du tableau.
     <informalexample>
      <programlisting role="php">
&lt;?php
  $var = 'ciao';
  $arr = (array) $var;
  echo $arr[0];  // affiche 'ciao'
?&gt;
      </programlisting>
     </informalexample>
    </para>
    <para>
     Lorsque vous transtypez un scalaire ou une cha&icirc;ne en objet,
     la valeur de la variable sera transform&eacute;e en attribut de
     l'objet. L'attribut s'appellera 'scalar':
     <informalexample>
      <programlisting role="php">
&lt;?php
  $var = 'ciao';
  $obj = (object) $var;
  echo $obj-&gt;scalar;  // affiche 'ciao'
?&gt;
      </programlisting>
     </informalexample>
    </para>
   </sect2>
  </sect1>
 </chapter>
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
