  <chapter id="language.types">
	<title>Types</title>
   <para>
    PHP supporte les types suivants :
   <itemizedlist>
    <listitem>
     <simpara>
      <link linkend="language.types.array">tableau</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.types.double">nombre &agrave; virgule flottante</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.types.integer">entier</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.types.object">objet</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.types.string">cha&icirc;ne</link>
     </simpara>
    </listitem>
   </itemizedlist>
  </para>
  <simpara>
     Habituellement, le type d'une variable n'est pas d&eacute;clar&eacute;
     par le programmeur. Il est d&eacute;cid&eacute; au moment de
     l'ex&eacute;cution par le PHP, en fonction du contexte dans
     lequel la variable est utilis&eacute;e.
  </simpara>
  <simpara>
      Si vous voulez forcer une variable &agrave; &ecirc;tre convertie
      en un certain type, vous devez transtyper
      (<link linkend="language.types.typecasting">cast</link>) la
      variable ou utiliser la fonction <function>settype</function>.
  </simpara>
  <simpara>
      Il est &agrave; noter qu'une variable peut se comporter de
      mani&egrave;re diff&eacute;rente suivant les situations, en
      fonction du type qui lui est affect&eacute;.
      Pour plus d'informations, voir le paragraphe
      <link linkend="language.types.type-juggling">transtypage</link>.
  </simpara>
  <sect1 id="language.types.integer">
   <title>Entiers</title>
   <para>
    Il est possible de sp&eacute;cifier les nombres entiers (integers) de
    la mani&egrave;re suivante :
    <informalexample>
     <programlisting role="php">
&lt;?php
$a = 1234; # nombre entier en base 10
$a = -123; # nombre entier n&eacute;gatif
$a = 0123; # nombre entier en base 8, octale (&eacute;quivalent &agrave; 83 en base 10)
$a = 0x12; # nombre entier en base 16, hexad&eacute;cimale (&eacute;quivalent &agrave; 18 en base 10)
?&gt;
     </programlisting>
    </informalexample>
   </para>
  </sect1>
  <sect1 id="language.types.double">
   <title>Les nombres &agrave; virgule flottante</title>
   <para>
    Les nombres &agrave; virgule flottante ("double") peuvent &ecirc;tres
    sp&eacute;cifi&eacute;s en utilisant la syntaxe suivante:
    <informalexample>
     <programlisting role="php">
&lt;?php
$a = 1.234;
$a = 1.2e3;
?&gt;
     </programlisting>
    </informalexample>
   </para>
   <warning id="warn.float-precision">
    <para>
     Il est fr&eacute;quent que de simples fractions d&eacute;cimales telles que
     <literal>0.1</literal> ou <literal>0.7</literal> ne puissent
     &ecirc;tre converties au format interne binaire sans une l&eacute;g&egrave;re perte
     de pr&eacute;cision. Cela peut conduire &agrave; des r&eacute;sultats &eacute;tonnants :
     par exemple, <literal>floor((0.1+0.7)*10)</literal> retournera
     <literal>7</literal> au lieu de <literal>8</literal>
     car le r&eacute;sultat de la repr&eacute;sentation interne est
     <literal>7.9999999999...</literal>.
    </para>
    <para>
     Tout ceci est li&eacute; au fait qu'il est impossible d'exprimer
     certaines fractions en un nombre fini de chiffres. Par exemple
     <literal>1/3</literal> s'&eacute;crira <literal>0.3333333...</literal>
     en mode d&eacute;cimal.
    </para>
    <para>
     Ne fa&icirc;tes donc jamais confiance aux nombres &agrave; virgule
     jusqu'&agrave; leur derni&egrave;re d&eacute;cimale, et ne comparer
     jamais ces nombres avec l'op&eacute;rateur d'&eacute;galit&eacute;.
     Si vous avez besoin d'une pr&eacute;cision particuli&egrave;re,
     reportez vous au traitement des nombres de grande taille avec les
     librairies <link linkend="ref.bc">BC</link> ou <link linkend="ref.gmp">GMP</link>.
    </para>
   </warning>
  </sect1>
  <sect1 id="language.types.string">
   <title>Les cha&icirc;nes de caract&egrave;res</title>
   <para>
    Les cha&icirc;nes de caract&egrave;res peuvent &ecirc;tre d&eacute;finies
    en utilisant deux types de d&eacute;limiteurs.
   </para>
   <para>
    Si la cha&icirc;ne de caract&egrave;res est d&eacute;limit&eacute;e
    par des guillemets doubles ("), les variables &agrave;
    l'int&eacute;rieur de la cha&icirc;ne seront &eacute;valu&eacute;es,
    et remplac&eacute;es par leur valeur. Comme en C ou en Perl, le
    caract&egrave;re antislash (\) est utilis&eacute; pour
    prot&eacute;ger (&eacute;chapper) un caract&egrave;re sp&eacute;cial.
    <table>
     <title>Les caract&egrave;res sp&eacute;ciaux</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>s&eacute;quence</entry>
        <entry>valeur</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>\n</literal></entry>
        <entry>Nouvelle ligne (linefeed, LF ou 0x0A en ASCII)</entry>
       </row>
       <row>
        <entry><literal>\r</literal></entry>
        <entry>Retour &agrave; la ligne(carriage return, CR ou 0x0D en ASCII)</entry>
       </row>
       <row>
        <entry><literal>\t</literal></entry>
        <entry>Tabulation horizontale (HT ou 0x09 en ASCII)</entry>
       </row>
       <row>
        <entry><literal>\\</literal></entry>
        <entry>Antislash</entry>
       </row>
       <row>
        <entry><literal>\$</literal></entry>
        <entry>Caract&egrave;re $</entry>
       </row>
       <row>
        <entry><literal>\"</literal></entry>
        <entry>Guillemet double</entry>
       </row>
       <row>
        <entry><literal>\[0-7]{1,3}</literal></entry>
        <entry>
          Une s&eacute;quence de caract&egrave;re qui permet de
          rechercher un nombre en notation octale.
        </entry>
       </row>
       <row>
        <entry><literal>\x[0-9A-Fa-f]{1,2}</literal></entry>
        <entry>
          Une s&eacute;quence de caract&egrave;re qui permet de
          rechercher un nombre en notation hexad&eacute;cimale.
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>
   <para>
    Vous pouvez utiliser le caract&egrave;re d'&eacute;chappement
    antislash sur n'importe quel autre caract&egrave;re, mais cela
    produira une alerte (si le niveau d'alerte maximal a
    &eacute;t&eacute; fix&eacute;).
   </para>
   <para>
    Le deuxi&egrave;me moyen de d&eacute;limiter une cha&icirc;ne de
    caract&egrave;re est d'utiliser les guillemets simples ("'"). Dans
    une telle cha&icirc;ne de caract&egrave;res, les variables
    <emphasis>ne seront pas</emphasis> &eacute;valu&eacute;es,
    et le caract&egrave;re antislash n'aura aucun effet (&agrave;
    deux exceptions pr&egrave;s, pour "\\" et "\'", afin de pouvoir
    utiliser les caract&egrave;res guillemets simples, et antislash
    dans la cha&icirc;ne de caract&egrave;res).
   </para>
   <para>
    Un autre moyen de d&eacute;limiter les cha&icirc;nes est d'utiliser
    la syntaxe de "Here doc" (en fran&ccedil;ais, doc ici): &lt;&lt;&lt;,
    suivi d'un identifiant arbitraire, puis de la cha&icirc;ne. Cette
    s&eacute;quence se termine par l'identifiant initial, plac&eacute; en
    premier sur une nouvelle ligne. L'identifiant utilis&eacute; doit suivre
    les m&ecirc;mes r&egrave;gles que les &eacute;tiquettes PHP : il ne doit contenir un
    uniquement des caract&egrave;res alpha-num&eacute;riques, et des soulign&eacute;s
    ("_"), et enfin, commencer par un caract&egrave;re alphab&eacute;tique ou un
    soulign&eacute;.
   </para>
   <para>
    La syntaxe Here doc se comporte exactement comme une cha&icirc;ne &agrave;
    guillemets doubles, sans les guillemets doubles. Cela signifie
    que vous n'avez pas &agrave; &eacute;chapper les guillemets (simples ou doubles)
    dans cette syntaxe. Les variables sont remplac&eacute;es par leur valeur, et
    le m&ecirc;me soin doit leur &ecirc;tre aport&eacute; que dans les cha&icirc;nes &agrave; guillemets
    doubles.
    <example>
     <title>Exemple de cha&icirc;ne Here Doc</title>
     <programlisting role="php">
&lt;?php
$str = &lt;&lt;&lt;EOD
Exemple de cha&icirc;ne
s'&eacute;talant sur
plusieurs lignes
avec la syntaxe heredoc
EOD;
/* Exemple plus complexe, avec des variables. */
class foo {
    var $foo;
    var $bar;
    function foo() {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}
$foo = new foo();
$name = 'MonNom';
echo &lt;&lt;&lt;EOT
Mon nom est "$name". J'affiche des $foo->foo.
Maintenant, j'affiche un {$foo->bar[1]}.
Ceci se traduit par un 'A' majuscule: \x41
EOT;
?&gt;
     </programlisting>
    </example>
   </para>
   <note>
    <para>
     Le support Here doc a &eacute;t&eacute; ajout&eacute; en PHP 4.
    </para>
   </note>
   <para>
    Les cha&icirc;nes peuvent &ecirc;tre concat&eacute;n&eacute;es avec
    l'op&eacute;rateur '.' (point). Notez que l'op&eacute;rateur '+'
    (addition) ne fonctionera pas. Reportez vous &agrave;
    <link linkend="language.operators.string">Op&eacute;rateurs de cha&icirc;nes</link>
    pour plus d'informations.
   </para>
   <para>
    <example>
     <title>Quelques exemples de cha&icirc;nes</title>
     <programlisting role="php">
&lt;?php
/* Assignation d'une cha&icirc;ne */
$str = "Ceci est une cha&icirc;ne ";
/*  Concat&eacute;nation d'une cha&icirc;ne */
$str = $str . " avec une extension";
/* Une autre m&eacute;thode de concat&eacute;nation, y compris une nouvelle ligne */
$str .= " et termin&eacute;e par une nouvelle ligne.\n";
/* Cette cha&icirc; se terminera par '&lt;B&gt;Nombre: 9&lt;/B&gt;' */
$nombre = 9;
$str = "&lt;B&gt;Nombre: $nombre&lt;/B&gt;";
/* Cette ci sera '&lt;B&gt;Nombre: $num&lt;/B&gt;' */
$num = 9;
$str = '&lt;B&gt;Nombre: $num&lt;/B&gt;';
/* Lire le premier caract&egrave;re d'une cha&icirc;ne  */
$str = 'Ceci est un test.';
$first = $str[0];
/* Lire le dernier caract&egrave;re d'une cha&icirc;ne */
$str = 'Ceci est un autre test.';
$last = $str[strlen($str)-1];
?&gt;
     </programlisting>
    </example>
   </para>
   <sect2 id="language.types.string.conversion">
    <title>Conversion de type</title>
    <simpara>
      Lorsqu'une cha&icirc;ne de caract&egrave;re est
      &eacute;valu&eacute;e comme une valeur num&eacute;rique,
      le r&eacute;sultat et le type de la variable sont
      d&eacute;termin&eacute;s comme suit.
    </simpara>
    <simpara>
      La cha&icirc;ne de caract&egrave;res est de type "double" si
      elle contient un des caract&egrave;re '.', 'e' ou 'E'. Sinon,
      elle est de type entier ("integer").
    </simpara>
    <para>
      La valeur est d&eacute;finie par la premi&egrave;re partie
      de la cha&icirc;ne. Si la cha&icirc;ne de caract&egrave;res
      d&eacute;bute par une valeur num&eacute;rique cette valeur
      sera celle utilis&eacute;e. Sinon, la valeur sera &eacute;gale
      &agrave; 0 (z&eacute;ro).
    </para>
    <simpara>
      Lorsque la premi&egrave;re expression est une cha&icirc;ne de
      caract&egrave;res, le type de la variable d&eacute;pend de la
      seconde expression.
    </simpara>
    <informalexample>
     <programlisting role="php">
&lt;?php
$foo = 1 + "10.5";              // $foo est du type  double (11.5)
$foo = 1 + "-1.3e3";            // $foo est du type  double (-1299)
$foo = 1 + "bob-1.3e3";         // $foo est du type  integer (1)
$foo = 1 + "bob3";              // $foo est du type  integer (1)
$foo = 1 + "10 Small Pigs";     // $foo est du type  integer (11)
$foo = 1 + "10 Little Piggies"; // $foo est du type  integer (11)
$foo = "10.0 pigs " + 1;        // $foo est du type  integer (11)
$foo = "10.0 pigs " + 1.0;      // $foo est du type  double (11)
?&gt;
     </programlisting>
    </informalexample>
    <simpara>
      Pour plus d'informations sur les conversions de type, voir les
      pages de man &agrave; propos de la fonction strtod(3).
    </simpara>
    <para>
     Si vous voulez testez l'un des exemples de cette section,
     vous pouvez faire un copier/coller et l'ins&eacute;rer dans un script
     pour voir comment il se comporte.
     <informalexample>
      <programlisting role="php">
&lt;?php
echo "\$foo==$foo; type is " . gettype( $foo ) . "&lt;br&gt;\n";
?&gt;
      </programlisting>
     </informalexample>
    </para>
   </sect2>
  </sect1>
  <sect1 id="language.types.array">
   <title>Les tableaux</title>
   <para>
     Les tableaux ressemblent aux tables de hashage (tableaux associatifs) et
     aux tableaux index&eacute;s (vecteurs).</para>
   <sect2 id="language.types.array.single-dim">
    <title>Tableaux &agrave; une dimension</title>
    <para>
      PHP supporte les tableaux scalaires et les tableaux associatifs.
      En fait, il n'y a aucune diff&eacute;rence entre les deux. Vous
      pouvez cr&eacute;er un tableau en utilisant les fonctions
      <function>list</function> ou <function>array</function>, ou bien
      en affectant explicitement chacune des valeurs.
     <informalexample>
      <programlisting role="php">
&lt;?php
$a[0] = "abc";
$a[1] = "def";
$b["foo"] = 13;
?&gt;
      </programlisting>
     </informalexample>
    </para>
    <para>
      Vous pouvez aussi cr&eacute;er un tableau en ajoutant
      simplement les valeurs &agrave; ce tableau.
     <informalexample>
      <programlisting role="php">
&lt;?php
$a[] = "Bonjour"; // $a[2] == "Bonjour";
$a[] = "Monde"; // $a[3] == "Monde";
?&gt;
      </programlisting>
     </informalexample>
    </para>
    <para>
     Un tableau peut &ecirc;tre tri&eacute; en utilisant les fonctions
     <function>asort</function>,
     <function>arsort</function>, <function>ksort</function>,
     <function>rsort</function>, <function>sort</function>,
     <function>uasort</function>, <function>usort</function>, ou
     <function>uksort</function> en fonction du type de classement que vous voulez.
    </para>
    <para>
      Vous pouvez compter le nombre d'&eacute;l&eacute;ments qu'il y
      a dans un tableau en utilisant la fonction <function>count</function>.
    </para>
    <para>
      Vous pouvez vous d&eacute;placer &agrave; l'int&eacute;rieur d'un
      tableau en utilisant les fonctions <function>next</function> et
      <function>prev</function>. Un autre moyen de se d&eacute;placer
      dans un tableau est d'utiliser la fonction <function>each</function>.
    </para>
   </sect2>
   <sect2 id="language.types.array.multi-dim">
    <title>Tableaux &agrave; plusieurs dimensions</title>
    <para>
      Les tableaux &agrave; plusieurs dimensions sont extr&ecirc;mement simples.
      Pour chaque dimension du tableau, vous ajouter une nouvelle [clef] &agrave;
      la fin:
     <informalexample>
      <programlisting role="php">
&lt;?php
$a[1]      = $f;               # tableau &agrave; une dimension
$a["foo"]  = $f;
$a[1][0]     = $f;             # tableau &agrave; deux dimensions
$a["foo"][2] = $f;             # vous pouvez m&eacute;langer les indices associatifs et num&eacute;riques
$a[3]["bar"] = $f;             # vous pouvez m&eacute;langer les indices associatifs et num&eacute;riques
$a["foo"][4]["bar"][0] = $f;   # tableau &agrave; quatre dimensions
?&gt;
      </programlisting>
     </informalexample>
    </para>
    <para>
     En PHP 3 il n'est pas possible de r&eacute;f&eacute;rencer un tableau
     &agrave; l'int&eacute;rieur d'une cha&icirc;ne. Par exemple, ceci ne
     fonctionne pas :
     <informalexample>
      <programlisting role="php">
&lt;?php
$a[3]['bar'] = 'Bob';
echo "Cela ne marche pas : $a[3][bar]";
?&gt;
      </programlisting>
     </informalexample>
     En PHP 3, l'exemple ci dessu va afficher :
     <computeroutput>Cela ne marche pas : Array[bar]</computeroutput>.
     L'op&eacute;rateur de concat&eacute;nation,
     peut &ecirc;tre utilis&eacute; pour corriger cela :
     <informalexample>
      <programlisting role="php">
&lt;?php
$a[3]['bar'] = 'Bob';
echo "Cela ne marche pas : " . $a[3][bar];
?&gt;
      </programlisting>
     </informalexample>
    </para>
    <para>
     En PHP 4, cependant, le probl&egrave;me peut &ecirc;tre contourn&eacute;
     en entourant le tableau par des accolades :
     <informalexample>
      <programlisting role="php">
&lt;?php
$a[3]['bar'] = 'Bob';
echo "Cela marche  : {$a[3][bar]}";
?&gt;
      </programlisting>
     </informalexample>
    </para>
    <para>
      Vous pouvez remplir un tableau &agrave; plusieurs dimensions
      par de nombreux moyens mais la m&eacute;thode la plus simple
      &agrave; comprendre est l'utilisation de la fonction
      <function>array</function>. Les deux exemples suivants
      montre comment remplir un tableau &agrave; une dimension:
     <informalexample>
      <programlisting role="php">
&lt;?php
# Exemple 1:
$a["couleur"]	= "rouge";
$a["saveur"]	= "sucr&eacute;e";
$a["forme"]		= "rond";
$a["nom"]		= "pomme";
$a[3]			= 4;
# Exemple 2:
$a = array(
     "couleur" => "rouge",
     "saveur" => "sucr&eacute;e",
     "forme" => "rond",
     "nom"  => "pomme",
     3       => 4
);
?&gt;
      </programlisting>
     </informalexample>
    </para>
    <para>
     La fonction <function>array</function> peut &ecirc;tre
     embo&icirc;t&eacute;e pour remplir un tableau &agrave;
     plusieurs dimensions :
     <informalexample>
      <programlisting role="php">
&lt;?php
$a = array(
     "pomme"  => array(
          "couleur"  => "rouge",
          "saveur"  => "sucr&eacute;e",
          "forme"  => "rond"
     ),
     "orange"  => array(
          "couleur"  => "orange",
          "saveur"  => "am&egrave;re",
          "forme"  => "rond"
     ),
     "banane"  => array(
          "couleur"  => "jaune",
          "saveur"  => "paste-y",
          "forme"  => "banano&iuml;de"
     )
);
echo $a["pomme"]["saveur"];    # va afficher "sucr&eacute;e"
?&gt;
      </programlisting>
     </informalexample>
    </para>
   </sect2>
  </sect1>
  <sect1 id="language.types.object">
   <title>Les objets</title>
   <sect2 id="language.types.object.init">
    <title>Initialisation d'un objet</title>
    <para>
      Pour initialiser un objet, vous devez utiliser la commande "new"
      afin de cr&eacute;er linstance de l'objet.
     <informalexample>
       <programlisting role="php">
&lt;?php
class foo {
    function faire_foo () {
        echo "Faisant foo.";
    }
}
$bar = new foo;
$bar->do_foo();
?&gt;
      </programlisting>
     </informalexample>
    </para>
   </sect2>
  </sect1>
  <sect1 id="language.types.type-juggling">
   <title>D&eacute;finition du type</title>
   <simpara>
     PHP ne n&eacute;cessite pas de d&eacute;claration explicite
     du type d'une variable. Le type d'une variable est
     d&eacute;termin&eacute; par le contexte d'utilisation.
     Par exemple, si vous assignez une cha&icirc;ne de caract&egrave;res
     &agrave; la variable <parameter>var</parameter>, var devient une
     cha&icirc;ne de caract&egrave;re. Si vous assignez un nombre
     entier &agrave; <parameter>var</parameter>, elle devient un entier.
   </simpara>
   <para>
     Un exemple de convertisseur automatique de type est l'op&eacute;rateur
     '+'. Si un des op&eacute;randes est de type double, alors tous les
     op&eacute;randes sont &eacute;valu&eacute;s comme des variables de
     type double et le r&eacute;sultat est de type double. Sinon, tous
     les op&eacute;randes sont &eacute;valu&eacute;s comme des variables
     de type entier et le r&eacute;sultat sera du type entier. Il est
     &agrave; noter que cela NE CHANGE PAS le type des op&eacute;randes.
     Le seul changement est la mani&egrave;re dont les op&eacute;randes
     sont &eacute;valu&eacute;es.
    <informalexample>
     <programlisting role="php">
&lt;?php
$foo = "0";  // $foo est une cha&icirc;ne de caract&egrave;res (ASCII 48)
$foo++;      // $foo est la cha&icirc;ne de caract&egrave;res "1" (ASCII 49)
$foo += 1;   // $foo est maintenant du type entier (2)
$foo = $foo + 1.3;  // $foo est maintenant du type double (3.3)
$foo = 5 + "10 Petits cochons"; // $foo est du type entier (15)
$foo = 5 + "10 cochonnets";     // $foo est du type entier (15)
?&gt;
     </programlisting>
    </informalexample>
   </para>
   <simpara>
     Si les deux derniers exemples vous semblent obscurs ou si vous
     voulez forcer une variable a &ecirc;tre &eacute;valu&eacute;e
     avec un certain type, reportez vous au paragraphe Conversion de
     type ci-dessous. Si vous voulez changer le type d'une variable,
     int&eacute;ressez vous &agrave; aux fonctions de
     <link linkend="language.types.string.conversion">conversion de cha&icirc;nes</link>.
   </simpara>
   <simpara>
	Si vous voulez forcer le type d'une variable, vous pouvez
	vous reporter &agrave; la section
	<link linkend="language.types.typecasting">transtypage</link>. Si
	vous voulez changer le type d'une variable, utilisez
	<function>settype</function>.
   </simpara>
   <para>
    Pour tester les exemples de cette section, il suffit d'en faire
    un copier/coller, et d'ins&egrave;rer les lignes dans un script PHP.
    <informalexample>
     <programlisting role="php">
&lt;?php
echo "\$foo==$foo; le type est " . gettype( $foo ) . "&lt;br&gt;\n";
?&gt;
     </programlisting>
    </informalexample>
   </para>
   <note>
    <para>
     Le comportement de la conversion automatique est actuellement
     ind&eacute;finie.
     <informalexample>
      <programlisting role="php">
&lt;?php
$a = 1;       // $a est un entier
$a[0] = "f";  // $a devient un tableau, et $a[0] contient "f"
?&gt;
      </programlisting>
     </informalexample>
    </para>
    <para>
     Bien que dans l'exemple ci dessus, il semble &eacute;vident que
     $a va devenir un tableau, dont le premier &eacute;l&eacute;ment
     est 'f', consid&eacute;rez l'exemple suivant :
     <informalexample>
      <programlisting role="php">
&lt;?php
$a = "1";     // $a est une cha&icirc;ne
$a[0] = "f";  // Qu'est ce qu'une position dans une cha&icirc;ne ? que se passe t il?
?&gt;
      </programlisting>
     </informalexample>
    </para>
    <para>
     Etant donn&eacute; que PHP supporte l'indexation de cha&icirc;ne avec des
     offsets identiques &agrave; celles des tableaux, l'exemple ci dessus
     conduit &agrave; un probl&egrave;me : est ce que $a est un tableau,
     dont le premier &eacute;l&eacute;ment est "f", ou bien est ce que
     "f" est le premier &eacute;l&eacute;ment de la cha&icirc;ne de
     caract&egrave;res $a?
    </para>
    <para>
     Pour cette raison, aussi bien pour PHP 3.0.12 que PHP 4.0b3-RC4,
     le r&eacute;sultat de la conversion automatique est
     consid&eacute;r&eacute; comme ind&eacute;finie. Des solutions
     sont en cours de discussion.
     </para>
   </note>
   <sect2 id="language.types.typecasting">
    <title>Transtypage</title>
    <para>
      La conversion de type en PHP fonctionne de la m&ecirc;me
      mani&egrave;re qu'en C: le nom du type d&eacute;sir&eacute;
      est &eacute;crit entre parenth&egrave;ses devant la variable
      &agrave; transtyper ("cast").
     <informalexample>
      <programlisting role="php">
&lt;?php
$foo = 10;   // $foo est un entier
$bar = (double) $foo;   // $bar est un double
?&gt;
      </programlisting>
     </informalexample>
    </para>
    <para>
     Les conversions autoris&eacute;es sont:
     <itemizedlist>
      <listitem>
       <simpara>(int), (integer) - type entier</simpara>
      </listitem>
      <listitem>
       <simpara>(real), (double), (float) - type double</simpara>
      </listitem>
      <listitem>
       <simpara>(string) - ctype cha&icirc;ne</simpara>
      </listitem>
      <listitem>
       <simpara>(array) - type tableau</simpara>
      </listitem>
      <listitem>
       <simpara>(object) - type objet</simpara>
      </listitem>
     </itemizedlist>
    </para>
    <para>
      Il est &agrave; noter que les tabulations et les espaces
      sont autoris&eacute;s &agrave; l'int&eacute;rieur des
      parenth&egrave;ses, donc les lignes suivantes sont &eacute;quivalentes:
     <informalexample>
      <programlisting role="php">
&lt;?php
$foo = (int) $bar;
$foo = ( int ) $bar;
?&gt;
      </programlisting>
     </informalexample>
    </para>
    <para>
      Le transtypage n'a pas toujours le r&eacute;sultat attendu. Par exemple :
    </para>
    <para>
	  Lorsque vous transtypez un scalaire ou une cha&icirc;ne en tableau,
	  la variable verra son contenu affect&eacute; au premier
	  &eacute;l&eacute;ment du tableau.
     <informalexample>
      <programlisting role="php">
&lt;?php
$var = 'ciao';
$arr = (array) $var;
echo $arr[0];  // affiche 'ciao'
?&gt;
      </programlisting>
     </informalexample>
    </para>
    <para>
     Lorsque vous transtypez un scalaire ou une cha&icirc;ne en objet,
     la valeur de la variable sera transform&eacute;e en attribut de
     l'objet. L'attribut s'appellera 'scalar':
     <informalexample>
      <programlisting role="php">
&lt;?php
$var = 'ciao';
$obj = (object) $var;
echo $obj-&gt;scalar;  // affiche 'ciao'
?&gt;
      </programlisting>
     </informalexample>
    </para>
   </sect2>
  </sect1>
 </chapter>
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
