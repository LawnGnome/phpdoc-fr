  <chapter id="language.operators">
   <title>Les op&eacute;rateurs</title>
   <simpara>
   </simpara>

   <sect1 id="language.operators.arithmetic">
    <title>Les op&eacute;rateurs arithm&eacute;tiques</title>
    <simpara>
      Vous rappelez vous des op&eacute;rations &eacute;l&eacute;mentaires 
      apprises &agrave; l'&eacute;cole ? 
    </simpara>
    <table>
     <title>Op&eacute;rations &eacute;l&eacute;mentaires</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Exemple</entry>
        <entry>Nom</entry>
        <entry>R&eacute;sultat</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>$a + $b</entry>
        <entry>Addition</entry>
        <entry> Somme de $a et $b.</entry>
       </row>
       <row>
        <entry>$a - $b</entry>
        <entry>Soustraction</entry>
        <entry>Diff&eacute;rence de $a et $b.</entry>
       </row>
       <row>
        <entry>$a * $b</entry>
        <entry>Multiplication</entry>
        <entry>Produit de $a et $b.</entry>
       </row>
       <row>
        <entry>$a / $b</entry>
        <entry>Division</entry>
        <entry>Quotient de $a etd $b.</entry>
       </row>
       <row>
        <entry>$a % $b</entry>
        <entry>Modulo</entry>
        <entry>Reste de $a divis&eacute; par $b.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <simpara>
      L'op&eacute;rateur de division ("/") retourne une valeur enti&egrave;re
      (le r&eacute;sultat d'une division enti&egrave;re) si les deux op&eacute;randes
      sont entiers (ou bien des cha&icirc;nes converties en entiers. 
      Si l'un des op&eacute;randes est un nombre &agrave; virgule flottante,
      ou bien le r&eacute;sultat d'une op&eacute;ration qui retourne une valeur
      non enti&egrave;re, un nombre &agrave; virgule flottante sera retourn&eacute;.
    </simpara>
   </sect1>

   <sect1 id="language.operators.assignment">
    <title>Les op&eacute;rateurs d'assignement</title>
    <simpara>
       L'op&eacute;rateurs d'assignement le plus simple est le signe "=". 
       Le premier r&eacute;flexe est de penser que ce signe veut dire 
       "&eacute;gal &agrave;". Ce n'est pas le cas. Il signifie que 
       l'op&eacute;rande de gauche se voit affecter la valeur de 
       l'expression qui est &agrave; droite du signe &eacute;gal.
    </simpara>
    <para>
      La valeur d'une expression d'assignement est la valeur 
      assign&eacute;e. Par exemple, la valeur de l'expression 
      '$a = 3' est la valeur 3. Cela permet de faire d'utiliser 
      des astuces telles que : 
      <informalexample>
       <programlisting>
        $a = ($b = 4) + 5; // $a est maintenant &eacute;gal &agrave; 9, et $b vaut 4.
       </programlisting>
      </informalexample>
     </para>
    <para>
     En plus du simple op&eacute;rateur d'assignement, il existe des 
     "op&eacute;rateurs combin&eacute;s" pour tous les op&eacute;rateurs 
     arithm&eacute;tiques et pour les op&eacute;rateurs sur les 
     cha&icirc;nes de caract&egrave;res. Cela permet d'utiliser 
     la valeur d'une variable dans une expression et d'affecter le 
     r&eacute;sultat de cette expression &agrave; cette variable. 
     Par exemple: 
     <informalexample>
      <programlisting>
$a = 3;
$a += 5; // affecte la valeur 8 &agrave; la variable $a. (correspond &agrave; l'instruction '$a = $a + 5');
$b = "Bonjour ";
$b .= " tout le monde!"; // affecte la valeur "Bonjour tout le monde!" &agrave; la variable $b (correspond &agrave; $b = $b." tout le monde!";
      </programlisting>
     </informalexample>
    </para>

   <para>
	On peut noter que l'assignement copie le contenu de la variable originale 
	dans la nouvelle (assignement par valeur), ce qui fait que les changements
	de valeur d'une variable ne modifieront pas la valeur de l'autre. Cela peut
	se rev&eacute;ler important lors de la copie d'un grand tableau 
	durant une boucle. PHP4 supporte aussi l'assignement par 
	r&eacute;f&eacute;rence, en utilisant la syntaxe 
	<computeroutput>$var = &amp;$othervar;</computeroutput>, mais ce 
	n'&eacute;tait pas possible en PHP3. 'L'assignement par 
	r&eacute;f&eacute;rence' signifie que les deux variables contiennent les
	m&ecirc;mes donn&eacute;es, et que la modification de l'une affecte 
	l'autre. D'un autre cot&eacute;, la recopie est tr&egrave;s rapide.
   </para>
  </sect1>

   <sect1 id="language.operators.bitwise">
    <title>Bitwise Operators</title>
    <simpara>
     Les op&eacute;rateurs sur les bits vous permettent de
     manipuler les bits dans un entier.
    </simpara>
    <table>
     <title>Les op&eacute;rateurs sur les bits</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>exemple</entry>
        <entry>nom</entry>
        <entry>r&eacute;sultat</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>$a & $b</entry>
        <entry>ET (AND)</entry>
        <entry>
          Les bits positionn&eacute;s &agrave; 1 dans $a ET dans $b
          sont positionn&eacute;s &agrave; 1.
        </entry>
       </row>
       <row>
        <entry>$a | $b</entry>
        <entry>OU (OR)</entry>
        <entry>
          Les bits positionn&eacute;s &agrave; 1 dans $a OU $b sont 
          sont positionn&eacute;s &agrave; 1.
        </entry>
       </row>
       <row>
        <entry>$a ^ $b</entry>
        <entry>Xor</entry>
        <entry>
          Les bits positionn&eacute;s &agrave; 1 dans $a OU dans $b 
          sont positionn&eacute;s &agrave; 1.
        </entry>
       </row>
       <row>
        <entry>~ $a</entry>
        <entry>NON (Not)</entry>
        <entry>
          Les bits qui sont positionn&eacute;s &agrave; 1 dans $a 
          sont positionn&eacute;s &agrave; 0, et vice versa.
        </entry>
       </row>
       <row>
        <entry>$a &lt;&lt; $b</entry>
        <entry>D&eacute;calage &agrave; gauche</entry>
        <entry>
          D&eacute;cale les bits de $a dans $b par la gauche 
          (chaque d&eacute;calage &eacute;quivaut &agrave; une multiplication par 2).
        </entry>
       </row>
       <row>
        <entry>$a &gt;&gt; $b</entry>
        <entry>D&eacute;calage &agrave; droite</entry>
        <entry>
          D&eacute;calage des bits de $a dans $b par la droite 
          (chaque d&eacute;calage &eacute;quivaut &agrave; une division par 2).
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </sect1>

   <sect1 id="language.operators.comparison">
    <title>Op&eacute;rateurs de comparaison</title>
    <simpara>
      Les op&eacute;rateurs de comparaison, comme leur nom l'indique, 
      vous permettent de comparer deux valeurs.
    </simpara>
    <table>
     <title>Op&eacute;rateurs de comparaison</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Exemple</entry>
        <entry>Nom</entry>
        <entry>R&eacute;sultat</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>$a == $b</entry>
        <entry>Egal</entry>
        <entry>Vrai si $a est &eacute;gal &agrave; $b.</entry>
       </row>
       <row>
        <entry>$a === $b</entry>
        <entry>Identique</entry>
        <entry>Vrai si $a est &eacute;gal &agrave; $b et qu'ils sont de m&ecirc;me type (PHP4 seulement).</entry>
       </row>
       <row>
        <entry>$a != $b</entry>
        <entry>Diff&eacute;rent</entry>
        <entry>Vrai si $a est diff&eacute;rent de $b.</entry>
       </row>
       <row>
        <entry>$a &lt; $b</entry>
        <entry>Plus petit que</entry>
        <entry>Vrai si $a est plus petit strictement que $b.</entry>
       </row>
       <row>
        <entry>$a &gt; $b</entry>
        <entry>Plus grand</entry>
        <entry>Vrai si $a est plus grand strictement que $b.</entry>
       </row>
       <row>
        <entry>$a &lt;= $b</entry>
        <entry>Inf&eacute;rieur ou &eacute;gal</entry>
        <entry>Vrai si $a est plus petit ou &eacute;gal &agrave; $b.</entry>
       </row>
       <row>
        <entry>$a &gt;= $b</entry>
        <entry>Sup&eacute;rieur ou &eacute;gal</entry>
        <entry>Vrai si $a est plus grand ou &eacute;gal &agrave; $b.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   <para>
     Un autre op&eacute;rateur conditionnel est l'op&eacute;rateur 
     ternaire (":?"), qui fonctionne comme en langage C. 
	
	<informalexample>
	 <programlisting>
(expr1) ? (expr2) : (expr3);
	 </programlisting>
	</informalexample> 
	 Cette expression renvoie la valeur de l'expression 
	 <replaceable>expr2</replaceable> si l'expression 
	 <replaceable>expr1</replaceable> est vraie, et l'expression 
	 <replaceable>expr3</replaceable> si l'expression 
	 <replaceable>expr1</replaceable> est fausse.
   </para>
  </sect1>

  <sect1 id="language.operators.errorcontrol">
   <title>Op&eacute;rateur de contr&ocirc;le d'erreur</title>
   
   <simpara>
    PHP supporte un op&eacute;ratuer de contr&ocirc;le d'erreur : c'est @. Lorsque cet
    op&eacute;rateur est ajout&eacute; en pr&eacute;fixe d'une expression PHP, les messages
    d'erreur qui peuvent &ecirc;tre g&eacute;n&eacute;r&eacute;s par cette expression seront
    ignor&eacute;s.
   </simpara>

   <simpara>
    Si l'option <link linkend="ini.track-errors">track_errors</link>
    est activ&eacute;e, les messages d'erreurs g&eacute;n&eacute;r&eacute;s une expression seront
    sauv&eacute; dans la variable globale $php_errormsg. Cette variable
    sera &eacute;cras&eacute;e &agrave; chaque erreur. Il faut alors la surveiller souvent
    pour pouvoir l'utiliser.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
&lt;?php
/* Erreur SQL intentionnelle (trop de guillemets): */
$res = @mysql_query( "select nom, code from 'listedenom" ) ou
   die( "La requ&ecirc;te a &eacute;chou&eacute; : l'erreur est '$php_errormsg'" );
?&gt;
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Voir aussi <function>error_reporting</function>.
   </simpara>
  </sect1>


  <sect1 id="language.operators.execution">
   <title>Op&eacute;rateur d'ex&eacute;cutions</title>
   
   <para>
	PHP supporte un op&eacute;rateur d'ex&eacute;cution : guillemets obliques ("``").
	Notez bien la diff&eacute;rence avec les guillemets simples (sur la touche
	4), et ceux-ci (sur la touche de la livre anglaise). PHP essaiera 
	d'ex&eacute;cuter le contenu de ces guillemets obliques comme une commande
	shell. Le r&eacute;sultat sera retourn&eacute; (i.e. : il ne sera pas simplement
	envoy&eacute; &agrave; la sortie standard, il peut &ecirc;tre assign&eacute; &agrave; une variable).

	<informalexample>
	 <programlisting role="php">
$output = `ls -al`;
echo "&lt;pre&gt;$output&lt;/pre&gt;";
	 </programlisting>
	</informalexample>
   </para>
   <para>
	Voir aussi <function>system</function>,
	<function>passthru</function>, <function>exec</function>,
	<function>popen</function>, et
	<function>escapeshellcmd</function>.
   </para>
  </sect1>
  
  <sect1 id="language.operators.increment">
   <title>Op&eacute;rateurs d'incrementation/D&eacute;crementation</title>

   <para>
	PHP supporte les op&eacute;rateurs de pr&eacute; et post incr&eacute;mentation et
	d&eacute;cr&eacute;mentation, comme en C.
   </para>

    <table>
     <title>Op&eacute;rateurs d'incrementation/D&eacute;crementation</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Exemple</entry>
        <entry>Nom</entry>
        <entry>R&eacute;sultat</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>++$a</entry>
        <entry>Pr&eacute;-incr&eacute;mente</entry>
        <entry>Incr&eacute;mente $a de 1, puis retourne $a.</entry>
       </row>
       <row>
        <entry>$a++</entry>
        <entry>Post-incr&eacute;mente</entry>
        <entry>Retourne $a, puis l'incr&eacute;mente $a de 1.</entry>
       </row>
       <row>
        <entry>--$a</entry>
        <entry>Pr&eacute;-d&eacute;cr&eacute;mente</entry>
        <entry>D&eacute;cr&eacute;mente $a de 1, puis retourne $a.</entry>
       </row>
       <row>
        <entry>$a--</entry>
        <entry>Post-d&eacute;cr&eacute;mente</entry>
        <entry>Retourne $a, puis d&eacute;cr&eacute;mente $a de 1.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
	Voici un exempla simple 
	<informalexample>
	 <programlisting>
&lt;?php
echo "&lt;h3&gt;Post-incr&eacute;mentation&lt;/h3&gt;";
$a = 5;
echo "Devrait valoir  5: " . $a++ . "&lt;br&gt;\n";
echo "Devrait valoir  6: " . $a . "&lt;br&gt;\n";

echo "&lt;h3&gt;Pr&eacute;-incr&eacute;mentation&lt;/h3&gt;";
$a = 5;
echo "Devrait valoir  6: " . ++$a . "&lt;br&gt;\n";
echo "Devrait valoir  6: " . $a . "&lt;br&gt;\n";

echo "&lt;h3&gt;Post-d&eacute;cr&eacute;mentation&lt;/h3&gt;";
$a = 5;
echo "Devrait valoir  5: " . $a-- . "&lt;br&gt;\n";
echo "Devrait valoir  4: " . $a . "&lt;br&gt;\n";

echo "&lt;h3&gt;Pr&eacute;-d&eacute;crementation&lt;/h3&gt;";
$a = 5;
echo "Devrait valoir  4: " . --$a . "&lt;br&gt;\n";
echo "Devrait valoir  4: " . $a . "&lt;br&gt;\n";
?&gt;	  
	 </programlisting>
	</informalexample>
   </para>

  </sect1>


  <sect1 id="language.operators.logical">
    <title>Les op&eacute;rateurs logiques</title>
    <table>
    <title>Les op&eacute;rateurs logiques</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Exemple</entry>
        <entry>Nom</entry>
        <entry>R&eacute;sultat</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>$a and $b</entry>
        <entry>ET (And)</entry>
        <entry> Vrai si $a ET $b sont vrais.</entry>
       </row>
       <row>
        <entry>$a or $b</entry>
        <entry>OU (Or)</entry>
        <entry>Vrai si $a OU $b est vrai</entry>
       </row>
       <row>
        <entry>$a xor $b</entry>
        <entry>XOR(Or)</entry>
        <entry>Vrai si $a OU $b est vrai, mais pas les deux en m&ecirc;me temps.</entry>
       </row>
       <row>
        <entry>! $a</entry>
        <entry>NON (Not)</entry>
        <entry>Vrai si $a est faux.</entry>
       </row>
       <row>
        <entry>$a &amp;&amp; $b</entry>
        <entry>ET (And)</entry>
        <entry>Vrai si $a ET $b sont vrais.</entry>
       </row>
       <row>
        <entry>$a || $b</entry>
        <entry>OU (Or)</entry>
        <entry>Vrai si $a OU $b est vrai.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   <simpara>
	La raison pour laquelle il existe deux types de "ET" et de "OU"
	est qu'ils ont des priorit&eacute;s diff&eacute;rentes. Voir le 
	paragraphe 
	<link linkend="language.operators.precedence">pr&eacute;c&eacute;dence d'op&eacute;rateurs</link>.
   </simpara>
  </sect1>

   <sect1 id="language.operators.precedence">
    <title>La pr&eacute;c&eacute;dence des op&eacute;rateurs</title>
    <para>
     La priorit&eacute; des op&eacute;rateurs sp&eacute;cifie 
     l'ordre dans lequel les valeurs doivent &ecirc;tre analys&eacute;es. 
     Par exemple, dans l'expression 1 + 5 * 3, le r&eacute;sultat est 
     16 et non 18, car la multiplication ("*") &agrave; une 
     priorit&eacute; sup&eacute;rieure par rapport &agrave; 
     &agrave; l'addition ("+").
    </para>
    <para>
      Le tableau suivant dresse une liste de la priorit&eacute; des 
      diff&eacute;rents op&eacute;rateurs dans un ordre croissant de 
      priorit&eacute;. 
    <table>
     <title>Pr&eacute;c&eacute;dence des op&eacute;rateurs</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Associativit&eacute;</entry>
        <entry>Op&eacute;rateurs</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>gauche</entry>
        <entry>,</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>or</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>xor</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>and</entry>
       </row>
       <row>
        <entry>droite</entry>
        <entry>print</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>= += -= *= /= .= %= &= |= ^= ~= &lt;&lt;= &gt;&gt;=</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>? :</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>||</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>&amp;&amp;</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>|</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>^</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>&amp;</entry>
       </row>
       <row>
        <entry>non-associative</entry>
        <entry>== != ===</entry>
       </row>
       <row>
        <entry>non-associative</entry>
        <entry>&lt; &lt;= &gt; &gt;=</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>&lt;&lt; &gt;&gt;</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>+ - .</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>* / %</entry>
       </row>
       <row>
        <entry>droite</entry>
        <entry>! ~ ++ -- (int) (double) (string) (array) (object) @</entry>
       </row>
       <row>
        <entry>droite</entry>
        <entry>[</entry>
       </row>
       <row>
        <entry>non-associative</entry>
        <entry>new</entry>
       </row>
      </tbody>
     </tgroup>
    </table></para></sect1>

  <sect1 id="language.operators.string">
   <title>Op&eacute;rateurs de cha&icirc;nes</title>
   <simpara>
	Il y a deux op&eacute;rateurs de cha&icirc;nes. Le premier 
	est l'op&eacute;rateur de concat&eacute;nation ('.'), qui 
	retourne la concat&eacute;nation de ses deux arguments.
	Le second est l'op&eacute;rateur d'assignement 
	concat&eacute;nant ('.='). Reportez vous &agrave; 
	<link linkend="language.operators.assignment">Op&eacute;rateurs d'assignements</link> 
	pour plus de d&eacute;tails.
   </simpara>
   <para>
	<informalexample>
	 <programlisting>
$a = "Bonjour ";
$b = $a . "Monde!"; // $b contient "Bonjour Monde!"

$a = "Bonjour ";
$a = $a . "Monde!"; // $a contient "Bonjour Monde!"
     </programlisting>
	</informalexample>
   </para>
  </sect1>
 </chapter>
 
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 sgml-parent-document:nil
 sgml-default-dtd-file:"../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
