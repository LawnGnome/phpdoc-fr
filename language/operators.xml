  <chapter id="language.operators">
   <title>Les op&eacute;rateurs</title>
   <simpara>
   </simpara>

   <sect1 id="language.operators.arithmetic">
    <title>Les op&eacute;rateurs arithm&eacute;tiques</title>
    <simpara>
Vous rappelez vous des op&eacute;rations &eacute;l&eacute;mentaires apprises &agrave; l'&eacute;cole ? 
    </simpara>

    <table>
     <title>Vous rappelez vous des op&eacute;rations &eacute;l&eacute;mentaires apprises &agrave; l'&eacute;cole ? </title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>exemple</entry>
        <entry>nom</entry>
        <entry>r&eacute;sultat</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>$a + $b</entry>
        <entry>Addition</entry>
        <entry> Somme de $a et $b.</entry>
       </row>
       <row>
        <entry>$a - $b</entry>
        <entry>Soustraction</entry>
        <entry>Diff&eacute;rence de $a et $b.</entry>
       </row>
       <row>
        <entry>$a * $b</entry>
        <entry>Multiplication</entry>
        <entry>Produit de $a et $b.</entry>
       </row>
       <row>
        <entry>$a / $b</entry>
        <entry>Division</entry>
        <entry>Quotient de $a etd $b.</entry>
       </row>
       <row>
        <entry>$a % $b</entry>
        <entry>Modulo</entry>
        <entry>Reste de $a divis&eacute; par $b.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

<!-- This appears to be inaccurate. Division always returns a float.
    <simpara>
     The division operator ("/") returns an integer value (the result
     of an integer division) if the two operands are integers (or
     strings that get converted to integers). If either operand is a
     floating-point value, floating-point division is performed.
    </simpara>
--></sect1>

   <sect1 id="language.operators.assignment">
    <title>Les op&eacute;rateurs d'assignement</title>
    <simpara>
L'op&eacute;rateurs d'assignement le plus simple est le signe "=". Le premier r&eacute;flexe est de penser que ce signe veut dire "&eacute;gal &agrave;". Ce n'est pas le cas. Il signifie que l'op&eacute;rande de gauche se voit affecter la valeur de l'expression qui est &agrave; droite du signe &eacute;gal.
    </simpara>
    <para>
La valeur d'une expression d'assignement est la valeur assign&eacute;e. Par exemple, la valeur de l'expression '$a = 3' est la valeur 3. Cela permet de faire d'utiliser des astuces telles que : <informalexample><programlisting>
$a = ($b = 4) + 5; // $a est maintenant &eacute;gal &agrave; 9, et $b vaut 4.
</programlisting></informalexample>
    </para>
    <para>
     En plus du simple op&eacute;rateur d'assignement, il existe des "op&eacute;rateurs combin&eacute;s" pour tous les op&eacute;rateurs arithm&eacute;tiques et pour les op&eacute;rateurs sur les cha&icirc;nes de caract&egrave;res. Cela permet d'utiliser la valeur d'une variable dans une expression et d'affecter le r&eacute;sultat de cette expression &agrave; cette variable. Par exemple: 
 <informalexample><programlisting>
$a = 3;
$a += 5; // affecte la valeur 8 &agrave; la variable $a. (correspond &agrave; l'instruction '$a = $a + 5');
$b = "Hello ";
$b .= "There!"; // affecte la valeur "Bonjour ici!" &agrave; la variable $b (correspond &agrave; $b = $b."ici!";
</programlisting></informalexample>
    </para>

   <para>
	On peut noter que l'assignement copie le contenu de la variable originale 
	dans la nouvelle (assignement par valeur), ce qui fait que les changements
de valeur d'une variable ne modifieront pas la valeur de l'autre. Cela peut se
rev&eacute;ler important lors de la copie d'un grand tableau durant une boucle. 
PHP4 supporte aussi l'assignement par r&eacute;f&eacute;rence, en utilisant la syntaxe <computeroutput>$var =
	&amp;$othervar;</computeroutput>, mais ce n'&eacute;tait pas possible en 
PHP3. 'L'assignement par r&eacute;f&eacute;rence' signifie que les deux variables contiennent les
m&ecirc;mes donn&eacute;es, et que la modification de l'une affecte l'autre. D'un autre
cot&eacute;, la recopie est tr&egrave;s rapide.
   </para>

  </sect1>

   <sect1 id="language.operators.bitwise">
    <title>Bitwise Operators</title>
    <simpara>
     Bitwise operators allow you to turn specific bits within an integer
     on or off.
    </simpara>

    <table>
     <title>Les op&eacute;rateurs sur les bits</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>exemple</entry>
        <entry>nom</entry>
        <entry>r&eacute;sultat</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>$a & $b</entry>
        <entry>ET (AND)</entry>
        <entry>Les bits positionn&eacute;s &agrave; 1 dans $a ET dans $b sont positionn&eacute;s &agrave; 1.</entry>
       </row>
       <row>
        <entry>$a | $b</entry>
        <entry>OU (OR)</entry>
        <entry>Bits that are set in either $a or $b are set.</entry>
       </row>
       <row>
        <entry>$a ^ $b</entry>
        <entry>Xor</entry>
        <entry>Les bits positionn&eacute;s &agrave; 1 dans $a OU dans $b sont positionn&eacute;s &agrave; 1.</entry>
       </row>
       <row>
        <entry>~ $a</entry>
        <entry>NON (Not)</entry>
        <entry>Les bits qui sont positionn&eacute;s &agrave; 1 dans $a sont positionn&eacute;s &agrave; 0, et vice versa.</entry>
       </row>
       <row>
        <entry>$a &lt;&lt; $b</entry>
        <entry>D&eacute;calage &agrave; gauche</entry>
        <entry>D&eacute;cale les bits de $a dans $b par la gauche (chaque d&eacute;calage &eacute;quivaut &agrave; une multiplication par 2).</entry>
       </row>
       <row>
        <entry>$a &gt;&gt; $b</entry>
        <entry>D&eacute;calage &agrave; droite</entry>
        <entry>d&eacute;calage des bits de $a dans $b par la droite (chaque d&eacute;calage &eacute;quivaut &agrave; une division par 2).</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
  </sect1>



   <sect1 id="language.operators.comparison">
    <title>Op&eacute;rateurs de comparaison</title>
    <simpara>
Les op&eacute;rateurs de comparaison, comme le nom l'indique, vous permettent de comparer deux valeurs.
    </simpara>

    <table>
     <title>Op&eacute;rateurs de comparaison</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>exemple</entry>
        <entry>nom</entry>
        <entry>r&eacute;sultat</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>$a == $b</entry>
        <entry>Egal</entry>
        <entry>Vrai si $a est &eacute;gal &agrave; $b.</entry>
       </row>
       <row>
        <entry>$a === $b</entry>
        <entry>Identique</entry>
        <entry>Vrai si $a est &eacute;gal &agrave; $b et qu'ils sont de m&ecirc;me type (PHP4 seulement).</entry>
       </row>
       <row>
        <entry>$a != $b</entry>
        <entry>Diff&eacute;rent</entry>
        <entry>Vrai si $a est diff&eacute;rent de $b.</entry>
       </row>
       <row>
        <entry>$a &lt; $b</entry>
        <entry>Plus petit que</entry>
        <entry>Vrai si $a est plus petit strictement que $b.</entry>
       </row>
       <row>
        <entry>$a &gt; $b</entry>
        <entry>Plus grand</entry>
        <entry>Vrai si $a est plus grand strictement que $b.</entry>
       </row>
       <row>
        <entry>$a &lt;= $b</entry>
        <entry>Inf&eacute;rieur ou &eacute;gal</entry>
        <entry>Vrai si $a est plus petit ou &eacute;gal &agrave; $b.</entry>
       </row>
       <row>
        <entry>$a &gt;= $b</entry>
        <entry>Sup&eacute;rieur ou &eacute;gal</entry>
        <entry>Vrai si $a est plus grand ou &eacute;gal &agrave; $b.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
Un autre op&eacute;rateur conditionnelle est l'op&eacute;rateur ternaire (":?"), qui fonctionne comme en langage C. 
	
	<informalexample>
	 <programlisting>
(expr1) ? (expr2) : (expr3);
	 </programlisting>
	</informalexample> 

Cette expression renvoie la valeur de l'expression <replaceable>expr2</replaceable>
 si l'expression <replaceable>expr1</replaceable> est vraie, et l'expression <replaceable>expr3</replaceable>
 si l'expression <replaceable>expr1</replaceable> est fausse.
   </para>
  </sect1>


  <sect1 id="language.operators.errorcontrol">
   <title>Op&eacute;rateur de contr&ocirc;le d'erreur</title>
   
   <simpara>
    PHP supports one error control operator: the at sign (@). When
    prepended to an expression in PHP, any error messages that might
    be generated by that expression will be ignored. 
   </simpara>

   <simpara>
    If the <link linkend="ini.track-errors">track_errors</link>
    feature is enabled, any error message generated by the expression
    will be saved in the global variable $php_errormsg. This variable
    will be overwritten on each error, so check early if you want to
    use it.
   </simpara>

   <para>
    <informalexample>
     <programlisting role="php">
&lt;?php
/* Intentional SQL error (extra quote): */
$res = @mysql_query( "select name, code from 'namelist" ) or
   die( "Query failed: error was '$php_errormsg'" );
?&gt;
     </programlisting>
    </informalexample>

   </para>

   <simpara>
    See also <function>error_reporting</function>.
   </simpara>

  </sect1>


  <sect1 id="language.operators.execution">
   <title>Op&eacute;rateur d'ex&eacute;cutions</title>
   
   <para>
	PHP supports one execution operator: backticks (``). Note that
	these are not single-quotes! PHP will attempt to execute the
	contents of the backticks as a shell command; the output will be
	returned (i.e., it won't simply be dumped to output; it can be
	assigned to a variable).

	<informalexample>
	 <programlisting role="php">
$output = `ls -al`;
echo "&lt;pre&gt;$output&lt;/pre&gt;";
	 </programlisting>
	</informalexample>

   </para>

   <para>
	See also <function>system</function>,
	<function>passthru</function>, <function>exec</function>,
	<function>popen</function>, and
	<function>escapeshellcmd</function>.
   </para>

  </sect1>

  
  <sect1 id="language.operators.increment">
   <title>Incrementing/Decrementing Operators</title>

   <para>
	PHP supports C-style pre- and post-increment and decrement
	operators.
   </para>

    <table>
     <title>Increment/decrement Operators</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>example</entry>
        <entry>name</entry>
        <entry>effect</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>++$a</entry>
        <entry>Pre-increment</entry>
        <entry>Increments $a by one, then returns $a.</entry>
       </row>
       <row>
        <entry>$a++</entry>
        <entry>Post-increment</entry>
        <entry>Returns $a, then increments $a by one.</entry>
       </row>
       <row>
        <entry>--$a</entry>
        <entry>Pre-decrement</entry>
        <entry>Decrements $a by one, then returns $a.</entry>
       </row>
       <row>
        <entry>$a--</entry>
        <entry>Post-decrement</entry>
        <entry>Returns $a, then decrements $a by one.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
	Here's a simple example script:
	<informalexample>
	 <programlisting>
&lt;?php
echo "&lt;h3&gt;Postincrement&lt;/h3&gt;";
$a = 5;
echo "Should be 5: " . $a++ . "&lt;br&gt;\n";
echo "Should be 6: " . $a . "&lt;br&gt;\n";

echo "&lt;h3&gt;Preincrement&lt;/h3&gt;";
$a = 5;
echo "Should be 6: " . ++$a . "&lt;br&gt;\n";
echo "Should be 6: " . $a . "&lt;br&gt;\n";

echo "&lt;h3&gt;Postdecrement&lt;/h3&gt;";
$a = 5;
echo "Should be 5: " . $a-- . "&lt;br&gt;\n";
echo "Should be 4: " . $a . "&lt;br&gt;\n";

echo "&lt;h3&gt;Predecrement&lt;/h3&gt;";
$a = 5;
echo "Should be 4: " . --$a . "&lt;br&gt;\n";
echo "Should be 4: " . $a . "&lt;br&gt;\n";
?&gt;	  
	 </programlisting>
	</informalexample>
   </para>

  </sect1>


  <sect1 id="language.operators.logical">
    <title>Les op&eacute;rateurs logiques</title>

    <table>
     <title>Logical Operators</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>exemple</entry>
        <entry>nom</entry>
        <entry>r&eacute;sultat</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>$a and $b</entry>
        <entry>ET (And)</entry>
        <entry> Vrai si $a ET $b sont vrais.</entry>
       </row>
       <row>
        <entry>$a or $b</entry>
        <entry>OU (Or)</entry>
        <entry>Vrai si $a OU $b est vrai</entry>
       </row>
       <row>
        <entry>$a xor $b</entry>
        <entry>XOR(Or)</entry>
        <entry>Vrai si $a OU $b est vrai, mais pas les deux en m&ecirc;me temps.</entry>
       </row>
       <row>
        <entry>! $a</entry>
        <entry>NON (Not)</entry>
        <entry>Vrai si $a est faux.</entry>
       </row>
       <row>
        <entry>$a &amp;&amp; $b</entry>
        <entry>ET (And)</entry>
        <entry>Vrai si $a ET $b sont vrais.</entry>
       </row>
       <row>
        <entry>$a || $b</entry>
        <entry>OU (Or)</entry>
        <entry>Vrai si $a OU $b est vrai.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <simpara>
	La raison pour laquelle il existe deux types de "ET" et de "OU" est qu'ils ont 
des priorit&eacute;s diff&eacute;rentes. Voir le paragraphe <link linkend="language.operators.precedence">pr&eacute;c&eacute;dence d'op&eacute;rateurs</link>.
   </simpara>
  </sect1>

   <sect1 id="language.operators.precedence">
    <title>La pr&eacute;c&eacute;dence des op&eacute;rateurs</title>
    <para>
     La priorit&eacute; des op&eacute;rateurs sp&eacute;cifie l'ordre dans lequel les valeurs doivent &ecirc;tre analys&eacute;es. Par exemple, dans l'expression 1 + 5 * 3, le r&eacute;sultat est 16 et non 18, car la multiplication ("*") &agrave; une priorit&eacute; sup&eacute;rieure par rapport &agrave; &agrave; l'addition ("+").</para>
    <para>
Le tableau suivant dresse une liste de la priorit&eacute; des diff&eacute;rents op&eacute;rateurs dans un ordre croissant de priorit&eacute;. 

    <table>
     <title>Pr&eacute;c&eacute;dence des op&eacute;rateurs</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Associativit&eacute;</entry>
        <entry>Op&eacute;rateurs</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>gauche</entry>
        <entry>,</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>or</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>xor</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>and</entry>
       </row>
       <row>
        <entry>droite</entry>
        <entry>print</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>= += -= *= /= .= %= &= |= ^= ~= &lt;&lt;= &gt;&gt;=</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>? :</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>||</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>&amp;&amp;</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>|</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>^</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>&amp;</entry>
       </row>
       <row>
        <entry>non-associative</entry>
        <entry>== != ===</entry>
       </row>
       <row>
        <entry>non-associative</entry>
        <entry>&lt; &lt;= &gt; &gt;=</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>&lt;&lt; &gt;&gt;</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>+ - .</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>* / %</entry>
       </row>
       <row>
        <entry>droite</entry>
        <entry>! ~ ++ -- (int) (double) (string) (array) (object) @</entry>
       </row>
       <row>
        <entry>droite</entry>
        <entry>[</entry>
       </row>
       <row>
        <entry>non-associative</entry>
        <entry>new</entry>
       </row>
      </tbody>
     </tgroup>
    </table></para></sect1>

  <sect1 id="language.operators.string">
   <title>String Operators</title>
   <simpara>
	Il y a deux op&eacute;rateurs de cha&icirc;nes. Le premier est l'op&eacute;rateur de
concat&eacute;nation ('.'), qui retourne la concat&eacute;nation de ses deux arguments.
Le second est l'op&eacute;rateur d'assignement concat&eacute;nant ('.='). Reportez vous &agrave; <link
	linkend="language.operators.assignment">Op&eacute;rateurs d'assignements</link> 
pour plus de d&eacute;tails.
   </simpara>
   <para>
	<informalexample>
	 <programlisting>
$a = "Bonjour ";
$b = $a . "Monde!"; // $b contient "Bonjour Monde!"

$a = "Bonjour ";
$a = $a . "Monde!"; // $a contient "Bonjour Monde!"
     </programlisting>
	</informalexample>
   </para>
  </sect1>


  </chapter>
 
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 sgml-parent-document:nil
 sgml-default-dtd-file:"../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
