<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.32 $ -->
<!-- EN-Revision: 1.1 Maintainer: nobody Status: partial -->
  <chapter id="language.operators">
   <title>Les opérateurs</title>
   <simpara>
   </simpara>
   <sect1 id="language.operators.precedence">
    <title>La précédence des opérateurs</title>
    <para>
     La priorité des opérateurs spécifie
     l'ordre dans lequel les valeurs doivent être analysées.
     Par exemple, dans l'expression 1 + 5 * 3, le résultat est
     16 et non 18, car la multiplication ("*") a une priorité 
     supérieure par rapport à l'addition ("+").
    </para>
    <para>
      Le tableau suivant dresse une liste de la priorité des
      différents opérateurs dans un ordre croissant de
      priorité.
    <table>
     <title>Précédence des opérateurs</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Associativité</entry>
        <entry>Opérateurs</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>gauche</entry>
        <entry>,</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>or</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>xor</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>and</entry>
       </row>
       <row>
        <entry>droite</entry>
        <entry>print</entry>
       </row>
       <row>
        <entry>droite</entry>
        <entry>
         = += -= *= /= .= %= &amp;= |= ^= &lt;&lt;= &gt;&gt;=
        </entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>? :</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>||</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>&amp;&amp;</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>|</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>^</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>&amp;</entry>
       </row>
       <row>
        <entry>non-associatif</entry>
        <entry>== != === !==</entry>
       </row>
       <row>
        <entry>non-associatif</entry>
        <entry>&lt; &lt;= &gt; &gt;=</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>&lt;&lt; &gt;&gt;</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>+ - .</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>* / %</entry>
       </row>
       <row>
        <entry>droite</entry>
        <entry>! ~ ++ -- (int) (float) (string) (array) (object) @</entry>
       </row>
       <row>
        <entry>droite</entry>
        <entry>[</entry>
       </row>
       <row>
        <entry>non-associatif</entry>
        <entry>new</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>
   <note>
    <para>
     Bien que <literal>!</literal> soit prioritaire sur 
     <literal>=</literal>, &php; va tout de même exécuter des
     expressions comme : <literal>if (!$a = foo())</literal>.
     Dans cette situation, le résultat de <literal>foo()</literal> 
     sera placé dans la variable <varname>$a</varname>.
    </para>
   </note>
  </sect1>
  <sect1 id="language.operators.arithmetic">
    <title>Les opérateurs arithmétiques</title>
    <simpara>
      Vous rappelez-vous des opérations élémentaires
      apprises à l'école ?
    </simpara>
    <table>
     <title>Opérations élémentaires</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Exemple</entry>
        <entry>Nom</entry>
        <entry>Résultat</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>$a + $b</literal></entry>
        <entry>Addition</entry>
        <entry>Somme de <varname>$a</varname> et <varname>$b</varname>.</entry>
       </row>
       <row>
        <entry><literal>$a - $b</literal></entry>
        <entry>Soustraction</entry>
        <entry>Différence de <varname>$a</varname> et <varname>$b</varname>.</entry>
       </row>
       <row>
        <entry><literal>$a * $b</literal></entry>
        <entry>Multiplication</entry>
        <entry>Produit de <varname>$a</varname> et <varname>$b</varname>.</entry>
       </row>
       <row>
        <entry><literal>$a / $b</literal></entry>
        <entry>Division</entry>
        <entry>Quotient de <varname>$a</varname> et <varname>$b</varname>.</entry>
       </row>
       <row>
        <entry><literal>$a % $b</literal></entry>
        <entry>Modulo</entry>
        <entry>Reste de <varname>$a</varname> divisé par <varname>$b</varname>.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
    <simpara>
     L'opérateur de division ("/") retourne une valeur entière
     (le résultat d'une division entière) si les deux opérandes
     sont entiers (ou bien des chaînes converties en entier.
     Si l'un des opérandes est un nombre à virgule flottante,
     ou bien le résultat d'une opération qui retourne une valeur
     non entière, un nombre à virgule flottante sera retourné.
    </simpara>
   <simpara>
    Voir aussi le manuel sur les <link linkend="ref.math">fonctions mathématiques</link>. 
   </simpara>
   </sect1>
   <sect1 id="language.operators.assignment">
    <title>Les opérateurs d'assignation</title>
    <simpara>
     L'opérateur d'assignation le plus simple est le signe "=".
     Le premier réflexe est de penser que ce signe veut dire
     "égal à". Ce n'est pas le cas. Il signifie que
     l'opérande de gauche se voit affecter la valeur de
     l'expression qui est à droite du signe égal.
    </simpara>
    <para>
     La valeur d'une expression d'assignation est la valeur
     assignée. Par exemple, la valeur de l'expression
     '<literal>$a = 3</literal>' est la valeur 3. Cela permet d'utiliser
     des astuces telles que :
     <example>
      <title>Astuce d'assignation</title>
      <programlisting role="php">
<![CDATA[
<?php
  $a = ($b = 4) + 5; 
// $a est maintenant égal à 9, et $b vaut 4.
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     En plus du simple opérateur d'assignation, il existe des
     "opérateurs combinés" pour tous les opérateurs
     arithmétiques et pour les opérateurs sur les
     chaînes de caractères. Cela permet d'utiliser
     la valeur d'une variable dans une expression et d'affecter le
     résultat de cette expression à cette variable.
     Par exemple :
     <example>
      <title>Exemples avec les opérateurs d'assignation</title>
       <programlisting role="php">
<![CDATA[
<?php
  $a = 3;
  $a += 5;
// affecte la valeur 8 à la variable $a.
// correspond à l'instruction '$a = $a + 5');
  $b = "Bonjour ";
  $b .= " tout le monde!";
// affecte la valeur "Bonjour tout le monde!" à
//  la variable $b 
//  identique à $b = $b." tout le monde!";
?>
]]>
      </programlisting>
     </example>
    </para>
   <para>
	On peut noter que l'assignation copie le contenu de la variable originale
	dans la nouvelle variable (assignation par valeur), ce qui fait que les changements
	de valeur d'une variable ne modifieront pas la valeur de l'autre. Cela peut
	se révéler important lors de la copie d'un grand tableau
	durant une boucle. &php; 4 supporte aussi l'assignation par
	référence, en utilisant la syntaxe
	<literal>$var = &$othervar;</literal>, mais ce
	n'était pas possible en &php; 3. 'L'assignation par
	référence' signifie que les deux variables contiennent les
	mêmes données, et que la modification de l'une affecte
	l'autre. D'un autre côté, la recopie est très rapide.
   </para>
  </sect1>
   <sect1 id="language.operators.bitwise">
    <title>Opérateurs sur les bits</title>
    <simpara>
     Les opérateurs sur les bits vous permettent de
     manipuler les bits dans un entier.
    </simpara>
   <para>
    <example>
      <title>Exemples avec les opérateurs sur les bits</title>
     <programlisting role="php">
<![CDATA[
<?php
    echo 12 ^ 9; 
// Affiche '5'

    echo "12" ^ "9"; 
// Affiche le caractère d'effacement (ascii 8)
// ('1' (ascii 49)) ^ ('9' (ascii 57)) = #8

echo "hallo" ^ "hello"; 
// Affiche la valeur asciie : s #0 #4 #0 #0 #0
// 'a' ^ 'e' = #4
?>
]]>
     </programlisting>
    </example> 
   </para>
    <table>
     <title>Les opérateurs sur les bits</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Exemple</entry>
        <entry>Nom</entry>
        <entry>Résultat</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>$a & $b</literal></entry>
        <entry>ET (AND)</entry>
        <entry>
         Les bits positionnés à 1 dans <varname>$a</varname> ET dans <varname>$b</varname>
         sont positionnés à 1.
        </entry>
       </row>
       <row>
        <entry><literal>$a | $b</literal></entry>
        <entry>OU (OR)</entry>
        <entry>
         Les bits positionnés à 1 dans <varname>$a</varname> OU <varname>$b</varname> sont
         sont positionnés à 1.
        </entry>
       </row>
       <row>
        <entry><literal>$a ^ $b</literal></entry>
        <entry>Xor</entry>
        <entry>
         Les bits positionnés à 1 dans <varname>$a</varname> OU dans <varname>$b</varname>
         mais pas dans les deux sont positionnés à 1.
        </entry>
       </row>
       <row>
        <entry><literal>~ $a</literal></entry>
        <entry>NON (<literal>Not</literal>)</entry>
        <entry>
         Les bits qui sont positionnés à 1 dans <varname>$a</varname>
         sont positionnés à 0, et vice versa.
        </entry>
       </row>
       <row>
        <entry><literal>$a &lt;&lt; $b</literal></entry>
        <entry>Décalage à gauche</entry>
        <entry>
         Décale les bits de <varname>$a</varname> <varname>$b</varname> fois sur la gauche
         (chaque décalage équivaut à une multiplication par 2).
        </entry>
       </row>
       <row>
        <entry><literal>$a &gt;&gt; $b</literal></entry>
        <entry>Décalage à droite</entry>
        <entry>
         Décalage des bits de <varname>$a</varname> <varname>$b</varname> fois par la droite
         (chaque décalage équivaut à une division par 2).
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </sect1>
   <sect1 id="language.operators.comparison">
    <title>Opérateurs de comparaison</title>
    <simpara>
      Les opérateurs de comparaison, comme leur nom l'indique,
      vous permettent de comparer deux valeurs.
    </simpara>
    <table>
     <title>Opérateurs de comparaison</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Exemple</entry>
        <entry>Nom</entry>
        <entry>Résultat</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>$a == $b</literal></entry>
        <entry>Egal</entry>
        <entry>Vrai si <varname>$a</varname> est égal à <varname>$b</varname>.</entry>
       </row>
       <row>
        <entry><literal>$a === $b</literal></entry>
        <entry>Identique</entry>
        <entry>
          Vrai si <varname>$a</varname> est égal à <varname>$b</varname> et qu'ils sont de même type
          (&php; 4 seulement).
        </entry>
       </row>
       <row>
        <entry><literal>$a != $b</literal></entry>
        <entry>Différent</entry>
        <entry>Vrai si <varname>$a</varname> est différent de <varname>$b</varname>.</entry>
       </row>
       <row>
        <entry><literal>$a &lt;&gt; $b</literal></entry>
        <entry>Différent</entry>
        <entry>Vrai si <varname>$a</varname> est différent de <varname>$b</varname>.</entry>
       </row>
       <row>
        <entry><literal>$a &lt; $b</literal></entry>
        <entry>Plus petit que</entry>
        <entry>Vrai si <varname>$a</varname> est plus petit strictement que <varname>$b</varname>.</entry>
       </row>
       <row>
        <entry><literal>$a &gt; $b</literal></entry>
        <entry>Plus grand</entry>
        <entry>Vrai si <varname>$a</varname> est plus grand strictement que <varname>$b</varname>.</entry>
       </row>
       <row>
        <entry><literal>$a &lt;= $b</literal></entry>
        <entry>Inférieur ou égal</entry>
        <entry>Vrai si <varname>$a</varname> est plus petit ou égal à <varname>$b</varname>.</entry>
       </row>
       <row>
        <entry><literal>$a &gt;= $b</literal></entry>
        <entry>Supérieur ou égal</entry>
        <entry>Vrai si <varname>$a</varname> est plus grand ou égal à <varname>$b</varname>.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   <para>
     Un autre opérateur conditionnel est l'opérateur
     ternaire (":?"), qui fonctionne comme en langage C.
	<informalexample>
	 <programlisting role="php">
<![CDATA[
<?php
// Exemple d'utilisation pour l'opérateur ternaire
$action = (empty($_POST['action'])) ? 'default' : $_POST['action'];

// L'expression ci-dessus est identique à 
if (empty($_POST['action'])) {
    $action = 'default';
} else {
    $action = $_POST['action'];
}
?>
]]>
	 </programlisting>
	</informalexample>
	 L'expression <literal>(expr1) ? (expr2) : (expr3)</literal> renvoie la valeur de l'expression
	 <replaceable>expr2</replaceable> si l'expression
	 <replaceable>expr1</replaceable> est vraie, et l'expression
	 <replaceable>expr3</replaceable> si l'expression
	 <replaceable>expr1</replaceable> est fausse.
   </para>
   <para>
    Voir aussi
    <function>strcasecmp</function>,
    <function>strcmp</function> et le chapitre sur les
    <link linkend="language.types">types</link>.
   </para>
  </sect1>
  <sect1 id="language.operators.errorcontrol">
   <title>Opérateur de contrôle d'erreur</title>
   <simpara>
    &php; supporte un opérateur de contrôle d'erreur : c'est &#64;.
    Lorsque cet opérateur est ajouté en préfixe d'une
    expression &php;, les messages d'erreur qui peuvent être
    générés par cette expression seront ignorés.
   </simpara>
   <simpara>
    Si l'option <link linkend="ini.track-errors"><option>track_errors</option></link>
    est activée, les messages d'erreurs générés
    par une expression seront sauvés dans la variable globale
    <varname>$php_errormsg</varname>. Cette variable sera écrasée à
    chaque erreur. Il faut alors la surveiller souvent pour pouvoir l'utiliser.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* Erreur intentionnelle (le fichier n'existe pas): */
  $my_file = @file ('non_persistent_file') or
    die ("Impossible d'ouvrir le fichier : L'erreur est : '$php_errormsg'");
// Cela fonctionne avec n'importe quelle expression, pas seulement les fonctions
  $value = @$cache[$key];
// la ligne ci-dessus n'affichera pas d'alerte si la clé $key du tableau n'existe pas
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <simpara>
     L'opérateur &#64; ne fonctionne qu'avec les expressions. La règle
     générale de fonctionnement est la suivante : si vous pouvez prendre
     la valeur de quelque chose, vous pouvez le préfixer avec &#64;. Par exemple,
     vous pouvez ajouter &#64; aux variables, fonctions, à
     <function>include</function>, aux constantes, etc. Vous ne pourrez
     pas le faire avec des éléments de langage tels que les classes,
     <literal>if</literal> et <literal>foreach</literal>, etc.
    </simpara>
   </note>
   <note>
    <simpara>
     La plupart des fonctions d'accès aux bases de données ne retournent
     pas d'erreur &php;. Il faut y accéder avec une fonction du type
     <literal>base_de_donnees_get_error()</literal>.
    </simpara>
   </note>
   <simpara>
    Voir aussi
    <function>error_reporting</function>.
   </simpara>
  </sect1>
  <sect1 id="language.operators.execution">
   <title>Opérateur d'exécutions</title>
   <para>
	&php; supporte un opérateur d'exécution : guillemets obliques
	("``").	Notez bien la différence entre les guillemets simples (sur
	la touche 4), et ceux-ci (sur la touche de la livre anglaise). &php; essaiera
	d'exécuter le contenu de ces guillemets obliques comme une commande
	shell. Le résultat sera retourné (i.e. : il ne sera pas
	simplement envoyé à la sortie standard, il peut être
	assigné à une variable).
	<informalexample>
	 <programlisting role="php">
<![CDATA[
<?php
  $output = `ls -al`;
  echo "<pre>$output</pre>";
?>
]]>
	 </programlisting>
	</informalexample>
   </para>
   <note>
    <para>
     Cet opérateur est désactivé lorsque le
     &safemode; est activé ou bien que la fonction
     <function>shell_exec</function> est désactivée.
    </para>
   </note>
   <para>
	Voir aussi
	<function>system</function>,
	<function>passthru</function>,
	<function>exec</function>,
	<function>shell_exec</function>,
	<function>popen</function> et
	<function>escapeshellcmd</function>.
   </para>
  </sect1>
  <sect1 id="language.operators.increment">
   <title>Opérateurs d'incrémentation/Décrémentation</title>
   <para>
	&php; supporte les opérateurs de pré et post incrémentation et
	décrémentation, comme en C.
   </para>
    <table>
     <title>Opérateurs d'incrémentation/Décrémentation</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Exemple</entry>
        <entry>Nom</entry>
        <entry>Résultat</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>++$a</literal></entry>
        <entry>Pré-incrémente</entry>
        <entry>Incrémente <varname>$a</varname> de 1, puis retourne <varname>$a</varname>.</entry>
       </row>
       <row>
        <entry><literal>$a++</literal></entry>
        <entry>Post-incrémente</entry>
        <entry>Retourne <varname>$a</varname>, puis l'incrémente de 1.</entry>
       </row>
       <row>
        <entry><literal>--$a</literal></entry>
        <entry>Pré-décrémente</entry>
        <entry>Décrémente <varname>$a</varname> de 1, puis retourne <varname>$a</varname>.</entry>
       </row>
       <row>
        <entry><literal>$a--</literal></entry>
        <entry>Post-décrémente</entry>
        <entry>Retourne <varname>$a</varname>, puis décrémente <varname>$a</varname> de 1.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   <para>
	Voici un exemple simple
	<informalexample>
	 <programlisting role="php">
<![CDATA[
<?php
  echo "<h3>Post-incrémentation</h3>";
  $a = 5;
  echo "Devrait valoir  5: " . $a++ . "<br>\n";
  echo "Devrait valoir  6: " . $a . "<br>\n";
  echo "<h3>Pré-incrémentation</h3>";
  $a = 5;
  echo "Devrait valoir  6: " . ++$a . "<br>\n";
  echo "Devrait valoir  6: " . $a . "<br>\n";
  echo "<h3>Post-décrémentation</h3>";
  $a = 5;
  echo "Devrait valoir  5: " . $a-- . "<br>\n";
  echo "Devrait valoir  4: " . $a . "<br>\n";
  echo "<h3>Pré-décrémentation</h3>";
  $a = 5;
  echo "Devrait valoir  4: " . --$a . "<br>\n";
  echo "Devrait valoir  4: " . $a . "<br>\n";
?>
]]>
	 </programlisting>
	</informalexample>
   </para>
   <para>
    &php; suit les conventions de Perl pour la gestion des opérateurs arithmétiques,
    et non pas celle du C. Par exemple, en Perl <literal>'Z'+1</literal> retourne
    <literal>'AA'</literal>, alors qu'en C, <literal>'Z'+1</literal> retourne
    <literal>'['</literal> ( <literal>ord('Z') == 90</literal>, donc
    <literal>ord('[') == 91</literal> ).
    Notez que les variables de caractères peuvent être incrémentées, mais pas
    décrémentées.
    <example>
     <title>Opérations arithmétiques sur un caractère</title>
     <programlisting role="php">
<![CDATA[
<?php
$i = 'W';
for($n=0; $n<6; $n++)
  echo ++$i . "\n";

/*
  Produit un résultat identique à celui-ci : 
  
X
Y
Z
AA
AB
AC

*/
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect1>
  <sect1 id="language.operators.logical">
    <title>Les opérateurs logiques</title>
    <table>
    <title>Les opérateurs logiques</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Exemple</entry>
        <entry>Nom</entry>
        <entry>Résultat</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>$a and $b</literal></entry>
        <entry>ET (And)</entry>
        <entry> Vrai si <varname>$a</varname> ET <varname>$b</varname> sont vrais.</entry>
       </row>
       <row>
        <entry><literal>$a or $b</literal></entry>
        <entry>OU (Or)</entry>
        <entry>Vrai si <varname>$a</varname> OU <varname>$b</varname> est vrai</entry>
       </row>
       <row>
        <entry><literal>$a xor $b</literal></entry>
        <entry>XOR (Xor)</entry>
        <entry>Vrai si <varname>$a</varname> OU <varname>$b</varname> est vrai, mais pas les deux en même temps.</entry>
       </row>
       <row>
        <entry><literal>! $a</literal></entry>
        <entry>NON (Not)</entry>
        <entry>Vrai si <varname>$a</varname> est faux.</entry>
       </row>
       <row>
        <entry><literal>$a && $b</literal></entry>
        <entry>ET (And)</entry>
        <entry>Vrai si <varname>$a</varname> ET <varname>$b</varname> sont vrais.</entry>
       </row>
       <row>
        <entry><literal>$a || $b</literal></entry>
        <entry>OU (Or)</entry>
        <entry>Vrai si <varname>$a</varname> OU <varname>$b</varname> est vrai.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   <simpara>
	La raison pour laquelle il existe deux types de "ET" et de "OU"
	est qu'ils ont des priorités différentes. Voir le
	paragraphe
	<link linkend="language.operators.precedence">précédence d'opérateurs</link>.
   </simpara>
  </sect1>

  <sect1 id="language.operators.string">
   <title>Opérateurs de chaînes</title>
   <simpara>
	Il y a deux opérateurs de chaînes. Le premier
	est l'opérateur de concaténation ('.'), qui
	retourne la concaténation de ses deux arguments.
	Le second est l'opérateur d'assignation
	concaténant (<literal>.=</literal>). Reportez-vous à
	<link linkend="language.operators.assignment">opérateurs d'assignation</link>
	pour plus de détails.
   </simpara>
   <para>
	<informalexample>
	 <programlisting role="php">
<![CDATA[
<?php
  $a = "Bonjour ";
  $b = $a . "Monde!";
// $b contient "Bonjour Monde!"
  $a = "Bonjour ";
  $a = $a . "Monde!";
// $a contient "Bonjour Monde!"
?>
]]>
     </programlisting>
	</informalexample>
   </para>
  </sect1>
  <sect1 id="language.operators.array">
   <title>Opérateurs de tableaux</title>
   <simpara>
    Le seul opérateur en &php; pour les tableaux est l'opérateur
    <literal>+</literal>. Cet opérateur ajoute le tableau de
    droite au tableau de gauche. Les clés communes sont laissées
    inchangées.
   </simpara>
   <para>
    <example>
     <title>Addition de tableaux</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = array("a" => "pomme", "b" => "banane");
$b = array("a" =>"poire", "b" => "fraise", "c" => "cerise");

$c = $a + $b;

var_dump($c);
?>
]]>
     </programlisting>
     <screen role="php">
<![CDATA[
array(3) {
  ["a"]=>
  string(5) "pomme"
  ["b"]=>
  string(6) "banane"
  ["c"]=>
  string(6) "cerise"
}

]]>
       </screen>
    </example>
   </para>
  </sect1>
 </chapter>
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
indent-tabs-mode:nil
 sgml-parent-document:nil
 sgml-default-dtd-file:"../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
