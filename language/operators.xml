<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.61 $ -->
<!-- EN-Revision: 1.81 Maintainer: dams Status: ready -->
 <chapter id="language.operators">
  <title>Les opérateurs</title>
  <simpara>
   Un opérateur est quelque chose que vous alimentez avec une ou plusieurs valeurs
   (ou expression, dans le jargon de programmation) qui retourne une autre valeur
   (donc que la construction elle-même devient une expression). Donc, vous pouvez penser
   aux fonctions ou constructions qui retournent une valeur (comme print) comme opérateur
   et ceux qui retournent rien du tout (comme echo).
  </simpara>
  <para>
   Il y a trois types d'opérateurs. Le premier, l'opérateur unaire, qui opère
   sur une seule valeur, par exemple ! (l'opérateur de négation) ou ++ (l'opérateur
   d'incrémentation). Le second groupe, les opérateurs binaires ; ce groupe
   contient la plus part des opérateurs supportés par &php; qui sont listés
   ci-dessous dans la section
   "<link linkend="language.operators.precedence">La précédence des opérateurs</link>".
  </para>
  <para>
   Le troisième groupe est le groupe des opérateurs de terminaison : ?:. Ils doivent être utilisés
   pour choisir entre deux expressions dépendants d'une troisième, plutôt que
   sélectionner deux phrases ou chemins d'exécution.
   Les expressions ternaires environnantes avec des parenthèses est une idée très bonne.
  </para>

  <sect1 id="language.operators.precedence">
   <title>La précédence des opérateurs</title>
   <para>
    La priorité des opérateurs spécifie
    l'ordre dans lequel les valeurs doivent être analysées.
    Par exemple, dans l'expression <literal>1 + 5 * 3</literal>, le résultat est
    <literal>16</literal> et non <literal>18</literal>, car la multiplication ("*") a une priorité
    supérieure par rapport à l'addition ("+").
    Des parenthèses peuvent être utilisées pour forcer la priorité, si nécessaire.
    Par exemple : <literal>(1 + 5) * 3</literal> donnera
    <literal>18</literal>. Si la priorité d'opérateur est égale,
    l'associativité de gauche à droite est utilisée.
   </para>
   <para>
    Le tableau suivant dresse une liste de la priorité des
    différents opérateurs dans un ordre croissant de
    priorité.
    Les opérateurs sur une même ligne ont une priorité équivalente et dans ce cas,
    leur association décide de l'ordre de leur évaluation.
    <table>
     <title>Précédence des opérateurs</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Associativité</entry>
        <entry>Opérateurs</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>non-associative</entry>
        <entry>new</entry>
       </row>
       <row>
        <entry>droite</entry>
        <entry>[</entry>
       </row>
       <row>
        <entry>non-associatif</entry>
        <entry>++ --</entry>
       </row>
       <row>
        <entry>non-associatif</entry>
        <entry>! ~ - (int) (float) (string) (array) (object) @</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>* / %</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>+ - .</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>&lt;&lt; &gt;&gt;</entry>
       </row>
       <row>
        <entry>non-associatif</entry>
        <entry>&lt; &lt;= &gt; &gt;=</entry>
       </row>
       <row>
        <entry>non-associatif</entry>
        <entry>== != === !==</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>&amp;</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>^</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>|</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>&amp;&amp;</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>||</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>? :</entry>
       </row>
       <row>
        <entry>droite</entry>
        <entry>
         = += -= *= /= .= %= &amp;= |= ^= &lt;&lt;= &gt;&gt;=
        </entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>and</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>xor</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>or</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>,</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>
   <para>
    L'associativité de gauche signifie que l'expression est évaluée de gauche à droite,
    l'associativité de droite, l'inverse.
    <example>
     <title>Associativité</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 3 * 3 % 5; // (3 * 3) % 5 = 4
$a = true ? 0 : true ? 1 : 2; // (true ? 0 : true) ? 1 : 2 = 2

$a = 1;
$b = 2;
$a = $b += 3; // $a = ($b += 3) -> $a = 5, $b = 5
?>
]]>
     </programlisting>
    </example>
    Utilisez les parenthèses pour augmenter la lisibilité du code.
   </para>
   <note>
    <para>
     Bien que <literal>!</literal> soit prioritaire sur
     <literal>=</literal>, &php; va tout de même exécuter des
     expressions comme : <literal>if (!$a = foo())</literal>.
     Dans cette situation, le résultat de <literal>foo()</literal>
     sera placé dans la variable <varname>$a</varname>.
    </para>
   </note>
  </sect1>

  <sect1 id="language.operators.arithmetic">
   <title>Les opérateurs arithmétiques</title>
   <simpara>
    Vous rappelez-vous des opérations élémentaires
    apprises à l'école ? Ils fonctionnent comme cela.
   </simpara>
   <table>
    <title>Opérations élémentaires</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Exemple</entry>
       <entry>Nom</entry>
       <entry>Résultat</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>-$a</entry>
       <entry>Negation</entry>
       <entry>Opposé de $a.</entry>
      </row>
      <row>
       <entry><literal>$a + $b</literal></entry>
       <entry>Addition</entry>
       <entry>Somme de <varname>$a</varname> et <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry><literal>$a - $b</literal></entry>
       <entry>Soustraction</entry>
       <entry>Différence de <varname>$a</varname> et <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry><literal>$a * $b</literal></entry>
       <entry>Multiplication</entry>
       <entry>Produit de <varname>$a</varname> et <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry><literal>$a / $b</literal></entry>
       <entry>Division</entry>
       <entry>Quotient de <varname>$a</varname> et <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry><literal>$a % $b</literal></entry>
       <entry>Modulo</entry>
       <entry>Reste de <varname>$a</varname> divisé par <varname>$b</varname>.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <simpara>
    L'opérateur de division ("/") retourne une valeur entière
    (le résultat d'une division entière) si les deux opérandes
    sont entiers (ou bien des chaînes converties en entier).
   </simpara>
   <note>
    <simpara>
     Souvenez-vous que <literal>$a % $b</literal> est négatif si <literal>$a</literal>
     est négatif.
    </simpara>
   </note>
   <simpara>
    Voir aussi le manuel sur les <link linkend="ref.math">fonctions mathématiques</link>.
   </simpara>

  </sect1>

  <sect1 id="language.operators.assignment">
   <title>Les opérateurs d'assignation</title>
   <simpara>
    L'opérateur d'assignation le plus simple est le signe "=".
    Le premier réflexe est de penser que ce signe veut dire
    "égal à". Ce n'est pas le cas. Il signifie que
    l'opérande de gauche se voit affecter la valeur de
    l'expression qui est à droite du signe égal.
   </simpara>
   <para>
    La valeur d'une expression d'assignation est la valeur
    assignée. Par exemple, la valeur de l'expression
    '<literal>$a = 3</literal>' est la valeur 3. Cela permet d'utiliser
    des astuces telles que :
    <example>
     <title>Astuce d'assignation</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = ($b = 4) + 5;
// $a est maintenant égal à 9, et $b vaut 4.
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    En plus du simple opérateur d'assignation, il existe des
    "opérateurs combinés" pour tous les opérateurs
    arithmétiques et pour les opérateurs sur les
    chaînes de caractères. Cela permet d'utiliser
    la valeur d'une variable dans une expression et d'affecter le
    résultat de cette expression à cette variable.
    Par exemple :
    <example>
     <title>Exemples avec les opérateurs d'assignation</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 3;
$a += 5; // affecte la valeur 8 à la variable $a correspond à l'instruction '$a = $a + 5';
$b = "Bonjour ";
$b .= " tout le monde!";  // affecte la valeur "Bonjour tout le monde!" à
                                    //  la variable $b
                                    //  identique à $b = $b." tout le monde!";

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    On peut noter que l'assignation copie le contenu de la variable originale
    dans la nouvelle variable (assignation par valeur), ce qui fait que les changements
    de valeur d'une variable ne modifieront pas la valeur de l'autre. Cela peut
    se révéler important lors de la copie d'un grand tableau
    durant une boucle. Depuis &php; 4, l'assignation par
    référence est supporté, en utilisant la syntaxe
    <computeroutput>$var = &amp;$othervar;</computeroutput>, mais ce
    n'était pas possible en &php; 3. 'L'assignation par
    référence' signifie que les deux variables contiennent les
    mêmes données, et que la modification de l'une affecte
    l'autre et rien n'est copié nul part. Pour plus d'informations sur les références,
    lisez <link
    linkend="language.references">l'explication sur les références</link>.
   </para>
  </sect1>

  <sect1 id="language.operators.bitwise">
   <title>Opérateurs sur les bits</title>
   <simpara>
    Les opérateurs sur les bits vous permettent de
    manipuler les bits dans un entier. Si les paramètres de gauche et de droite
    sont des chaînes de caractères, l'opérateur de bits agira sur les valeurs ASCII
    de ces caractères.
   </simpara>
   <para>
    <example>
      <title>Exemples avec les opérateurs sur les bits</title>
     <programlisting role="php">
<![CDATA[
<?php
echo 12 ^ 9; // Affiche '5'

echo "12" ^ "9"; // Affiche le caractère d'effacement (ascii 8)
                        // ('1' (ascii 49)) ^ ('9' (ascii 57)) = #8

echo "hallo" ^ "hello"; // Affiche la valeur asciie : s #0 #4 #0 #0 #0
                                 // 'a' ^ 'e' = #4
?>
]]>
     </programlisting>
    </example>
   </para>
   <table>
    <title>Les opérateurs sur les bits</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Exemple</entry>
       <entry>Nom</entry>
       <entry>Résultat</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><literal>$a &amp; $b</literal></entry>
       <entry>ET (<literal>And</literal>)</entry>
       <entry>
        Les bits positionnés à 1 dans <varname>$a</varname> ET dans
        <varname>$b</varname> sont positionnés à 1.
       </entry>
      </row>
      <row>
       <entry><literal>$a | $b</literal></entry>
       <entry>OU (<literal>Or</literal>)</entry>
       <entry>
        Les bits positionnés à 1 dans <varname>$a</varname> OU <varname>$b</varname>
        sont sont positionnés à 1.
       </entry>
      </row>
      <row>
       <entry><literal>$a ^ $b</literal></entry>
       <entry><literal>Xor</literal></entry>
       <entry>
        Les bits positionnés à 1 dans <varname>$a</varname> OU dans
        <varname>$b</varname> mais pas dans les deux sont positionnés à 1.
       </entry>
      </row>
      <row>
       <entry><literal>~ $a</literal></entry>
       <entry>NON (<literal>Not</literal>)</entry>
       <entry>
        Les bits qui sont positionnés à 1 dans <varname>$a</varname>
        sont positionnés à 0, et vice versa.
       </entry>
      </row>
      <row>
       <entry><literal>$a &lt;&lt; $b</literal></entry>
       <entry>Décalage à gauche</entry>
       <entry>
        Décale les bits de <varname>$a</varname>, <varname>$b</varname> fois sur la
        gauche (chaque décalage équivaut à une multiplication par 2).
       </entry>
      </row>
      <row>
       <entry><literal>$a &gt;&gt; $b</literal></entry>
       <entry>Décalage à droite</entry>
       <entry>
        Décalage des bits de <varname>$a</varname>, <varname>$b</varname> fois par la
        droite (chaque décalage équivaut à une division par 2).
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <warning>
    <para>
     N'effectuez pas de décalage à droite de plus de 32 bits sur les systèmes 32 bits.
     N'effectuez pas de décalage à droite dans le cas où le résultat est un nombre
     plus long que 32 its.
    </para>
   </warning>
  </sect1>

  <sect1 id="language.operators.comparison">
   <title>Opérateurs de comparaison</title>
   <simpara>
    Les opérateurs de comparaison, comme leur nom l'indique,
    vous permettent de comparer deux valeurs. Vous devriez également être intéressé
    par les <link linkend="types.comparisons">tables de comparaisons de types</link>
    car ils montrent des exemples de beaucoup de types de comparaisons.
   </simpara>
   <table>
    <title>Opérateurs de comparaison</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Exemple</entry>
       <entry>Nom</entry>
       <entry>Résultat</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><literal>$a == $b</literal></entry>
       <entry>Egal</entry>
       <entry>&true; si <varname>$a</varname> est égal à
       <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry><literal>$a === $b</literal></entry>
       <entry>Identique</entry>
       <entry>
        &true; si <varname>$a</varname> est égal à <varname>$b</varname> et qu'ils sont
        de même type (introduit en &php; 4).
       </entry>
      </row>
      <row>
       <entry><literal>$a != $b</literal></entry>
       <entry>Différent</entry>
       <entry>&true; si <varname>$a</varname> est différent de
       <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry><literal>$a &lt;&gt; $b</literal></entry>
       <entry>Différent</entry>
       <entry>&true; si <varname>$a</varname> est différent de
       <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a !== $b</entry>
       <entry>Différent</entry>
       <entry>
        &true; si <varname>$a</varname> est différent de <varname>$b</varname>
        ou bien qu'ils ne sont pas du même type. (introduit en &php; 4)
       </entry>
      </row>
      <row>
       <entry><literal>$a &lt; $b</literal></entry>
       <entry>Plus petit que</entry>
       <entry>&true; si <varname>$a</varname> est strictement plus petit que
       <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry><literal>$a &gt; $b</literal></entry>
       <entry>Plus grand</entry>
       <entry>&true; si <varname>$a</varname> est strictement plus grand que
       <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry><literal>$a &lt;= $b</literal></entry>
       <entry>Inférieur ou égal</entry>
       <entry>&true; si <varname>$a</varname> est plus petit ou égal à
       <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry><literal>$a &gt;= $b</literal></entry>
       <entry>Supérieur ou égal</entry>
       <entry>&true; si <varname>$a</varname> est plus grand ou égal à
       <varname>$b</varname>.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Si vous comparez un entier avec une chaîne, la chaîne est
    <link linkend="language.types.string.conversion">convertie en un nombre</link>.
    Si vous comparez deux chaînes numériques, elles seront comparées en tant
    qu'entiers. Ces règles s'appliquent aussi à l'instruction
    <link linkend="control-structures.switch">switch</link>.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
var_dump(0 == "a"); // 0 == 0 -> true
var_dump("1" == "01"); // 1 == 1 -> true

switch ("a") {
case 0:
    echo "0";
    break;
case "a": // jamais évalué parceque "a" est déjà trouvé avec 0
    echo "a";
    break;
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Un autre opérateur conditionnel est l'opérateur
    ternaire (":?"), qui fonctionne comme en langage C.
    <example>
     <title>Opérateur ternaire</title>
     <programlisting role="php">
<![CDATA[
<?php
// Exemple d'utilisation pour l'opérateur ternaire
$action = (empty($_POST['action'])) ? 'default' : $_POST['action'];

// L'expression ci-dessus est identique à
if (empty($_POST['action'])) {
    $action = 'default';
} else {
    $action = $_POST['action'];
}
?>
]]>
     </programlisting>
    </example>
     L'expression <literal>(expr1) ? (expr2) : (expr3)</literal> renvoie la valeur de l'expression
     <literal>expr2</literal> si l'expression
     <literal>expr1</literal> est vraie, et l'expression
     <literal>expr3</literal> si l'expression
     <literal>expr1</literal> est fausse.
   </para>
   <para>
    Voir aussi
    <function>strcasecmp</function>,
    <function>strcmp</function>
    <link linkend="language.operators.array">les opérateurs de tableaux</link>,
    et le chapitre sur les <link linkend="language.types">types</link>.
   </para>
  </sect1>

  <sect1 id="language.operators.errorcontrol">
   <title>Opérateur de contrôle d'erreur</title>
   <simpara>
    &php; supporte un opérateur de contrôle d'erreur : c'est @.
    Lorsque cet opérateur est ajouté en préfixe d'une
    expression &php;, les messages d'erreur qui peuvent être
    générés par cette expression seront ignorés.
   </simpara>
   <simpara>
    Si l'option <link linkend="ini.track-errors"><option>track_errors</option></link>
    est activée, les messages d'erreurs générés
    par une expression seront sauvés dans la variable globale
    <link linkend="reserved.variables.phperrormsg"><varname>$php_errormsg</varname></link>.
    Cette variable sera écrasée à chaque erreur.
    Il faut alors la surveiller souvent pour pouvoir l'utiliser.
   </simpara>
   <para>
    <example>
     <title>Opérateur de contrôle d'erreur</title>
     <programlisting role="php">
<![CDATA[
<?php
/* Erreur intentionnelle (le fichier n'existe pas): */
$mon_fichier = @file ('non_persistent_file') or
    die ("Impossible d'ouvrir le fichier : L'erreur est : '$php_errormsg'");

// Cela fonctionne avec n'importe quelle expression, pas seulement les fonctions
  $value = @$cache[$key];
// la ligne ci-dessus n'affichera pas d'alerte si la clé $key du tableau n'existe pas

?>
]]>
     </programlisting>
    </example>
   </para>
   <note>
    <simpara>
     L'opérateur @ ne fonctionne qu'avec les expressions. La règle
     générale de fonctionnement est la suivante : si vous pouvez prendre
     la valeur de quelque chose, vous pouvez le préfixer avec @. Par exemple,
     vous pouvez ajouter @ aux variables, fonctions, à
     <function>include</function>, aux constantes, etc. Vous ne pourrez
     pas le faire avec des éléments de langage tels que les classes,
     <literal>if</literal> et <literal>foreach</literal>, etc.
    </simpara>
   </note>
   <simpara>
    Voir aussi
    <function>error_reporting</function> et la section sur la
    <link linkend="ref.errorfunc">gestion d'erreurs</link>.
   </simpara>
   <note>
    <para>
     L'opérateur "@" ne masque pas les messages d'erreurs
     dûs à des erreurs d'analyse.
    </para>
   </note>
   <warning>
    <para>
     Actuellement, l'opérateur "@" va aussi désactiver les rapports
     d'erreurs critiques, qui stoppent l'exécution du script. Entre autres,
     si vous utilisez "@" pour supprimer les erreurs de certaines
     fonctions, et que cette fonction n'existe pas, ou qu'elle
     a été mal orthographiée, vous n'aurez aucune indication.
    </para>
   </warning>
  </sect1>

  <sect1 id="language.operators.execution">
   <title>Opérateur d'exécution</title>
   <para>
    &php; supporte un opérateur d'exécution : guillemets obliques
    ("``").    Notez bien qu'il ne s'agit pas de guillemets simples. &php; essaiera
    d'exécuter le contenu de ces guillemets obliques comme une commande
    shell. Le résultat sera retourné (i.e. : il ne sera pas
    simplement envoyé à la sortie standard, il peut être
    assigné à une variable). Utilisez les guillemets obliques revient à utiliser
    la fonction <function>shell_exec</function>.
    <example>
     <title>Opérateur d'exécution</title>
     <programlisting role="php">
<![CDATA[
<?php
$output = `ls -al`;
echo "<pre>$output</pre>";
?>
]]>
     </programlisting>
    </example>
   </para>
   <note>
    <para>
     Cet opérateur est désactivé lorsque le
     &safemode; est activé ou bien que la fonction
     <function>shell_exec</function> est désactivée.
    </para>
   </note>
   <para>
    Voir aussi le manuel à la section sur les
    <link linkend="ref.exec">fonctions d'exécution système</link>,
    <function>popen</function>,
    <function>proc_open</function> et
    <link linkend="features.commandline">l'utilisation de &php; en ligne de commande</link>.
   </para>
  </sect1>

  <sect1 id="language.operators.increment">
   <title>Opérateurs d'incrémentation et décrémentation</title>
   <para>
    &php; supporte les opérateurs de pre- et post-incrémentation et
    décrémentation, comme en langage C.
   </para>
   <table>
    <title>Opérateurs d'incrémentation et décrémentation</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Exemple</entry>
       <entry>Nom</entry>
       <entry>Résultat</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><literal>++$a</literal></entry>
       <entry>Pre-incrémente</entry>
       <entry>
        Incrémente <varname>$a</varname> de 1, puis retourne
        <varname>$a</varname>.
       </entry>
      </row>
      <row>
       <entry><literal>$a++</literal></entry>
       <entry>Post-incrémente</entry>
       <entry>Retourne <varname>$a</varname>, puis l'incrémente de 1.</entry>
      </row>
      <row>
       <entry><literal>--$a</literal></entry>
       <entry>Pré-décrémente</entry>
       <entry>
        Décrémente <varname>$a</varname> de 1, puis retourne
        <varname>$a</varname>.
       </entry>
      </row>
      <row>
       <entry><literal>$a--</literal></entry>
       <entry>Post-décrémente</entry>
       <entry>
        Retourne <varname>$a</varname>, puis décrémente
        <varname>$a</varname> de 1.
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Voici un exemple simple
    <example>
     <title>Exemples d'incrémentations et décrémentations</title>
     <programlisting role="php">
<![CDATA[
<?php
echo '<h3>Post-incrémentation</h3>';
$a = 5;
echo "Devrait valoir  5: " . $a++ . "<br />\n";
echo "Devrait valoir  6: " . $a . "<br />\n";
echo '<h3>Pre-incrémentation</h3>';
$a = 5;
echo "Devrait valoir  6: " . ++$a . "<br />\n";
echo "Devrait valoir  6: " . $a . "<br />\n";
echo '<h3>Post-décrémentation</h3>';
$a = 5;
echo "Devrait valoir  5: " . $a-- . "<br />\n";
echo "Devrait valoir  4: " . $a . "<br />\n";
echo '<h3>Pre-décrémentation</h3>';
$a = 5;
echo "Devrait valoir  4: " . --$a . "<br />\n";
echo "Devrait valoir  4: " . $a . "<br />\n";
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    &php; suit les conventions de Perl pour la gestion des opérateurs arithmétiques,
    et non pas celle du C. Par exemple, en Perl <literal>'Z'+1</literal> retourne
    <literal>'AA'</literal>, alors qu'en C, <literal>'Z'+1</literal> retourne
    <literal>'['</literal> ( <literal>ord('Z') == 90</literal>, donc
    <literal>ord('[') == 91</literal> ).
    Notez que les variables de caractères peuvent être incrémentées, mais pas
    décrémentées.
    <example>
     <title>Opérations arithmétiques sur un caractère</title>
     <programlisting role="php">
<![CDATA[
<?php
$i = 'W';
for($n=0; $n<6; $n++) {
  echo ++$i . "\n";
}
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
X
Y
Z
AA
AB
AC
]]>
     </screen>
    </example>
   </para>
   <para>
    L'incrémentation ou la décrémentation d'un booléen n'a aucun effet.
   </para>
  </sect1>

  <sect1 id="language.operators.logical">
   <title>Les opérateurs logiques</title>

    <table>
    <title>Les opérateurs logiques</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Exemple</entry>
        <entry>Nom</entry>
        <entry>Résultat</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>$a and $b</literal></entry>
        <entry>ET (<literal>And</literal>)</entry>
        <entry> Vrai si <varname>$a</varname> ET <varname>$b</varname> sont vrais.</entry>
       </row>
       <row>
        <entry><literal>$a or $b</literal></entry>
        <entry>OU (<literal>Or</literal>)</entry>
        <entry>Vrai si <varname>$a</varname> OU <varname>$b</varname> est vrai</entry>
       </row>
       <row>
        <entry><literal>$a xor $b</literal></entry>
        <entry>XOR (<literal>Xor</literal>)</entry>
        <entry>
         Vrai si <varname>$a</varname> OU <varname>$b</varname> est vrai,
         mais pas les deux en même temps.
        </entry>
       </row>
       <row>
        <entry><literal>! $a</literal></entry>
        <entry>NON (<literal>Not</literal>)</entry>
        <entry>Vrai si <varname>$a</varname> est faux.</entry>
       </row>
       <row>
        <entry><literal>$a &amp;&amp; $b</literal></entry>
        <entry>ET (<literal>And</literal>)</entry>
        <entry>Vrai si <varname>$a</varname> ET <varname>$b</varname> sont vrais.</entry>
       </row>
       <row>
        <entry><literal>$a || $b</literal></entry>
        <entry>OU (<literal>Or</literal>)</entry>
        <entry>Vrai si <varname>$a</varname> OU <varname>$b</varname> est vrai.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   <simpara>
    La raison pour laquelle il existe deux types de "ET" et de "OU"
    est qu'ils ont des priorités différentes. Voir le
    paragraphe
    <link linkend="language.operators.precedence">précédence d'opérateurs</link>.
   </simpara>
  </sect1>

  <sect1 id="language.operators.string">
   <title>Opérateurs de chaînes</title>
   <simpara>
    Il y a deux opérateurs de chaînes de caractères <type>string</type>. Le premier
    est l'opérateur de concaténation ('.'), qui
    retourne la concaténation de ses deux arguments.
    Le second est l'opérateur d'assignation
    concaténant (<literal>.=</literal>). Reportez-vous à
    <link linkend="language.operators.assignment">opérateurs d'assignation</link>
    pour plus de détails.
   </simpara>

   <para>
    <example>
     <title>Opérateur de concaténation</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = "Bonjour ";
$b = $a . "Monde!"; // $b contient "Bonjour Monde!"

$a = "Bonjour ";
$a = $a . "Monde!"; // $a contient "Bonjour Monde!"
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Voir aussi les sections du manuel sur
    <link linkend="language.types.string">les types de chaînes de caractères</link> et
    <link linkend="ref.strings">les chaînes de caractères</link>.
   </para>
  </sect1>

  <sect1 id="language.operators.array">
   <title>Opérateurs de tableaux</title>
   <table>
    <title>Opérateurs de tableaux</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Exemple</entry>
       <entry>Nom</entry>
       <entry>Résultat</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><varname>$a + $b</varname></entry>
       <entry>Union</entry>
       <entry>Union de <varname>$a</varname> et <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry><varname>$a == $b</varname></entry>
       <entry>Egalité</entry>
       <entry>&true; si <varname>$a</varname> et <varname>$b</varname> contiennent les mêmes paires clés / valeurs.</entry>
      </row>
      <row>
       <entry><varname>$a === $b</varname></entry>
       <entry>Identique</entry>
       <entry>&true; si <varname>$a</varname> et <varname>$b</varname> contiennent les mêmes paires clés / valeurs dans le même ordre et du même type.</entry>
      </row>
      <row>
       <entry><varname>$a != $b</varname></entry>
       <entry>Inégalité</entry>
       <entry>&true; si <varname>$a</varname> n'est pas égal à <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry><varname>$a &lt;&gt; $b</varname></entry>
       <entry>Inégalité</entry>
       <entry>&true; si <varname>$a</varname> n'est pas égal à <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry><varname>$a !== $b</varname></entry>
       <entry>Non-identique</entry>
       <entry>&true; si <varname>$a</varname> n'est pas identique à <varname>$b</varname>.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Le seul opérateur en &php; pour les tableaux est l'opérateur
    <literal>+</literal>. Cet opérateur ajoute le tableau de
    droite au tableau de gauche. Les clés communes sont laissées
    inchangées.
   </para>
   <para>
    <example>
     <title>Addition de tableaux</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = array("a" => "pomme", "b" => "banane");
$b = array("a" =>"poire", "b" => "fraise", "c" => "cerise");

$c = $a + $b; // Union de $a et $b
echo "Union de \$a et \$b : \n";
var_dump($c);

$c = $b + $a; // Union de $b et $a
echo "Union de \$b et \$a : \n";
var_dump($c);
?>
]]>
     </programlisting>
    </example>
   </para>
   &example.outputs;
   <para>
    <screen role="php">
<![CDATA[
Union de $a et $b :
array(3) {
  ["a"]=>
  string(5) "pomme"
  ["b"]=>
  string(6) "banane"
  ["c"]=>
  string(6) "cerise"
}
Union de $b et $a :
array(3) {
  ["a"]=>
  string(5) "poire"
  ["b"]=>
  string(6) "fraise"
  ["c"]=>
  string(6) "cerise"
}
]]>
    </screen>
   </para>
   <para>
    Les éléments d'un tableau sont égaux en terme
    de comparaison s'ils ont la même clé et la même valeur.
   </para>
   <para>
    <example>
     <title>Comparer des tableaux</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = array("pomme", "banane");
$b = array(1 => "banane", "0" => "pomme");

var_dump($a == $b); // bool(true)
var_dump($a === $b); // bool(false)
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Voyez aussi le manuel aux sections
    <link linkend="language.types.array">Tableaux</link> et
    <link linkend="ref.array">fonctions de tableaux</link>.
   </para>
  </sect1>

  <sect1 id="language.operators.type">
   <title>Opérateur de type</title>
   <para>
    &php; a un seul opérateur de type : <literal>instanceof</literal>.
    <literal>instanceof</literal> sert à déterminer si un objet est
    d'une <link linkend="language.oop">classe</link> donnée.
   </para>
   <simpara>
    L'opérateur <literal>instanceof</literal> a été introduit en &php; 5.
    Avant cela, <function>is_a</function> été utilisé mais il est désormais déconseillé
    de l'utiliser, en faveur de <literal>instanceof</literal>.
   </simpara>
   <example>
   <title>Opérateur de type : <literal>instanceof</literal></title>
    <programlisting>
<![CDATA[
<?php
class A { }
class B { }

$thing = new A;

if ($thing instanceof A) {
    echo 'A';
}
if ($thing instanceof B) {
    echo 'B';
}
?>
]]>
    </programlisting>
    <simpara>
     Comme <varname>$thing</varname> est un &object; de type A, mais
     pas B, seul le premier bloc de commande sera exécuté.
    </simpara>
    <screen>A</screen>
   </example>
   <para>
    Voir aussi
    <function>get_class</function> et
    <function>is_a</function>.
   </para>
  </sect1>
 </chapter>
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
indent-tabs-mode:nil
 sgml-parent-document:nil
 sgml-default-dtd-file:"../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
