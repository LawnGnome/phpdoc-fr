<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.27 $ -->
  <chapter id="language.operators">
   <title>Les op&eacute;rateurs</title>
   <simpara>
   </simpara>
   <sect1 id="language.operators.precedence">
    <title>La pr&eacute;c&eacute;dence des op&eacute;rateurs</title>
    <para>
     La priorit&eacute; des op&eacute;rateurs sp&eacute;cifie
     l'ordre dans lequel les valeurs doivent &ecirc;tre analys&eacute;es.
     Par exemple, dans l'expression 1 + 5 * 3, le r&eacute;sultat est
     16 et non 18, car la multiplication ("*") a une priorit&eacute; 
     sup&eacute;rieure par rapport &agrave; l'addition ("+").
    </para>
    <para>
      Le tableau suivant dresse une liste de la priorit&eacute; des
      diff&eacute;rents op&eacute;rateurs dans un ordre croissant de
      priorit&eacute;.
    <table>
     <title>Pr&eacute;c&eacute;dence des op&eacute;rateurs</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Associativit&eacute;</entry>
        <entry>Op&eacute;rateurs</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>gauche</entry>
        <entry>,</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>or</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>xor</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>and</entry>
       </row>
       <row>
        <entry>droite</entry>
        <entry>print</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>= += -= *= /= .= %= &amp;= |= ^= ~= &lt;&lt;=&gt;&gt;=</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>? :</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>||</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>&amp;&amp;</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>|</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>^</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>&amp;</entry>
       </row>
       <row>
        <entry>non-associatif</entry>
        <entry>== != === !==</entry>
       </row>
       <row>
        <entry>non-associatif</entry>
        <entry>&lt; &lt;= &gt; &gt;=</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>&lt;&lt; &gt;&gt;</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>+ - .</entry>
       </row>
       <row>
        <entry>gauche</entry>
        <entry>* / %</entry>
       </row>
       <row>
        <entry>droite</entry>
        <entry>! ~ ++ -- (int) (double) (string) (array) (object) &#64;</entry>
       </row>
       <row>
        <entry>droite</entry>
        <entry>[</entry>
       </row>
       <row>
        <entry>non-associatif</entry>
        <entry>new</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>
   <note>
    <para>
     Bien que <literal>!</literal> soit prioritaire sur 
     <literal>=</literal>, &php; va tout de m&ecirc;me ex&eacute;cuter des
     expressions comme : <literal>if (!$a = foo())</literal>.
     Dans cette situation, le r&eacute;sultat de <literal>foo()</literal> 
     sera plac&eacute; dans la variable <varname>$a</varname>.
    </para>
   </note>
  </sect1>
  <sect1 id="language.operators.arithmetic">
    <title>Les op&eacute;rateurs arithm&eacute;tiques</title>
    <simpara>
      Vous rappelez-vous des op&eacute;rations &eacute;l&eacute;mentaires
      apprises &agrave; l'&eacute;cole ?
    </simpara>
    <table>
     <title>Op&eacute;rations &eacute;l&eacute;mentaires</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Exemple</entry>
        <entry>Nom</entry>
        <entry>R&eacute;sultat</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>$a + $b</literal></entry>
        <entry>Addition</entry>
        <entry>Somme de <varname>$a</varname> et <varname>$b</varname>.</entry>
       </row>
       <row>
        <entry><literal>$a - $b</literal></entry>
        <entry>Soustraction</entry>
        <entry>Diff&eacute;rence de <varname>$a</varname> et <varname>$b</varname>.</entry>
       </row>
       <row>
        <entry><literal>$a * $b</literal></entry>
        <entry>Multiplication</entry>
        <entry>Produit de <varname>$a</varname> et <varname>$b</varname>.</entry>
       </row>
       <row>
        <entry><literal>$a / $b</literal></entry>
        <entry>Division</entry>
        <entry>Quotient de <varname>$a</varname> et <varname>$b</varname>.</entry>
       </row>
       <row>
        <entry><literal>$a % $b</literal></entry>
        <entry>Modulo</entry>
        <entry>Reste de <varname>$a</varname> divis&eacute; par <varname>$b</varname>.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
    <simpara>
     L'op&eacute;rateur de division ("/") retourne une valeur enti&egrave;re
     (le r&eacute;sultat d'une division enti&egrave;re) si les deux op&eacute;randes
     sont entiers (ou bien des cha&icirc;nes converties en entier.
     Si l'un des op&eacute;randes est un nombre &agrave; virgule flottante,
     ou bien le r&eacute;sultat d'une op&eacute;ration qui retourne une valeur
     non enti&egrave;re, un nombre &agrave; virgule flottante sera retourn&eacute;.
    </simpara>
   <simpara>
    Voir aussi le manuel sur les <link linkend="ref.math">fonctions math&eacute;matiques</link>. 
   </simpara>
   </sect1>
   <sect1 id="language.operators.assignment">
    <title>Les op&eacute;rateurs d'assignation</title>
    <simpara>
     L'op&eacute;rateur d'assignation le plus simple est le signe "=".
     Le premier r&eacute;flexe est de penser que ce signe veut dire
     "&eacute;gal &agrave;". Ce n'est pas le cas. Il signifie que
     l'op&eacute;rande de gauche se voit affecter la valeur de
     l'expression qui est &agrave; droite du signe &eacute;gal.
    </simpara>
    <para>
     La valeur d'une expression d'assignation est la valeur
     assign&eacute;e. Par exemple, la valeur de l'expression
     '<literal>$a = 3</literal>' est la valeur 3. Cela permet d'utiliser
     des astuces telles que :
     <example>
      <title>Astuce d'assignation</title>
      <programlisting role="php">
<![CDATA[
<?php
  $a = ($b = 4) + 5; 
// $a est maintenant &eacute;gal &agrave; 9, et $b vaut 4.
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     En plus du simple op&eacute;rateur d'assignation, il existe des
     "op&eacute;rateurs combin&eacute;s" pour tous les op&eacute;rateurs
     arithm&eacute;tiques et pour les op&eacute;rateurs sur les
     cha&icirc;nes de caract&egrave;res. Cela permet d'utiliser
     la valeur d'une variable dans une expression et d'affecter le
     r&eacute;sultat de cette expression &agrave; cette variable.
     Par exemple :
     <example>
      <title>Exemples avec les op&eacute;rateurs d'assignation</title>
       <programlisting role="php">
<![CDATA[
<?php
  $a = 3;
  $a += 5;
// affecte la valeur 8 &agrave; la variable $a.
// correspond &agrave; l'instruction '$a = $a + 5');
  $b = "Bonjour ";
  $b .= " tout le monde!";
// affecte la valeur "Bonjour tout le monde!" &agrave;
//  la variable $b 
//  identique &agrave; $b = $b." tout le monde!";
?>
]]>
      </programlisting>
     </example>
    </para>
   <para>
	On peut noter que l'assignation copie le contenu de la variable originale
	dans la nouvelle variable (assignation par valeur), ce qui fait que les changements
	de valeur d'une variable ne modifieront pas la valeur de l'autre. Cela peut
	se r&eacute;v&eacute;ler important lors de la copie d'un grand tableau
	durant une boucle. &php; 4 supporte aussi l'assignation par
	r&eacute;f&eacute;rence, en utilisant la syntaxe
	<literal>$var = &amp;$othervar;</literal>, mais ce
	n'&eacute;tait pas possible en &php; 3. 'L'assignation par
	r&eacute;f&eacute;rence' signifie que les deux variables contiennent les
	m&ecirc;mes donn&eacute;es, et que la modification de l'une affecte
	l'autre. D'un autre c&ocirc;t&eacute;, la recopie est tr&egrave;s rapide.
   </para>
  </sect1>
   <sect1 id="language.operators.bitwise">
    <title>Op&eacute;rateurs sur les bits</title>
    <simpara>
     Les op&eacute;rateurs sur les bits vous permettent de
     manipuler les bits dans un entier.
    </simpara>
   <para>
    <example>
      <title>Exemples avec les op&eacute;rateurs sur les bits</title>
     <programlisting role="php">
<![CDATA[
<?php
    echo 12 ^ 9; 
// Affiche '5'

    echo "12" ^ "9"; 
// Affiche le caract&egrave;re d'effacement (ascii 8)
// ('1' (ascii 49)) ^ ('9' (ascii 57)) = #8

echo "hallo" ^ "hello"; 
// Affiche la valeur asciie : s #0 #4 #0 #0 #0
// 'a' ^ 'e' = #4
?>
]]>
     </programlisting>
    </example> 
   </para>
    <table>
     <title>Les op&eacute;rateurs sur les bits</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Exemple</entry>
        <entry>Nom</entry>
        <entry>R&eacute;sultat</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>$a &amp; $b</literal></entry>
        <entry>ET (AND)</entry>
        <entry>
         Les bits positionn&eacute;s &agrave; 1 dans <varname>$a</varname> ET dans <varname>$b</varname>
         sont positionn&eacute;s &agrave; 1.
        </entry>
       </row>
       <row>
        <entry><literal>$a | $b</literal></entry>
        <entry>OU (OR)</entry>
        <entry>
         Les bits positionn&eacute;s &agrave; 1 dans <varname>$a</varname> OU <varname>$b</varname> sont
         sont positionn&eacute;s &agrave; 1.
        </entry>
       </row>
       <row>
        <entry><literal>$a ^ $b</literal></entry>
        <entry>Xor</entry>
        <entry>
         Les bits positionn&eacute;s &agrave; 1 dans <varname>$a</varname> OU dans <varname>$b</varname>
         sont positionn&eacute;s &agrave; 1.
        </entry>
       </row>
       <row>
        <entry><literal>~ $a</literal></entry>
        <entry>NON (<literal>Not</literal>)</entry>
        <entry>
         Les bits qui sont positionn&eacute;s &agrave; 1 dans <varname>$a</varname>
         sont positionn&eacute;s &agrave; 0, et vice versa.
        </entry>
       </row>
       <row>
        <entry><literal>$a &lt;&lt; $b</literal></entry>
        <entry>D&eacute;calage &agrave; gauche</entry>
        <entry>
         D&eacute;cale les bits de <varname>$a</varname> <varname>$b</varname> fois sur la gauche
         (chaque d&eacute;calage &eacute;quivaut &agrave; une multiplication par 2).
        </entry>
       </row>
       <row>
        <entry><literal>$a &gt;&gt; $b</literal></entry>
        <entry>D&eacute;calage &agrave; droite</entry>
        <entry>
         D&eacute;calage des bits de <varname>$a</varname> <varname>$b</varname> fois par la droite
         (chaque d&eacute;calage &eacute;quivaut &agrave; une division par 2).
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </sect1>
   <sect1 id="language.operators.comparison">
    <title>Op&eacute;rateurs de comparaison</title>
    <simpara>
      Les op&eacute;rateurs de comparaison, comme leur nom l'indique,
      vous permettent de comparer deux valeurs.
    </simpara>
    <table>
     <title>Op&eacute;rateurs de comparaison</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Exemple</entry>
        <entry>Nom</entry>
        <entry>R&eacute;sultat</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>$a == $b</literal></entry>
        <entry>Egal</entry>
        <entry>Vrai si <varname>$a</varname> est &eacute;gal &agrave; <varname>$b</varname>.</entry>
       </row>
       <row>
        <entry><literal>$a === $b</literal></entry>
        <entry>Identique</entry>
        <entry>
          Vrai si <varname>$a</varname> est &eacute;gal &agrave; <varname>$b</varname> et qu'ils sont de m&ecirc;me type
          (&php; 4 seulement).
        </entry>
       </row>
       <row>
        <entry><literal>$a != $b</literal></entry>
        <entry>Diff&eacute;rent</entry>
        <entry>Vrai si <varname>$a</varname> est diff&eacute;rent de <varname>$b</varname>.</entry>
       </row>
       <row>
        <entry><literal>$a &lt;&gt; $b</literal></entry>
        <entry>Diff&eacute;rent</entry>
        <entry>Vrai si <varname>$a</varname> est diff&eacute;rent de <varname>$b</varname>.</entry>
       </row>
       <row>
        <entry><literal>$a &lt; $b</literal></entry>
        <entry>Plus petit que</entry>
        <entry>Vrai si <varname>$a</varname> est plus petit strictement que <varname>$b</varname>.</entry>
       </row>
       <row>
        <entry><literal>$a &gt; $b</literal></entry>
        <entry>Plus grand</entry>
        <entry>Vrai si <varname>$a</varname> est plus grand strictement que <varname>$b</varname>.</entry>
       </row>
       <row>
        <entry><literal>$a &lt;= $b</literal></entry>
        <entry>Inf&eacute;rieur ou &eacute;gal</entry>
        <entry>Vrai si <varname>$a</varname> est plus petit ou &eacute;gal &agrave; <varname>$b</varname>.</entry>
       </row>
       <row>
        <entry><literal>$a &gt;= $b</literal></entry>
        <entry>Sup&eacute;rieur ou &eacute;gal</entry>
        <entry>Vrai si <varname>$a</varname> est plus grand ou &eacute;gal &agrave; <varname>$b</varname>.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   <para>
     Un autre op&eacute;rateur conditionnel est l'op&eacute;rateur
     ternaire (":?"), qui fonctionne comme en langage C.
	<informalexample>
	 <programlisting role="php">
<![CDATA[
<?php
// Exemple d'utilisation pour l'op&eacute;rateur ternaire
$action = (empty($_POST['action'])) ? 'default' : $_POST['action'];

// L'expression ci-dessus est identique &agrave; 
if (empty($_POST['action'])) {
    $action = 'default';
} else {
    $action = $_POST['action'];
}
?>
]]>
	 </programlisting>
	</informalexample>
	 L'expression <literal>(expr1) ? (expr2) : (expr3)</literal> renvoie la valeur de l'expression
	 <replaceable>expr2</replaceable> si l'expression
	 <replaceable>expr1</replaceable> est vraie, et l'expression
	 <replaceable>expr3</replaceable> si l'expression
	 <replaceable>expr1</replaceable> est fausse.
   </para>
   <para>
    Voir aussi
    <function>strcasecmp</function>,
    <function>strcmp</function> et le chapitre sur les
    <link linkend="language.types">types</link>.
   </para>
  </sect1>
  <sect1 id="language.operators.errorcontrol">
   <title>Op&eacute;rateur de contr&ocirc;le d'erreur</title>
   <simpara>
    &php; supporte un op&eacute;rateur de contr&ocirc;le d'erreur : c'est &#64;.
    Lorsque cet op&eacute;rateur est ajout&eacute; en pr&eacute;fixe d'une
    expression &php;, les messages d'erreur qui peuvent &ecirc;tre
    g&eacute;n&eacute;r&eacute;s par cette expression seront ignor&eacute;s.
   </simpara>
   <simpara>
    Si l'option <link linkend="ini.track-errors"><option>track_errors</option></link>
    est activ&eacute;e, les messages d'erreurs g&eacute;n&eacute;r&eacute;s
    par une expression seront sauv&eacute;s dans la variable globale
    <varname>$php_errormsg</varname>. Cette variable sera &eacute;cras&eacute;e &agrave;
    chaque erreur. Il faut alors la surveiller souvent pour pouvoir l'utiliser.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* Erreur intentionnelle (le fichier n'existe pas): */
  $my_file = @file ('non_persistent_file') or
    die ("Impossible d'ouvrir le fichier : L'erreur est : '$php_errormsg'");
// Cela fonctionne avec n'importe quelle expression, pas seulement les fonctions
  $value = @$cache[$key];
// la ligne ci-dessus n'affichera pas d'alerte si la cl&eacute; $key du tableau n'existe pas
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <simpara>
     L'op&eacute;rateur &#64; ne fonctionne qu'avec les expressions. La r&egrave;gle
     g&eacute;n&eacute;rale de fonctionnement est la suivante : si vous pouvez prendre
     la valeur de quelque chose, vous pouvez le pr&eacute;fixer avec &#64;. Par exemple,
     vous pouvez ajouter &#64; aux variables, fonctions, &agrave;
     <function>include</function>, aux constantes, etc. Vous ne pourrez
     pas le faire avec des &eacute;l&eacute;ments de langage tels que les classes,
     <literal>if</literal> et <literal>foreach</literal>, etc.
    </simpara>
   </note>
   <note>
    <simpara>
     La plupart des fonctions d'acc&egrave;s aux bases de donn&eacute;es ne retournent
     pas d'erreur &php;. Il faut y acc&eacute;der avec une fonction du type
     <literal>base_de_donnees_get_error()</literal>.
    </simpara>
   </note>
   <simpara>
    Voir aussi
    <function>error_reporting</function>.
   </simpara>
  </sect1>
  <sect1 id="language.operators.execution">
   <title>Op&eacute;rateur d'ex&eacute;cutions</title>
   <para>
	&php; supporte un op&eacute;rateur d'ex&eacute;cution : guillemets obliques
	("``").	Notez bien la diff&eacute;rence entre les guillemets simples (sur
	la touche 4), et ceux-ci (sur la touche de la livre anglaise). &php; essaiera
	d'ex&eacute;cuter le contenu de ces guillemets obliques comme une commande
	shell. Le r&eacute;sultat sera retourn&eacute; (i.e. : il ne sera pas
	simplement envoy&eacute; &agrave; la sortie standard, il peut &ecirc;tre
	assign&eacute; &agrave; une variable).
	<informalexample>
	 <programlisting role="php">
<![CDATA[
<?php
  $output = `ls -al`;
  echo "<pre>$output</pre>";
?>
]]>
	 </programlisting>
	</informalexample>
   </para>
   <note>
    <para>
     Cet op&eacute;rateur est d&eacute;sactiv&eacute; lorsque le
     &safemode; est activ&eacute; ou bien que la fonction
     <function>shell_exec</function> est d&eacute;sactiv&eacute;e.
    </para>
   </note>
   <para>
	Voir aussi
	<function>system</function>,
	<function>passthru</function>,
	<function>exec</function>,
	<function>shell_exec</function>,
	<function>popen</function> et
	<function>escapeshellcmd</function>.
   </para>
  </sect1>
  <sect1 id="language.operators.increment">
   <title>Op&eacute;rateurs d'incr&eacute;mentation/D&eacute;cr&eacute;mentation</title>
   <para>
	&php; supporte les op&eacute;rateurs de pr&eacute; et post incr&eacute;mentation et
	d&eacute;cr&eacute;mentation, comme en C.
   </para>
    <table>
     <title>Op&eacute;rateurs d'incr&eacute;mentation/D&eacute;cr&eacute;mentation</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Exemple</entry>
        <entry>Nom</entry>
        <entry>R&eacute;sultat</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>++$a</literal></entry>
        <entry>Pr&eacute;-incr&eacute;mente</entry>
        <entry>Incr&eacute;mente <varname>$a</varname> de 1, puis retourne <varname>$a</varname>.</entry>
       </row>
       <row>
        <entry><literal>$a++</literal></entry>
        <entry>Post-incr&eacute;mente</entry>
        <entry>Retourne <varname>$a</varname>, puis l'incr&eacute;mente de 1.</entry>
       </row>
       <row>
        <entry><literal>--$a</literal></entry>
        <entry>Pr&eacute;-d&eacute;cr&eacute;mente</entry>
        <entry>D&eacute;cr&eacute;mente <varname>$a</varname> de 1, puis retourne <varname>$a</varname>.</entry>
       </row>
       <row>
        <entry><literal>$a--</literal></entry>
        <entry>Post-d&eacute;cr&eacute;mente</entry>
        <entry>Retourne <varname>$a</varname>, puis d&eacute;cr&eacute;mente <varname>$a</varname> de 1.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   <para>
	Voici un exemple simple
	<informalexample>
	 <programlisting role="php">
<![CDATA[
<?php
  echo "<h3>Post-incr&eacute;mentation</h3>";
  $a = 5;
  echo "Devrait valoir  5: " . $a++ . "<br>\n";
  echo "Devrait valoir  6: " . $a . "<br>\n";
  echo "<h3>Pr&eacute;-incr&eacute;mentation</h3>";
  $a = 5;
  echo "Devrait valoir  6: " . ++$a . "<br>\n";
  echo "Devrait valoir  6: " . $a . "<br>\n";
  echo "<h3>Post-d&eacute;cr&eacute;mentation</h3>";
  $a = 5;
  echo "Devrait valoir  5: " . $a-- . "<br>\n";
  echo "Devrait valoir  4: " . $a . "<br>\n";
  echo "<h3>Pr&eacute;-d&eacute;cr&eacute;mentation</h3>";
  $a = 5;
  echo "Devrait valoir  4: " . --$a . "<br>\n";
  echo "Devrait valoir  4: " . $a . "<br>\n";
?>
]]>
	 </programlisting>
	</informalexample>
   </para>
   <para>
    &php; suit les conventions de Perl pour la gestion des op&eacute;rateurs arithm&eacute;tiques,
    et non pas celle du C. Par exemple, en Perl <literal>'Z'+1</literal> retourne
    <literal>'AA'</literal>, alors qu'en C, <literal>'Z'+1</literal> retourne
    <literal>'['</literal> ( <literal>ord('Z') == 90</literal>, donc
    <literal>ord('[') == 91</literal> ).
    Notez que les variables de caract&egrave;res peuvent &ecirc;tre incr&eacute;ment&eacute;es, mais pas
    d&eacute;cr&eacute;ment&eacute;es.
    <example>
     <title>Op&eacute;rations arithm&eacute;tiques sur un caract&egrave;re</title>
     <programlisting role="php">
<![CDATA[
<?php
$i = 'W';
for($n=0; $n<6; $n++)
  echo ++$i . "\n";

/*
  Produit un r&eacute;sultat identique &agrave; celui-ci : 
  
X
Y
Z
AA
AB
AC

*/
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect1>
  <sect1 id="language.operators.logical">
    <title>Les op&eacute;rateurs logiques</title>
    <table>
    <title>Les op&eacute;rateurs logiques</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Exemple</entry>
        <entry>Nom</entry>
        <entry>R&eacute;sultat</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>$a and $b</literal></entry>
        <entry>ET (And)</entry>
        <entry> Vrai si <varname>$a</varname> ET <varname>$b</varname> sont vrais.</entry>
       </row>
       <row>
        <entry><literal>$a or $b</literal></entry>
        <entry>OU (Or)</entry>
        <entry>Vrai si <varname>$a</varname> OU <varname>$b</varname> est vrai</entry>
       </row>
       <row>
        <entry><literal>$a xor $b</literal></entry>
        <entry>XOR (Xor)</entry>
        <entry>Vrai si <varname>$a</varname> OU <varname>$b</varname> est vrai, mais pas les deux en m&ecirc;me temps.</entry>
       </row>
       <row>
        <entry><literal>! $a</literal></entry>
        <entry>NON (Not)</entry>
        <entry>Vrai si <varname>$a</varname> est faux.</entry>
       </row>
       <row>
        <entry><literal>$a &amp;&amp; $b</literal></entry>
        <entry>ET (And)</entry>
        <entry>Vrai si <varname>$a</varname> ET <varname>$b</varname> sont vrais.</entry>
       </row>
       <row>
        <entry><literal>$a || $b</literal></entry>
        <entry>OU (Or)</entry>
        <entry>Vrai si <varname>$a</varname> OU <varname>$b</varname> est vrai.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   <simpara>
	La raison pour laquelle il existe deux types de "ET" et de "OU"
	est qu'ils ont des priorit&eacute;s diff&eacute;rentes. Voir le
	paragraphe
	<link linkend="language.operators.precedence">pr&eacute;c&eacute;dence d'op&eacute;rateurs</link>.
   </simpara>
  </sect1>

  <sect1 id="language.operators.string">
   <title>Op&eacute;rateurs de cha&icirc;nes</title>
   <simpara>
	Il y a deux op&eacute;rateurs de cha&icirc;nes. Le premier
	est l'op&eacute;rateur de concat&eacute;nation ('.'), qui
	retourne la concat&eacute;nation de ses deux arguments.
	Le second est l'op&eacute;rateur d'assignation
	concat&eacute;nant (<literal>.=</literal>). Reportez-vous &agrave;
	<link linkend="language.operators.assignment">op&eacute;rateurs d'assignation</link>
	pour plus de d&eacute;tails.
   </simpara>
   <para>
	<informalexample>
	 <programlisting role="php">
<![CDATA[
<?php
  $a = "Bonjour ";
  $b = $a . "Monde!";
// $b contient "Bonjour Monde!"
  $a = "Bonjour ";
  $a = $a . "Monde!";
// $a contient "Bonjour Monde!"
?>
]]>
     </programlisting>
	</informalexample>
   </para>
  </sect1>
  <sect1 id="language.operators.array">
   <title>Op&eacute;rateurs de tableaux</title>
   <simpara>
    Le seul op&eacute;rateur en &php; pour les tableaux est l'op&eacute;rateur
    <literal>+</literal>. Cet op&eacute;rateur ajoute le tableau de
    droite au tableau de gauche. Les cl&eacute;s communes sont laiss&eacute;es
    inchang&eacute;es.
   </simpara>
   <para>
    <example>
     <title>Addition de tableaux</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = array("a" => "pomme", "b" => "banane");
$b = array("a" =>"poire", "b" => "fraise", "c" => "cerise");

$c = $a + $b;

var_dump($c);
?>
]]>
     </programlisting>
     <screen role="php">
<![CDATA[
array(3) {
  ["a"]=>
  string(5) "pomme"
  ["b"]=>
  string(6) "banane"
  ["c"]=>
  string(6) "cerise"
}

]]>
       </screen>
    </example>
   </para>
  </sect1>
 </chapter>
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
indent-tabs-mode:nil
 sgml-parent-document:nil
 sgml-default-dtd-file:"../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
