<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 303436 Maintainer: jpauli Status: ready -->
<!-- Reviewed: yes -->

 <sect1 xml:id="language.oop5.magic" xmlns="http://docbook.org/ns/docbook">
  <title>Méthodes magiques</title>
  <para>
   Les méthodes
   <link linkend="language.oop5.decon.constructor"><literal>__construct</literal></link>,
   <link linkend="language.oop5.decon.destructor"><literal>__destruct</literal></link>,
   <link linkend="language.oop5.overloading.methods"><literal>__call</literal></link>,
   <link linkend="language.oop5.overloading.methods"><literal>__callStatic</literal></link>,
   <link linkend="language.oop5.overloading.members"><literal>__get</literal></link>,
   <link linkend="language.oop5.overloading.members"><literal>__set</literal></link>,
   <link linkend="language.oop5.overloading.members"><literal>__isset</literal></link>,
   <link linkend="language.oop5.overloading.members"><literal>__unset</literal></link>,
   <link linkend="language.oop5.magic.sleep"><literal>__sleep</literal></link>,
   <link linkend="language.oop5.magic.sleep"><literal>__wakeup</literal></link>,
   <link linkend="language.oop5.magic.tostring"><literal>__toString</literal></link>,
   <link linkend="language.oop5.magic.invoke"><literal>__invoke</literal></link>,
   <link linkend="language.oop5.magic.set-state"><literal>__set_state</literal></link> et
   <link linkend="language.oop5.cloning"><literal>__clone</literal></link>
   sont magiques en PHP. Vous ne pouvez pas utiliser ces noms de méthode
   dans vos classes, sauf si vous voulez implémenter 
   le comportement associé à ces méthodes magiques.
  </para>

  <caution>
   <simpara>
    PHP réserve tous les noms de fonctions commençant par un double souligné
    <literal>__</literal> pour les méthodes magiques. Il est recommandé de
    ne pas utiliser de noms de fonctions commençant par <literal>__</literal>
    sauf si vous voulez des fonctionnalités magiques documentées.
   </simpara>
  </caution>

  <sect2 xml:id="language.oop5.magic.sleep">
   <title><literal>__sleep</literal> et <literal>__wakeup</literal></title>
   <para>
    La fonction <function>serialize</function> vérifie si votre classe a une méthode
    avec le nom magique <literal>__sleep</literal>. Si c'est le cas, cette méthode
    sera exécutée avant toute linéarisation. Elle peut nettoyer l'objet et elle est
    supposée retourner un tableau avec les noms de toutes les variables de l'objet
    qui doivent être linéarisées.
    Si la méthode ne retourne rien, alors &null; est linéarisé et une alerte de type
    <constant>E_NOTICE</constant> est émise.
   </para>
   <note>
    <para>
     Il n'est pas possible pour <literal>__sleep</literal> de retourner
     les noms des propriétés privées des classes parentes. Le faire
     résulte en une erreur de niveau <constant>E_NOTICE</constant>.
     À la place, vous devriez utiliser l'interface <classname>Serializable</classname>.
    </para>
   </note>
   <para>
    Le but avoué de <literal>__sleep</literal> est de valider des données en attente
    ou d'effectuer les opérations de nettoyage.
    De plus, cette fonction est utile si vous avez de très gros objets
    qui n'ont pas besoin d'être sauvegardés en totalité.
   </para>
   <para>
    Réciproquement, la fonction <function>unserialize</function> vérifie
    la présence d'une méthode dont le nom est le nom magique
    <literal>__wakeup</literal>. Si elle est présente, cette fonction
    peut reconstruire toute ressource que l'objet possède.
   </para>
   <para>
    Le but avoué de <literal>__wakeup</literal> est de rétablir
    toute connexion de base de données qui aurait été perdue
    durant la linéarisation et d'effectuer des tâches de réinitialisation.
   </para>
   <example>
    <title>Utilisation de sleep() et wakeup()</title>
    <programlisting role="php">
<![CDATA[
<?php
class Connection
{
    protected $link;
    private $server, $username, $password, $db;

    public function __construct($server, $username, $password, $db)
    {
        $this->server = $server;
        $this->username = $username;
        $this->password = $password;
        $this->db = $db;
        $this->connect();
    }

    private function connect()
    {
        $this->link = mysql_connect($this->server, $this->username, $this->password);
        mysql_select_db($this->db, $this->link);
    }

    public function __sleep()
    {
        return array('server', 'username', 'password', 'db');
    }

    public function __wakeup()
    {
        $this->connect();
    }
}
?>
]]>
    </programlisting>
   </example>
  </sect2>

  <sect2 xml:id="language.oop5.magic.tostring">
   <title><literal>__toString</literal></title>
   <para>
    La méthode <literal>__toString</literal> détermine comment l'objet
    doit réagir lorsqu'il est traité comme une chaîne de caractères.
    Par exemple, ce que <literal>echo $obj;</literal> affichera. Cette méthode doit
    retourner une chaine sinon une erreur <constant>E_RECOVERABLE_ERROR</constant>
    sera levée.
   </para>
   <example>
    <title>Exemple simple</title>
    <programlisting role="php">
<![CDATA[
<?php
// Déclaration d'une classe simple
class ClasseTest
{
    public $foo;

    public function __construct($foo)
    {
        $this->foo = $foo;
    }

    public function __toString()
    {
        return $this->foo;
    }
}

$class = new ClasseTest('Bonjour');
echo $class;
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Bonjour
]]>
    </screen>
   </example>
   <para>
    Il est important de noter qu'avant PHP 5.2.0, la méthode
    <literal>__toString</literal> n'était appelée que si elle était
    directement combinée avec <function>echo</function> ou
    <function>print</function>.
    Depuis PHP 5.2.0, elle est appelée dans tous les contextes de chaîne
    de caractères (e.g. dans <function>printf</function> avec
    le modificateur <literal>%s</literal>) mais pas dans les autres types
    de contextes (e.g. avec le modificateur <literal>%d</literal>).
    Depuis PHP 5.2.0, convertir un objet sans la méthode
    <literal>__toString</literal> en &string; émettra une
    <constant>E_RECOVERABLE_ERROR</constant>.
   </para>
  </sect2>

  <sect2 xml:id="language.oop5.magic.invoke">
   <title><literal>__invoke</literal></title>
   <para>
    La méthode <literal>__invoke</literal> est appelée lorsque le script tente
    d'appeler un objet comme une fonction.
   </para>
   <note>
    <para>
     Cette fonctionnalité est disponible depuis PHP 5.3.0.
    </para>
   </note>
   <example>
    <title>Exemple avec <literal>__invoke</literal></title>
    <programlisting role="php">
<![CDATA[
<?php
class CallableClass
{
    public function __invoke($x)
    {
        var_dump($x);
    }
}
$obj = new CallableClass;
$obj(5);
var_dump(is_callable($obj));
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
int(5)
bool(true)
]]>
    </screen>
   </example>
  </sect2>

  <sect2 xml:id="language.oop5.magic.set-state">
   <title><literal>__set_state</literal></title>
   <para>
    Cette méthode <link linkend="language.oop5.static">statique</link> est appelée
    pour les classes exportées par la fonction <function>var_export</function>
    depuis PHP 5.1.0.
   </para>
   <para>
    Le seul paramètre de cette méthode est un tableau contenant les propriétés
    exportées sous la forme <literal>array('propriété' => valeur, ...)</literal>.
   </para>
   <example>
    <title>Utilisation de <literal>__set_state</literal> (depuis PHP 5.1.0)</title>
    <programlisting role="php">
<![CDATA[
<?php

class A
{
    public $var1;
    public $var2;

    public static function __set_state($an_array) // Depuis PHP 5.1.0
    {
        $obj = new A;
        $obj->var1 = $an_array['var1'];
        $obj->var2 = $an_array['var2'];
        return $obj;
    }
}

$a = new A;
$a->var1 = 5;
$a->var2 = 'foo';

eval('$b = ' . var_export($a, true) . ';'); // $b = A::__set_state(array(
                                            //    'var1' => 5,
                                            //    'var2' => 'foo',
                                            // ));
var_dump($b);

?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
object(A)#2 (2) {
  ["var1"]=>
  int(5)
  ["var2"]=>
  string(3) "foo"
}
]]>
    </screen>
   </example>
  </sect2>
 </sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->