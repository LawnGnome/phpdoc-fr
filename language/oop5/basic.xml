<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.9 $ -->
<!-- EN-Revision: 1.14 Maintainer: yannick Status: ready -->
 <sect1 id="language.oop5.basic">
  <title>Syntaxe de base</title>
  <sect2 id="language.oop5.basic.class">
   <title>class</title>
   <para>
    Chaque définition de classe commence par le mot-clé <literal>class</literal>, suivi
    par le nom de la classe, qui peut être quelconque à condition que ce ne soit pas un
    <link linkend="reserved">mot réservé</link> en &php;.
    Suivent une paire de parenthèses contenant la définition des membres et des
    méthodes. Une pseudo-variable <varname>$this</varname> est disponible
    lorsqu'une méthode est appelée depuis un contexte objet.
    <varname>$this</varname> est une référence à l'objet appelé (habituellement,
    l'objet auquelle la méthode appartient, mais ce peut être un autre objet si la méthode
    est appelée de manière <link linkend="language.oop5.static">statique</link> depuis le
    contexte d'un autre objet). Ce comportement est illustré dans l'exemple suivant :
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
class A
{
  function toto()
  {
    if (isset($this)) {
      echo '$this is defined (';
      echo get_class($this);
      echo ")\n";
    } else {
      echo "\$this is not defined.\n";
    }
  }
}

class B
{
  function titi()
  {
    A::toto();
  }
}

$a = new A();
$a->toto();
A::toto();
$b = new B();
$b->titi();
B::titi();
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
$this is defined (a)
$this is not defined.
$this is defined (b)
$this is not defined.
]]>
     </screen>
    </informalexample>
   </para>
   <example>
    <title>Définition simple d'une classe</title>
    <programlisting role="php">
<![CDATA[
<?php
class SimpleClass
{
   // déclaration d'un membre
   public $var = 'une valeur par défaut';

   // déclaration de la méthode
   public function displayVar() {
     echo $this->var;
   }
}
?>
]]>
    </programlisting>
   </example>
  </sect2>

  <sect2 id="language.oop5.basic.new">
   <title>Le mot clé <literal>new</literal></title>
   <para>
    Pour créer une instance d'un objet, un nouvel objet doit être créé et assigné à
    une variable. Un objet doit toujours être assigné lors de la création d'un nouvel objet
    à moins qu'un l'objet ait un <link linkend="language.oop5.decon">constructeur</link>
    défini qui lance un  <link linkend="language.exceptions">exception</link>
    en cas d'erreur.
   </para>
   <example>
    <title>Création d'une instance</title>
    <programlisting role="php">
<![CDATA[
<?php
$instance = new SimpleClass()
?>
]]>
    </programlisting>
   </example>
   <para>
    Lors de l'assignation d'un instance déjà créée d'un objet à une variable,
    la nouvelle variable accédera à la même instance de l'objet assigné.
    Ce comportement est le même que lors du passage d'une instance à une fonction.
    Une nouvelle instance d'un objet déjà créé peut être effectuée par
    <link linkend="language.oop5.cloning">clonage</link>.
   </para>
   <example>
    <title>Assignation d'un objet</title>
    <programlisting role="php">
<![CDATA[
<?php
$assigned   =  $instance;
$reference  =& $instance;

$instance->var = '$assigned aura cette valeur';

$instance = null; // $instance et $reference deviennent null

var_dump($instance);
var_dump($reference);
var_dump($assigned);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
NULL
NULL
object(SimpleClass)#1 (1) {
   ["var"]=>
     string(30) "$assigned aura cette valeur"
}
]]>
    </screen>
   </example>
  </sect2>

  <sect2 id="language.oop5.basic.extends">
   <title>Le mot clé <literal>extends</literal></title>
   <para>
    Une classe peut hériter des méthodes et des membres d'une autre classe en
    utilisant le mot clé <literal>extends</literal> dans la déclaration.
    Il n'est pas possible d'étendre de multiples classes, une classe peut uniquement
    hériter d'une seule classe de base.
   </para>
   <para>
    Les méthodes et membres hérités peuvent être surchargés, à moins que
    la classe parent ait défini une méthode comme
    <link linkend="language.oop5.final">final</link>. Pour surcharger, il suffit
    de redéclarer la méthode avec le même nom
    que celui défini dans la classe parent. Il est possible d'accéder à une méthode
    ou un membre surchargé avec l'opérateur
    <link linkend="language.oop5.paamayim-nekudotayim">parent::</link>
   </para>
   <example>
    <title>Héritage d'une classe simple</title>
    <programlisting role="php">
<![CDATA[
<?php
class ExtendClass extends SimpleClass
{
  // Redéfinition de la méthode parent
  function displayVar()
  {
    echo "Classe étendue\n";
    parent::displayVar();
  }
}

$extended = new ExtendClass();
$extended->displayVar();
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Classe étendue
une valeur par défaut
]]>
    </screen>
   </example>
  </sect2>

 </sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
