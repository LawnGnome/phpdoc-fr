<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.9 $ -->
<!-- EN-Revision: 1.7 Maintainer: yannick Status: ready -->
 <sect1 id="language.oop5.static">
  <title>Statique</title>

  <para>
   Le fait de déclarer des membres ou des méthodes comme statiques vous
   permet d'y accéder sans avoir besoin d'instancier la classe. Un membre
   déclaré comme statique ne peut être accédé sans instancier un objet de la
   classe (bien qu'une méthode statique le peut). Les méthodes et les membres statiques
   ne peuvent être redéfinis dans les sous-classes.
  </para>

  <para>
   La déclaration <literal>static</literal> doit être faite après la déclaration de visibilité.
   Pour des raisons de compatiblité avec &php; 4, si aucune déclaration de 
   <link linkend="language.oop5.visibility">visibilité</link> n'est utilisée,
   alors le membre ou la méthode sera traité comme s'il avait été déclaré comme
   <literal>public static</literal>.
  </para>

  <para>
   Comme les méthodes statiques sont appelables sans instance d'objet créée,
   la pseudo variable <varname>$this</varname> n'est pas disponible
   dans la méthode déclarée en tant que statique.
  </para>
  
  <para>
   En fait, les appels de méthodes statiques sont résolus
   au moment de la compilation. Lorsque l'on utilise un nom de classe explicite,
   la méthode est déjà identifiée complètement et aucune notion d'héritage
   n'est appliquée. Si l'appel est effectuée par le mot clé <literal>self</literal>,
   alors <literal>self</literal> est traduit en la classe courante, qui est la classe
   appartenant au code. Ici aussi, aucune notion d'héritage
   n'est appliquée.
  </para>

  <para>
   On ne peut pas accéder à des propritétés statiques à travers l'objet en utilisant
   l'opérateur <literal>-&gt;</literal>.
  </para>

  <example>
   <title>Exemple avec un membre statique</title>
   <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    public static $my_static = 'foo';

    public function staticValue() {
        return self::$my_static;
    }
}

class Bar extends Foo 
{

    public function fooStatic() {
        return parent::$my_static;
    }
}


print Foo::$my_static . "\n";

$foo = new Foo();
print $foo->staticValue() . "\n";
print $foo->my_static . "\n";      // propriété my_static non définie

// $foo::my_static n'est pas possible

print Bar::$my_static . "\n";
$bar = new Bar();
print $bar->fooStatic() . "\n";
?>
]]>
   </programlisting>
  </example>

  <example>
   <title>Exemple avec une méthode statique</title>
    <programlisting role="php">
<![CDATA[
<?php
class Foo 
{
    public static function aStaticMethod() {
        // ...
    }
}

Foo::aStaticMethod();
?>
]]>
    </programlisting>
  </example>

 </sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
