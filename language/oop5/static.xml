<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.4 $ -->
<!-- EN-Revision: 1.5 Maintainer: yannick Status: ready -->
 <sect1 id="language.oop5.static">
  <title>Statique</title>

  <para>
   Le fait de déclarer des membres ou des méthodes comme statiques vous
   permet de les appeler en dehors de l'objet. Un membre ou une méthode
   déclaré comme statique ne peut être accédé avec une variable qui est une
   instance de l'objet et ne peut être redéfini dans une extension de la classe.
  </para>

  <para>
   La déclaration en statique doit être faite après la déclaration de visibilité.
   Pour des raisons de compatiblité avec &php; 4, si aucune déclaration de 
   <link linkend="language.oop5.visibility">visibilité</link> n'est utilisée,
   alors le membre ou la méthode sera traité comme s'il avait été déclaré comme
   <literal>public static</literal>.
  </para>

  <para>
   Parceque les méthodes statiques sont appelables sans instance d'objet créé,
   la pseudo variable <varname>$this</varname> n'est pas disponible
   dans la méthode déclarée en tant que statique.
  </para>
  
  <para>
   En faite, les appels de méthodes <literal>static</literal> sont résolus
   au moment de la compilation. Lorsqu'on utilise un nom de classe explicite,
   la méthode est déjà identifiée complétement et aucune notion d'héritage
   n'est appliquée. Si l'appel est effectuée par le mot clé <literal>self</literal>,
   alors <literal>self</literal> est traduit en la classe courante, qui est la classe
   appartenant au code. Ici aussi, aucune notion d'héritage
   n'est appliquée.
  </para>
  
  <para>
   Les propritétés statiques ne peuvent être accédés à travers l'objet en utilisant
   l'opérateur <literal>-&gt;</literal>.
  </para>

  <example>
   <title>Exemple avec un membre statique</title>
   <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    public static $my_static = 'foo';

    public function staticValue() {
        return self::$my_static;
    }
}

class Bar extends Foo 
{

    public function fooStatic() {
        return parent::$my_static;
    }
}


print Foo::$my_static . "\n";

$foo = new Foo();
print $foo->staticValue() . "\n";
print $foo->my_static . "\n";      // propriété my_static non définie

// $foo::my_static n'est pas possible

print Bar::$my_static . "\n";
$bar = new Bar();
print $bar->fooStatic() . "\n";
?>
]]>
   </programlisting>
  </example>

  <example>
   <title>Exemple avec une méthode statique</title>
    <programlisting role="php">
<![CDATA[
<?php
class Foo 
{
    public static function aStaticMethod() {
        // ...
    }
}

Foo::aStaticMethod();
?> 
]]>
    </programlisting>
  </example>

 </sect1>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
