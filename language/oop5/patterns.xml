<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 300101 Maintainer: jpauli Status: ready -->
<!-- Reviewed: yes -->

<sect1 xml:id="language.oop5.patterns" xmlns="http://docbook.org/ns/docbook">
 <title>Patterns</title>
 <para>
  Les patterns sont un moyen de décrire les meilleures pratiques 
  et les bonnes conceptions. Ils proposent une solution flexible aux problèmes
  habituels de programmation.
 </para>

 <sect2 xml:id="language.oop5.patterns.factory">
  <title>Usine</title>
  <para>
   Le pattern d'usine (factory) permet l'instanciation d'objets durant l'exécution.
   Il est appelé "pattern d'usine" puisqu'il est responsable de la "fabrication" 
   d'un objet. Une méthode d'usine reçoit le nom de la classe pour l'instancier en tant
   qu'argument.
  </para>
  <example>
   <title>Méthode de paramètre d'usine</title>
   <programlisting role="php">
<![CDATA[
<?php
class Exemple
{
    // La méthode d'usine
    public static function factory($type)
    {
        if (include_once 'Drivers/' . $type . '.php') {
            $classname = 'Driver_' . $type;
            return new $classname;
        } else {
            throw new Exception('Driver non trouvé');
        }
    }
}
?>
]]>
   </programlisting>
   <para>
    Définir cette méthode dans une classe permet de charger un pilote à la
    volée. Si la classe <literal>Example</literal> était une classe
    d'abstraction de base de données, le chargement des pilotes
    <literal>MySQL</literal> et <literal>SQLite</literal> pourrait être effectué
    comme ceci :
   </para>
   <programlisting role="php">
<![CDATA[
<?php
// Chargement du driver MySQL
$mysql = Exemple::factory('MySQL');

// Chargement du driver SQLite
$sqlite = Example::factory('SQLite');
?>
]]>
   </programlisting>
  </example>
 </sect2>

 <sect2 xml:id="language.oop5.patterns.singleton">
  <title>Singleton</title>
  <para>
   Le pattern singleton est utilisé dans les situations où l'on a besoin
   qu'il y ait une unique instance d'une certaine classe.
   L'exemple le plus commun est une connexion à une base de données.
   L'implémentation de ce pattern permet au développeur de rendre
   cette unique instance facilement accessible par beaucoup d'autres objets.
  </para>
  <example>
   <title>Pattern Singleton</title>
   <programlisting role="php">
<![CDATA[
<?php
class Example
{
    // instance de la classe
    private static $instance;

    // Un constructeur privé ; empêche la création directe d'objet
    private function __construct() 
    {
        echo 'Je suis construit';
    }

    // La méthode singleton
    public static function singleton() 
    {
        if (!isset(self::$instance)) {
            self::$instance = new self;
        }

        return self::$instance;
    }

    // Exemple d'une méthode
    public function bark()
    {
        echo 'Woof!';
    }

    // Prévient les utilisateurs sur le clônage de l'instance
    public function __clone()
    {
        trigger_error('Le clônage n\'est pas autorisé.', E_USER_ERROR);
    }
}

?>
]]>
   </programlisting>
   <para>
    Ceci autorise une unique instance de la classe <literal>Example</literal>.
   </para>
   <programlisting role="php">
<![CDATA[
<?php
// Ceci échoue car le constructeur est privé
$test = new Example;

// Ceci récupère toujours une seule instance de la classe
$test = Example::singleton();
$test->bark();

// Ceci provoque une erreur E_USER_ERROR.
$test_clone = clone $test;

?>
]]>
   </programlisting>
  </example>
 </sect2>

</sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->