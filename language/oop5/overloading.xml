<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.26 $ -->
<!-- EN-Revision: 1.29 Maintainer: yannick Status: ready -->
<!-- Reviewed: no -->

 <sect1 xml:id="language.oop5.overloading" xmlns="http://docbook.org/ns/docbook">
  <title>Surcharge</title>

  <para>
   La surcharge en PHP permet de créer dynamiquement des
   membres et des méthodes. Ces entités dynamiques sont
   traitées via mes méthodes magiques établies dans une
   classe pour diverses types d'actions.
  </para>

  <para>
   Les méthodes surchargées sont appelées lors de l'intéraction
   avec les membres et les méthodes qui n'ont pas été déclarés
   ou ne sont pas <link linkend="language.oop5.visibility">visibles</link>
   dans le contexte courant. Le reste de cette section utilise
   les termes de <quote>membres inaccessibles</quote> et de
   <quote>méthodes inaccessibles</quote> pour se référer à cette
   combinaison de déclaration et de visibilité.
  </para>

  <para>
   Toutes les méthodes surchargées doivent être définies comme
   <literal>public</literal>.
  </para>

  <note>
   <para>
    Aucun des arguments de ces méthodes magiques ne peut être
    <link linkend="functions.arguments.by-reference">passé par
    référence</link>.
   </para>
  </note>

  <note>
   <para>
    L'interprétation PHP de la <quote>surcharge</quote> est
    différente de la plupart des langages orientés objet.
    La surcharge, habituellement, fournit la possibilité d'avoir
    plusieurs méthodes portant le même nom mais avec une quantité
    et des types différents d'arguments.
   </para>
  </note>


  <sect2 xml:id="language.oop5.overloading.changelog">
   &reftitle.changelog;
   <para>
    <informaltable>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>&Version;</entry>
        <entry>&Description;</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>5.1.0</entry>
        <entry>
         Ajout de <literal>__isset()</literal> et de <literal>__unset()</literal>.
        </entry>
       </row>
       <row>
        <entry>5.3.0</entry>
        <entry>
         Ajout de <literal>__callStatic()</literal>.
        </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>
  </sect2>


  <sect2 xml:id="language.oop5.overloading.members">
   <title>Surcharge des membres</title>

   <methodsynopsis>
    <type>void</type><methodname>__set</methodname>
    <methodparam><type>string</type><parameter>name</parameter></methodparam>
    <methodparam><type>mixed</type><parameter>value</parameter></methodparam>
   </methodsynopsis>
   <methodsynopsis>
    <type>mixed</type><methodname>__get</methodname>
    <methodparam><type>string</type><parameter>name</parameter></methodparam>
   </methodsynopsis>
   <methodsynopsis>
    <type>bool</type><methodname>__isset</methodname>
    <methodparam><type>string</type><parameter>name</parameter></methodparam>
   </methodsynopsis>
   <methodsynopsis>
    <type>void</type><methodname>__unset</methodname>
    <methodparam><type>string</type><parameter>name</parameter></methodparam>
   </methodsynopsis>

   <para>
    <literal>__set()</literal> est exécuté lors de l'écriture de données
    vers des membres inaccessibles.
   </para>

   <para>
    <literal>__get()</literal> est utilisé pour lire des données depuis des
    membres inaccessibles.
   </para>

   <para>
    <literal>__isset()</literal> est lancé en appelant la fonction
    <function>isset</function> ou la fonction <function>empty</function>
    sur des membres inaccessibles.
   </para>

   <para>
    <literal>__unset()</literal> est appelé lorsque
    <function>unset</function> est appelé sur des membres inaccessibles.
   </para>

   <para>
    L'argument <varname>$name</varname> est le nom du membre qui interragit.
    L'argument <varname>$value</varname> de la méthode <literal>__set()</literal>
    spécifie la valeur du membre <varname>$name</varname> qui doit être définie.
   </para>

   <para>
    La surcharge des membres ne fonctionne que sur des objets du contexte.
    Ces méthodes magiques ne seront pas lancées dans un contexte statique.
    Par conséquent, ces méthodes ne peuvent être déclarées comme
    <link linkend="language.oop5.static">statiques</link>.
   </para>

   <example>
    <title>Exemple de surcharge avec with __get, __set, __isset et __unset</title>
    <programlisting role="php">
<![CDATA[
<?php
class MemberTest {
    /**  Variable pour les données surchargées.  */
    private $data = array();

    /**  La surcharge n'est pas utilisée sur les membres déclarés.  */
    public $declared = 1;

    /**  La surcharge n'est pas lancée lorsque l'on accède à la classe.  */
    private $hidden = 2;

    public function __set($name, $value) {
        echo "Définition de '$name' à la valeur '$value'\n";
        $this->data[$name] = $value;
    }

    public function __get($name) {
        echo "Récupération de '$name'\n";
        if (array_key_exists($name, $this->data)) {
            return $this->data[$name];
        }

        $trace = debug_backtrace();
        trigger_error(
            'Propriété non-définie : ' . $name .
            ' dans ' . $trace[0]['file'] .
            ' à la ligne ' . $trace[0]['line'],
            E_USER_NOTICE);
        return null;
    }

    /**  Depuis PHP 5.1.0  */
    public function __isset($name) {
        echo "Est-ce que '$name' est défini ?\n";
        return isset($this->data[$name]);
    }

    /**  Depuis PHP 5.1.0  */
    public function __unset($name) {
        echo "Effacement de '$name'\n";
        unset($this->data[$name]);
    }

    /**  Ce n'est pas une méthode magique, nécessaire ici que pour l'exemple.  */
    public function getHidden() {
        echo "'hidden' visible ici, donc __get() non utilisé\n";
        return $this->hidden;
    }
}


echo "<pre>\n";

$obj = new MemberTest;

$obj->a = 1;
echo $obj->a . "\n";

var_dump(isset($obj->a));
unset($obj->a);
var_dump(isset($obj->a));

echo $obj->declared . "\n";
echo $obj->getHidden() . "\n";
echo $obj->hidden . "\n";
?>
]]>
    </programlisting>
    &example.outputs;
    <screen role="php">
<![CDATA[
Définition de 'a' à '1'
Récupération de 'a'
1
Est-ce que 'a' est défini ?
bool(true)
Effacement de 'a'
Est-ce que 'a' est défini ?
bool(false)
1
'hidden' visible ici, donc __get() non utilisé
2
Récupération de 'hidden'


Notice:  Propriété non-définie : hidden dans <file> à la ligne 64 dans <file> à la ligne 28
]]>
    </screen>

   </example>
  </sect2>

  <sect2 xml:id="language.oop5.overloading.methods">
   <title>Surcharge de méthode</title>

   <methodsynopsis>
    <type>mixed</type><methodname>__call</methodname>
    <methodparam><type>string</type><parameter>name</parameter></methodparam>
    <methodparam><type>array</type><parameter>arguments</parameter></methodparam>
   </methodsynopsis>
   <methodsynopsis>
    <type>mixed</type><methodname>__callStatic</methodname>
    <methodparam><type>string</type><parameter>name</parameter></methodparam>
    <methodparam><type>array</type><parameter>arguments</parameter></methodparam>
   </methodsynopsis>

   <para>
    <literal>__call()</literal> est lancé lorsque l'on invoque des
    méthodes inaccessibles dans le contexte de l'objet.
   </para>

   <para>
    <literal>__callStatic()</literal> est lancé lorsque l'on invoque
    des méthodes inaccessibles dans un contexte statique.
   </para>

   <para>
    L'argument <varname>$name</varname> est le nom de la méthode appelée.
    L'argument <varname>$arguments</varname> est un tableau contenant
    les paramètres passés à la méthode <varname>$name</varname>.
   </para>

   <example>
    <title>Surcharge de méthodes instanciées avec __call et ___callStatic</title>
    <programlisting role="php">
  <![CDATA[
<?php
class MethodTest {
    public function __call($name, $arguments) {
        // Note : la valeur de $name est sensible à la casse.
        echo "Appel de la méthode '$name' "
             . implode(', ', $arguments). "\n";
    }

    /**  Depuis PHP 5.3.0  */
    public static function __callStatic($name, $arguments) {
        // Note : la valeur de $name est convertie en minuscule.
        echo "Appel de la méthode statique '$name' "
             . implode(', ', $arguments). "\n";
    }
}

$obj = new MethodTest;
$obj->runTest('dans un contexte objet');

MethodTest::runTest('dans un contexte statique');  // Depuis PHP 5.3.0
?>
]]>
    </programlisting>
    &example.outputs;
    <screen role="php">
<![CDATA[
Appel de la méthode 'runTest' dans un contexte objet
Appel de la méthode statique 'runtest' dans un contexte statique
]]>
    </screen>
   </example>

  </sect2>

 </sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
