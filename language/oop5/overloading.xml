<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 320521 Maintainer: jpauli Status: ready -->
<!-- Reviewed: yes -->

 <sect1 xml:id="language.oop5.overloading" xmlns="http://docbook.org/ns/docbook">
  <title>Surcharge magique</title>

  <para>
   La surcharge magique en PHP permet de créer dynamiquement des
   propriétés et des méthodes. Ces entités dynamiques sont
   traitées via les méthodes magiques établies dans une
   classe pour divers types d'actions.
  </para>

  <para>
   Les méthodes magiques de surcharge sont appelées lors de l'interaction
   avec les propriétés et les méthodes qui n'ont pas été déclarées
   ou ne sont pas <link linkend="language.oop5.visibility">visibles</link>
   dans le contexte courant. Le reste de cette section utilise
   les termes de <quote>propriétés inaccessibles</quote> et de
   <quote>méthodes inaccessibles</quote> pour se référer à cette
   combinaison de déclaration et de visibilité.
  </para>

  <para>
   Toutes les méthodes magiques de surcharge doivent être définies comme
   <literal>public</literal>.
  </para>

  <note>
   <para>
    Aucun des arguments de ces méthodes magiques ne peut être
    <link linkend="functions.arguments.by-reference">passé par
    référence</link>.
   </para>
  </note>

  <note>
   <para>
    L'interprétation PHP de la <quote>surcharge</quote> est
    différente de la plupart des langages orientés objet.
    La surcharge, habituellement, fournit la possibilité d'avoir
    plusieurs méthodes portant le même nom mais avec une quantité
    et des types différents d'arguments.
   </para>
  </note>


  <sect2 xml:id="language.oop5.overloading.changelog">
   &reftitle.changelog;
   <para>
    <informaltable>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>&Version;</entry>
        <entry>&Description;</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>5.3.0</entry>
        <entry>
         Ajout de <function>__callStatic</function>.
         Ajout d'un avertissement pour forcer la visibilité <literal>public</literal>
         et la déclaration non <literal>static</literal>.
        </entry>
       </row>
       <row>
        <entry>5.1.0</entry>
        <entry>
         Ajout de <function>__isset</function> et de <function>__unset</function>.
        </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>
  </sect2>


  <sect2 xml:id="language.oop5.overloading.members">
   <title>Surcharge des propriétés</title>

   <methodsynopsis>
    <type>void</type><methodname>__set</methodname>
    <methodparam><type>string</type><parameter>name</parameter></methodparam>
    <methodparam><type>mixed</type><parameter>value</parameter></methodparam>
   </methodsynopsis>
   <methodsynopsis>
    <type>mixed</type><methodname>__get</methodname>
    <methodparam><type>string</type><parameter>name</parameter></methodparam>
   </methodsynopsis>
   <methodsynopsis>
    <type>bool</type><methodname>__isset</methodname>
    <methodparam><type>string</type><parameter>name</parameter></methodparam>
   </methodsynopsis>
   <methodsynopsis>
    <type>void</type><methodname>__unset</methodname>
    <methodparam><type>string</type><parameter>name</parameter></methodparam>
   </methodsynopsis>

   <para>
    <function>__set</function> est sollicitée lors de l'écriture de données
    vers des propriétés inaccessibles.
   </para>

   <para>
    <function>__get</function> est sollicitée pour lire des données depuis des
    propriétés inaccessibles.
   </para>

   <para>
    <function>__isset</function> est sollicitée lorsque
    <function>isset</function> ou la fonction <function>empty</function>
    sont appelées avec des propriétés inaccessibles.
   </para>

   <para>
    <function>__unset()</function> est sollicitée lorsque
    <function>unset</function> est appelée avec des propriétés inaccessibles.
   </para>

   <para>
    L'argument <varname>$name</varname> est le nom du propriété qui interagit.
    L'argument <varname>$value</varname> de la méthode <function>__set</function>
    spécifie la valeur de la propriété <varname>$name</varname> qui doit être définie.
   </para>

   <para>
    La surcharge des propriétés ne fonctionne que dans les contextes objets.
    Ces méthodes magiques ne seront pas lancées dans un contexte statique.
    Par conséquent, ces méthodes ne devraient pas être déclarées comme
    <link linkend="language.oop5.static">statiques</link>. Depuis PHP 5.3.0,
    une alerte est levée si une des méthodes magiques est déclarée statique.
   </para>

   <note>
    <para>
     La valeur retournée par <function>__set</function>
     est ignorée en raison de la façon dont le processus PHP
     assigne les opérateurs. De la même façon,
     <function>__get</function> n'est jamais appelée lors
     d'un enchaînement d'assignements, comme ceci :
     <literal><![CDATA[ $a = $obj->b = 8; ]]></literal>
    </para>
   </note>
   
   <note>
    <para>
     Il n'est pas possible d'utiliser les attributs surchargés dans d'autres
     structures de langages que <function>isset</function>. Ceci signifie que
     si <function>empty</function> est appelée avec un attribut surchargé, la méthode
     de surcharge n'est pas invoquée.
    </para>
    <para>
     Pour contourner cette limitation, l'attribut surchargé doit être copié dans une
     variable locale du contexte courant puis passée à <function>empty</function>.
    </para>
   </note>

   <example>
    <title>Exemple de surcharge de propriétés avec les méthodes
     <function>__get</function>, <function>__set</function>,
     <function>__isset</function> et <function>__unset</function>
    </title>
    <programlisting role="php">
<![CDATA[
<?php
class PropertyTest
{
    /**  Variable pour les données surchargées.  */
    private $data = array();

    /**  La surcharge n'est pas utilisée sur les propriétés déclarées.  */
    public $declared = 1;

    /**  La surcharge n'est lancée que lorsque l'on accède à la classe depuis l'extérieur.  */
    private $hidden = 2;

    public function __set($name, $value)
    {
        echo "Définition de '$name' à la valeur '$value'\n";
        $this->data[$name] = $value;
    }

    public function __get($name)
    {
        echo "Récupération de '$name'\n";
        if (array_key_exists($name, $this->data)) {
            return $this->data[$name];
        }

        $trace = debug_backtrace();
        trigger_error(
            'Propriété non-définie via __get(): ' . $name .
            ' dans ' . $trace[0]['file'] .
            ' à la ligne ' . $trace[0]['line'],
            E_USER_NOTICE);
        return null;
    }

    /**  Depuis PHP 5.1.0  */
    public function __isset($name)
    {
        echo "Est-ce que '$name' est défini ?\n";
        return isset($this->data[$name]);
    }

    /**  Depuis PHP 5.1.0  */
    public function __unset($name)
    {
        echo "Effacement de '$name'\n";
        unset($this->data[$name]);
    }

    /**  Ce n'est pas une méthode magique, nécessaire ici que pour l'exemple.  */
    public function getHidden()
    {
        return $this->hidden;
    }
}


echo "<pre>\n";

$obj = new PropertyTest;

$obj->a = 1;
echo $obj->a . "\n\n";

var_dump(isset($obj->a));
unset($obj->a);
var_dump(isset($obj->a));
echo "\n";

echo $obj->declared . "\n\n";

echo "Manipulons maintenant la propriété privée nommée 'hidden':\n";
echo "'hidden' est visible depuis la classe, donc __get() n'est pas utilisée...\n";
echo $obj->getHidden() . "\n";
echo "'hidden' n'est pas visible en dehors de la classe, donc __get() est utlisée...\n";
echo $obj->hidden . "\n";
?>
]]>
    </programlisting>
    &example.outputs;
    <screen role="php">
<![CDATA[
Définition de 'a' à '1'
Récupération de 'a'
1

Est-ce que 'a' est défini ?
bool(true)
Effacement de 'a'
Est-ce que 'a' est défini ?
bool(false)

1

Manipulons maintenant la propriété privée nommée 'hidden':
'hidden' est visible depuis la classe, donc __get() n'est pas utilisée...
2
'hidden' n'est pas visible en dehors de la classe, donc __get() est utlisée...
Récupération de 'hidden'


Notice:  Propriété non-définie via __get(): hidden dans <file> à la ligne 64 dans <file> à la ligne 28
]]>
    </screen>

   </example>
  </sect2>

  <sect2 xml:id="language.oop5.overloading.methods">
   <title>Surcharge de méthodes</title>

   <methodsynopsis>
    <type>mixed</type><methodname>__call</methodname>
    <methodparam><type>string</type><parameter>name</parameter></methodparam>
    <methodparam><type>array</type><parameter>arguments</parameter></methodparam>
   </methodsynopsis>
   <methodsynopsis>
    <type>mixed</type><methodname>__callStatic</methodname>
    <methodparam><type>string</type><parameter>name</parameter></methodparam>
    <methodparam><type>array</type><parameter>arguments</parameter></methodparam>
   </methodsynopsis>

   <para>
    <function>__call</function> est lancée lorsque l'on invoque des
    méthodes inaccessibles dans le contexte de l'objet.
   </para>

   <para>
    <function>__callStatic</function> est lancée lorsque l'on invoque
    des méthodes inaccessibles dans un contexte statique.
   </para>

   <para>
    L'argument <varname>$name</varname> est le nom de la méthode appelée.
    L'argument <varname>$arguments</varname> est un tableau contenant
    les paramètres passés à la méthode <varname>$name</varname>.
   </para>

   <example>
    <title>Surcharge de méthodes avec
     <function>__call</function> et
     <function>__callStatic</function></title>
    <programlisting role="php">
  <![CDATA[
<?php
class MethodTest
{
    public function __call($name, $arguments)
    {
        // Note : la valeur de $name est sensible à la casse.
        echo "Appel de la méthode '$name' "
             . implode(', ', $arguments). "\n";
    }

    /**  Depuis PHP 5.3.0  */
    public static function __callStatic($name, $arguments)
    {
        // Note : la valeur de $name est sensible à la casse.
        echo "Appel de la méthode statique '$name' "
             . implode(', ', $arguments). "\n";
    }
}

$obj = new MethodTest;
$obj->runTest('dans un contexte objet');

MethodTest::runTest('dans un contexte static');  // Depuis PHP 5.3.0
?>
]]>
    </programlisting>
    &example.outputs;
    <screen role="php">
<![CDATA[
Appel de la méthode 'runTest' dans un contexte objet
Appel de la méthode statique 'runTest' dans un contexte static
]]>
    </screen>
   </example>

  </sect2>

 </sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
