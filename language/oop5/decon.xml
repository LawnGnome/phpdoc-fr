<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 301474 Maintainer: jpauli Status: ready -->
<!-- Reviewed: yes -->

 <sect1 xml:id="language.oop5.decon" xmlns="http://docbook.org/ns/docbook">
  <title>Constructeurs et destructeurs</title>

  <sect2 xml:id="language.oop5.decon.constructor">
   <title>Constructeurs</title>
   <methodsynopsis>
    <type>void</type><methodname>__construct</methodname>
    <methodparam choice="opt"><type>mixed</type><parameter>args</parameter></methodparam>
    <methodparam choice="opt"><parameter>...</parameter></methodparam>
   </methodsynopsis>
   <para>
    PHP permet aux développeurs de déclarer des constructeurs pour
    les classes. Les classes qui possèdent une méthode constructeur
    appellent cette méthode à chaque création d'une nouvelle instance
    de l'objet, ce qui est intéressant pour toutes les initialisations
    dont l'objet a besoin avant d'être utilisé.
   </para>
   <note>
    <simpara>
     Les constructeurs parents ne sont pas appelés implicitement
     si la classe enfant définie un constructeur. Si vous
     voulez utiliser un constructeur parent, il sera nécessaire de faire
     appel à <literal>parent::__construct()</literal>.
    </simpara>
   </note>
   <example>
    <title>Exemple d'utilisation des nouveaux constructeurs unifiés</title>
    <programlisting role="php">
<![CDATA[
<?php
class BaseClass {
    function __construct() {
        print "In BaseClass constructor\n";
    }
}

class SubClass extends BaseClass {
    function __construct() {
        parent::__construct();
        print "In SubClass constructor\n";
    }
}

$obj = new BaseClass();
$obj = new SubClass();
?>
]]>
    </programlisting>
   </example>
   <para>
    Pour des raisons de compatibilité ascendante, si PHP ne peut pas
    trouver une fonction <literal>__construct()</literal> pour une classe
    donnée, il cherchera une fonction constructeur représentée, comme dans
    l'ancien style (PHP &lt; 5), par le nom de la classe.
    Effectivement, cela signifie que le seul cas où il pourrait y avoir
    un problème de compatibilité est celui où votre classe contiendrait une
    méthode nommée <literal>__construct()</literal> et que vous en ayez un
    autre usage.
   </para>
   <para>
    A la différence des autres méthodes, PHP ne génèrera pas d'erreur de niveau
    <constant>E_STRICT</constant> lorsque <function>__construct</function> est
    surchargé avec des paramètres différents du constructeur parent.
   </para>
   <para>
    Depuis PHP 5.3.3, les méthodes ayant le même nom que la classe dans laquelle
    elle se trouve ne sont plus traitées comme des constructeur, si la classe
    considérée se situe dans un espace de noms. Ceci n'affecte pas les classes
    sans espace de noms.
   </para>
   <example>
    <title>Constructeurs dans les classes dans des espaces de noms</title>
    <programlisting role="php">
<![CDATA[
<?php
namespace Foo;
class Bar {
    public function Bar() {
        // Traitée comme un constructeur dans PHP 5.3.0-5.3.2
        // Traitée comme une méthode normale depuis PHP 5.3.3
    }
}
?>
]]>
    </programlisting>
   </example>
  </sect2>

  <sect2 xml:id="language.oop5.decon.destructor">
   <title>Destructeurs</title>
   <methodsynopsis>
    <type>void</type><methodname>__destruct</methodname>
    <void />
   </methodsynopsis>
   <para>
    PHP 5 introduit un concept de destructeur similaire aux autres langages
    orientés objet, comme le <literal>C++</literal>. La méthode destructeur est appelée
    aussitôt que toutes les références à un objet particulier sont effacées ou lorsque
    l'objet est explicitement détruit ou dans n'importe quel ordre de la séquence d'arrêt.
   </para>
   <example>
    <title>Exemple avec un Destructeur</title>
    <programlisting role="php">
<![CDATA[
<?php
class MyDestructableClass {
    function __construct() {
        print "In constructor\n";
        $this->name = "MyDestructableClass";
    }

    function __destruct() {
        print "Destruction de " . $this->name . "\n";
    }
}

$obj = new MyDestructableClass();
?>
]]>
    </programlisting>
   </example>
   <para>
    Tout comme le constructeur, le destructeur parent n'est pas appelé
    implicitement par le moteur. Pour exécuter le destructeur parent, vous
    devez appeler explicitement la fonction
    <literal>parent::__destruct</literal> dans le corps du destructeur.
   </para>
   <para>
    Le destructeur sera appelé même si l'exécution du script est stoppé
    en utilisant la fonction <function>exit</function>. Appeler la fonction
    <function>exit</function> dans un destructeur permettra de ne pas
    exécuter les autres routines d'arrêt.
   </para>
   <note>
    <para>
     Les destructeurs appelées durant l'arrêt du script ont déjà envoyés
     les en-têtes HTTP. Le dossier de travail dans la phase du script d'arrêt
     peut être différent avec d'autres APIs (e.g. Apache).
    </para>
   </note>
   <note>
    <para>
     Tenter de lancer une exception depuis un destructeur (appelé à la fin du script)
     émet une erreur fatale.
    </para>
   </note>
  </sect2>
 </sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->