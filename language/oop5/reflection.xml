<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.31 $ -->
<!-- EN-Revision: 1.34 Maintainer: yannick Status: ready -->
<!-- Reviewed: yes -->

 <sect1 xml:id="language.oop5.reflection" xmlns="http://docbook.org/ns/docbook">
  <title>Réflexion</title>
  <sect2 xml:id="language.oop5.reflection.toc">
   <title>Sommaire</title>
   <simplelist>
    <member><link linkend="language.oop5.reflection.introduction">Introduction</link></member>
    <member><link linkend="language.oop5.reflection.reflector">L'interface de réflection</link></member>
    <member><link linkend="language.oop5.reflection.reflectionexception">La classe ReflectionException</link></member>
    <member><link linkend="language.oop5.reflection.reflectionfunction">La classe ReflectionFunction</link></member>
    <member><link linkend="language.oop5.reflection.reflectionparameter">La classe ReflectionParameter</link></member>
    <member><link linkend="language.oop5.reflection.reflectionclass">La classe ReflectionClass</link></member>
    <member><link linkend="language.oop5.reflection.reflectionobject">La classe ReflectionObject</link></member>
    <member><link linkend="language.oop5.reflection.reflectionmethod">La classe ReflectionMethod</link></member>
    <member><link linkend="language.oop5.reflection.reflectionproperty">La classe ReflectionProperty</link></member>
    <member><link linkend="language.oop5.reflection.reflectionextension">La classe ReflectionExtension</link></member>
    <member><link linkend="language.oop5.reflection.extending">Étendre les classes de réflection</link></member>
   </simplelist>
  </sect2>
  <sect2 xml:id="language.oop5.reflection.introduction">
   &reftitle.intro;
   <para>
    &php; 5 introduit API de réflexion complète qui permet de faire du
    <literal>reverse-engineering</literal> sur les classes, les interfaces,
    les fonctions et les méthodes tout comme les extensions. L'API de
    réflexion permet également d'obtenir les commentaires de la documentation
    pour les fonctions, les classes et les méthodes.
   </para>
   <para>
    L'API de réflexion est une extension orientée objet du Moteur Zend,
    constituée des classes suivantes :
   </para>
   <example>
    <title>API de réflexion</title>
    <programlisting role="php">
<![CDATA[
<?php
class Reflection { }
interface Reflector { }
class ReflectionException extends Exception { }
class ReflectionFunction extends ReflectionFunctionAbstract implements Reflector { }
class ReflectionParameter implements Reflector { }
class ReflectionMethod extends ReflectionFunctionAbstract implements Reflector { }
class ReflectionClass implements Reflector { }
class ReflectionObject extends ReflectionClass { }
class ReflectionProperty implements Reflector { }
class ReflectionExtension implements Reflector { }
?>
]]>
    </programlisting>
   </example>
   <note>
    <simpara>
     Pour plus de détails sur ces classes, lisez les chapitres suivants.
    </simpara>
   </note>
   <para>
    Si nous exécutons le code de l'exemple ci-dessous :
    <example>
     <title>Utilisation basique de l'API de réflexion</title>
     <programlisting role='php'>
<![CDATA[
<?php
Reflection::export(new ReflectionClass('Exception'));
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Class [ <internal> class Exception ] {

  - Constants [0] {
  }

  - Static properties [0] {
  }

  - Static methods [0] {
  }

  - Properties [6] {
    Property [ <default> protected $message ]
    Property [ <default> private $string ]
    Property [ <default> protected $code ]
    Property [ <default> protected $file ]
    Property [ <default> protected $line ]
    Property [ <default> private $trace ]
  }

  - Methods [9] {
    Method [ <internal> final private method __clone ] {
    }


    Method [ <internal, ctor> public method __construct ] {

      - Parameters [2] {
        Parameter #0 [ <optional> $message ]
        Parameter #1 [ <optional> $code ]
      }
    }

    Method [ <internal> final public method getMessage ] {
    }

    Method [ <internal> final public method getCode ] {
    }

    Method [ <internal> final public method getFile ] {
    }

    Method [ <internal> final public method getLine ] {
    }

    Method [ <internal> final public method getTrace ] {
    }

    Method [ <internal> final public method getTraceAsString ] {
    }

    Method [ <internal> public method __toString ] {
    }
  }
}
]]>
     </screen>
    </example>
   </para>
  </sect2>

  <sect2 xml:id="language.oop5.reflection.reflector">
   <title><classname>Reflector</classname></title>
   <para>
    <classname>Reflector</classname> est une interface implémentée
    par toutes les classes exportables de réflection.
   </para>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
interface Reflector
{
    public string __toString()
    public static string export()
}
?>
]]>
    </programlisting>
   </informalexample>
  </sect2>

  <sect2 xml:id="language.oop5.reflection.reflectionexception">
   <title><classname>ReflectionException</classname></title>
   <para>
    <classname>ReflectionException</classname> étend le standard
    <link linkend="language.exceptions">Exception</link> et est lancé
    par l'API Reflection. Aucune méthode spécifique ni de propriété
    ne sont introduites.
   </para>
  </sect2>

  <sect2 xml:id="language.oop5.reflection.reflectionfunction">
   <title><classname>ReflectionFunction</classname></title>
   <para>
    La classe <classname>ReflectionFunction</classname> vous permet de faire
    du <literal>reverse-engineering</literal> sur les fonctions.
   </para>
   <example>
   <title>La classe <classname>ReflectionFunction</classname></title>
    <programlisting role="php">
<![CDATA[
<?php
class ReflectionFunction extends ReflectionFunctionAbstract implements Reflector
{
    final private __clone()
    public void __construct(string name)
    public string __toString()
    public static string export(string name, bool return)
    public string getName()
    public bool isInternal()
    public bool isDisabled()
    public bool isUserDefined()
    public string getFileName()
    public int getStartLine()
    public int getEndLine()
    public string getDocComment()
    public array getStaticVariables()
    public mixed invoke([mixed args [, ...]])
    public mixed invokeArgs(array args)
    public bool returnsReference()
    public ReflectionParameter[] getParameters()
    public int getNumberOfParameters()
    public int getNumberOfRequiredParameters()
}
?>
]]>
    </programlisting>
   </example>
   <para>
    La classe parent <classname>ReflectionFunctionAbstract</classname> a les mêmes méthodes,
    exceptée <function>invoke</function>, <function>invokeArgs</function>,
    <function>export</function> et <function>isDisabled</function>.
   </para>
   <note>
    <simpara>
     <function>getNumberOfParameters</function> et
     <function>getNumberOfRequiredParameters</function> ont été ajoutés en &php;
     5.0.3, tandis que <function>invokeArgs</function> a été ajouté en &php; 5.1.0.
    </simpara>
   </note>
   <para>
    Pour connaître le fonctionnement d'une fonction, vous devez tout d'abord
    créer une instance de la classe <classname>ReflectionFunction</classname>.
    Ainsi, vous pouvez appeler n'importe quelle méthode de cette instance.
   </para>
   <example>
    <title>Utilisation de la classe <classname>ReflectionFunction</classname></title>
    <programlisting role='php'>
<![CDATA[
<?php
/**
 * Un simple compteur
 *
 * @return    int
 */
function counter()
{
    static $c = 0;

    return $c++;
}

// Création d'une instance de la classe ReflectionFunction
$func = new ReflectionFunction('counter');

// Affichage d'informations basiques
printf(
    "===> The %s function '%s'\n".
    "     declared in %s\n".
    "     lines %d to %d\n",
    $func->isInternal() ? 'internal' : 'user-defined',
    $func->getName(),
    $func->getFileName(),
    $func->getStartLine(),
    $func->getEndline()
);

// Affichage du commentaire de la documentation
printf("---> Documentation:\n %s\n", var_export($func->getDocComment(), 1));

// Affichage des variables statiques si elles existent
if ($statics = $func->getStaticVariables())
{
    printf("---> Variables statiques : %s\n", var_export($statics, 1));
}

// Appel de la fonction
printf("---> Invocation des résultats dans : ");
var_dump($func->invoke());


// vous pouvez préférer utiliser la méthode export()
echo "\nRésultat de ReflectionFunction::export() :\n";
echo ReflectionFunction::export('counter');
?>
]]>
    </programlisting>
   </example>
   <note>
    <simpara>
     La méthode <function>invoke</function> accepte un nombre variable
     d'arguments, tout comme la fonction
     <function>call_user_func</function>.
    </simpara>
   </note>
  </sect2>

  <sect2 xml:id="language.oop5.reflection.reflectionparameter">
   <title><classname>ReflectionParameter</classname></title>
   <para>
    La classe <classname>ReflectionParameter</classname> récupère les
    informations concernant les paramètres des fonctions ou des méthodes.
   </para>
   <example>
    <title>La classe <classname>ReflectionParameter</classname></title>
    <programlisting role="php">
<![CDATA[
<?php
class ReflectionParameter implements Reflector
{
    final private __clone()
    public object __construct(string function, string parameter)
    public string __toString()
    public static string export(mixed function, mixed parameter, bool return)
    public string getName()
    public bool isPassedByReference()
    public ReflectionClass getDeclaringClass()
    public ReflectionClass getClass()
    public bool isArray()
    public bool allowsNull()
    public bool isPassedByReference()
    public bool isOptional()
    public bool isDefaultValueAvailable()
    public mixed getDefaultValue()
}
?>
]]>
    </programlisting>
   </example>
   <note>
    <para>
     <function>getDefaultValue</function>,
     <function>isDefaultValueAvailable</function> et
     <function>isOptional</function> ont été ajoutés en &php; 5.0.3,
     tandis que <function>isArray</function> a été ajoutée en &php; 5.1.0.
     <function>getDeclaringFunction</function> et
     <function>getPosition</function> ont été ajoutés en &php; 5.2.3.
    </para>
   </note>
   <para>
    Pour connaître le fonctionnement des paramètres d'une fonction, vous
    devez tout d'abord créer une instance de la classe
    <classname>ReflectionFunction</classname> ou
    <classname>ReflectionMethod</classname> et, ainsi, utiliser leurs méthodes
    <function>getparameters</function> pour récupérer un tableau de paramètres.
   </para>
   <example>
    <title>Utilisation de la classe <classname>ReflectionParameter</classname></title>
    <programlisting role='php'>
<![CDATA[
<?php
function foo($a, $b, $c) { }
function bar(Exception $a, &$b, $c) { }
function baz(ReflectionFunction $a, $b = 1, $c = null) { }
function abc() { }

// Création d'une instance de la classe ReflectionFunction avec le
// paramètre fourni en ligne de commande.
$reflect = new ReflectionFunction($argv[1]);

echo $reflect;

foreach ($reflect->getParameters() as $i => $param) {
    printf(
        "-- Paramètre #%d : %s {\n".
        "   Classe : %s\n".
        "   Autorise NULL : %s\n".
        "   Passé par référence : %s\n".
        "   Est optionnel ?: %s\n".
        "}\n",
        $i,
        $param->getName(),
        var_export($param->getClass(), 1),
        var_export($param->allowsNull(), 1),
        var_export($param->isPassedByReference(), 1),
        $param->isOptional() ? 'oui' : 'non'
    );
}
?>
]]>
    </programlisting>
   </example>
  </sect2>

  <sect2 xml:id="language.oop5.reflection.reflectionclass">
   <title><classname>ReflectionClass</classname></title>
   <para>
    La classe <classname>ReflectionClass</classname> vous permet
    de faire du <literal>reverse-engineering</literal> sur des classes
    et des interfaces.
   </para>
   <example>
    <title>La classe <classname>ReflectionClass</classname></title>
    <programlisting role="php">
<![CDATA[
<?php
class ReflectionClass implements Reflector
{
    final private __clone()
    public object __construct(string name)
    public string __toString()
    public static string export(mixed class, bool return)
    public string getName()
    public bool isInternal()
    public bool isUserDefined()
    public bool isInstantiable()
    public bool hasConstant(string name)
    public bool hasMethod(string name)
    public bool hasProperty(string name)
    public string getFileName()
    public int getStartLine()
    public int getEndLine()
    public string getDocComment()
    public ReflectionMethod getConstructor()
    public ReflectionMethod getMethod(string name)
    public ReflectionMethod[] getMethods()
    public ReflectionProperty getProperty(string name)
    public ReflectionProperty[] getProperties()
    public array getConstants()
    public mixed getConstant(string name)
    public ReflectionClass[] getInterfaces()
    public bool isInterface()
    public bool isAbstract()
    public bool isFinal()
    public int getModifiers()
    public bool isInstance(stdclass object)
    public stdclass newInstance(mixed args)
    public stdclass newInstanceArgs(array args)
    public ReflectionClass getParentClass()
    public bool isSubclassOf(ReflectionClass class)
    public array getStaticProperties()
    public mixed getStaticPropertyValue(string name [, mixed default])
    public void setStaticPropertyValue(string name, mixed value)
    public array getDefaultProperties()
    public bool isIterateable()
    public bool implementsInterface(string name)
    public ReflectionExtension getExtension()
    public string getExtensionName()
}
?>
]]>
    </programlisting>
   </example>
   <note>
    <simpara>
     <function>hasConstant</function>, <function>hasMethod</function>,
     <function>hasProperty</function>, <function>getStaticPropertyValue</function>
     et <function>setStaticPropertyValue</function> ont été ajoutées en &php;
     5.1.0, tandis que <function>newInstanceArgs</function> a été ajoutée dans
     &php; 5.1.3.
    </simpara>
   </note>
   <para>
    Pour connaître le fonctionnement d'une classe, vous devez d'abord créer
    une instance de la classe <classname>ReflectionClass</classname>. Vous
    pourrez donc appeler n'importe quelle méthode sur cette instance.
   </para>
   <example>
    <title>Utilisation de la classe <classname>ReflectionClass</classname></title>
    <programlisting role='php'>
<![CDATA[
<?php
interface Linearisable
{
    // ...
}

class Object
{
    // ...
}

/**
 * Une classe compteur
 *
 */
class Compteur extends Object implements Linearisable
{
    const START = 0;
    private static $c = Compteur::START;

    /**
     * Invocation du compteur
     *
     * @access  public
     * @return  int
     */
    public function count()
    {
        return self::$c++;
    }
}

// Création d'une instance de la classe ReflectionClass
$class = new ReflectionClass('Compteur');

// Affichage d'informations basiques
printf(
    "===> La %s%s%s %s '%s' [extension de %s]\n".
    "     déclarée dans %s\n".
    "     lignes %d à %d\n".
    "     a le modificateur %d [%s]\n",
    $class->isInternal() ? 'internal' : 'user-defined',
    $class->isAbstract() ? ' abstract' : '',
    $class->isFinal() ? ' final' : '',
    $class->isInterface() ? 'interface' : 'class',
    $class->getName(),
    var_export($class->getParentClass(), 1),
    $class->getFileName(),
    $class->getStartLine(),
    $class->getEndline(),
    $class->getModifiers(),
    implode(' ', Reflection::getModifierNames($class->getModifiers()))
);

// Affichage du commentaire de la documentation
printf("---> Documentation:\n %s\n", var_export($class->getDocComment(), 1));

// Affichage de l'interface qui implémente cette classe
printf("---> Implémenté :\n %s\n", var_export($class->getInterfaces(), 1));

// Affichage des constantes de la classe
printf("---> Constantes : %s\n", var_export($class->getConstants(), 1));

// Affichage des propriétés de la classe
printf("---> Properties: %s\n", var_export($class->getProperties(), 1));

// Affichage des méthodes de la classe
printf("---> Méthodes : %s\n", var_export($class->getMethods(), 1));

// Si cette classe est instanciable, création d'une instance
if ($class->isInstantiable()) {
    $counter = $class->newInstance();

    echo '---> $counter est uneinstance ? ';
    echo $class->isInstance($counter) ? 'oui' : 'non';

    echo "\n---> Le nouvel objet Object() est une instance ? ";
    echo $class->isInstance(new Object()) ? 'oui' : 'non';
}
?>
]]>
    </programlisting>
   </example>
   <note>
    <simpara>
     La méthode <function>newinstance</function> accepte un nombre variable
     d'arguments, tout comme la fonction
     <function>call_user_func</function>.
    </simpara>
   </note>
   <note>
    <simpara>
     <literal>$class = new ReflectionClass('Foo');
     $class-&gt;isInstance($arg)</literal>
     est équivalent à <literal>$arg instanceof Foo</literal> ou
     <literal>is_a($arg, 'Foo')</literal>.
    </simpara>
   </note>
  </sect2>

  <sect2 xml:id="language.oop5.reflection.reflectionobject">
   <title><classname>ReflectionObject</classname></title>
   <para>
    La classe <classname>ReflectionObject</classname> vous permet
    de retrouver les objets.
   </para>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class ReflectionObject extends ReflectionClass
{
    final private __clone()
    public object __construct(mixed object)
    public string __toString()
    public static string export(mixed object, bool return)
}
?>
]]>
    </programlisting>
   </informalexample>
  </sect2>

  <sect2 xml:id="language.oop5.reflection.reflectionmethod">
   <title><classname>ReflectionMethod</classname></title>
   <para>
    La classe <classname>ReflectionMethod</classname> vous permet de faire du
    <literal>reverse-engineering</literal> sur les méthodes des classes.
   </para>
   <example>
   <title>La classe <classname>ReflectionMethod</classname></title>
    <programlisting role="php">
<![CDATA[
<?php
class ReflectionMethod extends ReflectionFunctionAbstract implements Reflector
{
    public __construct(mixed class, string name)
    public string __toString()
    public static string export(mixed class, string name, bool return)
    public mixed invoke(stdclass object [, mixed args [, ...]])
    public mixed invokeArgs(stdclass object, array args)
    public bool isFinal()
    public bool isAbstract()
    public bool isPublic()
    public bool isPrivate()
    public bool isProtected()
    public bool isStatic()
    public bool isConstructor()
    public bool isDestructor()
    public int getModifiers()
    public ReflectionClass getDeclaringClass()

    // Inherited from ReflectionFunctionAbstract
    final private __clone()
    public string getName()
    public bool isInternal()
    public bool isUserDefined()
    public string getFileName()
    public int getStartLine()
    public int getEndLine()
    public string getDocComment()
    public array getStaticVariables()
    public bool returnsReference()
    public ReflectionParameter[] getParameters()
    public int getNumberOfParameters()
    public int getNumberOfRequiredParameters()
}
?>
]]>
    </programlisting>
   </example>
   <para>
    Pour connaître le fonctionnement d'une méthode, vous devez d'abord créer
    une instance de la classe <classname>ReflectionMethod</classname>. Vous
    pourrez ainsi appeler n'importe quelle méthode de cette instance.
   </para>
   <example>
    <title>
     Utilisation de la classe <classname>ReflectionMethod</classname>
    </title>
    <programlisting role='php'>
<![CDATA[
<?php
class Compteur
{
    private static $c = 0;

    /**
     * Incrémentation d'un compteur
     *
     * @final
     * @static
     * @access  public
     * @return  int
     */
    final public static function increment()
    {
        return self::$c;
    }
}

// Création d'une instance de la classe ReflectionMethod
$method = new ReflectionMethod('Compteur', 'increment');

// Affichage d'informations basiques
printf(
    "===> La méthode %s%s%s%s%s%s%s '%s' (qui est %s)\n".
    "     déclaré dans %s\n".
    "     lignes %d à %d\n".
    "     a les modificateurs %d[%s]\n",
    $method->isInternal() ? 'internal' : 'user-defined',
    $method->isAbstract() ? ' abstract' : '',
    $method->isFinal() ? ' final' : '',
    $method->isPublic() ? ' public' : '',
    $method->isPrivate() ? ' private' : '',
    $method->isProtected() ? ' protected' : '',
    $method->isStatic() ? ' static' : '',
    $method->getName(),
    $method->isConstructor() ? 'the constructor' : 'a regular method',
    $method->getFileName(),
    $method->getStartLine(),
    $method->getEndline(),
    $method->getModifiers(),
    implode(' ', Reflection::getModifierNames($method->getModifiers()))
  );

// Affichage du commentaire de la documentation
printf("---> Documentation:\n %s\n", var_export($method->getDocComment(), 1));

// Affichage des variables statiques si elles existent
if ($statics= $method->getStaticVariables()) {
    printf("---> Variales statiques : %s\n", var_export($statics, 1));
}

// Invocation de la méthode
printf("---> Résultat de l'invocation dans : ");
var_dump($method->invoke(NULL));
?>
]]>
    </programlisting>
   </example>
   <note>
    <simpara>
     Invoquer des méthodes privées, protégées ou abstraites provoquera
     une exception jetée par la méthode <function>invoke</function>.
    </simpara>
   </note>
   <note>
    <simpara>
     Pour les méthodes statiques comme vu précédemment, vous devez passer
     &null; comme premier argument à la fonction <function>invoke</function>.
     Pour les méthodes non-statiques, passez une instance de la classe.
    </simpara>
   </note>
  </sect2>

  <sect2 xml:id="language.oop5.reflection.reflectionproperty">
   <title><classname>ReflectionProperty</classname></title>
   <para>
    La classe <classname>ReflectionProperty</classname> vous permet
    de faire du <literal>reverse-engineering</literal> sur les propriétés des
    classes.
   </para>
   <example>
    <title>La classe <classname>ReflectionProperty</classname></title>
    <programlisting role="php">
<![CDATA[
<?php
class ReflectionProperty implements Reflector
{
    final private __clone()
    public __construct(mixed class, string name)
    public string __toString()
    public static string export(mixed class, string name, bool return)
    public string getName()
    public bool isPublic()
    public bool isPrivate()
    public bool isProtected()
    public bool isStatic()
    public bool isDefault()
    public int getModifiers()
    public mixed getValue(stdclass object)
    public void setValue(stdclass object, mixed value)
    public ReflectionClass getDeclaringClass()
    public string getDocComment()
}
?>
]]>
    </programlisting>
   </example>
   <note>
    <simpara>
     <function>getDocComment</function> a été ajouté en &php; 5.1.0.
    </simpara>
   </note>
   <para>
    Pour connaître le fonctionnement d'une propriété, vous devez d'abord créer
    une instance de la classe <classname>ReflectionProperty</classname>. Vous
    pourrez ainsi appeler n'importe quelle méthode de cette instance.
   </para>
   <example>
    <title>
     Utilisation de la classe <classname>ReflectionProperty</classname>
    </title>
    <programlisting role='php'>
<![CDATA[
<?php
class Chaine
{
    public $length  = 5;
}

// Création d'une instance de la classe ReflectionProperty
$prop = new ReflectionProperty('Chaine', 'length');

// Affichage d'informations basiques
printf(
    "===> Les propriétés %s%s%s%s '%s' (qui a %s)\n".
    "     a les modificateurs %s\n",
    $prop->isPublic() ? ' public' : '',
    $prop->isPrivate() ? ' private' : '',
    $prop->isProtected() ? ' protected' : '',
    $prop->isStatic() ? ' static' : '',
    $prop->getName(),
    $prop->isDefault() ? 'déclaré au moment de la compilation' : 'créé au moment de l\'exécution',
    var_export(Reflection::getModifierNames($prop->getModifiers()), 1)
);

// Création d'une instance de Chaine
$obj= new Chaine();

// Récupération de la valeur courante
printf("---> La veleur est : ");
var_dump($prop->getValue($obj));

// Modification de la valeur
$prop->setValue($obj, 10);
printf("---> Définition de la valeur à 10, la nouvelle valeur est : ");
var_dump($prop->getValue($obj));

// Affichage de l'objet
var_dump($obj);
?>
]]>
    </programlisting>
   </example>
   <note>
    <simpara>
     Essayer de récupérer ou de définir les valeurs des propriétés d'une classe
     privée ou protégée produira une exception.
    </simpara>
   </note>
  </sect2>

  <sect2 xml:id="language.oop5.reflection.reflectionextension">
   <title><classname>ReflectionExtension</classname></title>
   <para>
    La classe <classname>ReflectionExtension</classname> vous permet de faire du
    <literal>reverse-engineering</literal> sur les extensions. Vous pouvez
    connaître toutes les extensions chargées à l'exécution en utilisation la
    fonction <function>get_loaded_extensions</function>.
   </para>
   <example>
    <title>La classe <classname>ReflectionExtension</classname></title>
    <programlisting role="php">
<![CDATA[
<?php
class ReflectionExtension implements Reflector
{
    final private __clone()
    public __construct(string name)
    public string __toString()
    public static string export(string name, bool return)
    public string getName()
    public string getVersion()
    public ReflectionFunction[] getFunctions()
    public array getConstants()
    public array getINIEntries()
    public ReflectionClass[] getClasses()
    public array getClassNames()
    public string info()
}
?>
]]>
    </programlisting>
   </example>
   <para>
    Pour connaître le fonctionnement d'une extension, vous devez d'abord créer
    une instance de la classe <classname>ReflectionExtension</classname>. Vous
    pourrez ainsi appeler n'importe quelle méthode sur cette instance.
   </para>
   <example>
    <title>Utilisation de la classe <classname>ReflectionExtension</classname></title>
    <programlisting role='php'>
<![CDATA[
<?php
// Création d'une instance de la classe ReflectionProperty
$ext = new ReflectionExtension('standard');

// Affichage d'informations basiques
printf(
    "Nom        : %s\n".
    "Version     : %s\n".
    "Fonctions   : [%d] %s\n".
    "Entrées INI : [%d] %s\n" .
    "Classes     : [%d] %s\n",
        $ext->getName(),
        $ext->getVersion() ? $ext->getVersion() : 'NO_VERSION',
        sizeof($ext->getFunctions()),
        var_export($ext->getFunctions(), 1),

        sizeof($ext->getConstants()),
        var_export($ext->getConstants(), 1),

        sizeof($ext->getINIEntries()),
        var_export($ext->getINIEntries(), 1),

        sizeof($ext->getClassNames()),
        var_export($ext->getClassNames(), 1)
);
?>
]]>
    </programlisting>
   </example>
  </sect2>

  <sect2 xml:id="language.oop5.reflection.extending">
   <title>Extension des classes de réflexion</title>
   <para>
    Dans le cas où vous voudriez créer des versions spéciales des classes
    embarquées (par exemple pour créer du HTML colorisé lorsqu'il est exporté,
    pour avoir un accès facile aux variables des membres au lieu des méthodes ou
    pour avoir des méthodes utiles), vous devez étendre la classe.
   </para>
   <example>
    <title>Extension des classes embarquées</title>
    <programlisting role='php'>
<![CDATA[
<?php
/**
 * Ma classe Reflection_Method
 *
 */
class My_Reflection_Method extends ReflectionMethod
{
  public $visibility = array();

  public function __construct($o, $m)
  {
    parent::__construct($o, $m);
    $this->visibility = Reflection::getModifierNames($this->getModifiers());
  }
}

/**
 * Démo classe #1
 *
 */
class T {
  protected function x() {}
}

/**
 * Démo classe #2
 *
 */
class U extends T {
  function x() {}
}

// Affichage des informations
var_dump(new My_Reflection_Method('U', 'x'));
?>
]]>
    </programlisting>
   </example>
   <note>
    <simpara>
     <emphasis>Attention</emphasis> : si vous écrasez le constructeur, n'oubliez
     pas d'appeler le constructeur parent <emphasis>avant</emphasis> d'insérer
     le moindre code. Sinon, votre code produira l'erreur suivante :
     <literal>
      Fatal error: Internal error: Failed to retrieve the reflection object
     </literal>
    </simpara>
   </note>
  </sect2>
 </sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->