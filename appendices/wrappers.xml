<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.6 $ -->
<!-- EN-Revision: 1.1 Maintainer: nobody Status: partial -->
<appendix id="wrappers">
 <title>Liste des protocoles supportés</title>
 <para>
  Cette section recense une liste de protocolesw gérant les URL,
  qui sont intégrés dans les fonctions d'accès aux fichiers,
  dans &php;. Par exemple, les fonctions 
  <function>fopen</function> et <function>copy</function>.
  Ces fonctionnalités sont compilées comme des gestionnaires externes,
  et à partir de &php; 4.3.0, vous pouvez créer vos propres
  gestionnaires, avec la fonction <function>stream_register_wrapper</function>.
 </para>

 <section id="wrappers.file">
  <title>Système de fichiers</title>
  <simpara>
   Toutes les versions de &php;
   Explicitement avec le protocole <filename>file://</filename> depuis &php; 4.3.0.
  </simpara>

  <itemizedlist>
   <listitem><simpara><filename>/path/to/file.ext</filename></simpara></listitem>
   <listitem><simpara><filename>relative/path/to/file.ext</filename></simpara></listitem>
   <listitem><simpara><filename>fileInCwd.ext</filename></simpara></listitem>
   <listitem><simpara><filename>C:/path/to/winfile.ext</filename></simpara></listitem>
   <listitem><simpara><filename>C:\path\to\winfile.ext</filename></simpara></listitem>
   <listitem><simpara><filename>\\smbserver\share\path\to\winfile.ext</filename></simpara></listitem>
   <listitem><simpara><filename>file:///path/to/file.ext</filename></simpara></listitem>
  </itemizedlist>

  <simpara>
   <filename>file://</filename> est le gestionnaire par défaut de &php; 
   et il représente les fichiers locaux. Lorsqu'un chemin relatif eest
   spécifié (un chemin qui ne commence pas par /, \, \\, ou une lettre de 
   lecteur Windows), le chemin sera calculé relativement à la position courante.
   Dans de nombreux cas, c'est le dossier de résidence du script, à moins qu'il
   n'ait été modifié. En utilisant la version CLI, le chemin sera calculé
   par rapport au dossier d'appel du script.
  </simpara>

  <simpara>
   Avec certaines fonctions comme <function>fopen</function> et
   <function>file_get_contents</function>,
   <literal>include_path</literal> peut être scanné pour y trouver les
   fichiers, si un chemin relatif est fourni.
  </simpara>

  <para>
   <table>
    <title>Liste des gestionnaires</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Attribut</entry>
       <entry>Supporté</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>Restreint par <literal>allow_url_fopen</literal>.</entry>
       <entry>Non</entry>
      </row>
      <row>
       <entry>Autorise les lectures</entry>
       <entry>Oui</entry>
      </row>
      <row>
       <entry>Autorise les écritures</entry>
       <entry>Oui</entry>
      </row>
      <row>
       <entry>Autorise l'ajout</entry>
       <entry>Oui</entry>
      </row>
      <row>
       <entry>Autorise simultanément les lectures et écritures</entry>
       <entry>Oui</entry>
      </row>
      <row>
       <entry>Supporte <function>stat</function></entry>
       <entry>Oui</entry>
      </row>
      <row>
       <entry>Supporte <function>unlink</function></entry>
       <entry>Oui</entry>
      </row>
      <row>
       <entry>Supporte <function>rename</function></entry>
       <entry>Oui</entry>
      </row>
      <row>
       <entry>Supporte <function>mkdir</function></entry>
       <entry>Oui</entry>
      </row>
      <row>
       <entry>Supporte <function>rmdir</function></entry>
       <entry>Oui</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </para>
 </section>

 <section id="wrappers.http">
  <title>HTTP et HTTPS</title>
   <simpara>&php; 3, &php; 4. <filename>https://</filename> depuis &php; 4.3</simpara>

  <itemizedlist>
   <listitem><simpara><filename>http://exemple.com</filename></simpara></listitem>
   <listitem><simpara><filename>http://utilisateur:motdepasse@exemple.com</filename></simpara></listitem>
   <listitem><simpara><filename>https://exemple.com</filename></simpara></listitem>
   <listitem><simpara><filename>https://utilisateur:motdepasse@exemple.com</filename></simpara></listitem>
  </itemizedlist>

  <simpara>
   Permet des accès en lecture uniquement, pour des fichiers accessibles sur
   le réseau avec la méthode GET de HTTP 1.0. Un en-tête <literal>Host:</literal>
   est envoyé avec la requête, pour gérer les hôtes virtuels, basés sur des
   noms. Si vous avez configuré une version de navigateur avec
   l'option <link linkend="ini.user-agent">user_agent</link> dans votre 
   fichier &php.ini;, ou via le contexte de flux, il sera aussi 
   utilisé dans votre requête.
  </simpara>
   &warn.ssl-non-standard;
  <simpara>
   Les redirections sont supportées depuis &php; 4.0.5; si vous utilisez
   une version plus ancienne, vous devrez ajouter vous-même les 
   slash finaux dans vos URL. S'il est important de connaître l'URL
   de la ressource qui vous a fourni le document, une fois que
   toutes les redirections ont été suivies, vous devez analyser
   les entêtes de réponses retournés par le flux.
  </simpara>
  <example>
   <title>http:// et redirections</title>
   <programlisting role="php">
<![CDATA[
<?php
$url = 'http://www.exemple.com/redirecting_page.php';

$fp = fopen($url, 'r');

/* Avant PHP 4.3.0 utilisez $http_response_header 
   au lieu de stream_get_meta_data() */
foreach(stream_get_meta_data($fp) as $response) {

  /* Redirections? */
  if (substr(strtolower($response), 0, 10) == 'location: ') {
    /* modification de $url avec la nouvelle URL */
    $url = substr($response, 10);
  }
}

?>
]]>
   </programlisting>
  </example>  
  <simpara>
   Le flux donne l'accès au corps (<emphasis>body</emphasis>)
   de la ressource. Les en-têtes sont stockés dans la variable
   <varname>$http_response_header</varname>. Depuis &php; 4.3.0,
   les en-têtes sont aussi accessibles avec la fonction 
   <function>stream_get_meta_data</function>.
  </simpara>
  <simpara>
   Les connexions HTTP sont en lecture seule. Vous ne pouvez pas écrire
   dans des fichiers ouverts via le protocole HTTP.
  </simpara>
  <note>
   <simpara>
    HTTPS est supporté depuis &php; 4.3, si vous avez compilé
   le support d'OpenSSL.
   </simpara>
  </note>
 </section>

 <section id="wrappers.ftp">
  <title>FTP and FTPS</title>
  <simpara>&php; 3, &php; 4.  <filename>ftps://</filename> depuis &php; 4.3</simpara>

  <itemizedlist>
   <listitem><simpara><filename>ftp://example.com/pub/file.txt</filename></simpara></listitem>
   <listitem><simpara><filename>ftp://user:password@example.com/pub/file.txt</filename></simpara></listitem>
   <listitem><simpara><filename>ftps://example.com/pub/file.txt</filename></simpara></listitem>
   <listitem><simpara><filename>ftps://user:password@example.com/pub/file.txt</filename></simpara></listitem>
  </itemizedlist>

  <simpara>
   Permet l'accès aux fichiers existants, et la création de fichiers via FTP.
   Si le serveur ne supporte pas les connexions en mode passif, la
   connexion échouera.
  </simpara>
  <simpara>
   Vous pouvez ouvrir des fichiers en lecture et en écriture, mais
   pas les deux en même temps. Si le fichier distant existe déjà
   sur le serveur FTP, vous pourrez essayer de l'ouvrir en écriture,
   mais la connexion échouera. Si vous devez modifier un fichier qui
   existe déjà, utilisez <function>ftp_connect</function>.
  </simpara>
  <simpara>
   <filename>ftps://</filename> a été introduit en &php; 4.3.  
   C'est le même que <filename>ftp://</filename>, mais il tente d'établir
   une connexion sécurisée avec le serveur FTP. Si le serveur ne le supporte
   pas, la connexion sera une connexion non sécurisée.
  </simpara>
  <note>
   <simpara>
    FTPS est supporté depuis &php; 4.3.0, si vous avez compilé le 
    support d'OpenSSL.
   </simpara>
  </note>

 </section>

 <section id="wrappers.php">
  <title>Flux d'entrée/sortie</title>
  <simpara>
   &php; 3.0.13 et plus récent, <filename>php://output</filename> 
   et <filename>php://input</filename> depuis &php; 4.3
  </simpara>

  <itemizedlist>
   <listitem><simpara><filename>php://stdin</filename></simpara></listitem>
   <listitem><simpara><filename>php://stdout</filename></simpara></listitem>
   <listitem><simpara><filename>php://stderr</filename></simpara></listitem>
   <listitem><simpara><filename>php://output</filename></simpara></listitem>
   <listitem><simpara><filename>php://input</filename></simpara></listitem>
  </itemizedlist>

  <simpara>
   <filename>php://stdin</filename>, <filename>php://stdout</filename> 
   et <filename>php://stderr</filename> donne accès au flux correspondant
   d'entrée ou de sortie du processus &php;.
  </simpara>
  <simpara>
   <filename>php://output</filename> vous permet d'écrire dans le
   buffer de sortie, de la même manière que 
   <function>print</function> et <function>echo</function>.
  </simpara>
  <simpara>
   <filename>php://input</filename> permet de lire des données POST bruts.
   C'est moins gourmand en mémoire que <varname>$HTTP_RAW_POST_DATA</varname> 
   et il n'y a pas de directive spéciale dans &php.ini;.
  </simpara>
  <simpara>
   <filename>php://stdin</filename> et
   <filename>php://input</filename> sont lecture seule, tandis que
   <filename>php://stdout</filename>,
   <filename>php://stderr</filename> et
   <filename>php://output</filename> sont en écriture seule.
  </simpara>

  <simpara>
   <filename>php://filter</filename> est une sorte de méta-gestionnaire,
   prévu pour qui permet l'utilisation de filtre avec les données d'entrée
   au moment du démarrage du script. C'est pratique avec des fonctions
   compactes comme <function>readfile</function>, <function>file</function> et
   <function>file_get_contents</function> où il n'y a pas d'opportunité d'appliquer
   un filtre aux données lues.
  </simpara>
  <simpara>
   Le gestionaire de <filename>php://filter</filename> prend les paramètres
   suivants dans le chemin.
  </simpara>
  <itemizedlist>
   <listitem>
    <para>
     <literal>/resource=&lt;flux à filtrer&gt;</literal>
     (<emphasis>obligatoire</emphasis>) Ce paramètre doit être situé à la fin
     de votre chaîne <filename>php://filter</filename> et doit pointer sur le 
     flux à filtrer.
     <example>
      <title>php:// et les filtres</title>
      <programlisting role="php">
<![CDATA[
<?php
/* Ceci est l'équivalent de :
   readfile("http://www.exemple.com");
   puisqu'aucun filtre n'est spécifié */

readfile("php://filter/resource=http://www.exemple.com");
?>
]]>
      </programlisting>
     </example>
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>/read=&lt;liste de filtres de la chaîne de lecture&gt;</literal>
     (<emphasis>optionnel</emphasis>) Ce paramètre prend un ou plusieurs noms de
     filtres, séparés par le caractère pipe <literal>|</literal>.
     <example>
      <title>php:// et filtres de lecture</title>
      <programlisting role="php">
<![CDATA[
<?php
/* Cette ligne va afficher le contenu de 
   www.exemple.com tout en majuscule */
readfile("php://filter/read=string.toupper/resource=http://www.exemple.com");

/* Cela va faire la même chose que ci-dessus, mais en plus,
   le résultat sera chiffré en ROT13 */
readfile("php://filter/read=string.toupper|string.rot13/resource=http://www.exemple.com");
?>
]]>
      </programlisting>
     </example>
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>/write=&lt;liste de filtres de la chaîne d'écriture&gt;</literal>
     (<emphasis>optionnel</emphasis>) Ce paramètre prend un ou plusieurs noms de
     filtres, séparés par le caractère pipe <literal>|</literal>.
     <example>
      <title>php:// et filtres d'écritures</title>
      <programlisting role="php">
<![CDATA[
<?php
/* Cette ligne va filtrer la chaîne "Bonjour le monde"
   avec le filtre rot13, puis écrire le résultat dans 
   le fichier exemple.txt du dossier courant */
file_set_contents("php://filter/write=string.rot13/resource=exemple.txt","Bonjour le monde");
?>
]]>
      </programlisting>
     </example>
    </para>
   </listitem>
   <listitem>
    <simpara>
     <literal>/&lt;liste de filtres des deux chaînes&gt;</literal>
     (<emphasis>optionnel</emphasis>)  Tous les filtres qui ne sont pas
     préfixé avec <literal>read=</literal> ou
     <literal>write=</literal> seront appliqué aux deux chaînes de filtres,
     en lecture et en écriture.
    </simpara>
   </listitem>
  </itemizedlist>
 </section>

 <section id="wrappers.compression">
  <title>Flux compressés</title>
  <simpara><filename>zlib:</filename> &php; 4.0.4 - &php; 4.2.3 (systèmes avec
  fopencookie uniquement)</simpara>
  <simpara><filename>compress.zlib://</filename> et 
  <filename>compress.bzip2://</filename> depuis &php; 4.3.0 et plus récent.</simpara>

  <itemizedlist>
   <listitem><simpara><filename>zlib:</filename></simpara></listitem>
   <listitem><simpara><filename>compress.zlib://</filename></simpara></listitem>
   <listitem><simpara><filename>compress.bzip2://</filename></simpara></listitem>
  </itemizedlist>

  <simpara> 
   <filename>zlib:</filename> fonctionne comme <function>gzopen</function>, hormis
   le fait que le flux peut être utilisé directement avec <function>fread</function> 
   et les autres fonctions de système de fichier. Cette notation est obsolète
   depuis &php; 4.3.0, étant données les ambiguités dues aux noms de fichiers
   contenant des deux points ':'. Utilisez plutôt <filename>compress.zlib://</filename>.
  </simpara>

  <simpara>
   <filename>compress.zlib://</filename> et
   <filename>compress.bzip2://</filename> sont équivalents à 
   <function>gzopen</function> et <function>bzopen</function>
   respectivement, et ils opèrent même sur les systèmes qui ne supportent pas
   fopencookie.
  </simpara>
 </section>
</appendix>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
