<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.4 $ -->
<appendix id="wrappers">
 <title>Liste des protocoles supportés</title>
 <para>
  Cette section recense une liste de protocole gérant des URL,
  qui sont intégrés dans les fonctions ayant accès aux fichiers,
  dans PHP. Par exemple, les fonctions 
  <function>fopen</function> et <function>copy</function>.
  Ces fonctionnalités sont compilées comme des pilotes externes,
  et à partir de PHP 4.3.0, vous pouvez créer vos propres
  pilotes, avec la fonction <function>stream_register_wrapper</function>.
 </para>

 <section id="wrappers.http">
  <title>HTTP et HTTPS</title>
   <simpara>PHP 3, PHP 4. <filename>https://</filename> depuis PHP 4.3</simpara>

  <itemizedlist>
   <listitem><simpara><filename>http://exemple.com</filename></simpara></listitem>
   <listitem><simpara><filename>http://utilisateur:motdepasse@exemple.com</filename></simpara></listitem>
   <listitem><simpara><filename>https://exemple.com</filename></simpara></listitem>
   <listitem><simpara><filename>https://utilisateur:motdepasse@exemple.com</filename></simpara></listitem>
  </itemizedlist>

  <simpara>
   Permet des accès en lecture uniquement, pour des fichiers accessibles sur
   le réseau avec la méthode GET de HTTP 1.0. Un en-tête <literal>Host:</literal>
   est envoyé avec la requête, pour gérer les hôtes virtuels, basés sur des
   noms. Si vous avez configuré une version de navigateur avec
   l'option <link linkend="ini.user-agent">user_agent</link> dans votre 
   fichier &php.ini;, ou via le contexte de flux, il sera aussi 
   utilisé dans votre requête.
  </simpara>
  <simpara>
   Les redirections sont supportées depuis PHP 4.0.5; si vous utilisez
   une version plus ancienne, vous devrez ajouter vous même les 
   slash finaux dans vos URL.
  </simpara>
  <simpara>
   Le flux donne l'accès au corps (<emphasis>body</emphasis>)
   de la ressource. Les en-têtes sont stockés dans la variable
   <varname>$http_response_header</varname>. Depuis PHP 4.3.0,
   les en-têtes sont aussi accessibles avec la fonction 
   <function>stream_get_meta_data</function>.
  </simpara>
  <simpara>
   Les connexions HTTP sont en lecture seule. Vous ne pouvez pas écrire
   dans des fichiers ouverts via le protocole HTTP.
  </simpara>
  <note>
   <simpara>HTTPS est supporté depuis PHP 4.3, si vous avez compilé
   le support d'OpenSSL.
   </simpara>
  </note>
 </section>

 <section id="wrappers.ftp">
  <title>FTP and FTPS</title>
  <simpara>PHP 3, PHP 4.  <filename>ftps://</filename> depuis PHP 4.3</simpara>

  <itemizedlist>
   <listitem><simpara><filename>ftp://example.com/pub/file.txt</filename></simpara></listitem>
   <listitem><simpara><filename>ftp://user:password@example.com/pub/file.txt</filename></simpara></listitem>
   <listitem><simpara><filename>ftps://example.com/pub/file.txt</filename></simpara></listitem>
   <listitem><simpara><filename>ftps://user:password@example.com/pub/file.txt</filename></simpara></listitem>
  </itemizedlist>

  <simpara>
   Permet l'accès aux fichiers existants, et la création de fichiers via FTP.
   Si le serveur ne supporte pas les connexions en mode passif, la
   connexion échouera.
  </simpara>
  <simpara>
   Vous pouvez ouvrir des fichiers en lecture et en écriture, mais
   pas les deux en même temps. Si le fichier distant existe déjà
   sur le serveur FTP, vous pourrez essayer de l'ouvrir en écriture,
   mais la connexion échouera. Si vous devez modifier un fichier qui
   existe déjà, utilisez <function>ftp_connect</function>.
  </simpara>
  <simpara>
   <filename>ftps://</filename> a été introduit en PHP 4.3.  
   C'est le même que <filename>ftp://</filename>, mais il tente d'établir
   une connexion sécurisée avec le serveur FTP. Si le serveur ne le supporte
   pas, la connexion sera une connexion non sécurisée.
  </simpara>
  <note>
   <simpara>
    FTPS est supporté depuis PHP 4.3.0, si vous avez compilé le 
    support d'OpenSSL.
   </simpara>
  </note>

 </section>

 <section id="wrappers.php">
  <title>Flôts d'entrée/sortie</title>
  <simpara>
   PHP 3.0.13 et plus réscent, <filename>php://output</filename> 
   et <filename>php://input</filename> depuis PHP 4.3
  </simpara>

  <itemizedlist>
   <listitem><simpara><filename>php://stdin</filename></simpara></listitem>
   <listitem><simpara><filename>php://stdout</filename></simpara></listitem>
   <listitem><simpara><filename>php://stderr</filename></simpara></listitem>
   <listitem><simpara><filename>php://output</filename></simpara></listitem>
   <listitem><simpara><filename>php://input</filename></simpara></listitem>
  </itemizedlist>

  <simpara>
   <filename>php://stdin</filename>, <filename>php://stdout</filename> 
   et <filename>php://stderr</filename> donne accès au flux correspondant
   d'entrée ou de sortie du processus PHP.
  </simpara>
  <simpara>
   <filename>php://output</filename> vous permet d'écrire dans le
   buffer de sortie, de la même manière que 
   <function>print</function> et <function>echo</function>.
  </simpara>
  <simpara>
   <filename>php://input</filename> permet de lire des données POST bruts.
   C'est moins gourmand en mémoire que <varname>$HTTP_RAW_POST_DATA</varname> 
   et il n'y a pas de directive spéciale dans &php.ini;.
  </simpara>
  <simpara>
   <filename>php://stdin</filename> et
   <filename>php://input</filename> sont lecture seule, tandis que
   <filename>php://stdout</filename>,
   <filename>php://stderr</filename> et
   <filename>php://output</filename> sont en écriture seule.
  </simpara>

  <simpara>
   <filename>php://filter</filename> est une sorte de méta-gestionnaire,
   prévu pour qui permet l'utilisation de filtre avec les données d'entrée
   au moment du démarrage du script. C'est pratique avec des fonctions
   compactes comme <function>readfile</function>, <function>file</function> et
   <function>file_get_contents</function> où il n'y a pas d'opportunité d'appliquer
   un filtre aux données lues.
  </simpara>
  <simpara>
   Le gestionaire de <filename>php://filter</filename> prend les paramètres
   suivants dans le chemin.
  </simpara>
  <itemizedlist>
   <listitem>
    <para>
     <literal>/resource=&lt;flux à filtrer&gt;</literal>
     (<emphasis>obligatoire</emphasis>) Ce paramètre doit être situé à la fin
     de votre chaîne <filename>php://filter</filename> et doit pointer sur le 
     flux à filtrer.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
/* Ceci est l'équivalent de :
   readfile("http://www.example.com");
   puisqu'aucun filtre n'est spécifié */

readfile("php://filter/resource=http://www.exemple.com");
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>/read=&lt;liste de filtres de la chaîne de lecture&gt;</literal>
     (<emphasis>optionnel</emphasis>) Ce paramètre prend un ou plusieurs noms de
     filtres, séparés par le caractère pipe <literal>|</literal>.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
/* Cette ligne va afficher le contenu de 
   www.exemple.com tout en majuscule */
readfile("php://filter/read=string.toupper/resource=http://www.exemple.com");

/* Cela va faire la même chose que ci-dessus, mais en plus,
   le résultat sera chiffré en ROT13 */
readfile("php://filter/read=string.toupper|string.rot13/resource=http://www.exemple.com");
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>/write=&lt;liste de filtres de la chaîne d'écriture&gt;</literal>
     (<emphasis>optionnel</emphasis>) Ce paramètre prend un ou plusieurs noms de
     filtres, séparés par le caractère pipe <literal>|</literal>.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
/* Cette ligne va filtrer la chaîne "Bonjour le monde"
   avec le filtre rot13, puis écrire le résultat dans 
   le fichier exemple.txt du dossier courant */
file_set_contents("php://filter/write=string.rot13/resource=exemple.txt","Bonjour le monde");
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </listitem>
   <listitem>
    <simpara>
     <literal>/&lt;liste de filtres des deux chaînes&gt;</literal>
     (<emphasis>optionnel</emphasis>)  Tous les filtres qui ne sont pas
     préfixé avec <literal>read=</literal> ou
     <literal>write=</literal> seront appliqué aux deux chaînes de filtres,
     en lecture et en écriture.
    </simpara>
   </listitem>
  </itemizedlist>
 </section>

 <section id="wrappers.compression">
  <title>Flôts compressés</title>
  <simpara><filename>zlib:</filename> PHP 4.0.4 - PHP 4.2.3 (systèmes avec
  fopencookie uniquement)</simpara>
  <simpara><filename>compress.zlib://</filename> et 
  <filename>compress.bzip2://</filename> depuis PHP 4.3.0 et plus récent.</simpara>

  <itemizedlist>
   <listitem><simpara><filename>zlib:</filename></simpara></listitem>
   <listitem><simpara><filename>compress.zlib://</filename></simpara></listitem>
   <listitem><simpara><filename>compress.bzip2://</filename></simpara></listitem>
  </itemizedlist>

  <simpara> 
   <filename>zlib:</filename> fonctionne comme <function>gzopen</function>, hormis
   le fait que le flux peut être utilisé directement avec <function>fread</function> 
   et les autres fonctions de système de fichier. Cette notation est obsolète
   depuis PHP 4.3.0, étant données les ambiguités dues aux noms de fichiers
   contenant des deux points ':'. Utilisez plutôt <filename>compress.zlib://</filename>.
  </simpara>

  <simpara>
   <filename>compress.zlib://</filename> et
   <filename>compress.bzip2://</filename> sont équivalents à 
   <function>gzopen</function> et <function>bzopen</function>
   respectivement, et ils opèrent même sur les systèmes qui ne supportent pas
   fopencookie.
  </simpara>
 </section>
</appendix>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
