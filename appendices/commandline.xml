<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.10 $ -->
<chapter id="appendices.commandline">
 <title>Utiliser PHP en ligne de commande</title>
 <!-- NEW DOCUMENTATION STARTS -->
 <para>
  Depuis la version 4.3, &php; supporte un nouveau type
  de <literal>SAPI</literal> (Server Application Programming Interface,
  c'est &agrave; dire Interface de Programmation d'Applications Serveur) appel&eacute;
  <literal>CLI</literal>, ce qui signifie <emphasis>Command Line Interface</emphasis>
  et se traduit par <literal>Interface de Ligne de Commande</literal>. 
  Comme son nom l'indique, ce type <literal>SAPI</literal> cible les
  applications shell (ou desktop), &eacute;crites en PHP. Il y a pas mal de
  diff&eacute;rences enter le type <literal>CLI SAPI</literal> et les autres
  <literal>SAPI</literal>, qui sont expliqu&eacute;s dans ce chapitre.
 </para>
 <para>
  Le <literal>CLI SAPI</literal> a &eacute;t&eacute; publi&eacute; pour la premi&egrave;re fois avec
  la version <literal>PHP 4.2.0</literal>, mais il est rest&eacute; exp&eacute;rimental,
  et doit &ecirc;tre explicitement activ&eacute; avec la commande <literal>--enable-cli</literal>,
  lorsque vous ex&eacute;cutez le script <literal>./configure</literal>. Depuis
  PHP 4.3.0, le <literal>CLI SAPI</literal> n'est plus exp&eacute;rimental, et
  est donc <emphasis role="strong">toujours</emphasis> compil&eacute; et 
  install&eacute; comme binaire PHP (appel&eacute; aussi <filename>php.exe</filename> sous
  Windows).
 </para>
 <para>
  Les diff&eacute;rences les plus notables entre le <literal>CLI SAPI</literal> et les 
  <literal>SAPI</literal> sont :
  <itemizedlist>
   <listitem>
    <para>
     Contrairement au <literal>CGI SAPI</literal>, aucun en-t&ecirc;te HTTP n'est &eacute;crit
     dans le r&eacute;sultat.
    </para>
    <para>
     Bien que le <literal>CGI SAPI</literal> fournisse un moyen de supprimer les
     en-t&ecirc;tes HTTP, il n'y a pas moyen d'activer les en-t&ecirc;tes HTTP dans le 
     <literal>CLI SAPI</literal>.
    </para>
   </listitem>
   <listitem>
    <para>
     Il y a plusieurs directives du &php.ini; qui sont ignor&eacute;es par le 
     <literal>CLI SAPI</literal>, car elles n'ont pas de sens, en environnement
     shell : 
     <table>
      <title>Directives &php.ini; ignor&eacute;es</title>
      <tgroup cols="3">
       <thead>
        <row>
         <entry>Directive</entry>
         <entry>Valeur par d&eacute;faut pour <literal>CLI SAPI</literal></entry>
         <entry>Commentaire</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><link linkend="ini.html-errors">html_errors</link></entry>
         <entry>&false;</entry>
         <entry>
          Il peut &ecirc;tre bien difficile de lire les messages d'erreur sur un terminal
          lorsqu'ils sont noy&eacute;s dans des balises HTML sans grand int&eacute;r&ecirc;ts. Par
          cons&eacute;quent, cette directive est forc&eacute;e &agrave; &false;.
         </entry>
        </row>
        <row>
         <entry><link linkend="ini.implicit-flush">implicit_flush</link></entry>
         <entry>&true;</entry>
         <entry>
          Il est souhaitable que tout affichage en provenance de 
          <function>print</function>, <function>echo</function> et consorts soit
          imm&eacute;diatement affich&eacute; dans le terminal, et non pas plac&eacute; dans un
          buffer quelconque. Vous pouvez toujours utiliser 
          <link linkend="ref.outcontrol">la bufferisation de sortie</link>
          si vous voulez retarder un affichage, ou bien en manipuler ultimement
          le contenu.
         </entry>
        </row>
        <row>
         <entry><link linkend="ini.max-execution-time">max_execution_time</link></entry>
         <entry>0 (unlimited)</entry>
         <entry>
          Etant donn&eacute; les possibilit&eacute;s infinies de PHP en 
          environnement shell, le temps d'ex&eacute;cution maximal d'un 
          script PHP a &eacute;t&eacute; rendu illimit&eacute;.
          Alors que les scripts destin&eacute;s au web doivent s'accomplir en une 
          fraction de seconde, il arrive que les scripts shell requi&egrave;rent
          bien plus de temps.
         </entry>
        </row>
        <row>
         <entry><link linkend="ini.register-argc-argv">register_argc_argv</link></entry>
         <entry>&true;</entry>
         <entry>
         <para>
          En donnant la valeur de &true; &agrave; cette directive, vous aurez toujours
          acc&egrave;s &agrave; la variable <emphasis>argc</emphasis> (repr&eacute;sentant le nombre
          d'arguments pass&eacute;s &agrave; l'application) et 
          <emphasis>argv</emphasis> (le tableau contenant les arguments pass&eacute;s)
          dans le <literal>CLI SAPI</literal>.
         </para>
         <para>
          Depuis &php; 4.3.0, les variables <varname>$argc</varname>
          et <varname>$argv</varname> sont d&eacute;finies et remplies avec les valeurs
          appropri&eacute;es, en utilisant <literal>CLI SAPI</literal>. Avant cette version,
          la cr&eacute;ation de ces variables &eacute;tait li&eacute;e au comportement des versions 
          <literal>CGI</literal> et <literal>MODULE</literal>, qui requi&egrave;rent l'activation
          de la directive &php; 
          <link linkend="ini.register-globals">register_globals</link>. 
          Ind&eacute;pendamment de la version ou de la valeur de register_globals,
          vous pouvez toujour acc&eacute;der &agrave; 
          <link linkend="reserved.variables.server"><varname>$_SERVER</varname></link> et
          <varname>$HTTP_SERVER_VARS</varname>.  Par exemple:
          <varname>$_SERVER['argv']</varname>
         </para>
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </para>
    <note>
     <para>
      Ces directives ne peuvent pas &ecirc;tre initialis&eacute;es avec d'autres valeurs
      dans le fichier &php.ini; ou par une autre m&eacute;thode. C'est une limitation,
      car ces valeurs par d&eacute;faut s'appliquent une fois que tous les autres
      fichiers de configuration ont &eacute;t&eacute; analys&eacute;s. Cependant, ces
      valeurs peuvent &ecirc;tre modifi&eacute;es durant l'ex&eacute;cution (ce qui n'est pas
      logique pour certaines directives, comme par exemple 
      <link linkend="ini.register-argc-argv">register_argc_argv</link>).
     </para>
    </note>
   </listitem>
   <listitem>
    <para>
     Pour faciliter le travail en environnement shell, les constantes suivantes
     sont d&eacute;finies : 
     <table>
      <title>Constantes sp&eacute;cifiques au CLI</title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>Constante</entry>
         <entry>D&eacute;scription</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><constant>STDIN</constant></entry>
         <entry>
         Un descripteur de fichier d&eacute;j&agrave; disponible vers <literal>stdin</literal>. 
         Cela &eacute;vite de l'ouvrir avec 
         <programlisting role="php">
<![CDATA[
$stdin = fopen('php://stdin', 'r');
]]>
         </programlisting>
         </entry>
        </row>
        <row>
         <entry><constant>STDOUT</constant></entry>
         <entry>
         Un descripteur de fichier d&eacute;j&agrave; disponible vers <literal>stdout</literal>.
         Cela &eacute;vite de l'ouvrir avec 
         <programlisting role="php">
<![CDATA[
$stdout = fopen('php://stdout', 'w');
]]>
         </programlisting>
         </entry>
        </row>
        <row>
         <entry><constant>STDERR</constant></entry>
         <entry>
         Un descripteur de fichier d&eacute;j&agrave; disponible vers 
         <literal>stderr</literal>. Cela &eacute;vite de l'ouvrir avec 
         <programlisting role="php">
<![CDATA[
$stderr = fopen('php://stderr', 'w');
]]>
         </programlisting>
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </para>
    <para>
     Etant donn&eacute; ce qui pr&eacute;c&egrave;de, vous n'avez pas besoin d'ouvrir un fichier
     vers <literal>stderr</literal> par vous-m&ecirc;me, mais vous pouvez utiliser
     cette constante directement, comme un descripteur de fichier : 
     <programlisting role="php">
<![CDATA[
php -r 'fwrite(STDERR, "stderr\n");'
]]>
     </programlisting>
     Vous n'avez pas non plus &agrave; fermer explicitement ces fichiers, PHP s'en 
     chargera automatiquement.
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>CLI SAPI</literal> <emphasis role="strong">ne transforme pas</emphasis>
     le dossier courant en dossier d'ex&eacute;cution du script!
    </para>
    <para>
     Exemple de diff&eacute;rence entre <literal>CGI SAPI</literal> et <literal>CLI SAPI</literal>:
     <programlisting role="php">
<![CDATA[
<?php
    /* Un test simple : affiche le dossier d'ex&eacute;cution */
    echo getcwd(), "\n";
?>
]]>
     </programlisting>
    </para>
    <para>
     Lorsque vous utilisez la version <literal>CGI</literal>, l'affichage pourra &ecirc;tre
     <screen>
<![CDATA[
$ pwd
/tmp

$ php-cgi -f autre_dossier/test.php
/tmp/autre_dossier
]]>
     </screen>
     Cela monter clairement que &php; modifie le dossier
     courant, et utilise le dossier du script ex&eacute;cut&eacute;.
    </para>
    <para>
     En utilisant le <literal>CLI SAPI</literal>, on obtient :
     <screen>
<![CDATA[
$ pwd
/tmp

$ php -f autre_dossier/test.php
/tmp
]]>
     </screen>
     Cela donne beaucoup plus de souplesse lorsque vous r&eacute;digez des
     scripts shell avec &php;.
    </para>
    <note>
     <para>
      <literal>CGI SAPI</literal> supporte le m&ecirc;me comportement de 
      <literal>CLI SAPI</literal>, en lui passant l'option 
      <literal>-C</literal>, lorsque vous l'invoquez en ligne de commmande.
     </para>
    </note>
   </listitem>
  </itemizedlist>
 </para>
 <para>
  La liste des options de ligne de commande fournies par &php;
  est disponible en ex&eacute;cutant &php; avec l'option <literal>-h</literal> :
  <screen>
<![CDATA[
Usage: php [options] [-f] <file> [args...]
       php [options] -r <code> [args...]
       php [options] [-- args...]
  -s               Display colour syntax highlighted source.
  -w               Display source with stripped comments and whitespace.
  -f <file>        Parse <file>.
  -v               Version number
  -c <path>|<file> Look for php.ini file in this directory
  -a               Run interactively
  -d foo[=bar]     Define INI entry foo with value 'bar'
  -e               Generate extended information for debugger/profiler
  -z <file>        Load Zend extension <file>.
  -l               Syntax check only (lint)
  -m               Show compiled in modules
  -i               PHP information
  -r <code>        Run PHP <code> without using script tags <?..?>
  -h               This help

  args...          Arguments passed to script. Use -- args when first argument 
                   starts with - or script is read from stdin
]]>
  </screen>
 </para>
 <para>
  Le <literal>CLI SAPI</literal> dispose de trois moyens pour lire le 
  code du script PHP que vous voulez ex&eacute;cuter : 
  <orderedlist>
   <listitem>
    <para>
     Indiquer &agrave; &php; d'ex&eacute;cuter un fichier : 
    </para>
    <para>
     <screen>
<![CDATA[
php mon_script.php

php -f mon_script.php
]]>
     </screen>
     Les deux m&eacute;thodes (en utilisant <literal>-f</literal> ou pas) ex&eacute;cute le
     script contenu dans le fichier <filename>mon_script.php</filename>. Vous 
     pouvez choisir n'importe quel fichier, et ces fichiers ne sont pas
     tenus d'utiliser l'extension <filename>.php</filename>. N'importe
     quelle extension peut faire l'affaire.
    </para>
   </listitem>
   <listitem>
    <para>
     Donner du code &php; &agrave; ex&eacute;cuter directement en ligne de commande.
    </para>
    <para>
     <screen>
<![CDATA[
php -r 'print_r(get_defined_constants());'
]]>
     </screen>
     Une attention particuli&egrave;re doit alors &ecirc;tre apport&eacute;e aux variables d'environnement,
     qui seront remplac&eacute;es, et aux guillements, qui ont des significations sp&eacute;ciales en
     ligne de commande.
    </para>
    <note>
     <para>
      Lisez l'exemple attentivement, il n'y a ni balise d'ouverture, ni balise de fermeture!
      L'option <literal>-r</literal> fonctionne sans ces balises, et les ajouter conduira
      alors &agrave; une erreur d'analyse.
     </para>
    </note>
   </listitem>
   <listitem>
    <para>
     Donner du code &php; dans l'entr&eacute;e standard 
     (<literal>stdin</literal>).
    </para>
    <para>
     Cela donne la possibilit&eacute; de cr&eacute;er dynamiquement du code 
     &php;, puis de le fournir &agrave; PHP, et enfin,
     de le traiter &agrave; nouveau en shell. Voici un exemple fictif :
     <screen>
<![CDATA[
$ some_application | some_filter | php | sort -u >final_output.txt
]]>
     </screen>
    </para>
   </listitem>
  </orderedlist>
  Il n'est pas possible de combiner ces trois modes d'ex&eacute;cution.
 </para>
 <para>
  Comme toute application shell, l'ex&eacute;cutable &php; accepte
  des arguments, et votre script peut aussi les recevoirs. Le nombre d'arguments
  n'est pas limit&eacute; par PHP, mais par le shell, qui a une limite en terme
  de nombre de caract&egrave;res qui peuvent &ecirc;tre pass&eacute;s. G&eacute;n&eacute;ralement, vous n'atteidrez
  pas cette limite, mais cela reste possible. Les arguments pass&eacute;s au script seront
  transmis via la variable tableau <literal>$argv</literal>. L,index z&eacute;ro 
  contiendra toujours le nom du script appel&eacute;. Si le code a &eacute;t&eacute; fourni en ligne
  de commande, ou via <literal>stdin</literal>, ce premier &eacute;l&eacute;ment vaudra
  <literal>-</literal>. L'autre variable globale fournie est 
  <literal>$argc</literal> qui contient le nombre d'&eacute;l&eacute;ments dans le tableau
  <literal>$argv</literal> : ce nombre est <emphasis role="strong">diff&eacute;rent</emphasis> 
  du nombre d'arguments pass&eacute;s au script.
 </para>
 <para>
  Tant que les arguments que vous passez &agrave; votre script ne commencent pas par 
  le caract&egrave;re <literal>-</literal>, il n'y a rien de sp&eacute;cial &agrave; surveiller.
  Si vous passez des arguments &agrave; voter script qui commencent par 
  <literal>-</literal>, cela posera des probl&egrave;mes car &php;
  va penser qu'il doit les interpr&eacute;ter. Pour &eacute;viter cela, utilisez le s&eacute;parateur
  <literal>--</literal>. Apr&egrave;s cet argument, tous les arguments suivants seront
  pass&eacute;s &agrave; votre script sans &ecirc;tre modifi&eacute; ou analys&eacute; par PHP.
 </para>
 <screen>
<![CDATA[
# Cela ne va pas ex&eacute;cuter le code, mais afficher l'aide de PHP
$ php -r 'var_dump($argv);' -h
Usage: php [options] [-f] <file> [args...]
[...]

# Cela va passer l'argument '-h' &agrave; votre script, et &eacute;viter que PHP ne le traite
$ php -r 'var_dump($argv);' -- -h
array(2) {
  [0]=>
  string(1) "-"
  [1]=>
  string(2) "-h"
}
]]>
 </screen>
 <para>
  Cependant, il y a une autre m&eacute;thode pour utiliser PHP en script shell.
  Vous pouvez aussi utiliser la ligne <literal>#!/usr/bin/php</literal> 
  en tout d&eacute;but de votre script, suivi de code PHP compris entre
  balise ouvrantes/fermantes. Vous pouvez aussi ajouter apr&egrave;s 
  <literal>#!/usr/bin/php</literal> les options n&eacute;cessaires. Vous 
  pouvez aussi le faire en ligne de commande.
  De cette mani&egrave;re, le script peut &ecirc;tre ex&eacute;cut&eacute; comme un script
  shell habituel :
  <programlisting role="php">
<![CDATA[
#!/usr/bin/php
<?php
    var_dump($argv);
?>
]]>
  </programlisting>
  En supposant que ce fichier s'appelle<filename>test</filename>, dans le
  dossier courant, nous pouvons alors faire ceci : 
  <screen>
<![CDATA[
$ chmod 755 test
$ ./test -h -- foo
array(4) {
  [0]=>
  string(6) "./test"
  [1]=>
  string(2) "-h"
  [2]=>
  string(2) "--"
  [3]=>
  string(3) "foo"
}
]]>
  </screen>
  Comme vous le voyez, aucune pr&eacute;caution n'est n&eacute;cessaire pour passer des 
  param&egrave;tres qui commencent par <literal>-</literal> &agrave; votre script.
 </para>
 <para>
  <table>
   <title>Options de ligne de commande</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Option</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>-s</entry>
      <entry>
       <para>
        Affiche le code avec la colorisation syntaxique.
       </para>
       <para>
        Cette option utilise le m&eacute;canisme interne pour analyser le fichier,
        et produire une version coloris&eacute;e du code source, au format HTML.
        Notez que cette option ne fait que g&eacute;n&eacute;rer un bloc
        <literal>HTML</literal>, sans les en-t&ecirc;tes.
        <literal>&lt;code&gt; [...] &lt;/code&gt;</literal>
       </para>
       <note>
        <para>
         Cette option ne fonctionne pas avec l'option <literal>-r</literal>.
        </para>
       </note>
      </entry>
     </row>
     <row>
      <entry>-w</entry>
      <entry>
       <para>
        Affiche la source sans les commentaires et les espaces.
       </para>
       <note>
        <para>
         Cette option ne fonctionne pas avec l'option <literal>-r</literal>.
        </para>
       </note>
      </entry>
     </row>
     <row>
      <entry>-f</entry>
      <entry>
       <para>
        Analyse et ex&eacute;cute le fichier donn&eacute; apr&egrave;s l'option <literal>-f</literal>.
        Cette optione est optionnelle, et peut &ecirc;tre omise. Le seul nom du fichier
        est suffisant.
       </para>
      </entry>
     </row>
     <row>
      <entry>-v</entry>
      <entry>
       <para>
        Affiche les versions de PHP, PHP SAPI, et Zend sur le terminal. Par exemple : 
        <screen>
<![CDATA[
$ php -v
PHP 4.3.0-dev (cli), Copyright (c) 1997-2002 The PHP Group
Zend Engine v1.2.1, Copyright (c) 1998-2002 Zend Technologies
]]>
        </screen>
       </para>
      </entry>
     </row>
     <row>
      <entry>-c</entry>
      <entry>
       <para>
        Avec cette option, vous pouvez sp&eacute;cifier le nom du dossier dans lequel
        PHP va recherche le fichier &php.ini;, ou encore vous pouvez
        sp&eacute;cifier un fichier de configuration directement (qui n'a pas
        obligatoirement &agrave; &ecirc;tre appel&eacute; &php.ini;) :
        <screen>
<![CDATA[
$ php -c /custom/directory/ mon_script.php

$ php -c /custom/directory/custom-file.ini mon_script.php
]]>
        </screen>
       </para>
      </entry>
     </row>
     <row>
      <entry>-a</entry>
      <entry>
       <para>
        Ex&eacute;cute PHP de mani&egrave;re interactive.
        <!-- 
        mfischer, 20020510: Couldn't come up with a decent useful description
        of the current implementation of the interactive mode.
        -->
       </para>
      </entry>
     </row>
     <row>
      <entry>-d</entry>
      <entry>
       <para>
        Cette option permet de modifier n'importe quelle directive de configuration
        du fichier &php.ini;. La syntaxe est :
        <screen>
<![CDATA[
-d configuration_directive[=value]
]]>
        </screen>
       </para>
       <para>
        Exemples:
        <screen>
<![CDATA[
# L'omission de la valeur conduit &agrave; donner la valeur de "1"
$ php -d max_execution_time -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(1) "1"

# Passer une valeur vide conduit &agrave; donner la valeur de ""
php -d max_execution_time= -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(0) ""

# La directive de configuration sera n'importe quelle valeur pass&eacute;e apr&egrave;s le caract&egrave;re '='
$  php -d max_execution_time=20 -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(2) "20"
$  php -d max_execution_time=doesntmakesense -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(15) "doesntmakesense"
]]>
        </screen>
       </para>
      </entry>
     </row>
     <row>
      <entry>-e</entry>
      <entry>
       <para>
        G&eacute;n&eacute;re des informations &eacute;tendues pour le profilage et le d&eacute;bogage.
        <!-- 
        mfischer, 20020510: Anyone who can provide more information what it
        really does (even if it's only for developers) ?
        -->
       </para>
      </entry>
     </row>
     <row>
      <entry>-z</entry>
      <entry>
       <para>
        Charge une extension Zend. Si seulement un fichier est fourni, PHP
        essaie de charger cette extension dans le dossier courant par d&eacute;faut
        des librairie sur votre syst&egrave;me (g&eacute;n&eacute;ralement sp&eacute;cifi&eacute; avec 
        <filename>/etc/ld.so.conf</filename> sous Linux). Passer un nom de
        fichier avec le chemin complet fera que PHP utilisera ce fichier,
        sans recherche dans les dossiers classiques. Un chemin de dossier
        relatif indiquera &agrave; PHP qu'il doit chercher uniquement les extensions
        dans ce dossier.
       </para>
      </entry>
     </row>
     <row>
      <entry>-l</entry>
      <entry>
       <para>
        Cette option permet de faire une v&eacute;rification syntaxique sur le code
        PHP fourni. En cas de r&eacute;ussite, le message 
        <literal>No syntax errors detected in &lt;filename&gt;</literal> 
        (<literal>Aucune d'erreur de syntaxe n'ont &eacute;t&eacute; d&eacute;tect&eacute;es dans &lt;nom_de_fichier&gt;</literal> 
        est affich&eacute; sur la sortie standard, et le script shell retourne
        <literal>0</literal>. En cas d'erreur, le message 
        <literal>Errors parsing &lt;filename&gt;</literal> 
        (<literal>Erreurs d'analyse dans le fichier &lt;filename&gt;</literal>) 
        est affich&eacute;, en plus des messages d'erreurs d&eacute;tect&eacute;s par l'analyseur
        lui m&ecirc;me. Le script shell retourne le code <literal>255</literal>.
       </para>
       <para>
        Cette option ne d&eacute;tecte pas les erreurs fatales (comme par exemple les
        fonctions non d&eacute;finies). Utilisez <literal>-f</literal> si vous voulez
        tester aussi ces erreurs.
       </para>
       <note>
        <para>
         Cette option ne fonctionne pas avec l'option <literal>-r</literal>.
        </para>
       </note>
      </entry>
     </row>
     <row>
      <entry>-m</entry>
      <entry>
       <para>
        Cette option liste les extensions PHP et Zend compil&eacute;es et charg&eacute;es : 
        <screen>
<![CDATA[
$ php -m
[PHP Modules]
xml
tokenizer
standard
session
posix
pcre
overload
mysql
mbstring
ctype

[Zend Modules]
]]>
        </screen>
       </para>
      </entry>
     </row>
     <row>
      <entry>-i</entry>
      <entry>
       Cette option appelle la fonction <function>phpinfo</function>, et
       affiche le r&eacute;sultat. Si &php; ne fonctionne pas
       correctement, il est recommand&eacute; d'utiliser la commande <literal>php -i</literal> 
       et de voir si il n'y a pas d'erreurs affich&eacute;es avant ou apr&egrave;s la
       table d'information. N'oubliez pas que le r&eacute;sutltat de cette
       option est au format <literal>HTML</literal>, et donc grand
       et illisible directement.
      </entry>
     </row>
     <row>
      <entry>-r</entry>
      <entry>
       <para>
        Cette option permet l'ex&eacute;cution de &php; directement
        dans la ligne de commande. Les balises de &php; 
        (<literal>&lt;?php</literal> et <literal>?&gt;</literal>) 
        <emphasis role="strong">ne sont pas</emphasis> demand&eacute;es, et coauseront
        une erreur d'analyse.
       </para>
       <note>
        <para>
         De l'attention doit &ecirc;tre port&eacute;e lors de l'utilisation de cette option
         de &php;, pour qu'il n'y ait pas de collision avec
         les substitutions de variables en lignes de commande, r&eacute;alis&eacute;es par le
         shell.
        </para>
        <para>
         Exemple conduisant &agrave; une erreur d'analyse : 
         <screen>
<![CDATA[
$ php -r "$foo = get_defined_constants();"
Command line code(1) : Parse error - parse error, unexpected '='
]]>
         </screen>
         Le probl&egrave;me ici est que le shell (sh/bash) effectue une substitution
         de variables, gr&acirc;ce aux guillemets doubles <literal>"</literal>. 
         puisque la variable <literal>$foo</literal> n'est probablement pas
         d&eacute;finie dans le shell, elle est remplac&eacute;e par rien, ce qui fait
         que le code pass&eacute; &agrave; PHP pour l'ex&eacute;cution est : 
         <screen>
<![CDATA[
$ php -r " = get_defined_constants();"
]]>
         </screen>
         La solution de ce probl&egrave;me est d'utiliser les guillemets simples
         <literal>'</literal>. Les variables de ces cha&icirc;nes ne seront pas
         substitu&eacute;es par leurs valeurs par le shell.
         <screen>
<![CDATA[
$ php -r '$foo = get_defined_constants(); var_dump($foo);'
array(370) {
  ["E_ERROR"]=>
  int(1)
  ["E_WARNING"]=>
  int(2)
  ["E_PARSE"]=>
  int(4)
  ["E_NOTICE"]=>
  int(8)
  ["E_CORE_ERROR"]=>
  [...]
]]>
         </screen>
         Si vous utilisez un shell diff&eacute;rent de sh/bash, vous pouvez
         rencontrer d'autres probl&egrave;mes. N'h&eacute;sitez pas &agrave; ouvrir un
         rapport de bugs, ou d'envoyer un mail &agrave; 
         phpdoc@lists.php.net.

         Il est toujours tr&egrave;s facile d'avoir des probl&egrave;mes lorsque vous essayez
         d'inclure des variables shell dans le code, ou d'utiliser les anti-slash
         pour l'&eacute;chappement. Vous aurez &eacute;t&eacute; pr&eacute;venu.
       <!-- :-) -->
        </para>
       </note>
      </entry>
     </row>
     <row>
      <entry>-h</entry>
      <entry>
       Avec cette option, vous pouvez obtenir des informations sur la liste des
       options support&eacute; par votre PHP, avec des explications succintes.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </para>
 <!-- NEW DOCUMENTATION ENDS -->

 <!-- OLD DOCUMENTED STARTS
  mfischer, 20020510: I've commented out the start paragraphs of the old
  documentation as it is meant to be replaced by the new one.
 <para>
  The command line options of the PHP executable are useful
  if you would like to debug or test your PHP setup, but they
  can also be handy, if you would like to use PHP for a
  different purpose than web scripting.
 </para>
 <para>
  Note, that you can always direct the output of the PHP
  executable to an external file with the &gt; character,
  so <literal>php -q test.php > test.html</literal> will
  print out the output of <filename>test.php</filename>
  without HTTP headers to the <filename>test.html</filename>
  file in the same directory.
 </para>
 <para>
  You can only use these command line options if you have
  the PHP executable. If you built the server module
  version, and you have no CGI version available on your
  machine, than you have no chance to use these options.
  For Windows users both the PHP executable and the server
  modules are in the binary package, the executable is
  named <filename>php.exe</filename>.
 </para>
 <para>
  This list of command line options is consistent with PHP 4.0.6.
  You can get the actual list and some one line descriptions
  with the <literal>-h</literal> option. The output of
  <literal>php -h</literal> should be something like this:
  <screen>
<![CDATA[
Usage: php [-q] [-h] [-s [-v] [-i] [-f <file>] |  {<file> [args...]}
  -q             Quiet-mode.  Suppress HTTP Header output.
  -s             Display colour syntax highlighted source.
  -f <file>      Parse <file>.  Implies `-q'
  -v             Version number
  -C             Do not chdir to the script's directory
  -c <path>      Look for php.ini file in this directory
  -d foo[=bar]   Define INI entry foo with value 'bar'
  -e             Generate extended information for debugger/profiler
  -z <file>      Load Zend extension <file>.
  -l             Syntax check only (lint)
  -m             Show compiled in modules
  -i             PHP information
  -h             This help
]]>
  </screen>
 </para>
 <para>
  Here we list some of the most important command line options
  with detailed explanations.
 </para>
 <para>
  <table>
   <title>Command line options</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Option</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>-q</entry>
      <entry>
       Suppress HTTP headers output. Normally PHP prints out
       HTTP headers for the calling program (ie. webserver)
       to hand on to the browser. When writing command line
       applications these headers are useless.
      </entry>
     </row>
     <row>
      <entry>-s</entry>
      <entry>
       Display the color highlighted source of the file
       given with its name. This is the same as if you were
       printing out the source using the
       <function>highlight_file</function> function in
       a PHP script.
      </entry>
     </row>
     <row>
      <entry>-f</entry>
      <entry>
       Parse the file given, and search for syntactical and
       fatal errors. This option implies -q. Use for
       debugging purposes.
      </entry>
     </row>
     <row>
      <entry>-v</entry>
      <entry>
       By calling PHP with this option, you can ask
       it to print out its version number, ie: 4.0.6. 
      </entry>
     </row>
     <row>
      <entry>-C</entry>
      <entry>
       Normally PHP changes the working directory to the
       running scripts directory. This makes it possible
       for example, to open files in the same directory,
       with only specifying the name of the file. If you
       would like to disable this directory change, use
       this option.
      </entry>
     </row>
     <row>
      <entry>-c</entry>
      <entry>
       Using this option, you can specify an alternative
       &php.ini; path, so PHP will
       search your configurations file in this path
       instead of the default one.
      </entry>
     </row>
     <row>
      <entry>-d</entry>
      <entry>
       With this option, you can set individual 
       &php.ini; settings in the
       time of running a script.
      </entry>
     </row>
     <row>
      <entry>-l</entry>
      <entry>
       Check the file given for syntax errors. This
       option implies -q. Use for debugging purposes.
       This option won't find fatal errors (like undefined
       functions). Use -f if you would like to test
       for fatal errors too.
      </entry>
     </row>
     <row>
      <entry>-m</entry>
      <entry>
       Using this option, PHP prints out the built in
       (and loaded) PHP and Zend modules, the PHP
       and Zend version numbers, and a short Zend
       copyright notice.
      </entry>
     </row>
     <row>
      <entry>-i</entry>
      <entry>
       This command line option calls
       <function>phpinfo</function>, and prints
       out the results. If PHP is not working well,
       it is advisable to make a <literal>php -i</literal>
       and see if any error messages are printed out
       before or in place of the information tables.
      </entry>
     </row>
     <row>
      <entry>-h</entry>
      <entry>
       With this option, you can get information about
       the actual list of command line options and some
       one line descriptions about what they do.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </para>
 -->
 <para>
  L'ex&eacute;cutable PHP peut &ecirc;tre utilis&eacute; pour ex&eacute;cuter des scripts ind&eacute;pendants du
  serveur web. Si vous &ecirc;tes sur un syst&egrave;me Unix, il est recommand&eacute; d'ajouter
  la ligne de configuration en d&eacute;but de scripts, de le rendre ex&eacute;cutable de
  mani&egrave;re &agrave; ce que le syst&egrave;me sache quel programme doit ex&eacute;cuter le script.
  Sous Windows, vous pouvez associer l'ex&eacute;cutable <literal>php.exe</literal> 
  avec le double-clic sur les fichiers d'extension <literal>.php</literal>,
  ou bien vous pouvez faire un fichier batch pour ex&eacute;cuter le script gr&acirc;ce
  &agrave; PHP. La premi&egrave;re ligne utilis&eacute;e dans le monde Unix ne perturbera pas
  PHP sous Windows, ce qui rend les scripts facilements portables. Un exemple
  complet est disponible ci-dessous : 
 </para>
 <example>
  <title>Script pr&eacute;vu pour &ecirc;tre ex&eacute;cut&eacute; en ligne de commande (script.php)</title>
  <programlisting role="php">
<![CDATA[
#!/usr/bin/php
<?php

if ($argc != 2 || in_array($argv[1], array('--help', '-help', '-h', '-?'))) {
?>

C'est une ligne de commande &agrave; une option.

  Utilisation :
  <?php echo $argv[0]; ?> <option>

  <option> peut &ecirc;tre un mot que vous souhaitez afficher.
  Avec les options --help, -help, -h,
  et -?, vous obtiendrez cette aide.
  
<?php
} else {
    echo $argv[1];
}
?>
]]>
  </programlisting>
 </example>
 <para>
  Dans le script ci-dessus, nous utilisons la premi&egrave;re ligne pour indiquer
  que le fichier doit &ecirc;tre ex&eacute;cut&eacute; par PHP. Nous travaillons avec une version
  CLI, donc il n'y a pas d'en-t&ecirc;tes HTTP qui soient affich&eacute;s. Il y a deux
  variables que vous pouvez utiliser avec les applications de ligne de commande :
  <varname>$argc</varname> et <varname>$argv</varname>. La premi&egrave;re
  est le nombre d'arguments plus un (le nom du script qui est
  ex&eacute;cut&eacute;). La seconde est un tableau contenant les arguments, commen&ccedil;ant
  avec le nom du script en &eacute;l&eacute;ment 0 (<varname>$argv[0]</varname>).
 </para>
 <para>
  Dans notre exemple, nous avons v&eacute;rifi&eacute; qu'il y a plus ou moins d'un
  argument. De plus, si cet argument est <literal>--help</literal>,
  <literal>-help</literal>, <literal>-h</literal> ou <literal>-?</literal>,
  nous avons affich&eacute; un message d'aide, ainsi que le nom du
  script. Nous nous recevons un autre argument, cet argument est affich&eacute;
  dans le terminal.
 </para>
 <para>
  Pour ex&eacute;cuter le script ci-dessus sous Unix, vous devez le rendre
  ex&eacute;cu&eacute;table, puis l'appeler avec une commande comme : 
  <literal>script.php echothis</literal> ou
  <literal>script.php -h</literal>. Sous Windows, vous pouvez faire un
  fichier batch pour cela :
  </para>
 <example>
  <title>Fichier batch pour ex&eacute;cuter un script PHP en ligne de commande (script.bat)</title>
  <programlisting role="winbat">
@c:\php\php.exe script.php %1 %2 %3 %4
  </programlisting>
 </example>
 <para>
  Si vous avez nomm&eacute; le programme ci-dessus 
  <filename>script.php</filename>, et que vous avez votre ex&eacute;cutable
  <filename>php.exe</filename> situ&eacute; &agrave; 
  <filename>c:\php\php.exe</filename>, ce fichier batch l'ex&eacute;cutera
  avec les options que vous lui passez : 
  <literal>script.bat echothis</literal> ou
  <literal>script.bat -h</literal>.
 </para>
 <para>
  Voir aussi l'extension <link linkend="ref.readline">Readline</link>,
  qui dispose de nombreuses fonctions pour am&eacute;liorer la convivialit&eacute;
  de vos applications en ligne de commande.
 </para>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
