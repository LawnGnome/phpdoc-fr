<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.31 $ -->
<!-- EN-Revision: 1.39 Maintainer: dams Status: ready -->
 <appendix id="migration4">
    <title>Migration de &php; 3.0 à &php; 4.0</title>
    <section id="migration4.changes">
     <title>Ce qui a changé en &php; 4.0</title>
     <para>
      &php; 4.0 et le moteur Zend ont significativement amélioré les
      performances et les possibilités de &php;, tout en assurant une
      compatibilité ascendante maximale. Le maximum de codes existants
      sous &php; 3.0 fonctionneront sous &php; 4.0. La migration de votre
      code de &php; 3.0 vers &php; 4.0 sera beaucoup plus facile que
      celle de &php;/FI 2.0 vers 3.0. Un grand nombre de scripts seront
      prêts sans modifications, mais il est bon que vous connaissiez
      les quelques différences, et que vous testiez vos applications
      avant d'effectuer le changement de cadre de production. Les
      indications suivantes vous mettront sur la voie.
     </para>
    </section>
  <section id="migration4.php4.with.php3">
   <title>Utiliser &php; 3 et &php; 4 simultanément</title>
   <simpara>
    Les systèmes d'exploitation récents disposent de capacités
    de versioning et de scoping. Ces fonctionnalités rendent possible l'installation
    de &php; 3 et &php; 4 comme modules Apache, simultanément.
   </simpara>
   <simpara>
    Ceci a été fait sur les plates-formes suivantes :
   </simpara>
   <itemizedlist>
     <listitem>
      <simpara>
       Linux avec les binutils récents (testé avec binutils 2.9.1.0.25)
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Solaris 2.5 ou plus récent
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       FreeBSD (testé avec 3.2, 4.0)
      </simpara>
     </listitem>
   </itemizedlist>
   <para>
    Pour l'activer, configurez &php; 3 et &php; 4 pour qu'ils utilisent APXS
    (<option role="configure">--with-apxs</option>)
     et les extensions nécessaires
    (<option role="configure">--enable-versioning</option>).
    En dehors de cela, toutes les instructions d'installation habituelles
    s'appliquent. Par exemple :
    <example>
     <title>Configuration pour utiliser simultanément &php; 3 et 4</title>
     <programlisting role="shell">
<![CDATA[
$ ./configure \
  --with-apxs=/apache/bin/apxs \
  --enable-versioning \
  --with-mysql \
  --enable-track-vars
]]>
     </programlisting>
    </example>
   </para>
  </section>
  <section id="migration4.configuration">
   <title>Migration des fichiers de configuration</title>
   <para>
    Le fichier de configuration global, <filename>php3.ini</filename>,
    a été renommé en &php.ini;.
   </para>
   <para>
    Pour les fichiers de configuration Apache, il y a eu des modifications
    plus importantes. Les types MIME reconnus par le module &php; 
    ont été modifiés.
    <example>
     <title>Activation des types Mimes &php; 3 et 4</title>
     <programlisting>
<![CDATA[
application/x-httpd-php3        -->    application/x-httpd-php
application/x-httpd-php3-source -->    application/x-httpd-php-source
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Vous pouvez faire fonctionner vos deux versions de &php; avec le
    même fichier de configuration Apache (suivant la version qui est
    déjà compilée sur le serveur), en utilisant la syntaxe suivante :
    <example>
     <title>Utilisation du même fichier de configuration Apache pour &php; 3 et 4</title>
     <programlisting>
<![CDATA[
AddType  application/x-httpd-php3        .php3
AddType  application/x-httpd-php3-source .php3s
AddType  application/x-httpd-php         .php
AddType  application/x-httpd-php-source  .phps
]]>
      </programlisting>
    </example>
   </para>
   <simpara>
    De plus, les directives de nom de &php; pour Apache ont aussi été modifiées.
   </simpara>
   <para>
    Depuis &php; 4.0, il n'y a que 4 directives Apache qui se rapportent
    à &php; :
    <example>
     <title>Directives Apache pour &php; 4</title>
     <programlisting>
<![CDATA[
php_value [PHP directive name] [value]
php_flag [PHP directive name] [On|Off]
php_admin_value [PHP directive name] [value]
php_admin_flag [PHP directive name] [On|Off]
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Il y a deux différences entre les options Admin et les autres valeurs :
   </simpara>
   <itemizedlist>
    <listitem>
     <simpara>
      Les options Admin ne peuvent être placées que des le fichier de configuration
      général (i.e., &httpd.conf;).
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Les valeurs Standard ne peuvent pas contrôler certaines directives &php;. Par
      exemple, le &safemode; (si vous pouviez modifier les configurations dans le fichier
      &htaccess;, cela annulerait toute la sécurité du &safemode;.
      A l'inverse, les valeurs Admin peuvent modifier n'importe quelle directive
      &php;.
     </simpara>
    </listitem>
   </itemizedlist>
   <simpara>
    Pour rendre le processus de transition plus agréable, &php; 4.0 est
    distribué avec des scripts qui convertissent automatiquement vos
    configuration Apache et vos fichiers &htaccess;
    pour qu'ils puissent fonctionner aussi bien avec &php; 3 que &php; 4. Ces scripts
    ne convertissent PAS les lignes concernant les types MIME. Vous devez le faire
    vous-même.
   </simpara>
   <para>
    Pour convertir votre fichier de configuration Apache, exécutez le script
    <filename>apconf-conv.sh</filename> (disponible dans le dossier
    <filename>scripts/apache/</filename>). Par exemple :
    <example>
     <title>Conversion du fichier de configuration Apache pour &php; 4</title>
     <programlisting>
<![CDATA[
~/php4/scripts/apache:#  ./apconf-conv.sh /usr/local/apache/conf/httpd.conf
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Votre configuration originale sera sauvée dans le fichier
    <filename>httpd.conf.orig</filename>.
   </simpara>
   <para>
    Pour convertir vos fichiers &htaccess;, exécutez
    le script <filename>aphtaccess-conv.sh</filename> (disponible dans le dossier
    <filename>scripts/apache/</filename>). Par exemple :
    <example>
     <title>Conversion des fichiers <filename>.htaccess</filename> pour &php; 4</title>
     <programlisting>
<![CDATA[
~/php4/scripts/apache:#  find / -name .htaccess -exec ./aphtaccess-conv.sh {} \;
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    De la même façon, votre vieux fichier &htaccess;
    sera sauvé sous le nom <filename>.htaccess.orig</filename>.
   </simpara>
   <simpara>
    Les scripts de conversion requièrent l'installation préalable de awk.
   </simpara>
  </section>
    <section id="migration4.parser">
     <title>Comportement de l'analyseur</title>
     <para>
      L'analyse et l'exécution sont désormais deux étapes
      complètement dissociées, et l'exécution
      intervient lorsque le code, ainsi que tous ses inclusions et
      pré-requis, ont été complètement
      analysés et validés.
     </para>
     <para>
      Une des nouvelles conditions introduites est que les fichiers
      inclus et requis (<function>include</function> et
      <function>require</function>) doivent être syntaxiquement
      complets. Vous ne pouvez plus répartir différents cas de votre
      code dans plusieurs fichiers. Vous ne pouvez plus commencer une
      boucle <literal>for</literal> ou <literal>while</literal>,
      une condition <literal>if</literal> ou un cas <literal>switch</literal>
      dans un fichier, et finir la boucle ou placer les cas
      <literal>else</literal>, <literal>endif</literal>,
      <literal>case</literal> ou <literal>break</literal>
      dans un autre fichier.
     </para>
     <para>
      Il est toujours valable d'inclure du code supplémentaire depuis
      une boucle ou dans une condition, mais les accolades de
      bloc <literal>{...}</literal>, et les éléments de la boucle
      doivent être dans le même fichier ou chaîne évaluée avec
      <function>eval</function>.
     </para>
     <para>
      Cela ne devrait pas perturber trop de monde, car étaler son
      code de cette façon est plutôt un style à éviter.
     </para>
     <para>
      Une autre nouveauté est qu'il est plus possible de faire
      retourner une valeur avec un fichier requis (<function>require</function>)
      (mais c'est plutôt rare en &php; 3.0). Retourner une valeur
      avec un fichier inclus (<function>include</function>) est toujours
      possible.
     </para>
    </section>
    <section id="migration4.error-reporting">
     <title>Rapport d'erreur</title>
     <section id="migration4.error-reporting.config">
      <title>Changement de configuration</title>
      <para>
       Avec &php; 3.0, le niveau de rapport d'erreur était obtenu en
       ajoutant les constantes numériques de chaque niveau de
       rapport. Généralement, on utilisait 15 pour afficher toutes
       les erreurs, et 7 pour afficher toutes les erreurs hormis
       les alertes simples.
      </para>
      <para>
       &php; 4.0 dispose d'un nombre significativement plus grand de niveaux
       de rapport d'erreur, et l'analyseur comprend désormais les
       constantes, lors des modifications.
      </para>
      <para>
       Le niveau de rapport d'erreur doit désormais être explicitement
       configuré en supprimant les niveaux dont vous ne voulez pas
       du niveau maximal, grâce à la fonction de OU exclusif. Ca a
       l'air compliqué? Supposons que vous souhaitiez afficher toutes les
       erreurs, hormis les alertes de style, qui sont repérées par
       la constante : E_NOTICE. Il suffit d'ajouter la valeur
       suivante dans le fichier &php.ini; :
       <literal>error_reporting = E_ALL &amp; ~ ( E_NOTICE )</literal>.
       Si vous voulez supprimer en plus les alertes, vous pouvez
       ajouter la constante appropriée, en la combinant avec l'opérateur
       OU logique '|':
       <literal>error_reporting= E_ALL &amp; ~ ( E_NOTICE | E_WARNING )</literal>.
      </para>
      <warning>
       <para>
        Lors de la mise à jour de votre code ou de vos serveurs de &php; 3 à &php; 4,
        vous devez vérifier ces valeurs de configuration et appeler la fonction
        <function>error_reporting</function> ou bien désactiver
        les nouveaux types d'erreurs, tout spécialement <literal>E_COMPILE_ERROR</literal>.
        Ceci peut mener à vider des documents sans aucune rétroaction de ce qui s'est produit 
        ou d'où rechercher le problème.
       </para>
      </warning>
      <warning>
       <para>
          L'utilisation des vieilles valeurs de 7 et 15 est une très
          mauvaise idée, car elles ne prennent pas en compte les
          nouvelles classes d'erreurs, y compris certaines erreurs
          d'analyse. Cela peut conduire à de très étranges résultats,
          où le script n'affiche plus rien, malgré une erreur d'analyse.
       </para>
       <para>
          Cela a conduit à un grand nombre de rapport d'erreur dans
          le passé, alors que les programmeurs n'étaient tout simplement
          pas capables de repérer l'accolade manquante, car l'analyseur
          avait la consigne de cacher ces erreurs.
       </para>
       <para>
          Vérifier votre niveau d'erreur doit être le premier réflexe
          lorsque vos scripts meurent silencieusement. Le moteur
          Zend est considéré actuellement comme suffisamment mature pour
          ne plus causer ce genre de problème aujourd'hui.
       </para>
      </warning>
     </section>
     <section id="migration4.error-reporting.additions">
      <title>Nouveaux messages d'erreurs</title>
      <para>
       Un grand nombre de scripts &php; 3.0 utilisent des structures qui
       doivent être considérées comme un très mauvais style,
       même s'il effectue bien la tâche qui lui est affectée, car
       ils ne sont pas robustes. &php; 4.0 affichera de nombreux messages d'erreurs dans
       des situations où &php; 3.0 restera coi. La solution de facilité
       consiste à supprimer les messages de niveau E_NOTICE, mais c'est une
       meilleure idée de corriger le code à la place.
      </para>
      <para>
       Le cas le plus courant qui génèrera des messages d'alertes
       est l'utilisation de constantes sans guillemets comme
       index de tableaux. &php; 3.0, comme &php; 4.0, finiront par les
       interpréter littéralement comme des chaînes, si aucune constante
       n'est définie à la place. Mais si jamais une telle constante
       est définie dans une autre partie du code, cela risque de
       produire des résultats étonnants. Cela peut devenir un trou
       de sécurité si un pirate arrive à redéfinir les constantes
       de telle manière que le script lui donne accès à un niveau
       de droits supérieur. &php; 4.0 vous signalera tout oubli de
       guillemets par exemple dans :
       <literal>$_SERVER[REQUEST_METHOD]</literal>. Modifier
       ce code en <literal>$_SERVER['REQUEST_METHOD']</literal>
       rendra l'analyseur heureux, et améliorera grandement votre
       style et la sécurité du code.
      </para>
      <para>
       &php; 4.0 vous signalera les variables ou les
       éléments de tableaux non initialisés.
      </para>
     </section>
    </section>
    <section id="migration4.initializers">
     <title>Initialiseur</title>
     <para>
      Les variables statiques et les membres de classes n'acceptent
      plus que des initialiseurs scalaires, tandis que &php; 3.0 acceptait
      aussi les expressions. Cela est dû, encore une fois, à la
      séparation de l'analyse et de l'exécution : aucun code
      ne peut être exécuté tant que l'analyse
      n'est pas terminée.
     </para>
     <para>
      Pour les classes, il vaut mieux initialiser les membres dans
      le constructeur. Pour les variables statiques, une valeur fixe
      et simple est la seule chose qui viennent à l'esprit.
     </para>
    </section>
    <section id="migration4.empty">
     <title><literal>empty("0")</literal></title>
     <para>
      L'évolution la plus polémique est celle de <function>empty</function>.
      Une chaîne contenant seulement le caractère
      <literal>'0'</literal> (zéro) est maintenant considérée comme
      vide, alors qu'elle ne l'était pas en &php; 3.0.
     </para>
   <para>
    Ce nouveau comportement prend tout son sens dans les applications
    web, puisque tous les résultats de champs de type input sont de type
    chaîne de caractères, même si un nombre est demandé,
    et ce, grâce aux capacités de conversion automatique de &php;.
    D'un autre côté, cela peut
    casser votre code d'une manière très subtile, menant droit au
    comportement erratique, difficilement repérable si vous ne
    savez pas ce qui vous attend.
   </para>
  </section>
  <section id="migration4.missing">
   <title>Fonctions manquantes</title>
   <para>
    Bien que &php; 4.0 dispose de nombreuses nouvelles fonctionnalités
    fonctions et extensions, vous pouvez rencontrer des fonctions &php;
    3.0 qui manquent. Un petit nombre de fonctions de base n'ont pu
    être portées en &php; 4.0, maintenant que l'analyse et l'exécution
    ont été séparées. D'autres fonctions, et mêmes des extensions
    entières sont maintenant obsolètes, remplacées par de nouvelles
    fonctions plus puissantes ou plus efficaces. Certaines fonctions
    n'ont tout simplement pas été portées pour le moment ou pour
    des raisons de licences.
  </para>
  <section id="migration4.missing.concept">
   <title>Fonctions manquantes pour des raisons de structure</title>
    <para>
     Comme &php; 4.0 sépare l'analyse et l'exécution, il n'est plus
       possible de modifier le comportement de l'analyseur (intégré
       dans le moteur Zend) durant l'exécution, puisque toute
       l'analyse a eu lieu, et est terminée. La fonction
       short_tags() a cessé d'exister. Vous pouvez
       toujours modifier le comportement de l'analyseur avec
       le fichier &php.ini;.
      </para>
      <para>
       Une autre fonctionnalité qui ne fait pas partie de &php;
       est le débogueur. Des débogueurs réalisés par des tiers
       sont disponibles, mais ne sont pas distribués avec &php;
       D'autres extensions du Zend Engine sont aussi disponibles auprès
       de divers sites et groupes.
      </para>
     </section>
     <section id="migration4.deprecate">
      <title>Fonctions et extensions obsolètes</title>
      <para>
       Les extensions Adabas et Solid n'existent plus. Elles sont intégrées
       dans les fonctions <link linkend="ref.uodbc">ODBC Unifié</link>.
      </para>
     </section>
     <section id="migration4.unset">
      <title>Nouveau statut pour <function>unset</function></title>
      <para>
       <function>unset</function>, bien que toujours disponible, a
       été implémenté légèrement différemment en &php; 4.0, et elle 
       n'est plus vraiment une 'fonction'.
      </para>
      <para>
       Cela n'a pas de conséquence directe sur le comportement de
       <function>unset</function>, mais utiliser cette fonction
       pour faire un test avec <function>function_exists</function>
       retournera &false; comme il se doit avec
       les fonction bas niveau comme <function>echo</function>.
      </para>
      <para>
       Une autre application pratique disparue est qu'il n'est plus possible
       d'appeler <function>unset</function> indirectement, c'est-à-dire que
       <literal>$func="unset"; $func($somevar)</literal> ne fonctionne plus.
      </para>
     </section>
    </section>
    <section id="migration4.extensions">
     <title>Extensions &php; 3.0</title>
     <para>
      Les extensions écrites pour &php; 3.0 ne fonctionnent plus avec &php; 4.0,
      ni les exécutables, ni les codes sources. Il n'est pas difficile de
      porter les extensions de &php; 3.0 à 4.0 si vous avez accès aux
      sources originales. Une description détaillée du processus
      de portage ne fait pas partie de cet appendice (pour le moment).
     </para>
    </section>
    <section id="migration4.strings">
     <title>Substitution de variables dans les chaînes</title>
     <para>
      &php; 4.0 dispose d'un nouveau mécanisme de substitution des
      variables dans les chaînes. Vous pouvez désormais accéder aux
      membres d'objets et aux tableaux multidimensionnels dans une
      chaîne.
     </para>
     <para>
      Pour cela, il suffit de placer la variable entre accolades, le signe
      <literal>$</literal> suivant immédiatement la première accolade :
      <literal>{$variable['a']}</literal>
     </para>
     <para>
      Pour utiliser la valeur d'un membre d'objet dans une chaîne,
      il suffit d'écrire : <literal>"text {$obj->member} text"</literal>;
      alors qu'en &php; 3.0, il fallait faire comme ceci :
      <literal>"texte".$objet->membre." texte"</literal>.
     </para>
     <para>
      Cette technique rend le code beaucoup plus lisible, mais risque de
      poser des problèmes dans certains scripts &php; 3.0. Vous pouvez
      facilement traquer ce problème en recherche les séquences
      <literal>{$</literal> dans votre code, et en les remplaçant par
      <literal>\{$</literal> avec votre outil de remplacement habituel.
     </para>
    </section>
    <section id="migration4.cookies">
     <title>Cookies</title>
     <para>
      &php; 3.0 avait la mauvaise habitude d'envoyer les cookies dans l'ordre
      inverse de celui du code (l'ordre des appels à
      <function>setcookie</function>). &php; 4.0 rétablit l'ordre naturel
      en les envoyant dans le même ordre que vous même.
     </para>
     <para>
      Cela peut aussi prendre à contre-pied certains programmes, mais
      ce comportement était tellement étrange qu'il méritait un tel
      traitement un jour ou l'autre, pour éviter d'autres
      problèmes ultérieurs.
     </para>
    </section>
  <section id="migration4.variables">
   <title>Gestion des variables globales</title>
   <para>
    Alors que la gestion des variables globales a été surtout étudiée
    pour être simple en &php; 3 et aux premières versions de &php; 4,
    la sécurité est devenue la priorité avec les dernières versions.
    Alors qu'en &php; 3, le code suivant fonctionnait sans problème,
    en &php; 4, il faut utiliser <literal>unset($GLOBALS["id"]);</literal>. 
    Ce n'est qu'un des problème lié à la gestion des variables.
    Il faut toujours utiliser la variable <varname>$GLOBALS</varname> avec
    les nouvelles versions de &php;. Apprenez-en plus sur ce sujet
    dans la section <link linkend="references.global">Références globales</link>.
   </para>
   <example>
    <title>Migration des variables globales</title>
    <programlisting role="php">
<![CDATA[
<?php
  $id = 1;
  function test() {
    global $id;
    unset($id);
  }
  test();
  echo($id); 
  // Ceci va afficher 1 en PHP 4
?>
]]>
    </programlisting>
   </example>
  </section>
 </appendix>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
