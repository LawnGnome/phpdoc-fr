<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 343247 Maintainer: Jean-Baptiste Nahan Status: ready -->
<!-- Reviewed: no -->

<sect1 xml:id="migration72.incompatible">
 <title>Évolutions incompatibles avec les versions précédentes</title>

 <sect2 xml:id="migration72.incompatible.number_format-no-neg-zero">
  <title>Empêcher <function>number_format</function> de retourner zéro négatif</title>

  <para>
   Auparavant, il était possible pour la fonction 
   <function>number_format</function> retourne <literal>-0</literal>. 
   Bien que cela soit parfaitement valide conformément à la norme "IEEE 754 
   floating point spécification", cette bizarrerie n'était pas souhaitable 
   pour l’affichage des nombres mis en forme sous une forme lisible par l'homme.
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php

var_dump(number_format(-0.01)); // maintenant affiche string(1) "0" à la place de string(2) "-0"
]]>
   </programlisting>
  </informalexample>
 </sect2>

 <sect2 xml:id="migration72.incompatible.object-array-casts">
  <title>Conversion des clés numériques dans les objets et tableau lors de cast</title>

  <para>
   Les clé numériques sont maintenant mieux appréhendées lors de cast
   d'un tableau en objet et d'objet en tableau (cast explicite ou par 
   la fonction <function>settype</function>).
  </para>

  <para>
   Cela signifie que les clés représentées par un entier (ou un entier sous 
   forme de texte) d'un tableau casté en objet sont désormais accessibles :
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php

// tableau vers un objet
$arr = [0 => 1];
$obj = (object)$arr;
var_dump(
    $obj,
    $obj->{'0'}, // désormais accessible
    $obj->{0} // désormais accessible
);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
object(stdClass)#1 (1) {
  ["0"]=>    // désormais clé texte plutôt qu'une clé entière
  int(1)
}
int(1)
int(1)
]]>
   </screen>
  </informalexample>

  <para>
   Et entier (ou entier sous forme de texte) clés des objets casté en 
   tableaux sont désormais accessibles :
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php

// objet vers tableau
$obj = new class {
    public function __construct()
    {
        $this->{0} = 1;
    }
};
$arr = (array)$obj;
var_dump(
    $arr,
    $arr[0], // désormais accessible
    $arr['0'] // désormais accessible
);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
array(1) {
  [0]=>    // désormais clé entière plutôt qu'une clé texte
  int(1)
}
int(1)
int(1)
]]>
   </screen>
  </informalexample>
 </sect2>

 <sect2 xml:id="migration72.incompatible.no-null-to-get_class">
  <title>Interdire de passer &null; à <function>get_class</function></title>

  <para>
   Auparavent, passer &null; à la fonction <function>get_class</function>
   retournait le nom de la classe en cours. Ce comportement a été supprimé,
   une erreur <constant>E_WARNING</constant> est affiché à la place.
   Pour retrouver le même comportement qu'avant, l’argument devrait tout 
   simplement être supprimé.
  </para>
 </sect2>

 <sect2 xml:id="migration72.incompatible.warn-on-non-countable-types">
  <title>Avertir lors du comptage des types non dénombrable</title>

  <para>
   Un <constant>E_WARNING</constant> sera émis lors de la tentative de 
   d'utilisation de la fonction <function>count</function> sur un 
   type non dénombrable (cela inclus la fonction alias 
   <function>sizeof</function>).
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php

var_dump(
    count(1), // un entier n'est pas dénombrable
    count('abc'), // une chaîne n'est pas dénombrable
    count(new stdclass), // un objet qui n'implémente pas l'interface Countable n'est pas dénombrable
    count([1,2]) // un tableau est dénombrable
);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Warning: count(): Parameter must be an array or an object that implements Countable in %s on line %d

Warning: count(): Parameter must be an array or an object that implements Countable in %s on line %d

Warning: count(): Parameter must be an array or an object that implements Countable in %s on line %d
int(1)
int(1)
int(1)
int(2)
]]>
   </screen>
  </informalexample>
 </sect2>

 <sect2 xml:id="migration72.incompatible.hash-ext-to-objects">
  <title>Remplacement ext/hash de ressources en objets</title>

  <para>
   Dans le cadre de la migration à long terme de ressources, l’extension 
   Hash a été mis à jour pour utiliser les objets au lieu de ressources. 
   Le changement devrait être transparent pour les développeurs PHP, à 
   l’exception où des vérifications avec <function>is_resource</function> 
   ont été faites (il sera nécessaire de remplacer par 
   <function>is_object</function>).
  </para>
 </sect2>

 <sect2 xml:id="migration72.incompatible.ssl-tls-defaults">
  <title>Améliorer les valeurs par défaut SSL/TLS</title>

  <para>
   Les modifications suivantes concernant les valeurs par défaut ont été apportées :
  </para>

  <itemizedlist>
   <listitem>
    <simpara>
     <literal>tls://</literal> maintenant par défaut TLSv1.0 ou TLSv1.1 ou TLSv1.2
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <literal>ssl://</literal> est un alias de <literal>tls://</literal>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <literal>STREAM_CRYPTO_METHOD_TLS_*</literal> constantes par défaut de 
     TLSv1.0 ou TLSv1.1 + TLSv1.2, à la place de TLSv1.0 uniquement.
    </simpara>
   </listitem>
  </itemizedlist>
 </sect2>
</sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
