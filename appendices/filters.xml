<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.3 $ -->
<appendix id="filters">
 <title>Liste des filtres standards</title>
 <para>
  Cette section contient la liste des filtres de flux, à utiliser
  avec <function>stream_filter_append</function>.
  Votre version de &php; peut avoir des filtres supplémentaires,
  ou manquants par rapport à cette liste.
 </para>

 <para>
  Il est bon de noter une légère différence entre 
  <function>stream_filter_append</function>
  et <function>stream_filter_prepend</function>.  
  Tous les flux &php; disposent d'un petit <emphasis>buffer de lecture</emphasis>,
  où ils stockent des blocs de données lues dans le système
  de fichiers, ou dans d'autres sources, afin de les
  traiter plus efficacement. Aussitôt que les données sont
  lues depuis la ressource dans le buffer interne, les données
  sont immédiatement passées au filtre, même si l'application
  &php; n'est pas prête pour lire ces données.
  Si des données sont déjà en attente dans le buffer lorsqu'un
  filtre est ajouté au flux, ces données seront immédiatement
  passées au filtre, pour que la modification soit transparente.
  Mais si vous ajoutez un filtre avec prepend, les données
  <emphasis>NE seront PAS</emphasis> filtrées. Elles 
  attendront que le prochain bloc arrive de la ressource.
 </para>

 <para>
  Pour avoir la liste complète des filtres de votre version de
  &php;, utilisez la fonction <function>stream_get_filters</function>.
 </para>

 <section id="filters.string">
  <title>Filtres de chaînes de caractères</title>

  <simpara>
   Chaque filtre fait ce que son nom implique, et correspond au
   comportement de la fonction &php; correspondante. Pour plus de
   détails sur un filtre, reportez vous au manuel de la fonction
   correspondante.
  </simpara>

  <para>
   <table>
    <title>
     Filtres de chaînes de caractères
    </title>
    <tgroup cols="4">
     <thead>
      <row>
       <entry>Nom</entry>
       <entry>Fonction &php; équivalente</entry>
       <entry>Version</entry>
       <entry>Paramètres</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><literal>string.rot13</literal></entry>
       <entry>
        <function>str_rot13</function>
       </entry>
       <entry>&php; 4.3.0</entry>
       <entry>Aucun</entry>
      </row>
      <row>
       <entry><literal>string.toupper</literal></entry>
       <entry>
        <function>strtoupper</function>
       </entry>
       <entry>&php; 5.0.0</entry>
       <entry>Aucun</entry>
      </row>
      <row>
       <entry><literal>string.tolower</literal></entry>
       <entry>
        <function>strtolower</function>
       </entry>
       <entry>&php; 5.0.0</entry>
       <entry>Aucun</entry>
      </row>
      <row>
       <entry><literal>string.strip_tags</literal></entry>
       <entry>
        <function>strip_tags</function>
       </entry>
       <entry>&php; 5.0.0</entry>
       <entry>
        Une chaîne contenant les balises autorisées, similairement
        au second paramètre de <function>strip_tags</function>.
        Peut aussi être un tableau contenant une liste de balises,
        sans les symboles &lt;&gt;.
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </para>
 </section>

 <section id="filters.convert">
  <title>Filtres de conversion</title>

  <simpara>
   Comme pour les filtres de chaînes, les filtres de conversion
   font ce que leur nom indique. Pour plus d'informations, voyez
   le manuel de la fonction correspondante.
  </simpara>

  <para>
   <table>
    <title>Filtres de conversion</title>
    <tgroup cols="4">
     <thead>
      <row>
       <entry>Nom</entry>
       <entry>Fonction &php; équivalente</entry>
       <entry>Version</entry>
       <entry>Paramètres</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><literal>convert.base64-encode</literal></entry>
       <entry>
        <function>base64_encode</function>
       </entry>
       <entry>&php; 5.0.0</entry>
       <entry>
        Si les paramètres sont fournis sous forme de tableau,
        <literal>convert.base64-encode</literal> va insérer la valeur de 
        <literal>$parameters['line-break-chars']</literal> tous les
        <literal>$parameters['line-length']</literal>
        caractères du texte base64. Cela permet le formatage automatique
        du résultat, qui peut être fait avec
        <function>chunk_split</function>.
       </entry>
      </row>
      <row>
       <entry><literal>convert.base64-decode</literal></entry>
       <entry>
        <function>base64_decode</function>
       </entry>
       <entry>&php; 5.0.0</entry>
       <entry>None</entry>
      </row>
      <row>
       <entry><literal>convert.quoted-printable-encode</literal></entry>
       <entry>
        None.  C'est le contraire du filtre quoted-printable-decode.
       </entry>
       <entry>&php; 5.0.0</entry>
       <entry>
        <literal>line-break-chars</literal> et <literal>line-length</literal> sont
        supportés de la même façon que pour <literal>convert.base64-encode</literal>. 
        En plus, les index <literal>binary</literal> et <literal>force-encode-first</literal> 
        sont supportés, avec comme valeur par défaut &false;.
       </entry>
      </row>
      <row>
       <entry><literal>convert.quoted-printable-decode</literal></entry>
       <entry>
        <function>quoted_printable_decode</function>
       </entry>
       <entry>&php; 5.0.0</entry>
       <entry>
        Si <literal>line-break-chars</literal> est spécifié durant le processus
        d'encodage, il faut l'indiquer à nouveau ici pour qu'il soit correctement
        supprimé lors du décodage.
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </para>

 </section>

 <section id="filters.compression">
  <title>Filtres de compression</title>

  <simpara>
   Alors que les <xref linkend="wrappers.compression"/> fournissent un moyen
   pour générer des fichiers aux formats gzip et bz2, ils ne permettent pas
   de gérer les protocoles réseau compressés, ni de commencer avec un flux non
   compressé pour le transformer en flux compressé. Pour faire cela, il faut
   appliquer un filtre de compression.
  </simpara>

  <note>
   <simpara>
    Les filtres de compression <emphasis>ne génère pas</emphasis> les entêtes
    et fin de fichiers, comme le fait l'utilitaire <literal>gzip</literal>. 
    Ils ne font que compresser et décompresser des portions de flux de données.
   </simpara>
  </note>

  <simpara>
   <literal>zlib.deflate</literal> (compression) et
   <literal>zlib.inflate</literal> (decompression) sont les implémentations
   des méthodes de compression présentées dans la <ulink url="&url.rfc;1951">RFC 1951</ulink>.
   Le filtre <literal>deflate</literal> prend jusqu'à trois paramètres, passés sous
   la forme de tableau associatif.
  </simpara>
  <simpara>
   <parameter>level</parameter> spécifie le niveau de compression souhaité,
   de 1 à 9. Plus le niveau est haut, meilleure est la compression, et plus
   cher est le coût de compression. Deux niveaux de compression spéciaux existent : 
   0, qui représente l'absence de compression, et -1, qui
   représente le niveau par défaut de la bibliothèque zlib : actuellement, c'est 6.
  </simpara>
  <simpara>
   <parameter>window</parameter> est la taille du buffer mémoire, en base 2. 
   Les valeurs supérieures, jusqu'à 15, soit 32768 octets, donnent de meilleures 
   compressions, et les valeurs inférieures, jusqu'à 9, soit 512 octets, occupent
   le moins d'espace en mémoire. Par défaut, <parameter>window</parameter> 
   vaut actuellement <constant>15</constant>.
  </simpara>
  <simpara>
   <parameter>memory</parameter> est une indication du niveau de mémoire nécessaire.
   Les valeurs valides vont de 1, pour l'allocation minimale, à 9, pour une allocation
   maximale. L'allocation de mémoire affecte la vitesse d'exécution, et non pas le
   coût global.
  </simpara>

  <note>
   <simpara>
    Comme le niveau de compression est le paramètre le plus courant, il peut
    aussi être fourni en passant un entier comme paramètre, au lieu d'un tableau.
   </simpara>
  </note>

  <note>
   <simpara>
    Les filtres zlib.* ne sont pas intégrés au coeur de PHP. Pour activer
    ces filtres en &php; 5, installez le paquet
    <ulink url="&url.pecl.package;zlib_filter">zlib_filter</ulink>
    depuis <ulink url="&url.pecl;">PECL</ulink>. Ces filtres 
    <emphasis>ne sont pas</emphasis> disponibles en &php; 4.
   </simpara>
  </note>

  <example>
   <title>
    <literal>zlib.deflate</literal> et
    <literal>zlib.inflate</literal>
   </title>
   <programlisting role="php">
<![CDATA[
<?php
$params = array('level' => 6, 'window' => 15, 'memory' => 9);

$original_text = "This is a test.\nThis is only a test.\nThis is not an important string.\n";
echo "Le texte original est long de " . strlen($original_text) . " octets.\n";

$fp = fopen('test.deflated', 'w');
stream_filter_append($fp, 'zlib.deflate', STREAM_FILTER_WRITE, $params);
fwrite($fp, $original_text);
fclose($fp);

echo "Le fichier compressé fait " . filesize('test.deflated') . " octets de long.\n";
echo "Le texte original était :\n";
/* Utilise readfile et zlib.inflate pour décompresser à la volée */
readfile('php://filter/zlib.inflate/resource=test.deflated');

/* Affiche : 

Le texte original est long de 70 octets
Le fichier compressé fait 56 octets de long.
Le texte original était :
This is a test.
This is only a test.
This is not an important string.

 */
?>
]]>
   </programlisting>
  </example>

  <example>
   <title>
    simple <literal>zlib.deflate</literal>
   </title>
   <programlisting role="php">
<![CDATA[
<?php
$original_text = "This is a test.\nThis is only a test.\nThis is not an important string.\n";
echo "Le texte original est long de " . strlen($original_text) . " octets.\n";

$fp = fopen('test.deflated', 'w');
/* Ici, "6" indique le niveau de compression de 6 */
stream_filter_append($fp, 'zlib.deflate', STREAM_FILTER_WRITE, 6);
fwrite($fp, $original_text);
fclose($fp);

echo "Le fichier compressé fait " . filesize('test.deflated') . " octets de long.\n";

/* Affiche : 

Le texte original est long de 70 octets
Le fichier compressé fait 56 octets de long.

 */
?>
]]>
   </programlisting>
  </example>

  <simpara>
   <literal>bzip2.compress</literal> et
   <literal>bzip2.decompress</literal>
   fonctionnent de la même anière que les filtres zlib.
  </simpara>
  <simpara>
   Le filtre <literal>bzip2.compress</literal> accepte jusqu'à 2 paramètres,
   sous la forme d'un tableau associatif : 
  </simpara>
  <simpara>
   <parameter>blocks</parameter> est une valeur entière, de 1 à 9,
    an integer value
   from 1 to 9 specifying the number of 100kbyte blocks of memory to allocate for
   workspace. 
  </simpara>
  <simpara>
   <parameter>work</parameter> est aussi un entier dont la valeur va de 
   0 à 250, et qui indique le niveau d'efforts fournis avec une méthode de 
   compression avant de passer à une autre méthode, plus lente. Modifier ce 
   paramètre n'a qu'un effet sur la vitesse de compression. Le gain d'espace
   ou la mémoire utilisée restent les mêmes. Un niveau de 0 indique que la
   bibliothèque doit utiliser sa configuration par défaut.
  </simpara>
  <simpara>
   Le filtre <literal>bzip2.decompress</literal> accepte uniquement un paramètre,
   qui peut être passé sous la forme d'un booléen associé à l'index 
   <parameter>small</parameter>.
  </simpara>
  <simpara>
   <parameter>small</parameter>, lorsqu'il vaut &true;, indique à la bibliothèque
   bzip qu'elle doit faire une décompression en utilisant le moins de mémoire
   possible, aux dépends de la vitesse.
  </simpara>

  <note>
   <simpara>
    Les filtres bzip2.* ne sont pas inclus dans la distribution &php;. Pour activer
    ces filtres en &php; 5, installez le paquet 
    <ulink url="&url.pecl.package;bz2_filter">bz2_filter</ulink> depuis 
    <ulink url="&url.pecl;">PECL</ulink>. Ces filtres <emphasis>ne sont pas</emphasis>
    disponibles pour &php; 4.
   </simpara>
  </note>

  <example>
   <title>
    <literal>bzip2.compress</literal> et
    <literal>bzip2.decompress</literal>
   </title>
   <programlisting role="php">
<![CDATA[
<?php
$param = array('blocks' => 9, 'work' => 0);

echo "Le texte original est long de " . strlen(LICENSE) . " octets.\n";

$fp = fopen('LICENSE.compressed', 'w');
stream_filter_append($fp, 'bzip2.compress', STREAM_FILTER_WRITE, $param);
fwrite($fp, file_get_contents('LICENSE'));
fclose($fp);

echo "Le fichier compressé fait " . filesize('LICENSE.compressed') . " octets de long.\n";

/* Affiche : 

Le texte original est long de 3288 octets.
Le fichier compressé fait 1488 octets de long.

 */
?>
]]>
   </programlisting>
  </example>
 </section>
</appendix>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
