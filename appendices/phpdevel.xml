<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.28 $ -->
<!-- EN-Revision: 1.25 Maintainer: dams Status: ready -->
<appendix id="phpdevel">
 <title>Développement &php;</title>
 <simpara>
  Cette section est très ancienne, et aborde surtout l'extension de 
  &php; 3. SI vous êtes interessés à &php; 4, lisez la section sur
  l'<link linkend="zend">API Zend</link>. De plus, vous pouvez lire
  les différentes sources de &php;, et des fichiers comme
  <filename>README.SELF-CONTAINED-EXTENSIONS</filename> et 
  <filename>README.EXT_SKEL</filename>.
 </simpara>

 <sect1 id="phpdevel-addfunc">
  <title>Créer une fonction &php; 3</title>
  <sect2 id="phpdevel-addfunc-prototype">
   <title>Prototypes de fonctions</title>
   <para>
    Toutes les fonctions suivent le schéma suivant :
    <programlisting role="c">
<![CDATA[
void php3_foo(INTERNAL_FUNCTION_PARAMETERS) {
}
]]>
    </programlisting>
    Même si votre fonction ne prend aucun argument, c'est comme cela
    qu'elle doit être appelée.
   </para>
  </sect2>
  <sect2 id="phpdevel-addfunc-args">
   <title>Arguments de fonctions</title>
   <para>
    Les arguments sont toujours de type val. Ce type contient un membre de type
    union, qui indique le type reél d'argument. De cette façon,
    si votre fonction prend deux arguments, elle ressemble à ceci :
  </para>
   <para>
    <example>
     <title>Argument de fonction de lecture</title>
     <programlisting role="c">
<![CDATA[
pval *arg1, *arg2;
if (ARG_COUNT(ht) != 2 || getParameters(ht,2,&arg1,&arg2)==FAILURE) {
   WRONG_PARAM_COUNT;
}
]]>
     </programlisting>
    </example>
    NOTE : Les arguments peuvent être passé par valeur ou par
    référence. Dans les deux cas, vous devez passer &(pval *)
    à getParameters. Si vous voulez vérifier que le n-ième
    paramètre a été passé par référence
    ou par valeur, vous devez utiliser la fonction
    ParameterPassedByReference(ht,n). Elle retournera 1 ou 0.
   </para>
   <simpara>
    Lorsque vous modifiez l'un des paramètres, qu'ils soient envoyés
    par référence ou par valeur, vous pouvez le passer à
    pval_destructor pour le réinitialiser, ou, s'il s'agit d'un tableau et
    que vous voulez ajouter des valeurs, vous pouvez utiliser des fonctions
    similaires à celles qui sont dans internal_functions.h, qui manipule
    return_value comme tableau.
   </simpara>
   <simpara>
    Par ailleurs, si vous modifiez un paramètre en IS_STRING, assurez-vous
    que vous avez bien assigné un nouvelle chaîne avec estrdup()
    et une nouvelle longueur de chaîne. Seulement après, vous pouvez
    modifier le type en IS_STRING. Si vous modifiez une chaîne en IS_STRING
    ou IS_ARRAY vous devez d'abord appeler le destructeur pval_destructor.
   </simpara>
  </sect2>
  <sect2 id="phpdevel-addfunc-varargs">
   <title>Fonctions à nombre d'arguments variable</title>
   <para>
    Une fonction peut prendre un nombre variable d'arguments. Si votre fonction peut
    prendre deux ou trois arguments, utiliser la syntaxe suivante :
  </para>
   <para>
    <example>
     <title>Fonctions à nombre d'arguments variable</title>
     <programlisting role="c">
<![CDATA[
pval *arg1, *arg2, *arg3;
int arg_count = ARG_COUNT(ht);
if (arg_count < 2 || arg_count > 3 ||
    getParameters(ht,arg_count,&arg1,&arg2,&arg3)==FAILURE) {
    WRONG_PARAM_COUNT;
}
]]>
    </programlisting>
    </example>
   </para>
  </sect2>
  <sect2 id="phpdevel-addfunc-using-args">
   <title>Utiliser les arguments d'une fonction</title>
   <para>
    Le type de chaque argument est stocké dans le champ pval. Ce champ peut
    prendre les valeurs suivantes :
    <table>
     <title>Types de données internes &php;</title>
     <tgroup cols="2">
      <tbody>
       <row>
        <entry>IS_STRING</entry>
        <entry>Chaîne de caractères</entry>
       </row>
       <row>
        <entry>IS_DOUBLE</entry>
        <entry>Nombre à virgule flottante, en précision double</entry>
       </row>
       <row>
        <entry>IS_LONG</entry>
        <entry>Entier long</entry>
       </row>
       <row>
        <entry>IS_ARRAY</entry>
        <entry>Tableau</entry>
       </row>
       <row>
        <entry>IS_EMPTY</entry>
        <entry>Aucune</entry>
       </row>
       <row>
        <entry>IS_USER_FUNCTION</entry>
        <entry>??</entry>
       </row>
       <row>
        <entry>IS_INTERNAL_FUNCTION</entry>
        <entry>?? (Si ce type ne peut pas être passé à
               une fonction, effacez-le)
        </entry>
       </row>
       <row>
        <entry>IS_CLASS</entry>
        <entry>??</entry>
       </row>
       <row>
        <entry>IS_OBJECT</entry>
        <entry>??</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>
   <para>
    Si vous recevez un argument d'un type, et que vous voulez l'utiliser
    avec un autre type, ou si vous voulez simplement forcer le type, vous
    pouvez utiliser l'une des fonctions de conversion suivantes :
    <programlisting role="c">
<![CDATA[
convert_to_long(arg1);
convert_to_double(arg1);
convert_to_string(arg1);
convert_to_boolean_long(arg1);
/* Si la chaîne est "" ou "0" elle devient 0, 1 sinon */
convert_string_to_number(arg1);
/* Convertit une chaîne en LONG ou DOUBLE suivant la chaîne */
]]>
     </programlisting>
   </para>
   <simpara>
    Ces fonctions convertissent sur place : elles ne retournent aucune valeur.
   </simpara>
   <para>
    La valeur de l'argument est enregistrée dans une union. Les membres sont :
    <itemizedlist>
     <listitem><simpara>IS_STRING : <literal>arg1->value.str.val</literal></simpara></listitem>
     <listitem><simpara>IS_LONG : <literal>arg1->value.lval</literal></simpara></listitem>
     <listitem><simpara>IS_DOUBLE : <literal>arg1->value.dval</literal></simpara></listitem>
    </itemizedlist>
   </para>
  </sect2>
  <sect2 id="phpdevel-addfunc-memmgmt">
   <title>Gestion de la mémoire dans une fonction</title>
   <simpara>
    Toute la mémoire nécessaire à une fonction doit être
    allouée avec emalloc() ou estrdup().  Ces fonctions ont le goût et l'odeur
    des fonctions C classiques malloc() et strdup(). La mémoire doit être
    libérée avec efree().
   </simpara>
   <simpara>
    Il y a deux types de mémoire dans ce programme : la mémoire qui est
    retournée à l'analyseur, et la mémoire qui nécessaire
    pour le stockage temporaire dans la fonction. Lorsque vous assignez une
    chaîne dans une variable qui est retournée à l'analyseur,
    assurez-vous de bien allouer la mémoire avec emalloc() ou estrdup().
    Cette mémoire ne doit JAMAIS être libérée, sauf si
    vous réécrivez votre original plus loin, dans la même
    fonction (mais ce n'est pas de la programmation propre).
   </simpara>
   <simpara>
    Pour tous vos besoins en mémoire temporaire/permanante dont vous avez
    besoin dans vos fonctions/librairies, vous devez utiliser les fonctions
    emalloc(), estrdup() et efree(). Elles se comportent EXACTEMENT comme leurs
    homologues. Tout ce qui est créé avec emalloc() ou estrdup()
    doit être libéré avec efree() à un moment ou un
    autre, à moins que ce ne soit utile ailleurs dans le programme;
    sinon, il va y avoir une fuite de mémoire. La signification de
    "Elles se comportent EXACTEMENT comme leurs homologues" est que si vous
    libérez une variable qui n'a pas été créée
    avec emalloc() ou estrdup(), vous courez droit à au crash
    ("segmentation fault").  Soyez alors extrêmement prudent, et
    libérez toute votre mémoire inutilisée.
   </simpara>
   <simpara>
    Si vous compilez avec "-DDEBUG", &php; 3 affichera la liste de tous les appels
    à emalloc() et estrdup() mais jamais à efree() lorsque celui-ci
    intervient dans un script spécifié.
   </simpara>
  </sect2>
  <sect2 id="phpdevel-addfunc-symtab">
   <title>Affecter une variable dans la table des symboles</title>
   <para>
    Un grand nombre de macros sont disponibles pour rendre plus facile l'insertion de
    variables dans la table des symboles :
    <itemizedlist>
     <listitem><simpara>SET_VAR_STRING(name,value)</simpara></listitem>
     <listitem><simpara>SET_VAR_DOUBLE(name,value)</simpara></listitem>
     <listitem><simpara>SET_VAR_LONG(name,value)</simpara></listitem>
    </itemizedlist>
   </para>
   <warning>
    <para>
    Soyez prudent avec la constante SET_VAR_STRING. La valeur doit être 
    placée dans une portion de
    mémoire créée avec <literal>malloc()</literal>, sinon le gestionnaire de
    mémoire essayera de libérer le pointeur plus tard. Ne passez
    aucune mémoire allouée statiquement à SET_VAR_STRING.
    </para>
   </warning>
   <simpara>
    Les tables des symboles de &php; est une table de hash. A n'importe quel moment,
    &amp;symbol_table est un pointeur sur la table principale, et
    active_symbol_table pointe sur la table actuellement utilisée.
    (ces deux tables peuvent être identiques au démarrage, ou
    différent, suivant que vous êtes dans une fonction ou non).
   </simpara>
   <para>
    Les exemples suivants utilisent 'active_symbol_table'. Vous devriez la remplacer
    par &amp;symbol_table si vous voulez travailler sur la table principale.
    De plus, les mêmes fonctions peuvent être appliquées
    à des tableaux, comme expliqué ci-dessous.
   </para>
   <para>
    <example>
     <title>
       Vérification de l'existence de <varname>$foo</varname> dans
       la table des symboles
     </title>
     <programlisting role="php">
<![CDATA[
if (hash_exists(active_symbol_table,"foo",sizeof("foo"))) {
 // existe...
} else {
 // n'existe pas
}
]]>
     </programlisting>
    </example>
    <example>
     <title>Rechercher la taille d'une variable dans la table des symboles</title>
     <programlisting role="c">
<![CDATA[
hash_find(active_symbol_table,"foo",sizeof("foo"),&pvalue);
check(pvalue.type);
]]>
     </programlisting>
    </example>
    En &php; 3.0, les tableaux sont implémentés en utilisant les
    mêmes tables de hash que les variables. Cela signifie que les deux
    fonctions ci-dessus peuvent être appelées pour vérifier
    la présence de variables dans un tableau.
   </para>
   <simpara>
    Si vous voulez définir un nouveau tableau dans la table des symboles,
    utilisez le code suivant.
   </simpara>
   <simpara>
    D'abord, vous devez vérifier qu'il n'existe pas, avec hash_exists() ou
    hash_find().
   </simpara>
   <simpara>
    Puis, initialisez le tableau :
   </simpara>
   <para>
    <example>
     <title>Initialisation d'un tableau</title>
     <programlisting role="c">
<![CDATA[
pval arr;
if (array_init(&arr) == FAILURE) { /*Initialiation échouée*/ };
hash_update(active_symbol_table,"foo",sizeof("foo"),&arr,sizeof(pval),NULL);
]]>
     </programlisting>
    </example>
    Ce code déclare un nouveau tableau, appelé <varname>$foo</varname>, dans la table
    de symbole. Ce tableau est vide.
   </para>
   <simpara>
     Voici comment ajouter deux nouvelles entrées dans ce tableau :
   </simpara>
   <para>
    <example>
     <title>Ajout d'entrées dans un tableau.</title>
     <programlisting role="c">
<![CDATA[
pval entry;
entry.type = IS_LONG;
entry.value.lval = 5;
/* définit $foo["bar"] = 5 */
hash_update(arr.value.ht,"bar",sizeof("bar"),&entry,sizeof(pval),NULL);
/* définit $foo[7] = 5 */
hash_index_update(arr.value.ht,7,&entry,sizeof(pval),NULL);
/* définit la prochaine place libre dans $foo[],
 * $foo[8], qui sera 5 (comme en php2)
 */
hash_next_index_insert(arr.value.ht,&entry,sizeof(pval),NULL);
]]>
     </programlisting>
    </example>
    Si vous voulez modifier une valeur que vous avez inséré dans une
    table de hash, vous devez d'abord la lire dans la table. Pour éviter
    cette recherche, vous pouvez fournir une pval ** à la fonction d'ajout
    dans la table de hash, et elle modifiera la valeur à l'adresse pval *,
    avec la valeur donnée. Si cette valeur est &null;, (comme dans tous les
    exemples ci dessus), ce paramètre sera ignoré.
   </para>
   <simpara>
    hash_next_index_insert() utiliser plus ou moins la même logique que
    <literal>$foo[] = bar;</literal> in &php; 2.0.
   </simpara>
   <simpara>
    Si vous construisez un tableau, pour le retourner, vous pouvez l'initialiser
    comme ceci :
   </simpara>
   <programlisting role="c">
<![CDATA[
if (array_init(return_value) == FAILURE) { échec...; }
]]>
   </programlisting>
   <simpara>
    puis ajouter les valeurs grâces aux macros :
   </simpara>
   <programlisting role="c">
<![CDATA[
add_next_index_long(return_value,long_value);
add_next_index_double(return_value,double_value);
add_next_index_string(return_value,estrdup(string_value));
]]>
   </programlisting>
   <para>
    Bien sûr, si l'ajout n'est pas fait juste après l'initialisation,
    vous devrez d'abord rechercher le tableau :
    <programlisting role="c">
<![CDATA[
pval *arr;
if (hash_find(active_symbol_table,"foo",sizeof("foo"),(void **)&arr)==FAILURE)
{ introuvable... }
else
{ utilisez arr->value.ht... }
]]>
    </programlisting>
   </para>
   <simpara>
    Notez que hash_find reçoit un pointeur sur un pointeur sur pval, et pas un
    pointeur sur pval.
   </simpara>
   <simpara>
    Toutes les fonctions d'accès aux hash retourne &true; (SUCCES) ou
    &false; (FAILURE), excepté hash_exists(), qui retourne un booléen.
   </simpara>
   </sect2>
  <sect2 id="phpdevel-addfunc-retsimple">
   <title>Retourne une valeur simple</title>
   <simpara>
    Un grand nombre de macros sont disponible pour simplifier le retour des valeurs.
  </simpara>
   <para>
    La macro RETURN_* fixe la valeur de retour, et termine la fonction :
    <itemizedlist>
     <listitem><simpara>RETURN</simpara></listitem>
     <listitem><simpara>RETURN_FALSE</simpara></listitem>
     <listitem><simpara>RETURN_TRUE</simpara></listitem>
     <listitem><simpara>RETURN_LONG(l)</simpara></listitem>
     <listitem>
      <simpara>
       RETURN_STRING(s,dup)   Si dup est &true;, duplique la chaîne.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       RETURN_STRINGL(s,l,dup) retourne la chaîne (s) en spécifiant
       la longueur (l).
      </simpara>
     </listitem>
     <listitem><simpara>RETURN_DOUBLE(d)</simpara></listitem>
    </itemizedlist>
   </para>
   <para>
    La macro RETVAL_* macros fixe la valeur de retour, mais ne termine pas la fonction.
    <itemizedlist>
     <listitem><simpara>RETVAL_FALSE</simpara></listitem>
     <listitem><simpara>RETVAL_TRUE</simpara></listitem>
     <listitem><simpara>RETVAL_LONG(l)</simpara></listitem>
     <listitem>
      <simpara>
       RETVAL_STRING(s,dup)   Si dup est &true;, duplique la
       chaîne
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       RETVAL_STRINGL(s,l,dup) retourne la chaîne (s) en
       spécifiant la longueur (l).
      </simpara>
     </listitem>
     <listitem><simpara>RETVAL_DOUBLE(d)</simpara></listitem>
    </itemizedlist>
   </para>
   <simpara>
    Les macros ci-dessus vont utiliser estrdup() sur les arguments passés.
    Cela vous permet de libérer tranquillement les arguments après
    avoir appelé cette fonction, ou bien, utiliser de la mémoire
    allouée statiquement.
   </simpara>
   <simpara>
    Si votre fonction retourne un booléen de succès/erreur,
    utilisez toujours RETURN_TRUE et RETURN_FALSE respectivement.
   </simpara>
  </sect2>
  <sect2 id="phpdevel-addfunc-retcomplex">
   <title>Retourner des valeurs complexes</title>
   <simpara>
    Votre fonction peut aussi retourner des valeurs complexes, tels que des objets ou
    tableaux.
   </simpara>
   <para>
    Retourner un objet :
    <orderedlist numeration="arabic">
     <listitem>
      <simpara>
       Appeler object_init(return_value).
      </simpara>
     </listitem>
     <listitem>
      <para>
       Remplissez les valeurs. Les fonctions utilisables sont listées ci
       dessous.
      </para>
     </listitem>
     <listitem>
      <para>
       Eventuellement, enregistrez les fonctions pour cet objet.
       Afin de lire des valeurs de cet objet, la fonction doit lire dans "this",
       dans la table de symbole active active_symbol_table. Son type doit être
       IS_OBJECT, et c'est une table de hash basique.  (i.e., vous pouvez utiliser
       les fonctions habituelles de .value.ht).  L'enregistrement reél
       peut être fait comme suit :
       <programlisting role="c">
<![CDATA[
add_method( return_value, function_name, function_ptr );
]]>
       </programlisting>
      </para>
     </listitem>
    </orderedlist>
   </para>
   <para>
    Les fonctions d'accès aux objets sont :
    <itemizedlist>
     <listitem>
      <simpara>
       add_property_long( return_value, property_name, l )
       - Ajoute un membre nommé 'property_name', de type long,
       égal à 'l'
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       add_property_double( return_value, property_name, d )
       - Idem, ajoute un double
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       add_property_string( return_value, property_name, str )
       - Idem, ajoute une chaîne
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       add_property_stringl( return_value, property_name, str, l )
       - Idem, ajoute une chaîne de longueur 'l'.
      </simpara>
     </listitem>
    </itemizedlist>
   </para>
   <para>
    Retournez un tableau :
     <orderedlist numeration="arabic">
      <listitem>
       <simpara>
        Appelez array_init(return_value).
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Remplissez les valeurs. Les fonctions disponibles sont listées
       ci-dessous.
      </simpara>
     </listitem>
    </orderedlist>
   </para>
   <para>
    Les fonctions utilisées pour accéder à un tableau sont :
    <itemizedlist>
     <listitem><simpara>add_assoc_long(return_value,key,l) - Ajoute une entrée
     associative avec la clé 'key' et la valeur 'l', de type long</simpara></listitem>
     <listitem><simpara>add_assoc_double(return_value,key,d) - Ajoute une entrée
     associative avec la clé 'key' et la valeur 'l', de type double</simpara></listitem>
     <listitem><simpara>add_assoc_string(return_value,key,str,duplicate)</simpara></listitem>
     <listitem><simpara>add_assoc_stringl(return_value,key,str,length,duplicate)
     spécifie la taille d'une chaîne</simpara></listitem>
     <listitem><simpara>add_index_long(return_value,index,l) - Ajoute
     une entrée d'index index' avec la valeur 'l', de type long</simpara></listitem>
     <listitem><simpara>add_index_double(return_value,index,d)</simpara></listitem>
     <listitem><simpara>add_index_string(return_value,index,str)</simpara></listitem>
     <listitem><simpara>add_index_stringl(return_value,index,str,length)
     - spécifie la longueur de la chaîne.</simpara></listitem>
     <listitem><simpara>add_next_index_long(return_value,l) - ajoute une entrée tableau,
     dans le prochain offset libre, de longueur 'l', de type long</simpara></listitem>
     <listitem><simpara>add_next_index_double(return_value,d)</simpara></listitem>
     <listitem><simpara>add_next_index_string(return_value,str)</simpara></listitem>
     <listitem><simpara>add_next_index_stringl(return_value,str,length)
     - spécifie la taille d'une chaîne</simpara></listitem>
    </itemizedlist>
   </para>
  </sect2>
  <sect2 id="phpdevel-addfunc-reslist">
   <title>Utiliser la liste des ressources</title>
   <simpara>
    &php; 3.0 dispose de standards pour traiter un certains nombre de ressources.
    Ils remplacent tous les listes de &php; 2.0.
   </simpara>
   <para>
    Fonctions accessibles :
    <itemizedlist>
     <listitem><simpara>php3_list_insert(ptr, type) - retourne l'identifiant 'id'
       de la nouvelle ressource insérée.</simpara></listitem>
     <listitem><simpara>php3_list_delete(id) - efface la ressource
       d'identifiant id</simpara></listitem>
     <listitem><simpara>php3_list_find(id,*type)
       - retourne le pointeur de la ressource d'identifiant id,
       et modifie le type 'type'</simpara></listitem>
    </itemizedlist>
    Typiquement, ces fonctions sont utilisées pour les pilotes SQL, mais elles peuvent
    servir n'importe quoi d'autre. Par exemple, conserver un pointeur de fichier.
   </para>
   <simpara>
    La liste standard de code ressemble à ceci :
   </simpara>
   <para>
    <example>
     <title>Ajouter une nouvelle ressource</title>
     <programlisting role="c">
<![CDATA[
RESOURCE *resource;
/* ...alloue de la mémoire pour la ressource, et l'acquiert ... */
/* Ajoute la nouvelle ressource dans la liste */
return_value->value.lval = php3_list_insert((void *) resource, LE_RESOURCE_TYPE);
return_value->type = IS_LONG;
]]>
     </programlisting>
    </example>
    <example>
     <title>Utiliser une ressource existante</title>
     <programlisting role="c">
<![CDATA[
pval *resource_id;
RESOURCE *resource;
int type;
convert_to_long(resource_id);
resource = php3_list_find(resource_id->value.lval, &type);
if (type != LE_RESOURCE_TYPE) {
    php3_error(E_WARNING,"resource index %d has the wrong type",resource_id->value.lval);
    RETURN_FALSE;
}
/* ...utiliser la ressource... */
]]>
     </programlisting>
    </example>
    <example>
     <title>Effacer une ressource existante</title>
     <programlisting role="c">
<![CDATA[
pval *resource_id;
RESOURCE *resource;
int type;
convert_to_long(resource_id);
php3_list_delete(resource_id->value.lval);
]]>
     </programlisting>
    </example>
    Les types de ressources doivent être enregistré dans le fichier
    php3_list.h, dans l'énumération list_entry_type.  En plus, il
    faut penser à ajouter une fonction de terminaison, pour chaque type
    de ressource défini, dans le fichier list.c, pour la fonction
    list_entry_destructor() (même si vous n'avez rien de particulier
    à faire lors de la terminaison, vous devez au moins ajouter un cas vide.
   </para>
  </sect2>
  <sect2 id="phpdevel-addfunc-prestable">
   <title>Utiliser la table des ressources persistantes.</title>
   <para>
    &php; 3.0 dispose d'une lieu de stockage des ressources persistantes (i.e.,
    les ressources qui doivent être conservées d'un hit à
    l'autre). Le premier module a utiliser cette capacité a été
    MySQL, et mSQL suivi, ce qui fait que l'on peut se faire une impression
    du fonctionnement de cette fonction avec mysql.c. Les fonctions ressemblent
    à ceci :
    <simplelist>
     <member>
       php3_mysql_do_connect
     </member>
     <member>
       php3_mysql_connect()
     </member>
     <member>
       php3_mysql_pconnect()
     </member>
    </simplelist>
   </para>
   <para>
    L'idée conductrice de ces modules est la suivante :
    <orderedlist numeration="arabic">
     <listitem>
      <simpara>
       Programmez tout votre module pour qu'il travaille avec les
       ressources standard, comme mentionné dans la section (9).
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Ajoutez une autre fonction de connexion, qui vérifie d'abord que
       la ressource existe dans la liste des ressources persistantes. Si
       c'est le cas, enregistrez cette ressource comme pour les ressources
       standard (et grâce à la première étape,
       cela va fonctionner immédiatement). Si la ressource n'existe
       pas, créez la, ajoutez la à la liste de ressources
       persistantes, et ajoutez la à la liste de ressources, ce
       qui fait que le code va fonctionner, et que le prochain appel
       renverra une ressource existante. Vous devez enregistrer
       ces fonctions avec un type différent (LE_MYSQL_LINK pour
       les liens non persistants, et LE_MYSQL_PLINK pour les liens persistants).
     </simpara>
    </listitem>
   </orderedlist>
   </para>
   <simpara>
    Si vous jetez un oeil dans mysql.c, vous verrez que, hormis la fonction de
    connexion complexe, rien n'a du être changé dans le module.
   </simpara>
   <simpara>
    La même interface existe pour la liste des ressources standard, et pour
    la liste des ressources persistantes, seule la 'list' est remplacée par
    'plist':
   </simpara>
    <itemizedlist>
     <listitem><simpara>php3_plist_insert(ptr, type) - retourne l'identifiant 'id'
       de la nouvelle ressource insérée.</simpara></listitem>
     <listitem><simpara>php3_plist_delete(id) - efface la ressource
       d'identifiant id</simpara></listitem>
     <listitem><simpara>php3_plist_find(id,*type)
       - retourne le pointeur de la ressource d'identifiant id,
       et modifie le type 'type'</simpara></listitem>
    </itemizedlist>
   <simpara>
    Cependant, il est probable que ces fonctions seront inutiles pour vous,
    lorsque vous essayerez d'implémentez un module persistant. Typiquement,
    on utiliser le fait que la liste de ressources persistantes est une table de
    hash. Par exemple, dans les modules MySQL/mSQL, lors d'un appel à
    pconnect(), la fonction construit une chaîne avec
    l'hôte/utilisateur/mot_de_passe, et l'utilise pour enregistrer
    dans la table de hash. Au prochain appel, avec les mêmes
    hôte/utilisateur/mot_de_passe, la même clé sera
    générée, et la ressource associée sera
    retrouvée.
   </simpara>
   <simpara>
    Jusqu'à ce que la documentation s'étoffe, jetez un oeil aux
    fichiers mysql.c ou msql.c pour voir comment implémentez vos
    accès aux ressources persistantes.
   </simpara>
   <simpara>
    Une chose importante à noter : les ressources qui sont
    enregistrées dans la liste de ressource persistante ne DOIVENT PAS
    être allouée avec le gestionnaire de mémoire &php;,
    c'est-à-dire qu'elles ne doivent pas être créée
    avec emalloc(), estrdup(), etc. Au contraire, il faut utiliser les fonctions
    standard malloc(), strdup(), etc. La raison est for simple : à la fin
    de la requête, la mémoire sera supprimée par le
    gestionnaire. Etant donné que les liens persistants doivent être
    conservés, il ne faut pas utiliser le gestionnaire de mémoire.
   </simpara>
   <simpara>
    Lorsque vous enregistrez une ressource qui sera placé dans la liste de
    ressources persistantes, il faut ajouter les destructeurs dans les deux listes
    de ressources, persistantes ou pas. Le destructeur de la liste de ressources
    non persistantes ne doit rien faire du tout, tandis que celui de la liste de
    ressources persistantes doit libérer proprement toutes les ressources
    acquises (mémoire, lien SQL, etc). Commep pour les ressources non
    persistantes vous DEVEZ ajouter un destructeur, même s'il ne fait
    rien. N'oubliez pas que emalloc() et compagnie ne doivent pas être
    utilisé en conjonction avec la liste de ressources persistantes, et
    donc, vous ne devez pas utiliser efree() non plus.
   </simpara>
  </sect2>
  <sect2 id="phpdevel-addfunc-addcfg">
   <title>Ajouter des directives de configuration à l'exécution</title>
   <para>
    De nombreuses caractéristiques de &php; 3 peuvent être configurée
    à l'exécution. Ces directives peuvent apparaître dans le
    fichier <filename>php3.ini</filename>, ou, dans le cas du module Apache, dans
    le fichier <filename>.conf</filename>.  L'avantage de l'avoir dans le fichier
    <filename>.conf</filename>, est que ces caractéristiques peuvent
    être configurées dossier par dossier. Cela signifie qu'un
    dossier peut avoir un safe mode exec dir, tandis qu'un autre en aura un
    autre. Cette granularité de la configuration peut être
    extrêmement pratique lorsque le serveur supporte plusieurs serveurs
    virtuels.
   </para>
   <para>
    Les étapes de configuration d'une nouvelle directive sont :
    <orderedlist>
     <listitem>
      <simpara>
       Ajouter la directive à la structure php3_ini_structure dans le
       fichier <filename>mod_php3.h</filename>.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Dans main.c, éditez la fonction php3_module_startup
       et ajoutez l'appel aproprié à cfg_get_string() ou cfg_get_long().
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Ajoutez la directive, ses restrictions et un commentaire dans
       la structure php3_commands du fichier mod_php3.c.  Notez la partie
       restrictions RSRC_CONF sont des directives qui ne peuvent être
       disponibles que dans le fichier de configuration Apache. Toutes les
       directives OR_OPTIONS peuvent être placées n'importe
       où, y compris dans un fichier &htaccess;.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Soit dans php3take1handler(), soit dans php3flaghandler(), ajoutez
       l'entrée appropriée pour votre directive.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Dans la section de configuration, de _php3_info(), dans le fichier
       functions/info.c, vous devez ajouter votre configuration.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
        Finalement, vous devez utiliser votre configuration quelque part.
        Elle sera accessible par php3_ini.directive.
      </simpara>
     </listitem>
    </orderedlist>
   </para>
  </sect2>
 </sect1>
 <sect1 id="calling-user-functions">
  <title>Appeler des fonctions utilisateurs</title>
  <simpara>
   Pour appeler des fonctions utilisateurs depuis une fonction interne, vous
   devez utiliser la fonction call_user_function().
  </simpara>
  <simpara>
   call_user_function() retourne SUCCESS en cas de succès, et FAILURE
   en cas d'échec, ou si la fonction n'a pas été
   trouvée. Vous devez vérifier cette valeur. Si la
   réponse est SUCCESS, vous êtes responsable de la destruction de
   retval (ou alors, retournez la comme valeur de réponse de votre
   fonction). Si la réponse est FAILURE, la valeur de retval est
   indéfinie, et vous ne devez pas y toucher.
  </simpara>
  <simpara>
   Toutes les fonctions internes qui appellent une fonction utilisateur,
   <emphasis>DOIVENT</emphasis> être réentrante. En
   particulier, elles ne doivent pas utiliser de valeurs globales, ou
   de variables statiques.
  </simpara>
  <simpara>
   call_user_function() prend 6 arguments :
  </simpara>
  <sect2 id="calling-user-functions.function-table">
   <title>HashTable *function_table</title>
   <simpara>
    La table de hash dans laquelle le fonction doit être recherchée.
   </simpara>
  </sect2>
  <sect2 id="calling-user-functions.object">
   <title>pval *object</title>
   <simpara>
    Un pointeur sur un objet sur lequel la fonction est invoquée.
    Il devrait être à &null;, si on invoque une fonction globale.
    S'il n'est pas à &null; (ie, il pointe sur un objet), l'argument
    function_table est ignorée, et la liste des fonctions sera lue
    dans l'objet, plutôt que dans l'argument. L'objet PEUT être
    modifié par la fonction qui est appelée (la fonction y aura
    accès via <varname>$this</varname>).  Si, vous quelque raison, vous ne le voulez pas,
    envoyez une copie de l'objet à la place.
   </simpara>
  </sect2>
  <sect2 id="calling-user-functions.function-name">
   <title>pval *function_name</title>
   <simpara>
    Le nom de la fonction à appeler. Elle doit être de type pval,
    IS_STRING, avec les valeurs de function_name.str.val et function_name.str.len
    correctes. function_name est modifié par call_user_function() -
    il est converti en minuscule. Si vous voulez préserver la casse,
    envoyez une copie du nom de la fonction.
   </simpara>
  </sect2>
  <sect2 id="calling-user-functions.retval">
   <title>pval *retval</title>
   <simpara>
    Un pointeur sur une structure pval, dans laquelle la valeur de retour de
    la fonction sera placée. La structure doit avoir été
    allouée au préalable, - call_user_function() ne l'allouera pas.
   </simpara>
  </sect2>
  <sect2 id="calling-user-functions.param-count">
   <title>int param_count</title>
   <simpara>
    Le nombre de paramètre passé à la fonction.
   </simpara>
  </sect2>
  <sect2 id="calling-user-functions.params">
   <title>pval *params[]</title>
   <simpara>
    Un tableau de pointeur sur les valeurs qui vont être passées
    comme arguments à la fonction. Le premier argument est à
    l'offset 0, le second à l'offset 1,... Le tableau est un tableau
    de pointeurs sur pval;  Les pointeurs sont envoyés tels quels à la
    fonction, ce qui signifie que si la fonction modifie les arguments, les valeurs
    originales seront modifiées. Si vous voulez l'éviter, passez une
    copie à la place.
   </simpara>
  </sect2>
 </sect1>
 <sect1 id="phpdevel-errors">
  <title>Rapport d'erreurs</title>
  <simpara>
    Pour signaler les erreurs d'une fonction interne, vous devez appelez la fonction
    php3_error(). Cette fonction prend deux arguments au moins : le niveau de l'erreur,
    et le message d'erreur, sous forme de chaîne de caractères. Tous les
    arguments suivants sont des paramètres de formats de chaîne. Les
    niveaux d'erreurs sont :
  </simpara>
  <sect2 id="internal.e-notice">
   <title><constant>E_NOTICE</constant></title>
   <simpara>
    Les notes ne sont pas affichées par défaut, et indique que
    le script a rencontré quelque chose qui peut être une erreur,
    mais peut aussi être un événement normal dans la vie
    du script. Par exemple, essayer d'accéder à une valeur qui
    n'a pas été déclarée, ou appeler
    <function>stat</function> sur un fichier qui n'existe pas.
   </simpara>
  </sect2>
  <sect2 id="internal.e-warning">
   <title><constant>E_WARNING</constant></title>
   <simpara>
    Les alertes sont affichées par défaut, mais n'interrompent pas
    l'exécution du script. Elles indiquent un problème qui
    doit être intercepté par le script avant que l'appel.
    Par exemple, appeler <function>ereg</function> avec une regex invalide.
   </simpara>
  </sect2>
  <sect2 id="internal.e-error">
   <title><constant>E_ERROR</constant></title>
   <simpara>
    Les erreurs sont aussi affichées par défaut, et
    l'exécution du script est interrompue. Elles indiquent des erreurs
    qui ne peuvent pas être ignorées, comme des
    problèmes d'allocation de mémoire, par exemple.
   </simpara>
  </sect2>
  <sect2 id="internal.e-parse">
   <title><constant>E_PARSE</constant></title>
   <simpara>
    Les erreurs d'analyse de doivent être générées que
    par l'analyseur. Elles ne sont citées ici que dans le but d'être
    exhaustif.
   </simpara>
  </sect2>
  <sect2 id="internal.e-core-error">
   <title><constant>E_CORE_ERROR</constant></title>
   <simpara>
    Elles sont similaires aux erreurs <constant>E_ERROR</constant>, mais elles sont
    générées par le code de &php;. Les fonctions ne
    doivent pas générer ce genre d'erreur.
   </simpara>
  </sect2>
  <sect2 id="internal.e-core-warning">
   <title><constant>E_CORE_WARNING</constant></title>
   <simpara>
    Elles sont similaires à  <constant>E_WARNING</constant>, mais elles sont
    générées par le code de &php;. Les fonctions ne
    doivent pas générer ce genre d'erreur.
   </simpara>
  </sect2>
  <sect2 id="internal.e-compile-error">
   <title><constant>E_COMPILE_ERROR</constant></title>
   <simpara>
     Elles sont similaires à <constant>E_ERROR</constant>, mais elles sont
     générées par  Zend Scripting Engine.
     Les fonctions ne doivent pas générer ce genre d'erreur.
   </simpara>
  </sect2>
  <sect2 id="internal.e-compile-warning">
   <title><constant>E_COMPILE_WARNING</constant></title>
   <simpara>
      Elles sont similaires à <constant>E_WARNING</constant>, mais elles sont
     générées par  Zend Scripting Engine.
     Les fonctions ne doivent pas générer ce genre d'erreur.
   </simpara>
  </sect2>
  <sect2 id="internal.e-user-error">
   <title><constant>E_USER_ERROR</constant></title>
   <simpara>
     <constant>E_USER_ERROR</constant> est comparable à <constant>E_ERROR</constant>. Elle est
     générée en &php; par l'utilisation de la fonction
     <function>trigger_error</function>. Les fonctions ne doivent
     pas générer ce genre d'erreur.
   </simpara>
  </sect2>
  <sect2 id="internal.e-user-warning">
   <title><constant>E_USER_WARNING</constant></title>
   <simpara>
     <constant>E_USER_WARNING</constant> est comparable à <constant>E_WARNING</constant>. Elle est
     générée en &php; par
     l'utilisation de la fonction <function>trigger_error</function>. Les
     fonctions ne doivent pas générer ce genre d'erreur.
   </simpara>
  </sect2>
  <sect2 id="internal.e-user-notice">
   <title><constant>E_USER_NOTICE</constant></title>
   <simpara>
     <constant>E_USER_WARNING</constant> est comparable à <constant>E_NOTICE</constant>. Elle est
     générée en &php; par
     l'utilisation de la fonction <function>trigger_error</function>. Les
     fonctions ne doivent pas générer ce genre d'erreur.
   </simpara>
  </sect2>
  <sect2 id="internal.e-all">
   <title><constant>E_ALL</constant></title>
   <simpara>
    Toutes les erreurs ci-dessus. Utiliser ce niveau de rapport d'erreur
    provoque l'affichage de toutes les erreurs.
   </simpara>
  </sect2>
  </sect1>
</appendix>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
