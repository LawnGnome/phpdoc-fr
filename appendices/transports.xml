<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.10 $ -->
<!-- EN-Revision: 1.9 Maintainer: dams Status: ready -->
<appendix id="transports">
 <title>Liste des modes de transports de sockets disponibles</title>
 <para>
  Voici la liste des différents modes de transports, format URL, dont
  &php; dispose en interne pour les flux qui exploitent les sockets, tels 
  que <function>fsockopen</function> et
  <function>stream_socket_client</function>. Ces modes de transports 
  <emphasis>ne s'appliquent pas</emphasis> à l'extension 
  <link linkend="ref.sockets">sockets</link>.
 </para>

 <para>
  Pour connaître la liste des modes de transports installés sur votre version
  de &php;, utilisez <function>stream_get_transports</function>.
 </para>

 <section id="transports.inet">
  <title>Domaines Internet : TCP, UDP, SSL et TLS</title>
  <simpara>
   &php; 3, &php; 4, &php; 5. <literal>ssl://</literal> & <literal>tls://</literal> depuis
   &php; 4.3.
  </simpara>

  <note>
   <simpara>
    Si aucun transport n'est spécifié, <literal>tcp://</literal>
    est utilisé.
   </simpara>
  </note>

  <itemizedlist>
   <listitem><simpara><literal>127.0.0.1</literal></simpara></listitem>
   <listitem><simpara><literal>fe80::1</literal></simpara></listitem>
   <listitem><simpara><literal>www.example.com</literal></simpara></listitem>
   <listitem><simpara><literal>tcp://127.0.0.1</literal></simpara></listitem>
   <listitem><simpara><literal>tcp://fe80::1</literal></simpara></listitem>
   <listitem><simpara><literal>tcp://www.example.com</literal></simpara></listitem>
   <listitem><simpara><literal>udp://www.example.com</literal></simpara></listitem>
   <listitem><simpara><literal>ssl://www.example.com</literal></simpara></listitem>
   <listitem><simpara><literal>tls://www.example.com</literal></simpara></listitem>
  </itemizedlist>

  <simpara>
   Les sockets du domaine Internet utilisent un numéro de port en plus
   de l'adresse de l'hôte. Dans le cas de <function>fsockopen</function>,
   il est spécifié en deuxième paramètre, et donc, n'a pas d'impact
   sur le format du mode de transport. Avec <function>stream_socket_client</function>
   et les autres fonctions de la même famille, le numéro de port est
   spécifié comme un suffixe dans l'URL de transport,
   identifié par un signe deux-points.
  </simpara>

  <itemizedlist>
   <listitem><simpara><literal>tcp://127.0.0.1:80</literal></simpara></listitem>
   <listitem><simpara><literal>tcp://[fe80::1]:80</literal></simpara></listitem>
   <listitem><simpara><literal>tcp://www.example.com:80</literal></simpara></listitem>
  </itemizedlist>

  <note>
   <title>Adresse IPv6 et numéro de port</title>
   <simpara>
    Dans le second exemple ci-dessus, les exemples en IPv4 et les
    noms d'hôtes sont identiques, mais les IPv6 sont placées entre
    crochet, en plus d'avoir le deux-points et le numéro de port :
    <literal>[fe80::1]</literal>. Cela permet de distinguer les deux-points
    utilisés en IPv6 et le deux-points utilisé pour délimiter
    le numéro de port.
   </simpara>
  </note>

  <simpara>
   Les modes <literal>ssl://</literal> et <literal>tls://</literal> 
   (disponibles uniquement lorsque le support OpenSSl est compilé avec &php;) sont
   des extensions de <literal>tcp://</literal> qui incluent le chiffrement SSL.
   En &php; 4.3, OpenSll doit être compilé statiquement avec &php;. en 
   &php; 5.0, il peut être compilé en module ou statiquement.
  </simpara>

  <para>
   <table>
    <title>
     Les options de contexte de <literal>ssl://</literal> et 
     <literal>tls://</literal> (depuis &php; 4.3.2)
    </title>
    <tgroup cols="4">
     <thead>
      <row>
       <entry>Nom</entry>
       <entry>Utilisation</entry>
       <entry>Valeur par défaut</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><literal>verify_peer</literal></entry>
       <entry>
        &true; ou &false;.
        Requiert la vérification du certificat SSL utilisé.
       </entry>
       <entry>&false;</entry>
      </row>
      <row>
       <entry><literal>allow_self_signed</literal></entry>
       <entry>
        &true; ou &false;.
        Permet les certificats auto-signés.
       </entry>
       <entry>&false;</entry>
      </row>
      <row>
       <entry><literal>cafile</literal></entry>
       <entry>
        Situation du fichier de l'autorité de certification sur le
        serveur local, qui doit être utilisé avec 
        <literal>verify_peer</literal> comme option de contexte pour
        identifier un pair distant.
       </entry>
       <entry></entry>
      </row>
      <row>
       <entry><literal>capath</literal></entry>
       <entry>
        Si <literal>cafile</literal> n'est pas spécifié, ou si
        le certificat n'est pas trouvé, le dossier <literal>capath</literal>
        est scanné pour y trouver un certificat convenable. 
        <literal>capath</literal> doit être un dossier de certificats corrects.
       </entry>
      </row>
      <row>
       <entry><literal>local_cert</literal></entry>
       <entry>
        Chemin jusqu'au fichier de certificat local. Il doit être au
        format PEM, qui contient votre certificat, et la clé
        privée.
        Il peut éventuellement contenir la chaîne de certificat de
        l'émetteur.
       </entry>
       <entry></entry>
      </row>
      <row>
       <entry><literal>passphrase</literal></entry>
       <entry>
        Mot de passe avec lequel votre <literal>local_cert</literal> a
        été chiffré.
       </entry>
       <entry></entry>
      </row>
      <row>
       <entry><literal>CN_match</literal></entry>
       <entry>
        Le nom commun (Common Name) que nous attendons. &php; va effectuer
        une comparaison avec jokers limités. Si le nom commun ne correspond
        pas à celui attendu, la connexion va échouer.
       </entry>
       <entry></entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </para>

  <note>
   <simpara>
    Comme <literal>ssl://</literal> est le mode de transport sous-jacent de 
    <link linkend="wrappers.http"><literal>https://</literal></link> et
    <link linkend="wrappers.ftp"><literal>ftps://</literal></link>, 
    toutes les options de contexte qui s'applique à <literal>ssl://</literal>,
    s'appliquent aussi à <literal>https://</literal> et <literal>ftps://</literal>.
   </simpara>
  </note>
 </section>

 <section id="transports.unix">
  <title>Domaine Unix : UNIX et UDG</title>
  <simpara>
   <literal>unix://</literal> depuis &php; 3, 
   <literal>udg://</literal> depuis &php; 5
  </simpara>

  <itemizedlist>
   <listitem><simpara><literal>unix:///tmp/mysock</literal></simpara></listitem>
   <listitem><simpara><literal>udg:///tmp/mysock</literal></simpara></listitem>
  </itemizedlist>

  <simpara>
   <literal>unix://</literal> fournit l'accès à un flux de type socket, sur
   un domaine Unix. <literal>udg://</literal> fournit un mode de transport
   alternatif, avec un protocole de datagrammes utilisateurs.
  </simpara>

  <simpara>
   Les sockets du domaine Unix, contrairement à celle du domaine Internet,
   n'utilisent pas de numéro de port. Dans ce cas, le paramètre 
   <parameter>portno</parameter> de <function>fsockopen</function> doit valoir 0.
  </simpara>
 </section>

</appendix>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
