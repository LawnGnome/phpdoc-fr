<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.2 $ -->
<appendix id="transports">
 <title>Liste des modes de transports de sockets disponibles</title>
 <para>
  Voici la liste des diff&eacute;rents modes de transports, format URL, dont
  &php; dispose en interne pour les flux qui exploitent les sockets, tels 
  que <function>fsockopen</function> et
  <function>stream_socket_client</function>. Ces modes de transports 
  <emphasis>ne s'appliquent pas</emphasis> &agrave; l'extension 
  <link linkend="ref.sockets">sockets</link>.
 </para>

 <para>
  Pour conna&icirc;tre la liste des modes de transports install&eacute;s sur votre version
  de &php;, utilisez <function>stream_get_transports</function>.
 </para>

 <section id="transports.inet">
  <title>Domaien Internet : TCP, UDP, SSL et TLS</title>
  <simpara>
   PHP 3, PHP 4. <literal>ssl://</literal> &amp; <literal>tls://</literal> depuis
   PHP 4.3.
  </simpara>

  <note>
   <simpara>
    Si aucun transport n'est sp&eacute;cifi&eacute;, <literal>tcp://</literal>
    est utilis&eacute;.
   </simpara>
  </note>

  <itemizedlist>
   <listitem><simpara><literal>127.0.0.1</literal></simpara></listitem>
   <listitem><simpara><literal>fe80::1</literal></simpara></listitem>
   <listitem><simpara><literal>www.exemple.com</literal></simpara></listitem>
   <listitem><simpara><literal>tcp://127.0.0.1</literal></simpara></listitem>
   <listitem><simpara><literal>tcp://fe80::1</literal></simpara></listitem>
   <listitem><simpara><literal>tcp://www.exemple.com</literal></simpara></listitem>
   <listitem><simpara><literal>udp://www.exemple.com</literal></simpara></listitem>
   <listitem><simpara><literal>ssl://www.exemple.com</literal></simpara></listitem>
   <listitem><simpara><literal>tls://www.exemple.com</literal></simpara></listitem>
  </itemizedlist>

  <simpara>
   Les sockets du domaine Internet utilisent un num&eacute;ro de port en plus
   de l'adresse de l'h&ocirc;te. Dans le cas de <function>fsockopen</function>,
   il est sp&eacute;cifi&eacute; en deuxi&egrave;me param&egrave;tre, et donc, n'a pas d'impact
   sur le format du mode de transport. Avec <function>stream_socket_client</function>
   et les autres fonctions de la m&ecirc;me famille, le num&eacute;ro de port est
   sp&eacute;cifi&eacute; comme un suffixe dans l'URL de transport,
   identifi&eacute; par un signe deux-points.
  </simpara>

  <itemizedlist>
   <listitem><simpara><literal>tcp://127.0.0.1:80</literal></simpara></listitem>
   <listitem><simpara><literal>tcp://[fe80::1]:80</literal></simpara></listitem>
   <listitem><simpara><literal>tcp://www.exemple.com:80</literal></simpara></listitem>
  </itemizedlist>

  <note>
   <title>Adresse IPv6 et num&eacute;ro de port</title>
   <simpara>
    Dans le second exemple ci-dessus, les exemples en IPv4 et les
    noms d'h&ocirc;tes sont identiques, mais les IPv6 sont plac&eacute;es entre
    crochet, en plus d'avoir le deux-points et le num&eacute;ro de port :
    <literal>[fe80::1]</literal>. Cela permet de distinguer les deux-points
    utilis&eacute;s en IPv6 et le deux-points utilis&eacute; pour d&eacute;limiter
    le num&eacute;ro de port.
   </simpara>
  </note>

  <simpara>
   Les modes <literal>ssl://</literal> et <literal>tls://</literal> 
   (disponibles uniquement lorsque le support OpenSSl est compil&eacute; avec &php;) sont
   des extensions de <literal>tcp://</literal> qui incluent le chiffrement SSL.
   En &php; 4.3, OpenSll doit &ecirc;tre compil&eacute; statiquement avec &php;. en 
   &php; 5.0, il peut &ecirc;tre compil&eacute; en module ou statiquement.
  </simpara>

  <para>
   <table>
    <title>
     Les options de contexte de <literal>ssl://</literal> et 
     <literal>tls://</literal> (depuis &php; 4.3.2)
    </title>
    <tgroup cols="4">
     <thead>
      <row>
       <entry>Nom</entry>
       <entry>Utilisation</entry>
       <entry>Valeur par d&eacute;faut</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><literal>verify_peer</literal></entry>
       <entry>
        &true; ou &false;.
        Requiert la v&eacute;rification du certificat SSL utilis&eacute;.
       </entry>
       <entry>&false;</entry>
      </row>
      <row>
       <entry><literal>allow_self_signed</literal></entry>
       <entry>
        &true; ou &false;.
        Permet les certificats auto-sign&eacute;s.
       </entry>
       <entry>&false;</entry>
      </row>
      <row>
       <entry><literal>cafile</literal></entry>
       <entry>
        Situation du fichier de l'autorit&eacute; de certification sur le
        serveur local, qui doit &ecirc;tre utilis&eacute; avec 
        <literal>verify_peer</literal> comme option de contexte pour
        identifier un pair distant.
       </entry>
       <entry></entry>
      </row>
      <row>
       <entry><literal>capath</literal></entry>
       <entry>
        Si <literal>cafile</literal> n'est pas sp&eacute;cifi&eacute;, ou si
        le certificat n'est pas trouv&eacute;, le dossier <literal>capath</literal>
        est scann&eacute; pour y trouver un certificat convenable. 
        <literal>capath</literal> doit &ecirc;tre un dossier de certificats corrects.
       </entry>
      </row>
      <row>
       <entry><literal>local_cert</literal></entry>
       <entry>
        Chemin jusqu'au fichier de certificat local. Il doit &ecirc;tre au
        format PEM, qui contient votre certificat, et la cl&eacute;
        priv&eacute;e.
        Il peut &eacute;ventuellement contenir la cha&icirc;ne de certificat de
        l'&eacute;metteur.
       </entry>
       <entry></entry>
      </row>
      <row>
       <entry><literal>passphrase</literal></entry>
       <entry>
        Mot de passe avec lequel votre <literal>local_cert</literal> a
        &eacute;t&eacute; chiffr&eacute;.
       </entry>
       <entry></entry>
      </row>
      <row>
       <entry><literal>CN_match</literal></entry>
       <entry>
        Le nom commun (Common Name) que nous attendons. &php; va effectuer
        une comparaison avec jokers limit&eacute;s. Si le nom commun ne correspond
        pas &agrave; celui attendu, la connexion va &eacute;chouer.
       </entry>
       <entry></entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </para>

  <note>
   <simpara>
    Comme <literal>ssl://</literal> est le mode de transport sous-jacent de 
    <link linkend="wrappers.http"><literal>https://</literal></link> et
    <link linkend="wrappers.ftp"><literal>ftps://</literal></link>, 
    toutes les options de contexte qui s'applique &agrave; <literal>ssl://</literal>,
    s'appliquent aussi &agrave; <literal>https://</literal> et <literal>ftps://</literal>.
   </simpara>
  </note>
 </section>

 <section id="transports.unix">
  <title>Domaine Unix : UNIX et UDG</title>
  <simpara>
   <literal>unix://</literal> depuis &php; 3, 
   <literal>udg://</literal> depuis &php; 5
  </simpara>

  <itemizedlist>
   <listitem><simpara><literal>unix:///tmp/mysock</literal></simpara></listitem>
   <listitem><simpara><literal>udg:///tmp/mysock</literal></simpara></listitem>
  </itemizedlist>

  <simpara>
   <literal>unix://</literal> fournit l'acc&egrave;s &agrave; un flux de type socket, sur
   un domaine Unix. <literal>udg://</literal> fournit un mode de transport
   alternatif, avec un protocole de datagrammes utilisateurs.
  </simpara>

  <simpara>
   Les sockets du domaine Unix, contrairement &agrave; celle du domaine Internet,
   n'utilisent pas de num&eacute;ro de port. Dans ce cas, le param&egrave;tre 
   <parameter>portno</parameter> de <function>fsockopen</function> doit valoir 0.
  </simpara>
 </section>

</appendix>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
