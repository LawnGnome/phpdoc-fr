<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.10 $ -->
<appendix id="migration">
 <title>Migration de PHP/FI 2.0 &agrave; PHP 3.0</title>
 <sect1 id="migration.about">
  <title>A propos des incompatibilit&eacute;s en 3.0</title>
  <simpara>
   PHP 3.0 a &eacute;t&eacute; enti&egrave;rement r&eacute;&eacute;crit. Le nouvel
   analyseur syntaxique est beaucoup plus robuste et coh&eacute;rent qu'en version
   2.0. Il est aussi nettement plus rapide et utilise encore moins de
   m&eacute;moire. Cependant, ces am&eacute;liorations n'ont pu &ecirc;tre
   possible qu'au prix de modifications parfois importantes, tant au niveau des
   syntaxes, qu'au niveau des fonctionnalit&eacute;s.
  </simpara>
  <simpara>
   De plus, l'&eacute;quipe de d&eacute;veloppement PHP a essay&eacute; de nettoyer
   la syntaxe et les s&eacute;mantiques, ce qui a aussi caus&eacute; quelques
   incompatibilit&eacute;s. A long terme, nous pensons que ces modifications
   seront pour le bien de tous.
  </simpara>
  <simpara>
   Ce chapitre va tenter de vous montrer les incompatibilit&eacute;s que vous
   pourriez rencontrer lors de votre migration de PHP/FI 2.0 &agrave; PHP 3.0
   et de vous aider &agrave; les r&eacute;soudre. Les nouvelles
   fonctionnalit&eacute;s ne sont pas signal&eacute;es, &agrave; moins que
   cela ne soit n&eacute;cessaire.
  </simpara>
  <simpara>
   Un programme de conversion automatique de vos vieux script PHP/FI 2.0 existe.
   Il est disponible dans le dossier de convertisseur de la distribution PHP 3.0.
   Ce programme ne fait que rep&eacute;rer les modifications de syntaxe et ne
   vous &eacute;pargnera pas une relecture attentive du script.
  </simpara>
 </sect1>
 <sect1 id="migration.startendtags">
  <title>Balises PHP</title>
  <para>
   La premi&egrave;re chose que vous remarquerez probablement est que les balises
   de PHP start et end ont chang&eacute;. L'ancienne forme
   <literal>&lt;? ?&gt;</literal> a &eacute;t&eacute; remplac&eacute;e par trois
   nouvelles balises possibles :
   <example>
    <title>Migration: Migration: balises start/end </title>
    <programlisting role="php">
&lt;?php
  echo "Ceci est du code PHP/FI 2.0.\n";?
?&gt;
    </programlisting>
   </example>
   Comme en version 2.0, PHP/FI accepte aussi cette variante :
   <example>
    <title>Migration: premi&egrave;res nouvelles balises PHP</title>
    <programlisting role="php">
&lt;?php
  echo "Ceci est du code PHP 3.0!\n";
?&gt;
    </programlisting>
   </example>
   Notez bien que la balise de fin contient d&eacute;sormais un point
   d'interrogation et un signe sup&eacute;rieur ">". Cependant,
   si vous souhaitez utiliser XML sur votre serveur, vous aurez s&ucirc;rement
   des probl&egrave;mes avec cette variante, car PHP risque d'essayer
   d'ex&eacute;cuter des balises XML. A cause de ceci, la notation
   suivante a &eacute;t&eacute; ajout&eacute;e :
   <example>
    <title>Migration: Nouvelles balises PHP</title>
    <programlisting role="php">
&lt;?php
  echo "Ceci est du code PHP 3.0!\n";
?&gt;
    </programlisting>
   </example>
   Certains d'entre vous rencontrent des probl&egrave;mes avec les &eacute;diteurs qui
   ne comprennent pas ce type de balises d'instruction : Microsoft FrontPage
   est l'un de ces &eacute;diteurs, et, pour contourner le probl&egrave;me, la
   variation suivante a &eacute;t&eacute; introduite :
   <example><title>Nouvelles balises PHP</title>
    <programlisting role="php">
&lt;script language="php"&gt;
  echo "Ceci est du code PHP 3.0!\n";
&lt;/script&gt;
    </programlisting>
   </example>
  </para>
 </sect1>
 <sect1 id="migration.if-endif">
  <title>Syntaxe if..endif</title>
  <para>
   La syntaxe alternative pour &eacute;crire des instructions if/elseif/else, avec if();
   elseif(); else; endif; ne pouvait pas &ecirc;tre conserv&eacute;e sans ajouter beaucoup
   de complexit&eacute; &agrave; l'analyseur syntaxique. De ce fait, cette syntaxe
   &agrave; chang&eacute;e :
   <example>
    <title>Migration: ancienne syntaxe if..endif </title>
    <programlisting role="php">
&lt;?php
  if ($foo);
    echo "oui\n";
  elseif ($bar);
    echo "presque\n";
  else;
    echo "non\n";
  endif;
?&gt;
    </programlisting>
   </example>
   <example>
    <title>Migration: nouvelle syntaxe if..endif</title>
    <programlisting role="php">
&lt;?php
  if ($foo):
    echo "oui\n";
  elseif ($bar):
    echo "presque\n";
  else:
    echo "non\n";
  endif;
?&gt;
    </programlisting>
   </example>
   Notez que les points virgules ont &eacute;t&eacute; remplac&eacute;e par des points dans
   toutes les commandes, sauf pour la derni&egrave;re expression (endif).
  </para>
 </sect1>
 <sect1 id="migration.while">
  <title>Syntaxe while</title>
  <para>
   Tout comme pour if..endif, la syntaxe des boucles while..endwhile a chang&eacute;e :
   <example>
    <title>Migration: ancienne syntaxe while..endwhile </title>
    <programlisting role="php">
&lt;?php
  while ($more_to_come);
    ...
  endwhile;
?&gt;
    </programlisting>
   </example>
   <example><title>Migration: nouvelle syntaxe while..endwhile</title>
   <programlisting role="php">
&lt;?php
  while ($more_to_come):
    ...
  endwhile;
?&gt;
    </programlisting>
   </example>
  </para>
  <warning>
   <simpara>
    Attention : si vous utilisez la vieille syntaxe while..endwhile en PHP 3.0, vous
    obtiendrez une boucle sans fin !
   </simpara>
  </warning>
 </sect1>
 <sect1 id="migration.expr">
  <title>Types d'expression</title>
  <simpara>
   PHP/FI 2.0 utilisait le membre &agrave; gauche dans les expressions, pour d&eacute;terminer
   le type de r&eacute;sultat attendu. PHP 3.0 prend en compte les deux c&ocirc;t&eacute;s de
   l'expression et cela peut produire des r&eacute;sultats inattendus avec les scripts 2.0.
  </simpara>
  <para>
   Consid&eacute;rez les lignes suivantes:
   <informalexample>
    <programlisting role="php">
&lt;?php
  $a[0]=5;
  $a[1]=7;
  $key = key($a);
  while ("" != $key) {
    echo "$keyn";
    next($a);
  }
?&gt;
    </programlisting>
   </informalexample>
    En PHP/FI 2.0, cet exemple va afficher les indices des $a.
    En PHP 3.0, l'exemple ne va rien afficher du tout. La raison est qu'en PHP 2.0, puisque
    l'argument de gauche est de type cha&icirc;ne, une comparaison de cha&icirc;ne &eacute;tait
    effectu&eacute;e et, effectivement, <literal>""</literal> n'est pas <literal>""</literal>,
    ce qui conduit la boucle &agrave; continuer. En PHP 3, lorsqu'une cha&icirc;ne est
    compar&eacute;e avec un entier, la comparaison est de type cha&icirc;ne (la cha&icirc;ne
    est convertie en entier). Ce qui revient &agrave; faire la comparaison entre
    (<literal>atoi("")</literal>) qui vaut <literal>0</literal> et la variable
    qui vaut aussi 0 et comme 0==0, la boucle ne commence m&ecirc;me pas.
  </para>
  <para>
   La correction de ceci est simple : il suffit de remplacer les commandes while par:
   <informalexample>
    <programlisting role="php">
&lt;?php
  while ((string)$key != "") {
?&gt;
    </programlisting>
   </informalexample>
  </para>
 </sect1>
 <sect1 id="migration.errors">
  <title>Les messages d'erreur ont chang&eacute;</title>
  <simpara>
   Les messages d'erreur en PHP 3.0 sont g&eacute;n&eacute;ralement plus pr&eacute;cis que
   ceux de la version 2.0., mais vous ne verrez plus la portion de code qui a caus&eacute;
   l'erreur. A la place, un num&eacute;ro de ligne et un nom de fichier sera retourn&eacute;.
  </simpara>
 </sect1>
 <sect1 id="migration.booleval">
  <title>Evaluation rapide des bool&eacute;ens </title>
  <simpara>
   En PHP 3., l'&eacute;valuation des est court-circuit&eacute;. Cela signifie dans une
   expression telle que (<literal>(1 || test_me())</literal>), la fonction test_me()
   ne sera pas ex&eacute;cut&eacute;e, car cela ne changera pas le r&eacute;sultat.
  </simpara>
  <simpara>
   C'est une am&eacute;lioration mineure, mais qui peut avoir des effets secondaires importants.
  </simpara>
 </sect1>
 <sect1 id="migration.truefalse">
  <title>La valeur &true;/&false; comme retour de fonctions</title>
  <simpara>
   La plupart des fonctions internes de PHP ont &eacute;t&eacute;
   r&eacute;&eacute;crite pour qu'elle retourne &true; en cas de succ&egrave;s,
   et &false; en cas d'erreur, au contraire des fonctions qui retournaient 0 et -1
   en PHP/FI 2.0. Le nouveau comportement est beaucoup plus logique, comme par
   exemple $fp = fopen("/your/file") or fail("fichier non trouv&eacute;!");.
   Etant donn&eacute; que PHP/FI 2.0 n'a pas de r&egrave;gle claire &agrave;
   propos de ce que les fonctions doivent retourner en cas d'&eacute;chec, la
   plupart des scripts devront probablement &ecirc;tre v&eacute;rifi&eacute;
   manuellement, apr&egrave;s avoir utilis&eacute; le convertisseur 2.0 &agrave;
   3.0.
  </simpara>
  <para>
   <example>
    <title>
      Migration depuis 2.0: valeur retourn&eacute;es, ancienne fa&ccedil;on
    </title>
    <programlisting role="php">
&lt;?php
  $fp = fopen($file, "r");
  if ($fp == -1);
    echo("Impossible d'ouvrir le fichier $file en lecture &lt;br&gt;\n");
  endif;
?&gt;
    </programlisting>
   </example>
   <example>
    <title>Migration depuis 2.0: valeur retourn&eacute;es, nouvelle fa&ccedil;on</title>
    <programlisting role="php">
&lt;?php
  $fp = @fopen($file, "r") or
     print("Impossible d'ouvrir le fichier $file en lecture&lt;br&gt;\n");
?&gt;
    </programlisting>
   </example>
  </para>
 </sect1>
 <sect1 id="migration.other">
  <title>Diverses incompatibilit&eacute;s</title>
   <itemizedlist>
    <listitem>
     <simpara>
      Le module PHP 3.0 pour Apache n'accepte plus les versions d'Apache ant&eacute;rieure
      &agrave; la version 1.2. Apache 1.2 ou plus r&eacute;cent est n&eacute;cessaire.
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <function>echo</function> n'utilise plus de cha&icirc;ne de formatage. Il faut
     utiliser <function>printf</function> &agrave; la place.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      En PHP/FI 2.0, un effet secondaire de l'impl&eacute;mentation faisait que
      <literal>$foo[0]</literal> &eacute;tait la m&ecirc;me chose que
      <literal>$foo</literal>. Ce n'est plus vrai en PHP 3.0.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Lire un tableau avec $array[] n'est plus valable.
     </simpara>
     <simpara>
      Ainsi, il n'est plus possible de passer en revue un tableau avec des
      boucles telles que  <literal>$data = $array[]</literal>. Utilisez
      <function>current</function> et <function>next</function> &agrave; la place.
     </simpara>
     <simpara>
      Ainsi, <literal>$array1[] = $array2</literal> n'ajoute pas les valeurs
      de <literal>$array2</literal> &agrave; <literal>$array1</literal>,
      mais cr&eacute;e un nouvel &eacute;l&eacute;ment dans <literal>$array1</literal>
      et y affecte <literal>$array2</literal> comme dernier &eacute;l&eacute;ment.
      Voir aussi les tableaux multidimensionnels.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <literal>"+"</literal> n'est plus utilisable comme op&eacute;rateur de
      concat&eacute;nation de cha&icirc;ne. A la place, il convertit les
      arguments en nombres et effectue une addition num&eacute;rique.
      Utilisez <literal>"."</literal>  &agrave; la place.
     </simpara>
    </listitem>
   </itemizedlist>
   <example>
    <title>Migration depuis 2.0: concat&eacute;nation de cha&icirc;nes</title>
     <programlisting role="php">
&lt;?php
  echo "1" + "1";
?&gt;
     </programlisting>
     <para>
      En PHP 2.0 cela retournerait 11, en PHP 3.0 cela va retourner 2. A la place,
      faites :
      <programlisting role="php">
&lt;?php
  echo "1"."1";
?&gt;
      </programlisting>
      <programlisting role="php">
&lt;?php
  $a = 1;
  $b = 1;
  echo $a + $b;
?&gt;
      </programlisting>
      </para>
      <para>
       Cela va afficher 2, tant en PHP 2.0 qu'en 3.0.
       <programlisting role="php">
&lt;?php
  $a = 1;
  $b = 1;
  echo $a.$b;
?&gt;
        </programlisting>
        Cela va afficher 11 en PHP 3.0.
    </para>
   </example>
  </sect1>
 </appendix>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->