<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.22 $ -->
<!-- EN-Revision: 1.1 Maintainer: nobody Status: partial -->
<appendix id="migration">
 <title>Migration de PHP/FI 2.0 à &php; 3.0</title>
 <sect1 id="migration.about">
  <title>A propos des incompatibilités en 3.0</title>
  <simpara>
   &php; 3.0 a été entièrement réécrit. Le nouvel
   analyseur syntaxique est beaucoup plus robuste et cohérent qu'en version
   2.0. Il est aussi nettement plus rapide et utilise encore moins de
   mémoire. Cependant, ces améliorations n'ont pu être
   possibles qu'au prix de modifications parfois importantes, tant au niveau des
   syntaxes, qu'au niveau des fonctionnalités.
  </simpara>
  <simpara>
   De plus, l'équipe de développement &php; a essayé de nettoyer
   la syntaxe et les sémantiques, ce qui a aussi causé quelques
   incompatibilités. A long terme, nous pensons que ces modifications
   seront pour le bien de tous.
  </simpara>
  <simpara>
   Ce chapitre va tenter de vous montrer les incompatibilités que vous
   pourriez rencontrer lors de votre migration de PHP/FI 2.0 à &php; 3.0
   et de vous aider à les résoudre. Les nouvelles
   fonctionnalités ne sont pas signalées, à moins que
   cela ne soit nécessaire.
  </simpara>
  <simpara>
   Un programme de conversion automatique de vos vieux script PHP/FI 2.0 existe.
   Il est disponible dans le dossier de convertisseur de la distribution &php; 3.0.
   Ce programme ne fait que repérer les modifications de syntaxe et ne
   vous épargnera pas une relecture attentive du script.
  </simpara>
 </sect1>
 <sect1 id="migration.old-function">
  <title><literal>old_function</literal></title>
  <simpara>
   L'instruction <literal>old_function</literal> vous permet
   de déclarer une fonction en utilisant une syntaxe identique à 
   celle de PHP/FI (hormis le fait que vous devez remplacer
   '<literal>function</literal>' par '<literal>old_function</literal>').
  </simpara>
  <simpara>
   C'est une fonctionnalité obsolète, qui ne doit être utilisée
   que par les convertisseurs PHP/FI->&php; 3.
  </simpara>
  <warning>
   <para>
    Les fonctions déclarées comme <literal>old_function</literal> ne peuvent
    pas être appelées depuis le code interne &php;. Entre autres choses,
    cela signifique que vous ne pouvez pas les utiliser avec des fonctions
    comme <function>usort</function>, <function>array_walk</function> et
    <function>register_shutdown_function</function>. Vous pouvez
    contourner cette limitation en écrivant une fonction moderne, qui appelle
    cette vieille syntaxe <literal>old_function</literal>.
   </para>
  </warning>
 </sect1>
 <sect1 id="migration.startendtags">
  <title>Balises &php;</title>
  <para>
   La première chose que vous remarquerez probablement est que les balises
   de &php; start et end ont changé. L'ancienne forme
   <literal>&lt;? &gt;</literal> a été remplacée par trois
   nouvelles balises possibles :
   <example>
    <title>Migration: Migration: balises start/end </title>
    <programlisting role="php">
<![CDATA[
<?
  echo "Ceci est du code PHP/FI 2.0.\n";
>
]]>
    </programlisting>
   </example>
   Comme en version 2.0, PHP/FI accepte aussi cette variante :
   <example>
    <title>Migration: premières nouvelles balises &php;</title>
    <programlisting role="php">
<![CDATA[
<?
  echo "Ceci est du code PHP 3.0!\n";
?>
]]>
    </programlisting>
   </example>
   Notez bien que la balise de fin contient désormais un point
   d'interrogation et un signe supérieur ">". Cependant,
   si vous souhaitez utiliser XML sur votre serveur, vous aurez sûrement
   des problèmes avec cette variante, car &php; risque d'essayer
   d'exécuter des balises XML. A cause de ceci, la notation
   suivante a été ajoutée :
   <example>
    <title>Migration : nouvelles balises &php;</title>
    <programlisting role="php">
<![CDATA[
<?php
  echo "Ceci est du code PHP 3.0!\n";
?>
]]>
    </programlisting>
   </example>
   Certains d'entre vous rencontrent des problèmes avec les éditeurs qui
   ne comprennent pas ce type de balises d'instruction : Microsoft FrontPage
   est l'un de ces éditeurs, et, pour contourner le problème, la
   variation suivante a été introduite :
   <example><title>Nouvelles balises &php;</title>
    <programlisting role="php">
<![CDATA[
<script language="php">
  echo "Ceci est du code PHP 3.0!\n";
</script>
]]>
    
    </programlisting>
   </example>
  </para>
 </sect1>
 <sect1 id="migration.if-endif">
  <title>Syntaxe if..endif</title>
  <para>
   La syntaxe alternative pour écrire des instructions if/elseif/else, avec if();
   elseif(); else; endif; ne pouvait pas être conservée sans ajouter beaucoup
   de complexité à l'analyseur syntaxique. De ce fait, cette syntaxe
   à changée :
   <example>
    <title>Migration: ancienne syntaxe if..endif </title>
    <programlisting role="php">
<![CDATA[
<?php
  if ($foo);
    echo "oui\n";
  elseif ($bar);
    echo "presque\n";
  else;
    echo "non\n";
  endif;
?>
]]>
    </programlisting>
   </example>
   <example>
    <title>Migration: nouvelle syntaxe if..endif</title>
    <programlisting role="php">
<![CDATA[
<?php
  if ($foo):
    echo "oui\n";
  elseif ($bar):
    echo "presque\n";
  else:
    echo "non\n";
  endif;
?>
]]>
    </programlisting>
   </example>
   Notez que les points virgules ont été remplacée par des points dans
   toutes les commandes, sauf pour la dernière expression (endif).
  </para>
 </sect1>
 <sect1 id="migration.while">
  <title>Syntaxe while</title>
  <para>
   Tout comme pour if..endif, la syntaxe des boucles while..endwhile a changée :
   <example>
    <title>Migration: ancienne syntaxe while..endwhile </title>
    <programlisting role="php">
<![CDATA[
<?php
  while ($more_to_come);
    ...
  endwhile;
?>
]]>
    </programlisting>
   </example>
   <example><title>Migration: nouvelle syntaxe while..endwhile</title>
   <programlisting role="php">
<![CDATA[
<?php
  while ($more_to_come):
    ...
  endwhile;
?>
]]>
    </programlisting>
   </example>
  </para>
  <warning>
   <simpara>
    Attention : si vous utilisez la vieille syntaxe while..endwhile en &php; 3.0, vous
    obtiendrez une boucle sans fin !
   </simpara>
  </warning>
 </sect1>
 <sect1 id="migration.expr">
  <title>Types d'expression</title>
  <simpara>
   PHP/FI 2.0 utilisait le membre à gauche dans les expressions, pour déterminer
   le type de résultat attendu. &php; 3.0 prend en compte les deux côtés de
   l'expression et cela peut produire des résultats inattendus avec les scripts 2.0.
  </simpara>
  <para>
   Considérez les lignes suivantes:
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
  $a[0]=5;
  $a[1]=7;
  $key = key($a);
  while ("" != $key) {
    echo "$keyn";
    next($a);
  }
?>
]]>
    </programlisting>
   </informalexample>
    En PHP/FI 2.0, cet exemple va afficher les indices des $a.
    En &php; 3.0, l'exemple ne va rien afficher du tout. La raison est qu'en &php; 2.0, puisque
    l'argument de gauche est de type chaîne, une comparaison de chaîne était
    effectuée et, effectivement, <literal>""</literal> n'est pas <literal>""</literal>,
    ce qui conduit la boucle à continuer. En &php; 3, lorsqu'une chaîne est
    comparée avec un entier, la comparaison est de type chaîne (la chaîne
    est convertie en entier). Ce qui revient à faire la comparaison entre
    (<literal>atoi("")</literal>) qui vaut <literal>0</literal> et la variable
    qui vaut aussi 0 et comme 0==0, la boucle ne commence même pas.
  </para>
  <para>
   La correction de ceci est simple : il suffit de remplacer les commandes while par:
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
  while ((string)$key != "") {
?>
]]>
    </programlisting>
   </informalexample>
  </para>
 </sect1>
 <sect1 id="migration.errors">
  <title>Les messages d'erreur ont changé</title>
  <simpara>
   Les messages d'erreur en &php; 3.0 sont généralement plus précis que
   ceux de la version 2.0., mais vous ne verrez plus la portion de code qui a causé
   l'erreur. A la place, un numéro de ligne et un nom de fichier sera retourné.
  </simpara>
 </sect1>
 <sect1 id="migration.booleval">
  <title>Evaluation rapide des booléens </title>
  <simpara>
   En &php; 3, l'évaluation des est court-circuité. Cela signifie dans une
   expression telle que (<literal>(1 || test_me())</literal>), la fonction test_me()
   ne sera pas exécutée, car cela ne changera pas le résultat.
  </simpara>
  <simpara>
   C'est une amélioration mineure, mais qui peut avoir des effets secondaires importants.
  </simpara>
 </sect1>
 <sect1 id="migration.truefalse">
  <title>La valeur &true;/&false; comme retour de fonctions</title>
  <simpara>
   La plupart des fonctions internes de &php; ont été
   réécrite pour qu'elle retourne &true; en cas de succès,
   et &false; en cas d'erreur, au contraire des fonctions qui retournaient 0 et -1
   en PHP/FI 2.0. Le nouveau comportement est beaucoup plus logique, comme par
   exemple $fp = fopen("/your/file") or fail("fichier non trouvé!");.
   Etant donné que PHP/FI 2.0 n'a pas de règle claire à
   propos de ce que les fonctions doivent retourner en cas d'échec, la
   plupart des scripts devront probablement être vérifié
   manuellement, après avoir utilisé le convertisseur 2.0 à
   3.0.
  </simpara>
  <para>
   <example>
    <title>
      Migration depuis 2.0: valeur retournées, ancienne façon
    </title>
    <programlisting role="php">
<![CDATA[
<?php
  $fp = fopen($file, "r");
  if ($fp == -1);
    echo("Impossible d'ouvrir le fichier $file en lecture <br>\n");
  endif;
?>
]]>
    </programlisting>
   </example>
   <example>
    <title>Migration depuis 2.0: valeur retournées, nouvelle façon</title>
    <programlisting role="php">
<![CDATA[
<?php
  $fp = @fopen($file, "r") or
     print("Impossible d'ouvrir le fichier $file en lecture<br>\n");
?>
]]>
    </programlisting>
   </example>
  </para>
 </sect1>
 <sect1 id="migration.other">
  <title>Diverses incompatibilités</title>
   <itemizedlist>
    <listitem>
     <simpara>
      Le module &php; 3.0 pour Apache n'accepte plus les versions d'Apache antérieure
      à la version 1.2. Apache 1.2 ou plus récent est nécessaire.
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <function>echo</function> n'utilise plus de chaîne de formatage. Il faut
     utiliser <function>printf</function> à la place.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      En PHP/FI 2.0, un effet secondaire de l'implémentation faisait que
      <literal>$foo[0]</literal> était la même chose que
      <literal>$foo</literal>. Ce n'est plus vrai en &php; 3.0.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Lire un tableau avec $array[] n'est plus valable.
     </simpara>
     <simpara>
      Ainsi, il n'est plus possible de passer en revue un tableau avec des
      boucles telles que  <literal>$data = $array[]</literal>. Utilisez
      <function>current</function> et <function>next</function> à la place.
     </simpara>
     <simpara>
      Ainsi, <literal>$array1[] = $array2</literal> n'ajoute pas les valeurs
      de <literal>$array2</literal> à <literal>$array1</literal>,
      mais crée un nouvel élément dans <literal>$array1</literal>
      et y affecte <literal>$array2</literal> comme dernier élément.
      Voir aussi les tableaux multidimensionnels.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <literal>"+"</literal> n'est plus utilisable comme opérateur de
      concaténation de chaîne. A la place, il convertit les
      arguments en nombres et effectue une addition numérique.
      Utilisez <literal>"."</literal>  à la place.
     </simpara>
    </listitem>
   </itemizedlist>
   <example>
    <title>Migration depuis 2.0: concaténation de chaînes</title>
     <programlisting role="php">
<![CDATA[
<?php
  echo "1" + "1";
?>
]]>
     </programlisting>
     <para>
      En &php; 2.0 cela retournerait 11, en &php; 3.0 cela va retourner 2. A la place,
      faites :
      <programlisting role="php">
<![CDATA[
<?php
  echo "1"."1";
?>
]]>
      </programlisting>
      <programlisting role="php">
<![CDATA[
<?php
  $a = 1;
  $b = 1;
  echo $a + $b;
?>
]]>
      </programlisting>
      </para>
      <para>
       Cela va afficher 2, tant en &php; 2.0 qu'en 3.0.
       <programlisting role="php">
<![CDATA[
<?php
  $a = 1;
  $b = 1;
  echo $a.$b;
?>
]]>
        </programlisting>
        Cela va afficher 11 en &php; 3.0.
    </para>
   </example>
  </sect1>
 </appendix>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
