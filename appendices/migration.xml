<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.29 $ -->
<!-- EN-Revision: 1.25 Maintainer: dams Status: ready -->
<appendix id="migration">
 <title>Migration de PHP/FI 2 à &php; 3</title>
 <section id="migration.about">
  <title>À propos des incompatibilités en 3.0</title>
  <simpara>
   &php; 3.0 a été réécrit depuis le début. Le nouvel
   analyseur syntaxique est beaucoup plus robuste et cohérent qu'en version
   2.0. Il est aussi nettement plus rapide et utilise encore moins de
   mémoire. Cependant, ces améliorations n'ont pu être
   possibles qu'au prix de modifications parfois importantes, tant au niveau de
   la syntaxe qu'au niveau des fonctionnalités.
  </simpara>
  <simpara>
   De plus, l'équipe de développement &php; a essayé de nettoyer
   la syntaxe et la sémantique, ce qui a aussi causé quelques
   incompatibilités. À long terme, nous pensons que ces modifications
   seront pour le bien de tous.
  </simpara>
  <simpara>
   Ce chapitre va tenter de vous montrer les incompatibilités que vous
   pourriez rencontrer lors de votre migration de PHP/FI 2.0 à &php; 3.0
   et de vous aider à les résoudre. Les nouvelles
   fonctionnalités ne sont pas signalées, à moins que
   cela ne soit nécessaire.
  </simpara>
  <simpara>
   Un programme de conversion automatique de vos anciens scripts PHP/FI 2.0 
   existe. Il est disponible dans le dossier de convertisseur de la distribution
   &php; 3.0: c'est le dossier <filename class="directory">convertor</filename>.
   Ce programme ne fait que repérer les modifications de syntaxe et ne
   vous épargnera pas une relecture attentive du script.
  </simpara>
 </section>
 <section id="migration.old-function">
  <title><literal>old_function</literal></title>
  <simpara>
   L'instruction <literal>old_function</literal> vous permet
   de déclarer une fonction en utilisant une syntaxe identique à
   celle de PHP/FI (hormis le fait que vous devez remplacer
   &quot;<literal>function</literal>&quot; par
   &quot;<literal>old_function</literal>&quot;).
  </simpara>
  <simpara>
   C'est une fonctionnalité obsolète, qui ne doit être utilisée
   que par les convertisseurs PHP/FI 2 -> &php; 3.
  </simpara>
  <warning>
   <para>
    Les fonctions déclarées comme <literal>old_function</literal> ne peuvent
    pas être appelées depuis le code interne &php;. Entre autres choses,
    cela signifie que que vous ne pouvez pas les utiliser avec des fonctions
    comme <function>usort</function>, <function>array_walk</function> et
    <function>register_shutdown_function</function>. Vous pouvez
    contourner cette limitation en écrivant une fonction moderne, qui appelle
    cette vieille syntaxe <literal>old_function</literal>.
   </para>
  </warning>
 </section>
 <section id="migration.startendtags">
  <title>Balises &php;</title>
  <para>
   La première chose que vous remarquerez probablement est que les balises
   ouvrantes et fermantes de &php; ont changé. L'ancienne forme
   <literal>&lt;? &gt;</literal> a été remplacée par trois
   nouvelles balises possibles :
   <example>
    <title>Migration : balises &php;</title>
    <programlisting role="php">
<![CDATA[
<?
echo "Ceci est du code PHP/FI 2.0.\n";
>
]]>
    </programlisting>
   </example>
   Comme en version 2.0, PHP/FI accepte aussi cette variante :
   <example>
    <title>Migration : premières nouvelles balises &php;</title>
    <programlisting role="php">
<![CDATA[
<?
echo "Ceci est du code PHP 3.0!\n";
?>
]]>
    </programlisting>
   </example>
   Notez bien que la balise de fin contient désormais un point
   d'interrogation et un signe supérieur ">". Cependant,
   si vous souhaitez utiliser XML sur votre serveur, vous aurez sûrement
   des problèmes avec cette variante, car &php; risque d'essayer
   d'exécuter des balises XML. À cause de ceci, la notation
   suivante a été ajoutée :
   <example>
    <title>Migration : nouvelles balises &php;</title>
    <programlisting role="php">
<![CDATA[
<?php
echo "Ceci est du code PHP 3.0!\n";
?>
]]>
    </programlisting>
   </example>
   Certains d'entre vous rencontrent des problèmes avec les éditeurs qui
   ne comprennent pas ce type de balises d'instruction : Microsoft FrontPage
   est l'un de ces éditeurs, et, pour contourner le problème, la
   variation suivante a été introduite :
   <example><title>Nouvelles balises &php;</title>
    <programlisting role="php">
<![CDATA[
<script language="php">
    echo "Ceci est du code PHP 3.0!\n";
</script>
]]>

    </programlisting>
   </example>
  </para>
 </section>
 <section id="migration.if-endif">
  <title>Syntaxe <literal>if...endif</literal></title>
  <para>
   La syntaxe alternative pour écrire des instructions
   <literal>if/elseif/else</literal>, avec
   <literal>if(); elseif(); else; endif;</literal>
   ne pouvait pas être conservée sans ajouter beaucoup de
   complexité à l'analyseur syntaxique. De ce fait,
   cette syntaxe a été modifiée :
   <example>
    <title>Migration : ancienne syntaxe <literal>if...endif</literal></title>
    <programlisting role="php">
<![CDATA[
<?php
if ($foo);
    echo "oui\n";
elseif ($bar);
    echo "presque\n";
else;
    echo "non\n";
endif;
?>
]]>
    </programlisting>
   </example>
   <example>
    <title>Migration : nouvelle syntaxe <literal>if...endif</literal></title>
    <programlisting role="php">
<![CDATA[
<?php
if ($foo):
    echo "oui\n";
elseif ($bar):
    echo "presque\n";
else:
    echo "non\n";
endif;
?>
]]>
    </programlisting>
   </example>
   Notez que les points virgules ont été remplacée par des points dans
   toutes les commandes, sauf pour la dernière expression (<literal>endif</literal>).
  </para>
 </section>
 <section id="migration.while">
  <title>Syntaxe <literal>while</literal></title>
  <para>
   Tout comme pour <literal>if...endif</literal>, la syntaxe des boucles
   <literal>while...endwhile</literal> a changée :
   <example>
    <title>Migration : ancienne syntaxe <literal>while...endwhile</literal></title>
    <programlisting role="php">
<![CDATA[
<?php
while ($more_to_come);
    //...
endwhile;
?>
]]>
    </programlisting>
   </example>
   <example><title>Migration : nouvelle syntaxe <literal>while...endwhile</literal></title>
   <programlisting role="php">
<![CDATA[
<?php
while ($more_to_come):
    ...
endwhile;
?>
]]>
    </programlisting>
   </example>
  </para>
  <warning>
   <simpara>
    Attention : si vous utilisez la vieille syntaxe <literal>while...endwhile</literal>
    en &php; 3.0, vous obtiendrez une boucle sans fin !
   </simpara>
  </warning>
 </section>
 <section id="migration.expr">
  <title>Types d'expression</title>
  <simpara>
   PHP/FI 2.0 utilisait le membre à gauche dans les expressions, pour déterminer
   le type de résultat attendu. &php; 3.0 prend en compte les deux côtés de
   l'expression et cela peut produire des résultats inattendus avec les scripts 2.0.
  </simpara>
  <para>
   Considérez les lignes suivantes :
   <example>
    <title>Différence entre &php; 2 et &php; 3</title>
    <programlisting role="php">
<![CDATA[
<?php
$a[0]=5;
$a[1]=7;
$key = key($a);
while ("" != $key) {
  echo "$keyn";
  next($a);
}
?>
]]>
    </programlisting>
   </example>
    En PHP/FI 2.0, cet exemple va afficher les indices des <varname>$a</varname>.
    En &php; 3.0, l'exemple ne va rien afficher du tout. La raison est qu'en &php; 2.0, puisque
    l'argument de gauche est de type chaîne, une comparaison de chaîne était
    effectuée et, effectivement, &emptystring; n'est pas &emptystring;,
    ce qui conduit la boucle à continuer. En &php; 3, lorsqu'une chaîne est
    comparée avec un entier, la comparaison est de type chaîne (la chaîne
    est convertie en entier). Ce qui revient à faire la comparaison entre
    (<literal>atoi("")</literal>) qui vaut &zero; et la variable
    qui vaut aussi 0 et comme 0==0, la boucle ne commence même pas.
  </para>
  <para>
   La correction de ceci est simple. Il suffit de remplacer
   les commandes <literal>while</literal> par :
   <example>
    <title>Nouvelle syntaxe &php;3</title>
    <programlisting role="php">
<![CDATA[
<?php
while ((string)$key != "") {
?>
]]>
    </programlisting>
   </example>
  </para>
 </section>
 <section id="migration.errors">
  <title>Les messages d'erreur ont changé</title>
  <simpara>
   Les messages d'erreur en &php; 3.0 sont généralement plus précis que
   ceux de la version 2.0., mais vous ne verrez plus la portion de code qui a causé
   l'erreur. À la place, un numéro de ligne et un nom de fichier sera retourné.
  </simpara>
 </section>
 <section id="migration.booleval">
  <title>Evaluation rapide des booléens </title>
  <simpara>
   En &php; 3, l'évaluation des est court-circuité. Cela signifie dans une
   expression telle que (<literal>(1 || test_me())</literal>), la fonction
   <literal>test_me()</literal> ne sera pas exécutée, car cela ne changera
   pas le résultat.
  </simpara>
  <simpara>
   C'est une amélioration mineure, mais qui peut avoir des effets secondaires importants.
  </simpara>
 </section>
 <section id="migration.truefalse">
  <title>La valeur &true;/&false; comme retour de fonctions</title>
  <simpara>
   La plupart des fonctions internes de &php; ont été
   réécrite pour qu'elle retourne &true; en cas de succès,
   et &false; en cas d'erreur, au contraire des fonctions qui retournaient 0 et -1
   en PHP/FI 2.0. Le nouveau comportement est beaucoup plus logique, comme
   <literal>$fp = fopen("/your/file") or fail("fichier non trouvé!");</literal>.
   Étant donné que PHP/FI 2.0 n'a pas de règle claire à
   propos de ce que les fonctions doivent retourner en cas d'échec, la
   plupart des scripts devront probablement être vérifié
   manuellement, après avoir utilisé le convertisseur 2.0 à
   3.0.
  </simpara>
  <para>
   <example>
    <title>
      Migration depuis 2.0 : valeur retournées, ancienne méthode
    </title>
    <programlisting role="php">
<![CDATA[
<?php
$fp = fopen($file, "r");
if ($fp == -1);
    echo("Impossible d'ouvrir le fichier $file en lecture <br />\n");
endif;
?>
]]>
    </programlisting>
   </example>
   <example>
    <title>Migration depuis 2.0 : valeur retournées, nouvelle façon</title>
    <programlisting role="php">
<![CDATA[
<?php
$fp = @fopen($file, "r") or
print("Impossible d'ouvrir le fichier $file en lecture<br />\n");
?>
]]>
    </programlisting>
   </example>
  </para>
 </section>
 <section id="migration.other">
  <title>Diverses incompatibilités</title>
   <itemizedlist>
    <listitem>
     <simpara>
      Le module &php; 3.0 pour Apache n'accepte plus les versions d'Apache
      antérieure à la version 1.2. Apache 1.2 ou plus récent est nécessaire.
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <function>echo</function> n'utilise plus de chaîne de formatage. Il faut
     utiliser <function>printf</function> à la place.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      En PHP/FI 2.0, un effet secondaire de l'implémentation faisait que
      <literal>$foo[0]</literal> était la même chose que
      <literal>$foo</literal>. Ce n'est plus vrai en &php; 3.0.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Lire un tableau avec <literal>$array[]</literal> n'est plus valable.
     </simpara>
     <simpara>
      Ainsi, il n'est plus possible de passer en revue un tableau avec des
      boucles telles que  <literal>$data = $array[]</literal>. Utilisez
      <function>current</function> et <function>next</function> à la place.
     </simpara>
     <simpara>
      Ainsi, <literal>$array1[] = $array2</literal> n'ajoute pas les valeurs
      de <literal>$array2</literal> à <literal>$array1</literal>,
      mais crée un nouvel élément dans <literal>$array1</literal>
      et y affecte <literal>$array2</literal> comme dernier élément.
      Voir aussi les tableaux multidimensionnels.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <literal>"+"</literal> n'est plus utilisable comme opérateur de
      concaténation de chaîne. À la place, il convertit les
      arguments en nombres et effectue une addition numérique.
      Utilisez <literal>"."</literal>  à la place.
     </simpara>
    </listitem>
   </itemizedlist>
   <example>
    <title>Migration depuis 2.0 : concaténation de chaînes</title>
     <programlisting role="php">
<![CDATA[
<?php
echo "1" + "1";
?>
]]>
     </programlisting>
     <para>
      En &php; 2.0 cela retournerait 11, en &php; 3.0 cela va retourner 2. 
      À la place, faites :
      <programlisting role="php">
<![CDATA[
<?php
echo "1"."1";
?>
]]>
      </programlisting>
      <programlisting role="php">
<![CDATA[
<?php
$a = 1;
$b = 1;
echo $a + $b;
?>
]]>
      </programlisting>
      </para>
      <para>
       Cela va afficher 2, tant en &php; 2.0 qu'en 3.0.
       <programlisting role="php">
<![CDATA[
<?php
$a = 1;
$b = 1;
echo $a.$b;
?>
]]>
        </programlisting>
        Cela va afficher 11 en &php; 3.0.
    </para>
   </example>
  </section>
 </appendix>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
