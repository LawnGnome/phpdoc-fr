<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.6 $ -->
<!-- EN-Revision: 1.2 Maintainer: dams Status: ready -->
  <sect1 id="security.filesystem">
   <title>Sécurité des fichiers</title>
   <simpara>
    &php; est soumis aux règles de sécurité
    intrinsèques de la plupart des systèmes serveurs :
    il respecte notamment les droits des fichiers et des dossiers.
    Une attention particulière doit être portée aux
    fichiers ou dossiers qui sont accessibles à tout le monde, afin de
    s'assurer qu'ils ne divulguent pas d'informations critiques.
   </simpara>
   <simpara>
    Puisque &php; a été fait pour permettre aux utilisateurs
    d'accéder aux fichiers, il est possible de créer un
    script qui vous permet de lire des fichiers tels que /etc/password,
    de modifier les connexions ethernet, lancer des impressions de documents,
    etc. Cela implique notamment que vous devez vous assurer que les fichiers
    accédés par les scripts sont bien ceux qu'il faut.
   </simpara>
   <simpara>
    Considérez le script suivant, où l'utilisateur indique
    qu'il souhaite effacer un fichier dans son dossier racine. Nous
    supposons que &php; est utilisé comme interface web pour
    gérer les fichiers, et que l'utilisateur Apache est
    autorisé à effacer les fichiers dans le dossier racine des
    utilisateurs.
   </simpara>
   <para>
    <example>
     <title>Une erreur de vérification de variable conduit à ...</title>
     <programlisting role="php">
<![CDATA[
<?php
// Efface un fichier dans un dossier racine
$username = $_POST['user_submitted_name'];
$homedir = "/home/$username";
$file_to_delete = "$userfile";
unlink ($homedir/$userfile);
echo "$file_to_delete a été effacé!";
?>
]]>
     </programlisting>
    </example>
    Etant donné que le nom de l'utilisateur est à fournir, des intrus peuvent
    envoyer un nom d'utilisateur autre que le leur, et effacer des
    documents dans les comptes des autres utilisateurs.
    Dans ce cas, vous souhaiterez utiliser une autre forme d'authentification.
    Considérez ce qui pourrait se passer si les utilisateurs passent
    "../etc/" et "passwd" comme arguments! Le code serait exécuté
    tel que :
    <example>
     <title>Une attaque du système de fichiers!</title>
     <programlisting role="php">
<![CDATA[
<?php
// efface un fichier n'importe où sur le disque dur,
// où l'utilisateur PHP a accès. Si PHP a un accès root :
$username = "../etc/";
$homedir = "/home/../etc/";
$file_to_delete = "passwd";
unlink ("/home/../etc/passwd");
echo "/home/../etc/passwd a été effacé!";
?>
]]>
     </programlisting>
    </example>
    Il y a deux mesures primordiales à prendre pour éviter
    ces manoeuvres :
    <itemizedlist>
     <listitem>
      <simpara>
       Limiter les permissions de l'utilisateur web &php;.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Vérifier toutes les variables liées aux chemins et aux fichiers
       qui sont fournis.
      </simpara>
     </listitem>
    </itemizedlist>
    Voici un script renforcé :
    <example>
     <title>Une vérification renforcée</title>
     <programlisting role="php">
<![CDATA[
<?php
// Efface un fichier sur le disque où l'utilisateur à le droit d'aller
  $username = $_SERVER['REMOTE_USER'];
// utilise un mécanisme d'authentification
  $homedir = "/home/$username";
  $file_to_delete = basename("$userfile");
// supprime le chemin excédentaire
  unlink ($homedir/$file_to_delete);
  $fp = fopen("/home/logging/filedelete.log","+a"); //note l'effacement
  $logstring = "$username $homedir $file_to_delete";
  fputs ($fp, $logstring);
  fclose($fp);
  echo "$file_to_delete a été éffacé!";
?>
]]>
     </programlisting>
    </example>
    Cependant, même cette technique n'est pas sans faille.
    Si votre système d'identification permet aux utilisateurs
    de créer leur propre login, et qu'un utilisateur choisi
    le login "../etc/", le système est de nouveau exposé. Pour cette
    raison, vous pouvez essayez d'écrire un script renforcé :
    <example>
     <title>Vérification de noms de fichiers sécurisée</title>
     <programlisting role="php">
<![CDATA[
<?php
  $username = $_SERVER['REMOTE_USER'];;
  $homedir = "/home/$username";
  if (!ereg('^[^./][^/]*$', $username))
    die('Erreur de nom de fichier');
    //meurt, ne SURTOUT pas traiter!
// etc.
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Suivant votre système d'exploitation, vous devrez protéger
    un grand nombre de fichiers, notamment les entrées de périphériques,
    (/dev/ ou COM1), les fichiers de configuration (fichiers /etc/ et .ini),
    les lieux de stockage d'informations (/home/, My Documents), etc.
    Pour cette raison, il est généralement plus sûr d'établir une
    politique qui interdit TOUT sauf ce que vous autorisez.
   </para>
  </sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
