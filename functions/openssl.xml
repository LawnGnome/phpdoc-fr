 <reference id="ref.openssl">
  <title>OpenSSL</title>
  <titleabbrev>OpenSSL</titleabbrev>
  <partintro>
  <sect1 id="openssl.intro">
  <title>Introduction</title>
   <para>
    Cette extension utilise les fonctions de
    <ulink url="&url.openssl;">OpenSSL</ulink> pour g&eacute;n&eacute;rer
    et v&eacute;rifier les signatures, ainsi que pour sceller (chiffrer)
    et ouvrir (d&eacute;chiffrer) les donn&eacute;es. Vous avez besoin de
    OpenSSL >= 0.9.5 pour utiliser ce module.
   </para>
   <para>
    Cette extension supporte aussi la signature et le cryptage des
    courrier &eacute;l&eacute;ctroniques. Il est aussi possible de sp&eacute;cifier des
    couples cl&eacute;s/certificats d'un grand nombre de cas, qui rendent
    le code PHP plus facile &agrave; lire. Ces fonctionnalit&eacute;s sont disponibles
    en d&eacute;veloppement sur CVS, et probablement avec PHP 4.0.6.
    <emphasis>ATTENTION : cette extension est encore exp&eacute;rimentale!</emphasis>
   </para>
   <para>
    OpenSSL offre de nombreuses fonctionnalit&eacute;s qui ne sont pas
    encore support&eacute;es par ce module. Elle seront ajout&eacute;es
    ult&eacute;rieurement.
   </para>
  </sect1>
  <sect1 id="openssl.certparams">
  <title>Param&egrave;tres cl&eacute;s/certificats</title>
   <para>
    Un bon nombre de fonctions OpenSSL demandent une cl&eacute; et un certificat
    comme param&egrave;tres. PHP 4.0.5 et plus r&eacute;cent utilisait 
    des cl&eacute;s ou certificats sous forme de ressource, retourn&eacute;e 
    par l'une des fonctions openssl_get_xxx(). Les versions ult&eacute;rieures
    utilisent l'une des m&eacute;thodes suivantes :
    <itemizedlist>
     <listitem>
      <para>
       Certificats
       <orderedlist>
        <listitem>
         <simpara>
          Une ressource X.509 retourn&eacute;e par <function>openssl_x509_read</function>
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          Une cha&icirc;ne au format <filename>file://path/to/cert.pem</filename>;
          Le fichier ainsi rep&eacute;r&eacute; doit contenir un certificat, encod&eacute; au
          format PEM
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          Une cha&icirc;ne contenant le contenu d'un certificat, encod&eacute; au
          format PEM.
         </simpara>
        </listitem>
       </orderedlist>
      </para>
     </listitem>
     <listitem>
      <para>
       Cl&eacute;s publiques/priv&eacute;e
       <orderedlist>
        <listitem>
         <simpara>
          Une ressource cl&eacute;, retourn&eacute;e par la fonction
          <function>openssl_get_publickey</function> ou
          <function>openssl_get_privatekey</function>
         </simpara>
        </listitem>
        <listitem>
         <simpara>
         Pour les cl&eacute;s publiques seulement : une ressource
         X.509
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          Une cha&icirc;ne avec le format : <filename>file://path/to/file.pem</filename>.
          Le fichier doit contenir une cl&eacute; priv&eacute; ou un certificat, encod&eacute; au
          format PEM (il peut contenir les deux).
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          Une cha&icirc;ne contenant une cl&eacute; ou un certificat
          encod&eacute; au format PEM
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          Pour les cl&eacute;s priv&eacute;es, vous pouvez aussi utiliser la syntaxe
          <emphasis>array($key, $passphrase)</emphasis>, o&ugrave; $key repr&eacute;sente
          une cl&eacute; sp&eacute;cifi&eacute;e par un fichier ou une repr&eacute;sentation textuelle comme
          cit&eacute; ci-dessus, et $passphrase repr&eacute;sente une cha&icirc;ne contenant la
          passe-phrase de cette cl&eacute; priv&eacute;e.
         </simpara>
        </listitem>
       </orderedlist>
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </sect1>
  <sect1 id="openssl.cert.verification">
  <title>V&eacute;rification de certificats</title>
   <para>
    Lorsque vous appelez une fonction qui va v&eacute;rifier une signature ou
    un certificat, le param&egrave;tre <emphasis>cainfo</emphasis> doit &ecirc;tre un
    tableau contenant les noms d'un dossier et d'un fichier contenant les
    tiers de confiance. Si un dossier est sp&eacute;cifi&eacute;, il doit &ecirc;tre correct,
    car <command>openssl</command> va l'utiliser.
   </para>
   </sect1>
   <sect1 id="openssl.pkcs7.flags">
    <title>Constantes/flags PKCS7</title>
    <para>
     Les fonctions S/MIME utilisent des flags qui sont sp&eacute;cifi&eacute;s par un
     champs de bits. Les valeurs valides sont :
     <table>
      <title>Constantes PKCS7</title>
       <tgroup cols="2">
        <thead>
         <row>
          <entry>Constante</entry>
          <entry>Description</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry>PKCS7_TEXT</entry>
          <entry>
           Ajoute le texte plein en clair dans les ent&ecirc;tes du message
           sign&eacute;/chiffr&eacute;. Lors du d&eacute;chiffrement ou la v&eacute;rification,
           il supprime purement et simplement ces donn&eacute;es. Si le
           message chiffr&eacute; ou sign&eacute; n'est pas du type MIME, une erreur
           surviendra.
          </entry>
         </row>
         <row>
          <entry>PKCS7_BINARY</entry>
          <entry>
           Normalement, le message est converti au format canonique
           qui utilise effectivement des CR et LF comme fin de ligne,
           comme demand&eacute; dans les sp&eacute;cification de S/MIME.
           Lorsque cette option est activ&eacute;e, le message ne sera
           pas converti. Cela sert lorsque vous manipulez des donn&eacute;es
           binaires qui ne sont pas au format MIME.
          </entry>
         </row>
         <row>
          <entry>PKCS7_NOINTERN</entry>
          <entry>
           Lors de la v&eacute;rification d'un message, les certificats
           (s'il y en a) inclus dans le message sont normalement
           utilis&eacute; pour rechercher le certificat de signature. Avec
           cette option, seul le certificat sp&eacute;cifi&eacute; par le
           param&egrave;tre <parameter>extracerts</parameter> de la fonction
           <function>openssl_pkcs7_verify</function> est utilis&eacute;.
           Les certificats fournis peuvent toujours &ecirc;tre utilis&eacute;,
           avec un niveau de confiance r&eacute;duit.
          </entry>
         </row>
         <row>
          <entry>PKCS7_NOVERIFY</entry>
          <entry>
           Ne v&eacute;rifie pas les certificats des signataires d'un message
           sign&eacute;.
          </entry>
         </row>
         <row>
          <entry>PKCS7_NOCHAIN</entry>
          <entry>
           N'enchaine pas les v&eacute;rifications des signataires de certificats.
           C'est &agrave; dire, n'utilise pas les certificats contenu dans le
           message.
          </entry>
         </row>
         <row>
          <entry>PKCS7_NOCERTS</entry>
          <entry>
           Lors de la signature d'un message, le certificat du signataire
           est normalement inclus. Avec cette option, c'est d&eacute;sactiv&eacute;.
           Cela va r&eacute;duire la taille du message, mais le v&eacute;rificateur
           devra avoir une copie local du certificat du signataire
           (pass&eacute;e au param&egrave;tre <parameter>extracerts</parameter>, avec
           la fonction <function>openssl_pkcs7_verify</function>).
          </entry>
         </row>
         <row>
          <entry>PKCS7_NOATTR</entry>
          <entry>
           Normalement, lorsqu'un message est sign&eacute;, un jeu d'attributs
           contenant l'heure de signature et l'algorithme sym&eacute;trique
           support&eacute;, est inclus dans le message. Avec cette option,
           il n'est pas inclus.
          </entry>
         </row>
         <row>
          <entry>PKCS7_DETACHED</entry>
          <entry>
           Lors de la signature d'un message, utilise la signature
           en texte claire, avec le type MIME "multipart/signed".
           C'est la valeur par d&eacute;faut du param&egrave;tre <parameter>flags</parameter>
           pour la fonction <function>openssl_pkcs7_sign</function>.
           Si vous annulez cette optoin, le message sera sign&eacute; de mani&egrave;re
           opaque, ce qui resiste mieux &agrave; la traduction des relais mails
           (certains serveur mail anciens corrompent les messages), mais
           emp&ecirc;che la lecture par les client mails qui ne connaissent pas
           S/MIME.
          </entry>
         </row>
         <row>
          <entry>PKCS7_NOSIGS</entry>
          <entry>
           Ne v&eacute;rifie pas les signatures d'une message
          </entry>
         </row>
        </tbody>
       </tgroup>
      </table>
    </para>
    <note>
     <para>
      Ces constantes ont &eacute;t&eacute; ajout&eacute;es en PHP 4.0.6.
     </para>
    </note>
   </sect1>
  </partintro>
  <refentry id="function.openssl-error-string">
   <refnamediv>
    <refname>openssl_error_string</refname>
    <refpurpose>Retourne le message d'erreur OpenSSL</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>mixed <function>openssl_error_string</function></funcdef>
      <paramdef>void<parameter></parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>openssl_error_string</function> retourne un message d'erreur,
     sous forme de cha&icirc;ne de caract&egrave;res, ou <literal>FALSE</literal> s'il n'y a
     pas de message d'erreur.
    </para>
    <para>
     <function>openssl_error_string</function> retourne la derni&egrave;re erreur de
     la librairie OpenSSL. Les messages d'erreurs sont empil&eacute;s, et
     <function>openssl_error_string</function> doit &ecirc;tre appel&eacute; plusieurs fois
     pour afficher toutes les erreurs.
    </para>
    <para>
     <emphasis>Les param&egrave;tres et le type de retour de cette fonction risquent
     d'evoluer d'ici &agrave; la prochaine version de PHP.</emphasis>
    </para>
    <para>
     <example>
      <title>Exemple avec <function>openssl_error_string</function></title>
      <programlisting role="php">
&lt;?php
// Imaginons que vous avez appel&eacute; une fonction qui a &eacute;mis une erreur
while($msg = openssl_error_string)
    echo $msg . "&lt;br&gt;";
?&gt;
      </programlisting>
     </example>
    </para>
    <note>
     <para>
      Ces constantes ont &eacute;t&eacute; ajout&eacute;es en PHP 4.0.6.
     </para>
    </note>
   </refsect1>
  </refentry>
  <refentry id="function.openssl-free-key">
   <refnamediv>
    <refname>openssl_free_key</refname>
    <refpurpose>Lib&egrave;re les ressources</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>void <function>openssl_free_key</function></funcdef>
      <paramdef>resource <parameter>key_identifier</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>openssl_free_key</function> lib&egrave;re les ressources
     associ&eacute;es &agrave; <parameter>key_identifier</parameter>.
    </para>
   </refsect1>
  </refentry>
  <refentry id="function.openssl-get-privatekey">
   <refnamediv>
    <refname>openssl_get_privatekey</refname>
    <refpurpose>Pr&eacute;pare une cl&eacute; priv&eacute;e au format PEM</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>resource <function>openssl_get_privatekey</function></funcdef>
      <paramdef>mixed <parameter>key</parameter></paramdef>
      <paramdef>string <parameter><optional>passphrase</optional></parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>openssl_get_privatekey</function> retourne un identifiant
     de cl&eacute; positif, ou <literal>FALSE</literal> en cas d'erreur.
    </para>
    <para>
     <function>openssl_get_privatekey</function> analyse la cl&eacute; priv&eacute;e
     <parameter>key</parameter>, au format PEM, et la pr&eacute;pare pour
     &agrave; &ecirc;tre utilis&eacute;e par d'autres fonctions. Le param&egrave;tre optionnel
     <parameter>passphrase</parameter> doit &ecirc;tre utilis&eacute; si
     la cl&eacute; est chiffr&eacute;e (prot&eacute;g&eacute;e par un mot de passe).
    </para>
   </refsect1>
  </refentry>
  <refentry id="function.openssl-get-publickey">
   <refnamediv>
    <refname>openssl_get_publickey</refname>
    <refpurpose>Extrait une cl&eacute; publique d'un certificat</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>resource <function>openssl_get_publickey</function></funcdef>
      <paramdef>mixed <parameter>certificate</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>openssl_get_publickey</function> retourne un identifiant
     de cl&eacute; positif, ou <literal>FALSE</literal> en cas d'erreur.
    </para>
    <para>
     <function>openssl_get_publickey</function> extrait la cl&eacute; publique
     du certificat <parameter>certificate</parameter> (format X.509), et la
     pr&eacute;pare &agrave; &ecirc;tre utilis&eacute;e ult&eacute;rieurement.
    </para>
   </refsect1>
  </refentry>
  <refentry id="function.openssl-open">
   <refnamediv>
    <refname>openssl_open</refname>
    <refpurpose>Ouvre des donn&eacute;es scell&eacute;es</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>bool <function>openssl_open</function></funcdef>
      <paramdef>string <parameter>sealed_data</parameter></paramdef>
      <paramdef>string <parameter>open_data</parameter></paramdef>
      <paramdef>string <parameter>env_key</parameter></paramdef>
      <paramdef>mixed <parameter>priv_key_id</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>openssl_open</function> <literal>TRUE</literal>
     en cas de succ&egrave;s, et <literal>FALSE</literal> sinon.
     En cas de succ&egrave;s, les donn&eacute;es d&eacute;chiffr&eacute;es
     sont plac&eacute;es dans <parameter>open_data</parameter>.
    </para>
    <para>
     <function>openssl_open</function> ouvre (d&eacute;chiffre) les donn&eacute;es
     <parameter>sealed_data</parameter> en utilisant la cl&eacute; prvi&eacute;e
     <parameter>priv_key_id</parameter> et la cl&eacute; d'enveloppe
     <parameter>env_key</parameter> et remplis <parameter>open_data</parameter>
     avec les donn&eacute;es d&eacute;chiffr&eacute;es. La cl&eacute; d'enveloppe est
     g&eacute;n&eacute;r&eacute;e lorsque les donn&eacute;es sont
     scell&eacute;es, et ne peut &ecirc;tre utilis&eacute;e qu'avec
     la cl&eacute; priv&eacute;e sp&eacute;cifique. Reportez vous &agrave;
     <function>openssl_seal</function> pour plus d'informations.
    </para>
    <para>
     <example>
      <title>Exemple avec <function>openssl_open</function></title>
      <programlisting role="php">
&lt;?php
// On suppose que $sealed et $env_key contiennent les donn&eacute;es scell&eacute;es
// et la cl&eacute; d'enveloppe, fournies par l'exp&eacute;diteur
// lecture de la cl&eacute; priv&eacute;e dans un fichier
$fp = fopen("/src/openssl-0.9.6/demos/sign/key.pem", "r");
$priv_key = fread($fp, 8192);
fclose($fp);
$pkeyid = openssl_get_privatekey($priv_key);
// d&eacute;chiffrage des donn&eacute;es : elles sont plac&eacute;es dans $open
if (openssl_open($sealed, $open, $env_key, $pkeyid))
    echo "Voici les donn&eacute;es d&eacute;chiffr&eacute;es : ", $open;
else
    echo "Impossible de d&eacute;chiffrer les donn&eacute;es";
// lib&eacute;ration des ressources
openssl_free_key($pkeyid);
?&gt;
      </programlisting>
     </example>
    </para>
    <simpara>
     Voir aussi
     <function>openssl_seal</function>.
    </simpara>
   </refsect1>
  </refentry>
  <refentry id="function.openssl-seal">
   <refnamediv>
    <refname>openssl_seal</refname>
    <refpurpose>Scelle des donn&eacute;es</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>openssl_seal</function></funcdef>
      <paramdef>string <parameter>data</parameter></paramdef>
      <paramdef>string <parameter>sealed_data</parameter></paramdef>
      <paramdef>array <parameter>env_keys</parameter></paramdef>
      <paramdef>array <parameter>pub_key_ids</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>openssl_seal</function> retourne la longueur des donn&eacute;es
     scell&eacute;es en cas de succ&egrave;s, et <literal>FALSE</literal> sinon.
     En cas de succ&egrave;s, les donn&eacute;es scell&eacute;es sont
     plac&eacute;es dans le param&egrave;tre <parameter>sealed_data</parameter>,
     et les cl&eacute;s d'enveloppe dans <parameter>env_keys</parameter>.
    </para>
    <para>
     <function>openssl_seal</function> scelle (chiffre) les donn&eacute;es
     <parameter>data</parameter> en utilisant l'algorithme RC4 avec une cl&eacute;
     secr&egrave;tre g&eacute;n&eacute;r&eacute;e al&eacute;atoirement. La cl&eacute;
     est chiffr&eacute;e avec chaque cl&eacute; publique associ&eacute;e &agrave;
     <parameter>pub_key_ids</parameter> et chaque cl&eacute; ainsi
     encrypt&eacute;e est retourn&eacute;e dans <parameter>env_keys</parameter>.
     Cela signifique que vous pouvez envoyez des donn&eacute;es scell&eacute;es
     &agrave; plusieurs destinataires (en supposant que chacun ait recu la
     cl&eacute; publique). Chaque destinataire doit recevoir les donn&eacute;es
     encrypt&eacute;es et la cl&eacute; d'enveloppe, qui a &eacute;t&eacute;
     encrypt&eacute;e avec la cl&eacute; publique du destinataire.
    </para>
    <para>
     <example>
      <title>Exemple avec <function>openssl_seal</function></title>
      <programlisting role="php">
&lt;?php
// On suppose que $data contient les donn&eacute;es &agrave; sceller
// lecture de la cl&eacute; publique pour chaque destinataire
$fp = fopen("/src/openssl-0.9.6/demos/maurice/cert.pem", "r");
$cert = fread($fp, 8192);
fclose($fp);
$pk1 = openssl_get_publickey($cert);
// pour le deuxi&egrave;me destinataire
$fp = fopen("/src/openssl-0.9.6/demos/sign/cert.pem", "r");
$cert = fread($fp, 8192);
fclose($fp);
$pk2 = openssl_get_publickey($cert);
// scelle le message : seuls, les possessuers de $pk1 et $pk2 peuvent d&eacute;chiffrer
// le message $sealed avec les cl&eacute;s $ekeys[0] et $ekeys[1] (respectivement).
openssl_seal($data, $sealed, $ekeys, array($pk1,$pk2));
// lib&egrave;re les cl&eacute;s de la m&eacute;moire
openssl_free_key($pk1);
openssl_free_key($pk2);
?&gt;
      </programlisting>
     </example>
    </para>
    <simpara>
     Voir aussi
     <function>openssl_open</function>.
    </simpara>
   </refsect1>
  </refentry>
  <refentry id="function.openssl-sign">
   <refnamediv>
    <refname>openssl_sign</refname>
    <refpurpose>Signe les donn&eacute;es</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>bool <function>openssl_sign</function></funcdef>
      <paramdef>string <parameter>data</parameter></paramdef>
      <paramdef>string <parameter>signature</parameter></paramdef>
      <paramdef>mixed <parameter>priv_key_id</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>openssl_sign</function> retourne <literal>TRUE</literal> en cas de succ&egrave;s, et
     <literal>FALSE</literal> sinon. En cas de succ&egrave;s, la signature est plac&eacute;e dans
     <parameter>signature</parameter>.
    </para>
    <para>
     <function>openssl_sign</function> calcule la signature des donn&eacute;es
     <parameter>data</parameter> en utilisant l'algorithme SHA1 (hashing)
     suivi du chiffrage avec la cl&eacute; priv&eacute;e <parameter>priv_key_id</parameter>.
     Notez que les donn&eacute;es elles-m&ecirc;mes ne sont pas chiffr&eacute;es.
    </para>
    <para>
     <example>
      <title>Exemple avec <function>openssl_sign</function></title>
      <programlisting role="php">
&lt;?php
// On suppose que $data contient les donn&eacute;es &agrave; signer
// lecture de la cl&eacute; publique pour chaque destinataire
$fp = fopen("/src/openssl-0.9.6/demos/sign/key.pem", "r");
$priv_key = fread($fp, 8192);
fclose($fp);
$pkeyid = openssl_get_privatekey($priv_key);
// calcule de la signature
openssl_sign($data, $signature, $pkeyid);
// lib&egrave;re les cl&eacute;s de la m&eacute;moire
openssl_free_key($pkeyid);
?&gt;
      </programlisting>
     </example>
    </para>
    <simpara>
     Voir aussi
     <function>openssl_verify</function>.
    </simpara>
   </refsect1>
  </refentry>
  <refentry id="function.openssl-verify">
   <refnamediv>
    <refname>openssl_verify</refname>
    <refpurpose>V&eacute;rifie une signature</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>openssl_verify</function></funcdef>
      <paramdef>string <parameter>data</parameter></paramdef>
      <paramdef>string <parameter>signature</parameter></paramdef>
      <paramdef>resource <parameter>pub_key_id</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>openssl_verify</function> retourne 1 si la signature est
     correcte, 0 si la signature est incorrecte, et -1 en cas d'erreur.
    </para>
    <para>
     <function>openssl_verify</function> v&eacute;rifie que la signature
     <parameter>signature</parameter> est correcte pour les donn&eacute;es
     <parameter>data</parameter>, et avecd la cl&eacute; publique
     <parameter>pub_key_id</parameter>. Cette cl&eacute; doit &ecirc;tre la cl&eacute;
     publique correspondant &agrave; la cl&eacute; priv&eacute;e
     utilis&eacute;e lors de la signature.
    </para>
    <para>
     <example>
      <title>Exemple avec <function>openssl_verify</function></title>
      <programlisting role="php">
&lt;?php
// On suppose que $data et $signature contiennent les donn&eacute;es &agrave; signer et
// la signature
// lecture de la cl&eacute; publique depuis le certificat
$fp = fopen("/src/openssl-0.9.6/demos/sign/cert.pem", "r");
$cert = fread($fp, 8192);
fclose($fp);
$pubkeyid = openssl_get_publickey($cert);
// indique si la signature est correcte
$ok = openssl_verify($data, $signature, $pubkeyid);
if ($ok == 1)
    echo "Signature valide";
elseif ($ok == 0)
    echo "Signature erronn&eacute;e";
else
    echo "Erreur de v&eacute;rification de la signature";
// lib&egrave;re les cl&eacute;s de la m&eacute;moire
openssl_free_key($pubkeyid);
?&gt;
      </programlisting>
     </example>
    </para>
    <simpara>
     Voir aussi
     <function>openssl_sign</function>.
    </simpara>
   </refsect1>
  </refentry>
  <refentry id="function.openssl-pkcs7-decrypt">
   <refnamediv>
    <refname>openssl_pkcs7_decrypt</refname>
    <refpurpose>D&eacute;chiffre un message S/MIME</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>bool <function>openssl_pkcs7_decrypt</function></funcdef>
      <paramdef>string <parameter>infilename</parameter></paramdef>
      <paramdef>string <parameter>outfilename</parameter></paramdef>
      <paramdef>mixed <parameter>recipcert</parameter></paramdef>
      <paramdef>mixed <parameter>recipkey</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>openssl_pkcs7_decrypt</function> d&eacute;chiffre le message S/MIME
     contenu dans le fichier <parameter>infilename</parameter>, en utilisant le
     certificat et la cl&eacute; priv&eacute;e sp&eacute;cifi&eacute;s par <parameter>recipcert</parameter> et
     <parameter>recipkey</parameter>. Le message d&eacute;chiffr&eacute; sera &eacute;crit dans le
     fichier <parameter>outfilename</parameter>.
    </para>
    <para>
     <emphasis>Les param&egrave;tres et le type de retour de cette fonction risquent
     d'evoluer d'ici &agrave; la prochaine version de PHP.</emphasis>
    </para>
    <para>
     <example>
      <title>Exemple avec <function>openssl_pkcs7_decrypt</function></title>
      <programlisting role="php">
&lt;?php
// $cert et $key contiennent vos certificats et cl&eacute;s priv&eacute;s
// On suppose aussi que le message vous est destin&eacute;
$infilename = "encrypted.msg";  // Le message chiffr&eacute;
$outfilename = "decrypted.msg"; // Assurez vous de bien pouvoir &eacute;crire dans ce fichier
if (openssl_pkcs7_decrypt($infilename, $outfilename, $cert, $key))
    echo "d&eacute;chiffr&eacute;!";
else
    echo "impossible de d&eacute;chiffrer!";
?&gt;
      </programlisting>
     </example>
    </para>
    <note>
     <para>
      Ces constantes ont &eacute;t&eacute; ajout&eacute;es en PHP 4.0.6.
     </para>
    </note>
   </refsect1>
  </refentry>
  <refentry id="function.openssl-pkcs7-encrypt">
   <refnamediv>
    <refname>openssl_pkcs7_encrypt</refname>
    <refpurpose>Chiffre un message S/MIME</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>bool <function>openssl_pkcs7_encrypt</function></funcdef>
      <paramdef>string <parameter>infilename</parameter></paramdef>
      <paramdef>string <parameter>outfilename</parameter></paramdef>
      <paramdef>mixed <parameter>recipcerts</parameter></paramdef>
      <paramdef>array <parameter>headers</parameter></paramdef>
      <paramdef>long <parameter><optional>flags</optional></parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>openssl_pkcs7_encrypt</function> prend le contenu du fichier
     <parameter>infilename</parameter> et le chiffre en utilisant un
     chiffrement RC2 &agrave; 40-bit, de mani&egrave;re &agrave; ce que le message ne puisse
     &ecirc;tre lu que par le possesseur de <parameter>recipcerts</parameter>,
     qui peut &ecirc;tre un certificat X.509, ou un tableau de certificats X.509.
     <parameter>headers</parameter> est un tableau d'ent&ecirc;te qui sera
     ajout&eacute; en t&ecirc;te de message, une fois que les donn&eacute;es auront &eacute;t&eacute;
     chiffr&eacute;es. <parameter>flags</parameter> peut &ecirc;tre utilis&eacute; pour sp&eacute;cifier
     des options qui affecteront le chiffrement (voir les
     <link linkend="openssl.pkcs7.flags">constantes PKCS7</link>).
     <parameter>headers</parameter> peut &ecirc;tre un tableau associatif, dont
     les cl&eacute;s sont les noms d'ent&ecirc;te, ou bien un tableau index&eacute; dont chaque
     ligne contient une ligne d'ent&ecirc;te compl&egrave;te.
    </para>
    <para>
     <emphasis>Les param&egrave;tres et le type de retour de cette fonction risquent
     d'evoluer d'ici &agrave; la prochaine version de PHP.</emphasis>
    </para>
    <para>
     <example>
      <title>Exemple avec <function>openssl_pkcs7_encrypt</function></title>
      <programlisting role="php">
&lt;?php
// le message que vous souhaitez chiffrer et envoyer &agrave; votre agent secret
// en mission command&eacute;e, appel&eacute; "nighthawk". Vous avez son certificat
// dans le fichir "nighthawk.pem"
$data = &lt;&lt;&lt;EOD
Nighthawk,
Top secret, uniquement vous votre lecture!
L'ennemi approche! Rendez vous au caf&eacute; &agrave; 8h30,
pour votre faux passeport.
HQ
EOD;
// sauvez le message dans un fichier
$fp = fopen("msg.txt", "w");
fwrite($fp, $data);
fclose($fp);
// chiffrez le
if (openssl_pkcs7_encrypt("msg.txt", "enc.txt", "nighthawk.pem",
    array("To" =&gt; "nighthawk@agent.com", // keyed syntax
          "From: HQ &lt;hq@cia.com&gt;", // indexed syntax
          "Subject" =&gt; "Eyes only")))
{
    // message chiffr&eacute; : envoyez le!
    exec(ini_get("sendmail_path") . " &lt; enc.txt");
}
?&gt;
      </programlisting>
     </example>
    </para>
    <note>
     <para>
      Ces constantes ont &eacute;t&eacute; ajout&eacute;es en PHP 4.0.6.
     </para>
    </note>
   </refsect1>
  </refentry>
 <refentry id="function.openssl-pkcs7-sign">
  <refnamediv>
   <refname>openssl_pkcs7_sign</refname>
   <refpurpose>signe un message S/MIME</refpurpose>
  </refnamediv>
  <refsect1>
   <title>Description</title>
   <funcsynopsis>
    <funcprototype>
     <funcdef>bool <function>openssl_pkcs7_sign</function></funcdef>
     <paramdef>string <parameter>infilename</parameter></paramdef>
     <paramdef>string <parameter>outfilename</parameter></paramdef>
     <paramdef>mixed <parameter>signcert</parameter></paramdef>
     <paramdef>mixed <parameter>privkey</parameter></paramdef>
     <paramdef>array <parameter>headers</parameter></paramdef>
     <paramdef>long
     <parameter><optional>flags</optional></parameter></paramdef>
     <paramdef>string
     <parameter><optional>extracertsfilename</optional></parameter></paramdef>
    </funcprototype>
   </funcsynopsis>
   <para>
    <function>openssl_pkcs7_sign</function> prend le contenu du fichier
    <parameter>infilename</parameter> et le signe en utilisant le
    certificat et la cl&eacute; priv&eacute;e contenus dans les arguments
    <parameter>signcert</parameter> et <parameter>privkey</parameter>.
   </para>
   <para>
    <parameter>headers</parameter> est un tableau d'ent&ecirc;te qui
    sera ajout&eacute; au donn&eacute;es chiffr&eacute;es (voir la fonction
    <function>openssl_pkcs7_encrypt</function> pour plus de d&eacute;tails sur
    le format du param&egrave;tre).
   </para>
   <para>
    <parameter>flags</parameter> sert &agrave; modifier le message final.
    Voyez les <link linkend="openssl.pkcs7.flags">constantes PKCS7</link>. Par
    d&eacute;faut, la valeur est : PKCS7_DETACHED.
   </para>
   <para>
    <parameter>extracerts</parameter> sp&eacute;cifi le nom du fichier contenant
    un ensemble de certificat suppl&eacute;mentaires &agrave; inclure dans la
    signature, qui pourront aider le destinataire &agrave; v&eacute;rifier les
    donn&eacute;es que vous utilisez.
   </para>
    <para>
     <emphasis>Les param&egrave;tres et le type de retour de cette fonction risquent
     d'evoluer d'ici &agrave; la prochaine version de PHP.</emphasis>
    </para>
    <para>
     <example>
      <title><function>openssl_pkcs7_sign</function> example</title>
      <programlisting role="php">
&lt;?php
// le message que vous voulez signer, afin que le destinataire soit s&ucirc;r qu'il
// vient bien de vous
$data = &lt;&lt;&lt;EOD
Tu peux d&eacute;penser jusqu'&agrave; 10000 euros en note de frais.
Ton boss
HQ
EOD;
// sauvez le message dans un fichier
$fp = fopen("msg.txt", "w");
fwrite($fp, $data);
fclose($fp);
// chiffrez le
if (openssl_pkcs7_sign("msg.txt", "signed.txt", "mycert.pem",
    array("mycert.pem", "mypassphrase"),
    array("To" =&gt; "joes@sales.com", // keyed syntax
          "From: HQ &lt;ceo@sales.com&gt;", // indexed syntax
          "Subject" =&gt; "Eyes only"))
{
    // message signed - send it!
    exec(ini_get("sendmail_path") . " &lt; signed.txt");
}
?&gt;
      </programlisting>
     </example>
    </para>
    <note>
     <para>
      Ces constantes ont &eacute;t&eacute; ajout&eacute;es en PHP 4.0.6.
     </para>
    </note>
  </refsect1>
 </refentry>
 <refentry id="function.openssl-pkcs7-verify">
  <refnamediv>
   <refname>openssl_pkcs7_verify</refname>
   <refpurpose>V&eacute;rifie la signature d'un message S/MIME</refpurpose>
  </refnamediv>
  <refsect1>
   <title>Description</title>
   <funcsynopsis>
    <funcprototype>
     <funcdef>bool <function>openssl_pkcs7_verify</function></funcdef>
     <paramdef>string <parameter>filename</parameter></paramdef>
     <paramdef>int <parameter>flags</parameter></paramdef>
     <paramdef>string <parameter><optional>outfilename</optional></parameter></paramdef>
     <paramdef>array <parameter><optional>cainfo</optional></parameter></paramdef>
     <paramdef>string <parameter><optional>extracerts</optional></parameter></paramdef>
    </funcprototype>
   </funcsynopsis>
   <para>
    <function>openssl_pkcs7_verify</function> lit le message S/MIME contenu
    dans le fichier <parameter>filename</parameter> et examine la signature
    digitale. <function>openssl_pkcs7_verify</function> retourne
    <literal>TRUE</literal> si la signature est v&eacute;rifi&eacute;e, et <literal>FALSE</literal>
    sinon (le message a &eacute;t&eacute; modifi&eacute;, ou bien le certificat de signature est
    invalide). <function>openssl_pkcs7_verify</function> retourne -1
    en cas d'erreur de v&eacute;rification (la v&eacute;rification s'est mal d&eacute;roul&eacute;e, aucune
    conclusion possible).
   </para>
   <para>
    <parameter>flags</parameter> sert &agrave; modifier le message final.
    Voyez les <link linkend="openssl.pkcs7.flags">constantes PKCS7</link>. Par
    d&eacute;faut, la valeur est : PKCS7_DETACHED.
   </para>
   <para>
    Si le param&egrave;tre <parameter>outfilename</parameter> est sp&eacute;cifi&eacute;, il doit
    &ecirc;tre une cha&icirc;ne contenant le nom d'un fichier qui contient le certificat
    du signataire, au format PEM.
   </para>
   <para>
    Si le param&egrave;tre <parameter>cainfo</parameter> est sp&eacute;cifi&eacute;, il doit
    contenir les informations sur les tiers de certificats de confiance
    utilis&eacute; lors de la v&eacute;rification. Voyez
    <link linkend="openssl.cert.verification">v&eacute;rification des certificats</link>
    pour plus de d&eacute;tails.
   </para>
   <para>
    Si le param&egrave;tre <parameter>extracerts</parameter> est sp&eacute;cifi&eacute;, il doit
    repr&eacute;senter le nom d'un fichier contenant un ensemble de
    certificat utilis&eacute; comme certificats de peu de confiance.
   </para>
    <para>
     <emphasis>Les param&egrave;tres et le type de retour de cette fonction risquent
     d'evoluer d'ici &agrave; la prochaine version de PHP.</emphasis>
    </para>
    <note>
     <para>
      Ces constantes ont &eacute;t&eacute; ajout&eacute;es en PHP 4.0.6.
     </para>
    </note>
  </refsect1>
 </refentry>
 <refentry id="function.openssl-x509-checkpurpose">
  <refnamediv>
   <refname>openssl_x509_checkpurpose</refname>
   <refpurpose>V&eacute;rifie l'usage d'un certificat</refpurpose>
  </refnamediv>
  <refsect1>
   <title>Description</title>
   <funcsynopsis>
    <funcprototype>
     <funcdef>bool <function>openssl_x509_checkpurpose</function></funcdef>
     <paramdef>mixed <parameter>x509cert</parameter></paramdef>
     <paramdef>int <parameter>purpose</parameter></paramdef>
     <paramdef>array <parameter>cainfo</parameter></paramdef>
     <paramdef>string
     <parameter><optional>untrustedfile</optional></parameter></paramdef>
    </funcprototype>
   </funcsynopsis>
   <para>
    <function>openssl_x509_checkpurpose</function> <literal>TRUE</literal> si le
    certificat peut &ecirc;tre utilis&eacute; pour un but particulier, <literal>FALSE</literal>
    s'il ne le peut pas, et -1 en cas d'erreur.
   </para>
   <para>
    <function>openssl_x509_checkpurpose</function> examine le certificat
    specifi&eacute; par <parameter>x509cert</parameter>, pour voir s'il peut &ecirc;tre
    utilis&eacute; pour une op&eacute;ration particuli&egrave;re <parameter>purpose</parameter>.
   </para>
   <para>
    <parameter>cainfo</parameter> doit &ecirc;tre un tableau de dossiers/fichiers
    de CA de confiance comme d&eacute;crit
    dans la
    <link linkend="openssl.cert.verification">V&eacute;rification des certificats</link>.
   </para>
   <para>
    <parameter>untrustedfile</parameter>, si sp&eacute;cifi&eacute;, est le nom d'un
    fichier au format PEM contenant les certificats qui pourront aider
    lors de la v&eacute;rification du certificat, m&ecirc;me si une confiance limit&eacute;e
    doit leur &ecirc;tre port&eacute;e.
   </para>
    <para>
     <emphasis>Les param&egrave;tres et le type de retour de cette fonction risquent
     d'evoluer d'ici &agrave; la prochaine version de PHP.</emphasis>
    </para>
   <para>
    <table>
     <title>Utilisations de <function>openssl_x509_checkpurpose</function></title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Constante</entry>
        <entry>Description</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>X509_PURPOSE_SSL_CLIENT</entry>
        <entry>
         Est ce que le certificat peut &ecirc;tre utilis&eacute; avec le client d'une
         connexion SSL?
        </entry>
       </row>
       <row>
        <entry>X509_PURPOSE_SSL_SERVER</entry>
        <entry>
         Est ce que le certificat peut &ecirc;tre utilis&eacute; avec le serveur d'une
         connexion SSL?
        </entry>
       </row>
       <row>
        <entry>X509_PURPOSE_NS_SSL_SERVER</entry>
        <entry>
         Est ce que le certificat peut &ecirc;tre utilis&eacute; avec un serveur
         Netscape d'une connexion SSL?
        </entry>
       </row>
       <row>
        <entry>X509_PURPOSE_SMIME_SIGN</entry>
        <entry>
         Est ce que le certificat peut &ecirc;tre utilis&eacute; pour signer des
         courrier &agrave; la norme S/MIME?
        </entry>
       </row>
       <row>
        <entry>X509_PURPOSE_SMIME_ENCRYPT</entry>
        <entry>
         Est-ce que le certificat peut &ecirc;tre utilis&eacute; pour
         chiffrer un courrier au format S/MIME?
        </entry>
       </row>
       <row>
        <entry>X509_PURPOSE_CRL_SIGN</entry>
        <entry>
         Est-ce que le certificat peut &ecirc;tre utilis&eacute; pour
         chiffrer une liste de revocation de certificat?
         (CRL)?
        </entry>
       </row>
       <row>
        <entry>X509_PURPOSE_ANY</entry>
        <entry>
         Est-ce que le certificat peut &ecirc;tre utilis&eacute; pour
         n'importe lequel de ces cas?
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table>
    Ces options ne sont pas des champs de bits :  vous ne pouvez en
    passer qu'une seule &agrave; la fois.
   </para>
    <note>
     <para>
      Ces constantes ont &eacute;t&eacute; ajout&eacute;es en PHP 4.0.6.
     </para>
    </note>
  </refsect1>
 </refentry>
 <refentry id="function.openssl-x509-free">
  <refnamediv>
   <refname>openssl_x509_free</refname>
   <refpurpose>Lib&egrave;re les ressources prises par un certificat</refpurpose>
  </refnamediv>
  <refsect1>
   <title>Description</title>
   <funcsynopsis>
    <funcprototype>
     <funcdef>void <function>openssl_x509_free</function></funcdef>
     <paramdef>resource <parameter>x509cert</parameter></paramdef>
    </funcprototype>
   </funcsynopsis>
   <para>
    <function>openssl_x509_free</function> lib&egrave;re les ressources prises
    par le certificat <parameter>x509cert</parameter>
   </para>
    <note>
     <para>
      Ces constantes ont &eacute;t&eacute; ajout&eacute;es en PHP 4.0.6.
     </para>
    </note>
  </refsect1>
 </refentry>
 <refentry id="function.openssl-x509-parse">
  <refnamediv>
   <refname>openssl_x509_parse</refname>
   <refpurpose>Analyse un certificat X509.</refpurpose>
  </refnamediv>
  <refsect1>
   <title>Description</title>
   <funcsynopsis>
    <funcprototype>
     <funcdef>array <function>openssl_x509_parse</function></funcdef>
     <paramdef>mixed <parameter>x509cert</parameter></paramdef>
     <paramdef>bool
     <parameter><optional>shortnames</optional></parameter></paramdef>
    </funcprototype>
   </funcsynopsis>
   <para>
    <function>openssl_x509_parse</function> analyse le certificat X509
    <parameter>x509cert</parameter>, et retourne les informations contenues
    dedans, y compris le sujet (subject), nom (name), &eacute;metteur (issuer name),
    dates de d&eacute;but et de fin (valid from date et valid to date), etc...
    <parameter>shortnames</parameter> contr&ocirc;le l'indexation des donn&eacute;es dans
    le tableau : si <parameter>shortnames</parameter> vaut <literal>TRUE</literal>
    (valeur par d&eacute;faut), alors les champs seront index&eacute;s avec la forme
    courte des noms, sinon, les noms longs seront utilis&eacute;s.
    (par exemple, <literal>CN</literal> est le nom court de
    <literal>commonName</literal>).
   </para>
   <para>
    <emphasis>La structure des donn&eacute;es retourn&eacute;es est (d&eacute;lib&eacute;r&eacute;ment)
    non document&eacute;e, car elle se sujette &agrave; des changements probables.</emphasis>
   </para>
    <note>
     <para>
      Ces constantes ont &eacute;t&eacute; ajout&eacute;es en PHP 4.0.6.
     </para>
    </note>
  </refsect1>
 </refentry>
 <refentry id="function.openssl-x509-read">
  <refnamediv>
   <refname>openssl_x509_read</refname>
   <refpurpose>Analyse un certificat X.509 et retourne une ressource</refpurpose>
  </refnamediv>
  <refsect1>
   <title>Description</title>
   <funcsynopsis>
    <funcprototype>
     <funcdef>resource <function>openssl_x509_read</function></funcdef>
     <paramdef>mixed <parameter>x509certdata</parameter></paramdef>
    </funcprototype>
   </funcsynopsis>
   <para>
    <function>openssl_x509_read</function> analyse le certificat
    <parameter>x509certdata</parameter> et retourne un identifiant de ressource.
   </para>
    <note>
     <para>
      Ces constantes ont &eacute;t&eacute; ajout&eacute;es en PHP 4.0.6.
     </para>
    </note>
  </refsect1>
 </refentry>
 </reference>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
