 <reference id="ref.regex">
  <title>Expressions r&eacute;guli&egrave;res</title>
  <titleabbrev>Regex</titleabbrev>
  <partintro>
   <para>
     Les expressions r&eacute;guli&egrave;res sont utilis&eacute;es
     pour effectuer des manipulations complexes de cha&icirc;nes de
     caract&egrave;res. Les fonctions sont :
    <itemizedlist>
     <listitem>
      <simpara><function>ereg</function></simpara>
     </listitem>
     <listitem>
      <simpara><function>ereg_replace</function></simpara>
     </listitem>
     <listitem>
      <simpara><function>eregi</function></simpara>
     </listitem>
     <listitem>
      <simpara><function>eregi_replace</function></simpara>
     </listitem>
     <listitem>
      <simpara><function>split</function></simpara>
     </listitem>
     <listitem>
      <simpara><function>spliti</function></simpara>
     </listitem>
    </itemizedlist>
     Ces fonctions requi&egrave;rent toutes une expression r&eacute;guli&egrave;re
     comme premier argument. PHP utilise les expressions r&eacute;guli&egrave;res
     avanc&eacute;es de POSIX (POSIX 1003.2). Pour avoir tous les d&eacute;tails
     sur ces expressions, reportez vous aux pages de manuel inclues dans le
     r&eacute;pertoire de la distribution PHP.
<!-- Should add discussion of PCRE functions here. -->
  </para>
   <para>
    <example>
     <title>Expressions r&eacute;guli&egrave;res</title>
     <programlisting role="php">
&lt;?php
ereg(&quot;abc&quot;,$string);
/* Retourne <literal>TRUE</literal> si &quot;abc&quot;
   est trouv&eacute; quelque part dans la cha&icirc;ne $string. */
ereg(&quot;^abc&quot;,$string);
/* Retourne <literal>TRUE</literal> si  &quot;abc&quot;
   est trouv&eacute; au d&eacute;but de la cha&icirc;ne $string. */
ereg("abc$",$string);
/* Retourne <literal>TRUE</literal> si  &quot;abc&quot;
   est trouv&eacute; &agrave; la fin de la cha&icirc;ne  $string. */
eregi("(ozilla.[23]|MSIE.3)",$HTTP_USER_AGENT);
/* Retourne <literal>TRUE</literal> si  le client
   est Netscape 2, 3 ou MSIE 3. */
ereg("([[:alnum:]]+) ([[:alnum:]]+) ([[:alnum:]]+)",
     $string,$regs);
/* Introduit trois mots s&eacute;par&eacute;s par des espaces
   dans les cha&icirc;nes $regs[1], $regs[2] et $regs[3]. */
$string = ereg_replace("^","&lt;BR&gt;",$string);
/* Ins&egrave;re une balise &lt;BR&gt; au d&eacute;but de la cha&icirc;ne $string. */
$string = ereg_replace("$","&lt;BR&gt;",$string);
/* Ins&egrave;re une balise &lt;BR&gt; &agrave; la fin de la cha&icirc;ne $string. */
$string = ereg_replace("\n","",$string);
/* Supprime toutes les nouvelles lignes de $string. */
?&gt;
     </programlisting>
    </example>
   </para>
  </partintro>
  <refentry id="function.ereg">
   <refnamediv>
    <refname>ereg</refname>
    <refpurpose>Expression r&eacute;guli&egrave;re standard.</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>ereg</function></funcdef>
      <paramdef>string <parameter>pattern</parameter></paramdef>
      <paramdef>string <parameter>string</parameter></paramdef>
      <paramdef>array
       <parameter><optional>regs</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <simpara>
     Recherche dans la cha&icirc;ne <parameter>string</parameter> les
     s&eacute;quences de caract&egrave;res qui correspondent au masque
     <parameter>pattern</parameter>.
    </simpara>
    <simpara>
     Si au moins une s&eacute;quence est trouv&eacute;e
     (&eacute;ventuellement dans les parenth&egrave;ses capturantes de
     <parameter>pattern</parameter>), et que la fonction est appel&eacute;e
     avec un troisi&egrave;me argument <parameter>regs</parameter>, les
     r&eacute;sultats seront enregistr&eacute;s dans
     <parameter><optional>regs</optional></parameter>. $regs[1] contiendra
     la premi&egrave;re parenth&egrave;se capturante (celle qui commence le
     plus t&ocirc;t), $regs[2] contiendra la deuxi&egrave;me
     parenth&egrave;se capturante (celle qui commence apr&egrave;s
     la premi&egrave;re), et ainsi de suite.
     $regs[0] contient une copie de la cha&icirc;ne.
   </simpara>
    <simpara>
     Si <function>ereg</function> trouve ses solutions pour les parenth&egrave;ses
     capturantes, <parameter>$regs</parameter> contiendra exactement 10 &eacute;l&eacute;ments,
     m&ecirc;me si il y avait plus ou moins de 10 parenth&egrave;ses capturantes
     qui &eacute;taient valides. Cela n'a aucun effet sur les capacit&eacute;s de
     la fonction <function>ereg</function> &agrave; trouver d'autres sous cha&icirc;nes.
     Si aucune valeur n'est trouv&eacute;e, $regs ne sera pas modifi&eacute; par
     <function>ereg</function>.
    </simpara>
    <para>
      La recherche est sensible &agrave; la casse.
    </para>
    <para>
     <function>ereg</function> retourne <literal>TRUE</literal> si une occurence
     a &eacute;t&eacute; trouv&eacute;e dans la cha&icirc;ne et
     <literal>FALSE</literal> dans le cas contraire, ou si une erreur est survenue.
    </para>
    <para>
     L'exemple suivant prend une date au format ISO (YYYY-MM-DD) et l'affiche sous
     la forme DD.MM.YYYY :
     <example>
      <title>Exemple <function>ereg</function></title>
      <programlisting role="php">
&lt;?php
if ( ereg( "([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})", $date, $regs ) ) {
    echo "$regs[3].$regs[2].$regs[1]";
} else {
    echo "Format de date invalide : $date";
}
?&gt;
	  </programlisting>
	 </example>
	</para>
	<para>
     Voir aussi <function>eregi</function>, <function>ereg_replace</function>
     et <function>eregi_replace</function>.
    </para>
   </refsect1>
  </refentry>
  <refentry id="function.ereg-replace">
   <refnamediv>
    <refname>ereg_replace</refname>
    <refpurpose>Remplacement par expression r&eacute;guli&egrave;re.</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>string <function>ereg_replace</function></funcdef>
      <paramdef>string <parameter>pattern</parameter></paramdef>
      <paramdef>string <parameter>replacement</parameter></paramdef>
      <paramdef>string <parameter>string</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>ereg_replace</function> effectue une recherche par expression
     r&eacute;guli&egrave;re dans la cha&icirc;ne
     <parameter>string</parameter> en recherchant les occurrences de
     <parameter>pattern</parameter>, puis les remplace par la cha&icirc;ne
     <parameter>replacement</parameter>.
    </para>
    <para>
     La cha&icirc;ne modifi&eacute;e est retourn&eacute;e. (Ce qui
     signifie que la cha&icirc;ne originale sera retourn&eacute;e si
     aucune occurrence n'est trouv&eacute;e).
    </para>
    <para>
     Si <parameter>pattern</parameter> contient des parenth&egrave;ses
     capturantes, <parameter>replacement</parameter> pourra contenir des
     s&eacute;quences de la forme <literal>\\<replaceable>digit</replaceable></literal>,
     qui seront remplac&eacute;es par le texte captur&eacute; par la n-i&egrave;me
     parenth&egrave;se capturante. <literal>\\0</literal> correspond
     &agrave; la cha&icirc;ne originale compl&egrave;te. De 0 &agrave;
     9 parenth&egrave;ses capturantes peuvent &ecirc;tre utilis&eacute;es.
     Les parenth&egrave;ses peuvent &ecirc;tre imbriqu&eacute;es, et leur
     num&eacute;ro d'ordre est d&eacute;fini par leur parenth&egrave;se
     ouvrante.
    </para>
    <para>
     Si aucune occurrence n'est trouv&eacute;e, la cha&icirc;ne
     <parameter>string</parameter> sera retourn&eacute;e intacte.
    </para>
    <para>
     Par exemple, le code suivant affiche "Ceci est un test" trois fois :
     <example>
      <title>Exemple avec <function>ereg_replace</function></title>
      <programlisting role="php">
&lt;?php
$string = "Ceci est un test";
echo ereg_replace( " est", " etait", $string );
echo ereg_replace( "( )est ", "\\1etait", $string );
echo ereg_replace( "(( )est)", "\\2etait", $string );
?&gt;
      </programlisting>
     </example>
    </para>
    <para>
     Notez bien que si vous utilisez une valeur de type entier
     dans le param&egrave;tre de remplacement <parameter>replacement</parameter>,
     vous risquez de ne pas obtenir le r&eacute;sultat escompt&eacute;. Tout cela
     parce que <function>ereg_replace</function> va interpr&eacute;ter le nombre
     comme la valeur ordinale d'un caract&egrave;re, et l'utiliser. Par exemple :
     <example>
      <title>Exemple avec <function>ereg_replace</function></title>
      <programlisting role="php">
&lt;?php
/* Cet exemple ne fonctionne pas comme voulu. */
$num = 4;
$string = "Cette cha&icirc;ne a quatre mots.";
$string = ereg_replace('quatre', $num, $string);
echo $string;   /* Affichage : 'Cette cha&icirc;ne a  mots.' */
/* Ceci est bon. */
$num = '4';
$string = "Cette cha&icirc;ne a quatre mots.";
$string = ereg_replace('quatre', $num, $string);
echo $string;   /* Affichage : 'Cette cha&icirc;ne a 4 mots.' */
?&gt;
      </programlisting>
     </example>
    </para>
    <para>
     Voir aussi <function>ereg</function>, <function>eregi</function>
     et <function>eregi_replace</function>.
    </para>
   </refsect1>
  </refentry>
  <refentry id="function.eregi">
   <refnamediv>
    <refname>eregi</refname>
    <refpurpose>
      Recherche par expression r&eacute;guli&egrave;re insensible &agrave; la casse.
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>eregi</function></funcdef>
      <paramdef>string <parameter>pattern</parameter></paramdef>
      <paramdef>string <parameter>string</parameter></paramdef>
      <paramdef>array
       <parameter><optional>regs</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>eregi</function> est identique &agrave; <function>ereg</function>,
     hormis le fait qu'elle ignore la casse des caract&egrave;re lors
     de la recherche sur les caract&egrave;re alphab&eacute;tiques.
    </para>
    <para>
     Voir aussi <function>ereg</function>, <function>ereg_replace</function> et
     <function>eregi_replace</function>.
    </para>
   </refsect1>
  </refentry>
  <refentry id="function.eregi-replace">
   <refnamediv>
    <refname>eregi_replace</refname>
    <refpurpose>
      Remplacement par expression r&eacute;guli&egrave;re insensible &agrave;
      la casse.
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>string <function>eregi_replace</function></funcdef>
      <paramdef>string <parameter>pattern</parameter></paramdef>
      <paramdef>string <parameter>replacement</parameter></paramdef>
      <paramdef>string <parameter>string</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>eregi_replace</function> est identique &agrave;
     <function>ereg_replace</function>, hormis le fait qu'elle ne tient
     pas compte de la casse des caract&egrave;res alphab&eacute;tiques.
    </para>
    <para>
     Voir aussi <function>ereg</function>, <function>eregi</function>
     et <function>ereg_replace</function>.
    </para>
   </refsect1>
  </refentry>
  <refentry id="function.split">
   <refnamediv>
    <refname>split</refname>
    <refpurpose>
     Scinde une cha&icirc;ne en un tableau, gr&acirc;ce &agrave; une
     expression r&eacute;guli&egrave;re.
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcdef>array <function>split</function></funcdef>
     <paramdef>string <parameter>pattern</parameter></paramdef>
     <paramdef>string <parameter>string</parameter></paramdef>
     <paramdef>int <parameter><optional>limit</optional></parameter></paramdef>
    </funcsynopsis>
    <para>
     <function>split</function> retourne une tableau de cha&icirc;nes :
     chacune d'entre elle est une sous-cha&icirc;ne de
     <parameter>string</parameter> d&eacute;limit&eacute;e par les
     occurrences trouv&eacute;es de l'expression r&eacute;guli&egrave;re
     <parameter>pattern</parameter>. Si une erreur survient, retourne
     <literal>FALSE</literal>.
    </para>
    <para>
     Pour lire les 5 premiers champs d'une ligne du fichier
     <filename>/etc/passwd</filename>:
	 <example>
      <title>Exemple avec <function>split</function></title>
      <programlisting role="php">
&lt;?php
$passwd_list = split( ":", $passwd_line, 5 );
?&gt;
	  </programlisting>
	 </example>
	</para>
    <para>
     Pour analyser une date qui est d&eacute;limit&eacute;e par des /,
     des points ou des tirets :
	 <example>
      <title>Exemple avec <function>split</function></title>
      <programlisting role="php">
&lt;?php
$date = "04/30/1973";
// Les d&eacute;limiteurs peuvent &ecirc;tre des /, des points ou des tirets
list( $month, $day, $year ) = split( '[/.-]', $date );
echo "Mois: $month; Jour: $day; Annee: $year&lt;br&gt;\n";
?&gt;
	  </programlisting>
	 </example>
	</para>
    <para>
     Notez que <parameter>pattern</parameter>est insensible &agrave; la casse
    </para>
	<para>
	 Notez bien que si vous n'avez pas besoin de la puissance
	 des expressions r&eacute;guli&egrave;res, il est plus rapide
	 d'utiliser <function>explode</function>, qui n'utilise pas le
	 moteur d'expressions r&eacute;guli&egrave;res.
	</para>
	<para>
	 Notez aussi que <parameter>pattern</parameter> est une
	 expression r&eacute;guli&egrave;re. Si vous voulez utiliser
	 n'importe quel caract&egrave;re sp&eacute;cial des expressions
	 r&eacute;guli&egrave;res, vous devez les &eacute;chapper. Si vous
	 pensez que <function>split</function> (ou toute autre expression
	 r&eacute;guli&egrave;re) se comporte bizarrement, lisez d'abord
	 le fichier <filename>regex.7</filename>, inclus dans le dossier
	 <filename>regex/</filename> de la distribution PHP . Il est au
	 format manpage, et vous pourrez le lire avec une commande telle que
	 <command>man /usr/local/src/regex/regex.7</command>.
	</para>
    <para>
       Voir aussi : <function>explode</function> et <function>implode</function>.
    </para>
   </refsect1>
  </refentry>
  <refentry id="function.spliti">
   <refnamediv>
    <refname>spliti</refname>
    <refpurpose>
      Scinde une cha&icirc;ne en un tableau, gr&acirc;ce &agrave; une
      expression r&eacute;guli&egrave;re.
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>array <function>spliti</function></funcdef>
      <paramdef>string <parameter>pattern</parameter></paramdef>
      <paramdef>string <parameter>string</parameter></paramdef>
      <paramdef>int
       <parameter><optional>limit</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>spliti</function> est identique &agrave; <function>spliti</function>,
     hormis le fait qu'elle ignore la casse.
    </para>
    <para>
     Voir aussi <function>split</function>,
     <function>explode</function> et
     <function>implode</function>.
    </para>
   </refsect1>
  </refentry>
  <refentry id="function.sql-regcase">
   <refnamediv>
    <refname>sql_regcase</refname>
    <refpurpose>
      Pr&eacute;pare une expression r&eacute;guli&egrave;re pour effectuer
      une recherche insensible &agrave; la casse.
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcdef>string <function>sql_regcase</function></funcdef>
     <paramdef>string <parameter>string</parameter></paramdef>
    </funcsynopsis>
    <para>
     <function>sql_regcase</function> retourne une expression r&eacute;guli&egrave;re
     valide qui acceptera la cha&icirc;ne <parameter>string</parameter>,
     et toutes les variantes majuscule/minuscule possibles de cette
     cha&icirc;ne. Cette expression sera construite &agrave; partir de
     la cha&icirc;ne <parameter>string</parameter> en remplacant tous les
     caract&egrave;res par des expressions entre crochets (des classes de
     caract&egrave;res), contenant la lettre majuscule et minuscule. Si le
     caract&egrave;re n'est pas une lettre, les crochets contiendront
     deux fois le caract&egrave;re original.
     <example>
      <title>Exemple avec <function>sql_regcase</function></title>
      <programlisting role="php">
&lt;?php
echo sql_regcase( "Foo bar" );
?&gt;
      </programlisting>
     </example>
     affichera <computeroutput>[Ff][Oo][Oo] [Bb][Aa][Rr]</computeroutput>.
    </para>
    <para>
     Cette expression sert &agrave; effectuer des recherches
     insensibles &agrave; la casse avec d'autres logiciels, qui
     n'acceptent les recherches insensibles &agrave; la casse.
    </para>
   </refsect1>
  </refentry>
 </reference>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
