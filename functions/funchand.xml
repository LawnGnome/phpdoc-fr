<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.18 $ -->
<reference id="ref.funchand">
 <title>Fonctions</title>
 <titleabbrev>Fonctions</titleabbrev>
 <partintro>
  <para>
   Ces fonctions effectuent les manipulations li&eacute;es &agrave;
   la gestion des fonctions.
  </para>
 </partintro>
 <refentry id="function.call-user-func-array">
  <refnamediv>
   <refname>call_user_func_array</refname>
   <refpurpose>
    Appelle une fonction utilisateur avec les param&egrave;tres rassembl&eacute;s en tableau
   </refpurpose>
  </refnamediv>
  <refsect1>
   <title>Description</title>
    <methodsynopsis>
     <type>mixed</type><methodname>call_user_func_array</methodname>
     <methodparam><type>string</type><parameter>function_name</parameter></methodparam>
     <methodparam choice="opt"><type>array</type><parameter>paramarr</parameter></methodparam>
    </methodsynopsis>
   <para>
    <function>call_user_func_array</function> appelle la fonction utilisateur
    <parameter>function_name</parameter> avec les param&egrave;tres
    <parameter>paramarr</parameter>, rassembl&eacute;s dans un tableau.
    Par exemple:
    <informalexample>
     <programlisting role="php">
&lt;?php
function debug($var, $val)
    echo "***DEBUGGING\nVARIABLE: $var\nVALUE:";
    if (is_array($val) || is_object($val) || is_resource($val))
        print_r($val);
    else
        echo "\n$val\n";
    echo "***\n";
}
$c = mysql_connect();
$host = $HTTP_SERVER_VARS["SERVER_NAME"];
call_user_func_array ('debug', array("host", $host));
call_user_func_array ('debug', array("c", $c));
call_user_func_array ('debug', array("HTTP_POST_VARS", $HTTP_POST_VARS));
?&gt;
     </programlisting>
    </informalexample>
   </para>
   <para>
    Voir aussi
    <function>call_user_func</function>,
    <function>call_user_method</function> et
    <function>call_user_method_array</function>.
   </para>
   <note>
    <para>
     <function>call_user_func_array</function> a &eacute;t&eacute; ajout&eacute;
     en version PHP 4.05.
    </para>
   </note>
  </refsect1>
 </refentry>
 <refentry id="function.call-user-func">
  <refnamediv>
   <refname>call_user_func</refname>
   <refpurpose>
    Appelle une fonction utilisateur
   </refpurpose>
  </refnamediv>
  <refsect1>
   <title>Description</title>
    <methodsynopsis>
     <type>mixed</type><methodname>call_user_func</methodname>
     <methodparam><type>string</type><parameter>function_name</parameter></methodparam>
     <methodparam choice="opt"><type>mixed</type><parameter>parameter</parameter></methodparam>
     <methodparam choice="opt"><type>mixed</type><parameter>...</parameter></methodparam>
    </methodsynopsis>
   <para>
    <function>call_user_func</function> appelle la fonction utilisateur
    <parameter>function_name</parameter>, et lui passe les param&egrave;tres
    <parameter>parameter</parameter>.
    Par exemple :
    <informalexample>
     <programlisting role="php">
&lt;?php
  function barbier ($type) {
    print "Vous vouliez une coupe $type, pas de probl&egrave;me";
  }
  call_user_func('barbier', "iroquois");
  call_user_func('barbier', "militaire");
  call_user_func('barbier', "au bol");
?&gt;
     </programlisting>
    </informalexample>
   </para>
   <para>
    Voir aussi
    <function>call_user_func_array</function>,
    <function>call_user_method</function> et
    <function>call_user_method_array</function>.
   </para>
  </refsect1>
 </refentry>
 <refentry id="function.create-function">
  <refnamediv>
   <refname>create_function</refname>
   <refpurpose>Cr&eacute;e une fonction anonyme (style lambda)</refpurpose>
  </refnamediv>
  <refsect1>
   <title>Description</title>
    <methodsynopsis>
     <type>string</type><methodname>create_function</methodname>
     <methodparam><type>string</type><parameter>args</parameter></methodparam>
     <methodparam><type>string</type><parameter>code</parameter></methodparam>
    </methodsynopsis>
   <para>
    <function>create_function</function> cr&eacute;e une fonction anonyme,
    &agrave; partir des param&egrave;tres pass&eacute;s, et retourne
    un nom de fonction unique. G&eacute;n&eacute;ralement, les arguments
    <parameter>args</parameter> sont pr&eacute;sent&eacute;s sous
    la forme d'une cha&icirc;ne &agrave; guillemets simples, et la
    m&ecirc;me recommandation vaut pour <parameter>code</parameter>.
    La raison de l'utilisation des guillemets simples est de proteger
    les noms de variables du remplacement par leur valeur. Si vous utilisez
    les guillemets doubles, n'oubliez pas d'&eacute;chapper les noms
    de variables (i.e. <literal>\$avar</literal>).
   </para>
   <para>
    Vous pouvez utiliser cette fonction pour (par exemple) cr&eacute;er
    une fonction &agrave; partir d'informations r&eacute;colt&eacute;s
    durant l'&eacute;x&eacute;cution.
    <example>
     <title>
      Cr&eacute;ation d'une fonction anonyme avec <function>create_function</function>
     </title>
     <programlisting role="php">
&lt;?php
  $newfunc = create_function('$a,$b','return "ln($a) + ln($b) = ".log($a * $b);');
  echo "Nouvelle fonction anonyme : $newfunc\n";
  echo $newfunc(2,M_E)."\n";
// affichera :
// Nouvelle fonction anonyme : lambda_1
// ln(2) + ln(2.718281828459) = 1.6931471805599
?&gt;
     </programlisting>
    </example>
    Ou, pour pouvoir appliquer une fonction g&eacute;n&eacute;rique
    &agrave; une liste d'arguments.
    <example>
     <title>
      Traitement g&eacute;n&eacute;rique par fonction avec
      <function>create_function</function>
     </title>
     <programlisting role="php">
&lt;?php
function process($var1, $var2, $farr) {
    for ($f=0; $f &lt; count($farr); $f++)
    echo $farr[$f]($var1,$var2)."\n";
}
// cr&eacute;ation d'une s&eacute;rie de fonction math&eacute;matiques
$f1 = 'if ($a&gt;=0) {return "b*a^2 = ".$b*sqrt($a);} else {return FALSE;}';
$f2 = "return \"min(b^2+a, a^2,b) = \".min(\$a*\$a+\$b,\$b*\$b+\$a);";
$f3 = 'if ($a&gt; 0 &amp;&amp; $b != 0) {return "ln(a)/b = ".log($a)/$b;} else {return FALSE;}';
$farr = array(
    create_function('$x,$y', 'return "un peu de trigo : ".(sin($x) + $x*cos($y));'),
    create_function('$x,$y', 'return "une hypot&eacute;nuse: ".sqrt($x*$x + $y*$y);'),
    create_function('$a,$b', $f1),
    create_function('$a,$b', $f2),
    create_function('$a,$b', $f3)
    );
echo "\nUtilisation de la premi&egrave;re liste de fonctions anonymes\n";
echo "param&eacute;tres: 2.3445, M_PI\n";
process(2.3445, M_PI, $farr);
// Maintenant une liste de fonction sur cha&icirc;ne de caract&egrave;res
$garr = array(
    create_function('$b,$a','if (strncmp($a,$b,3) == 0) return "** \"$a\" '.
    'et \"$b\"\n** Ces cha&icirc;nes de ressemblent!! (regarde les trois premiers caract&egrave;res)";'),
    create_function('$a,$b','; return "CRCs: ".crc32($a)." , ".crc32(b);'),
    create_function('$a,$b','; return "similarit&eacute;(a,b) = ".similar_text($a,$b,&amp;$p)."($p%)";')
    );
echo "\nUtilisation de la secondes liste de fonctions anonymes\n";
process("Twas brilling and the slithy toves", "Twas the night", $garr);
?&gt;
     </programlisting>
    </example>
    Et lorsque vous utilisez le code ci-dessus, l'affichage va &ecirc;tre
    <informalexample>
     <programlisting>
Utilisation de la premi&egrave;re liste de fonctions anonymes
param&eacute;tres: 2.3445, M_PI
Un peu de trigo: -1.6291725057799
Une hypot&eacute;nuse: 3.9199852871011
b*a^2 = 4.8103313314525
min(b^2+a, a^2,b) = 8.6382729035898
ln(a/b) = 0.27122299212594
Utilisation de la seconde liste de fonctions anonymes
** "Twas the night" et "Twas brilling and the slithy toves"
** Ces cha&icirc;nes de ressemblent!! (regarde les trois premiers caract&egrave;res)
CRCs: -725381282 , 1908338681
similarit&eacute;(a,b) = 11(45.833333333333%)
     </programlisting>
    </informalexample>
    Mais l'utilisation la plus courante des fonctions lambda est la
    fonction de callback, par exemple lors de l'utilisation de
    <function>array_walk</function> ou <function>usort</function>
    <example>
     <title>Utilisation de fonctions anonymes comme fonction de callback</title>
     <programlisting role="php">
&lt;?php
$av = array("la ","une ","cette ","une certaine ");
array_walk($av, create_function('&amp;$v,$k','$v = $v."maison";'));
print_r($av);  // En PHP 3 utilisez <function>var_dump</function>
// affiche:
// Array
// (
//   [0] =&gt; la maison
//   [1] =&gt; une maison
//   [2] =&gt; cette maison
//   [3] =&gt; une certaine maison
// )
// un tableau de cha&icirc;ne class&eacute; par taille
$sv = array("petite","moyenne","tres longue","vraiment tres longue");
print_r($sv);
// affiche:
// Array
// (
//   [0] =&gt; petite
//   [1] =&gt; moyenne
//   [2] =&gt; tres longue
//   [3] =&gt; vraiment tres longue
// )
// Tri par ordre de taille d&eacute;croissant
usort($sv, create_function('$a,$b','return strlen($b) - strlen($a);'));
print_r($sv);
// outputs:
// Array
// (
//   [0] =&gt; vraiment tres longue
//   [1] =&gt; tres longue
//   [2] =&gt; moyenne
//   [3] =&gt; petite
// )
?&gt;
     </programlisting>
    </example>
   </para>
  </refsect1>
 </refentry>
 <refentry id="function.func-get-arg">
  <refnamediv>
   <refname>func_get_arg</refname>
   <refpurpose>
    Retourne un &eacute;l&eacute;ment de la liste des arguments
   </refpurpose>
  </refnamediv>
  <refsect1>
   <title>Description</title>
    <methodsynopsis>
     <type>mixed</type><methodname>func_get_arg</methodname>
     <methodparam><type>int</type><parameter>arg_num</parameter></methodparam>
    </methodsynopsis>
   <simpara>
    <function>func_get_arg</function> retourne l'argument &agrave;
    la position <parameter>arg_num</parameter> dans
    la liste d'argument d'une fonction utilisateur. Les arguments sont
    compt&eacute;s en commen&ccedil;ant &agrave; z&eacute;ro.
    <function>func_get_arg</function> g&eacute;n&eacute;rera une
    alerte si elle est appel&eacute;e hors d'une fonction.
   </simpara>
   <simpara>
    Si <parameter>arg_num</parameter> est plus grand que le nombre
    d'arguments pass&eacute;s, une alerte est g&eacute;n&eacute;r&eacute;e
    et la fonction retourne <literal>FALSE</literal>.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
&lt;?php
  function foo() {
     $numargs = func_num_args();
     echo "Nombre d'arguments: $numargs&lt;br&gt;\n";
     if ($numargs &gt;= 2) {
     echo "Le second argument est: " . func_get_arg (1) . "&lt;br&gt;\n";
     }
  }
  foo(1, 2, 3);
?&gt;
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    <function>func_get_arg</function> peut &ecirc;tre utilis&eacute;
    conjointement &agrave; <function>func_num_args</function> et
    <function>func_get_args</function> pour permettre aux fonctions
    utilisateurs d'accepter un nombre variable d'arguments.
   </simpara>
   <note>
    <simpara>
     <function>func_get_arg</function> a &eacute;t&eacute; ajout&eacute;e en PHP 4.
    </simpara>
   </note>
  </refsect1>
 </refentry>
 <refentry id="function.func-get-args">
  <refnamediv>
   <refname>func_get_args</refname>
   <refpurpose>
    Retourne les arguments d'une fonction sous forme de tableau
   </refpurpose>
  </refnamediv>
  <refsect1>
   <title>Description</title>
    <methodsynopsis>
     <type>array</type><methodname>func_get_args</methodname>
     <methodparam><type>void</type><parameter/></methodparam>
    </methodsynopsis>
   <simpara>
    <function>func_get_args</function> retourne un tableau dont
    les &eacute;l&eacute;ments correspondent aux &eacute;l&eacute;ments
    de la liste d'arguments de la fonction.
    <function>func_get_args</function> g&eacute;n&eacute;rera une
    alerte si elle est appel&eacute;e hors d'une fonction.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
&lt;?php
  function foo() {
    $numargs = func_num_args();
    echo "Nombre d'arguments: $numargs&lt;br&gt;\n";
    if ($numargs &gt;= 2) {
    echo "Le second argument est: " . func_get_arg (1) . "&lt;br&gt;\n";
    }
    $arg_list = func_get_args();
    for ($i = 0; $i &lt; $numargs; $i++) {
    echo "L'argument $i est: " . $arg_list[$i] . "&lt;br&gt;\n";
    }
  }
  foo(1, 2, 3);
?&gt;
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    <function>func_get_arg</function> peut &ecirc;tre utilis&eacute;
    conjointement &agrave; <function>func_num_args</function> et
    <function>func_get_args</function> pour permettre aux fonctions
    utilisateurs d'accepter un nombre variable d'arguments.
   </simpara>
   <note>
    <simpara>
     <function>func_get_arg</function> a &eacute;t&eacute; ajout&eacute;e
     en PHP 4.
    </simpara>
   </note>
  </refsect1>
 </refentry>
 <refentry id="function.func-num-args">
  <refnamediv>
   <refname>func_num_args</refname>
   <refpurpose>
    Retourne le nombre d'arguments pass&eacute; &agrave; la fonction
   </refpurpose>
  </refnamediv>
  <refsect1>
   <title>Description</title>
    <methodsynopsis>
     <type>int</type><methodname>func_num_args</methodname>
     <methodparam><type>void</type><parameter/></methodparam>
    </methodsynopsis>
   <simpara>
    <function>func_num_args</function> retourne le nombre d'arguments
    pass&eacute; &agrave; la fonction utilisateur courante.
    <function>func_num_args</function>
    g&eacute;n&eacute;rera une alerte si elle est appel&eacute;e
    hors d'une fonction.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
&lt;?php
  function foo() {
    $numargs = func_num_args();
    echo "Nombre d'arguments: $numargs\n";
  }
  foo (1, 2, 3);    // affiche 'Nombre d'arguments: 3'
?&gt;
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    <function>func_get_arg</function> peut &ecirc;tre utilis&eacute;
    conjointement &agrave; <function>func_num_args</function> et
    <function>func_get_args</function> pour permettre aux fonctions
    utilisateurs d'accepter un nombre variable d'arguments.
   </simpara>
   <note>
    <simpara>
     <function>func_get_arg</function> a &eacute;t&eacute; ajout&eacute;e
     en PHP 4.
    </simpara>
   </note>
  </refsect1>
 </refentry>
 <refentry id="function.function-exists">
  <refnamediv>
   <refname>function_exists</refname>
   <refpurpose>
    Indique si une fonction est d&eacute;finie.
   </refpurpose>
  </refnamediv>
  <refsect1>
   <title>Description</title>
    <methodsynopsis>
     <type>boolean</type><methodname>function_exists</methodname>
     <methodparam><type>string</type><parameter>function_name</parameter></methodparam>
    </methodsynopsis>
   <para>
    <function>function_exists</function> v&eacute;rifie la liste des
    fonctions d&eacute;finies par l'utilisateur, et retourne
    <literal>TRUE</literal> si <parameter>function_name</parameter>
    y est trouv&eacute;, <literal>FALSE</literal> sinon.
    <informalexample>
     <programlisting role="php">
&lt;?php
  if (function_exists('imap_open')) {
    echo "Les fonctions IMAP sont disponibles.&lt;br&gt;\n";
  } else {
    echo "Les fonctions IMAP ne sont pas disponibles.&lt;br&gt;\n";
  }
?&gt;
     </programlisting>
    </informalexample>
    Notez qu'une fonction peut exister, m&ecirc;me si elle est indisponible, &agrave;
    cause de la configuration ou des options de compilation.
   </para>
   <para>
    Voir aussi
    <function>method_exists</function>.
   </para>
  </refsect1>
 </refentry>
 <refentry id="function.get-defined-functions">
  <refnamediv>
   <refname>get_defined_functions</refname>
   <refpurpose>
    Liste toutes les fonctions d&eacute;finies
   </refpurpose>
  </refnamediv>
  <refsect1>
   <title>Description</title>
    <methodsynopsis>
     <type>array</type><methodname>get_defined_functions</methodname>
     <methodparam><type>void</type><parameter/></methodparam>
    </methodsynopsis>
   <para>
    <function>get_defined_functions</function> retourne un tableau multi-
    dimensionnel, contenant la liste de toutes les fonctions d&eacute;finies,
    aussi bien les fonctions internes &agrave; PHP que celle d&eacute;j&agrave;
    d&eacute;finie par l'utilisateur. Les noms des fonctions internes
    sont accessibles via <varname>$arr["internal"]</varname>, et les fonctions
    utilisateur sont accessibles via <varname>$arr["user"]</varname>.
    <informalexample>
     <programlisting role="php">
&lt;?php
  function maligne($id, $data) {
    return "&lt;tr&gt;&lt;th&gt;$id&lt;/th&gt;&lt;td&gt;$data&lt;/td&gt;&lt;/tr&gt;\n";
  }
  $arr = get_defined_functions();
  print_r($arr);
?&gt;
     </programlisting>
    </informalexample>
   </para>
   <para>
    Ce script va afficher :
    <informalexample>
     <programlisting>
Array
(
    [internal] =&gt; Array
        (
            [0] =&gt; zend_version
            [1] =&gt; func_num_args
            [2] =&gt; func_get_arg
            [3] =&gt; func_get_args
            [4] =&gt; strlen
            [5] =&gt; strcmp
            [6] =&gt; strncmp
            ...
            [750] =&gt; bcscale
            [751] =&gt; bccomp
        )
    [user] =&gt; Array
        (
            [0] =&gt; maligne
        )
)
     </programlisting>
    </informalexample>
   </para>
   <para>
    Voir aussi
    <function>get_defined_vars</function>.
   </para>
  </refsect1>
 </refentry>
 <refentry id="function.register-shutdown-function">
  <refnamediv>
   <refname>register_shutdown_function</refname>
   <refpurpose>
    Enregistre une fonction pour ex&eacute;cution &agrave; l'extinction
   </refpurpose>
  </refnamediv>
  <refsect1>
   <title>Description</title>
    <methodsynopsis>
     <type>int</type><methodname>register_shutdown_function</methodname>
     <methodparam><type>string</type><parameter>func</parameter></methodparam>
    </methodsynopsis>
   <simpara>
    <function>register_shutdown_function</function> enregistre la fonction
    <parameter>func</parameter> pour ex&eacute;cution &agrave; l'extinction
    du script.
   </simpara>
   <para>
    Erreur courante :
   </para>
   <simpara>
    Etant donn&eacute; qu'aucun affichage n'est possible depuis la fonction
    <parameter>func</parameter>, vous ne pouvez pas y mettre d'informations
    de d&eacute;buggage par <function>print</function> ou <function>echo</function>!
   </simpara>
  </refsect1>
 </refentry>
 <refentry id="function.register-tick-function">
  <refnamediv>
   <refname>register_tick_function</refname>
   <refpurpose>
    Enregistre une fonction ex&eacute;cut&eacute;e &agrave; chaque tick
   </refpurpose>
  </refnamediv>
  <refsect1>
   <title>Description</title>
    <methodsynopsis>
     <type>void</type><methodname>register_tick_function</methodname>
     <methodparam><type>string</type><parameter>func</parameter></methodparam>
     <methodparam choice="opt"><type>mixed</type><parameter>arg</parameter></methodparam>
    </methodsynopsis>
   <simpara>
    <function>register_tick_function</function> enregistre la fonction
    <parameter>func</parameter> pour &ecirc;tre ex&eacute;cut&eacute;e &agrave; chaque fois qu'un
    <link linkend="control-structures.declare">tick</link> est appel&eacute;.
   </simpara>
  </refsect1>
 </refentry>
 <refentry id="function.unregister-tick-function">
  <refnamediv>
   <refname>unregister_tick_function</refname>
   <refpurpose>
    Annule la fonction ex&eacute;cut&eacute;e &agrave; chaque tick
   </refpurpose>
  </refnamediv>
  <refsect1>
   <title>Description</title>
    <methodsynopsis>
     <type>void</type><methodname>unregister_tick_function</methodname>
     <methodparam><type>string</type><parameter>func</parameter></methodparam>
     <methodparam choice="opt"><type>mixed</type><parameter>arg</parameter></methodparam>
    </methodsynopsis>
   <simpara>
    <function>unregister_tick_function</function> annule l'ex&eacute;cution automatique
    de <parameter>func</parameter> &agrave; chaque
    <link linkend="control-structures.declare">tick</link>.
   </simpara>
  </refsect1>
 </refentry>
</reference>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->

