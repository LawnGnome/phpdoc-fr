<?xml version="1.0" encoding="ISO-8859-1" ?>
<!-- $Revision: 1.2 $ -->
<!-- EN-Revision: 1.1 Maintainer: yannick Status: ready -->
 <sect1 id="zend.calling-user-functions">
  <title>Appel des fonctions utilisateurs</title>
  <para>
   Vous pouvez appeler des fonctions utilisateurs depuis vos propres modules, ce qui
   est très maniable lors de l'implémentation de callbacks ; par exemple, pour parcourir ou
   rechercher dans un tableau, ou simplement pour les évènements de vos programmes.
  </para>
  <para>
   Les fonctions utilisateurs peuvent être appelées avec la fonction
   <function>call_user_function_ex</function>. Elle requiet une valeur de hashage pour
   la table de fonction dont vous voulez accéder, un pointeur vers un objet (si vous voulez
   appeler une méthode), le nom de la fonction, la valeur retournée, le nombre d'arguments,
   un tableau d'arguments, et un flag indiquant si oui ou non vous voulez effectuer
   une séparation zval.
  </para>
  <programlisting>
<![CDATA[
ZEND_API int call_user_function_ex(HashTable *function_table, zval *object,
zval *function_name, zval **retval_ptr_ptr,
int param_count, zval **params[],
int no_separation);
]]>
  </programlisting>
  <para>
   Notez que vous n'avez pas besoin de spécifier à la fois
   <envar>function_table</envar> et <envar>object</envar> ;
   l'un ou l'autre suffit. Si vous voulez appeler une méthode, vous devez fournir l'objet
   qui contient cette méthode, et dans ce cas, <function>call_user_function</function>
   définit automatiquement la table de fonction à cette objet. Sinon, vous ne devez spécifier
   que <envar>function_table</envar> et vous pouvez définir
   <envar>object</envar> à &null;.
  </para>
  <para>
   Habituellement, la table de fonction par défaut est la table de fonction "root"
   contenant toutes les entrées de fonction. Cette table de fonction est une partie
   du compilateur global et peut être accéder en utilisant la macro
   <literal>CG</literal>. Pour introduite le compilateur globale
   à votre fonction, appeler d'abord la macro <literal>TSRMLS_FETCH</literal>.
  </para>
  <para>
   Le nom de la fonction est spécifié dans un conteneur <envar>zval</envar>.
   Ceci peut paraître surprenant dans un premier temps, mais c'est une étape
   logique, car la plupart des fois, vous accepterez des noms de fonctions
   en tant queparamètres pour l'appel des fonctions dans votre script,
   qui seront eux-même dans un conteneur <envar>zval</envar>.
   Vous n'avez qu'à passer vos arguments via cette fonction. Ce conteneur
   <envar>zval</envar> doit être du type <literal>IS_STRING</literal>.
  </para>
  <para>
   Le prochain argument consiste en un pointeur de la valeur retournée.
   Vous n'avez pas à allouer de mémoire pour ce conteneur ; la fonction
   le fera elle-même. Cependant, vous devez ensuite détruire ce conteneur (en utilisant
   la fonction <function>zval_dtor</function>) !
  </para>
  <para>
   Le prochain est le paramètre de compteur (un entier) et un tableau
   contenant tous les paramètres nécessaires. Le dernier argument
   indique si la fonction doit effectuer une séparation zval - il doit
   toujours être défini à <literal>0</literal>. Si défini à <literal>1</literal>,
   la fonction consomme moins de mémoire mais échoue si un des paramètres
   doit être séparer.
  </para>
  <para>
   <xref linkend='example.call-user-func'/> montre une petite démonstration
   de l'appel d'une fonction utilisateur. Le code appelle une fonction qui lui est fournie
   en tant qu'argument et passe directement la valeur retournée par cette fonction
   via sa propre valeur retournée. Notez l'utilisation du constructeur et du destructeur
   à la fin - cela peut ne pas être nécessaire ici (car les valeurs doivent être séparées,
   l'assignement est sécurisé), mais c'est plus prudent.
  </para>
  <example id='example.call-user-func'>
   <title>Appeler des fonctions utilisateurs</title>
   <programlisting>
<![CDATA[
zval **function_name;
zval *retval;

if((ZEND_NUM_ARGS() != 1) || (zend_get_parameters_ex(1, &function_name) != SUCCESS))
{
    WRONG_PARAM_COUNT;
}

if((*function_name)->type != IS_STRING)
{
    zend_error(E_ERROR, "La fonction requiet une chaîne de caractères en tant qu'argument.");
}

TSRMSLS_FETCH();

if(call_user_function_ex(CG(function_table), NULL, *function_name, &retval, 0, NULL, 0) != SUCCESS)
{
    zend_error(E_ERROR, "L'appel à la fonction a échoué");
}

zend_printf("We have %i as type<br />", retval->type);

*return_value = *retval;
zval_copy_ctor(return_value);
zval_ptr_dtor(&retval);
]]>
   </programlisting>
  </example>
  <para/>
   <programlisting>
<![CDATA[
<?php

dl("call_userland.so");

function test_function()
{

    print("Nous sommes dans une fonction de test !<br />");

    return("hello");

}

$return_value = call_userland("test_function");

print("Valeur retournée : \"$return_value\"<br />");
?>
]]>
   </programlisting>
   <graphic fileref="figures/zend.10-userland.png"/>
 </sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
