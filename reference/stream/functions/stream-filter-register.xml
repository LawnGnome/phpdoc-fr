<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.9 $ -->
<!-- EN-Revision: 1.9 Maintainer: yannick Status: ready -->
  <refentry id="function.stream-filter-register">
   <refnamediv>
    <refname>stream_filter_register</refname>
    <refpurpose>Enregistre un filtre de flux</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <methodsynopsis>
     <type>bool</type><methodname>stream_filter_register</methodname>
     <methodparam><type>string</type><parameter>filtername</parameter></methodparam>
     <methodparam><type>string</type><parameter>classname</parameter></methodparam>
    </methodsynopsis>
    <para>
     <function>stream_filter_register</function> vous permet d'implémenter
     votre propre filtre de flux, à utiliser avec les fonctions d'accès
     aux données externes (comme <function>fopen</function>,
     <function>fread</function>, etc.).
    </para>
    <para>
     Pour ce faire, vous devez définir une classe qui étend la classe
     <literal>php_user_fitler</literal> avec les membres et méthodes définies
     ci-dessous. Lorsque vous réalisez des opérations de lecture et d'écriture
     dans le flux auquel votre filtre est attaché, &php; passera les données
     à travers votre filtre (et tous les autres filtres attachés), de façon
     à ce que les données soient modifiées telles que désiré. Vous devez
     implémenter les méthodes telles que décrit ci-dessous, sous peine de
     comportement indéfini.
    </para>
    <para>
     <function>stream_filter_register</function> retourne &false; si le nom
     de filtre <parameter>filtername</parameter> est déjà utilisé.
    </para>

    <methodsynopsis>
     <type>int</type><methodname>filter</methodname>
     <methodparam><type>resource</type><parameter>in</parameter></methodparam>
     <methodparam><type>resource</type><parameter>out</parameter></methodparam>
     <methodparam><type>int</type><parameter>&amp;consumed</parameter></methodparam>
     <methodparam><type>bool</type><parameter>closing</parameter></methodparam>
    </methodsynopsis>
    <para>
     Cette méthode est appelé à chaque fois que des données sont lues ou écrites
     dans le flux attaché (avec des fonctions comme <function>fread</function> ou
     <function>fwrite</function>).  
     Le paramètre <parameter>in</parameter> est une ressource 
     qui pointe sur une <literal>bucket brigade</literal> qui contient un ou plusieurs
     objet <literal>bucket</literal> contenant les données à filtrer.
     <parameter>out</parameter> est une autre ressource 
     qui pointe sur une <literal>bucket brigade</literal>
     dans laquelle les donnée seront placées.
     <parameter>consumed</parameter>, qui doit <emphasis>toujours</emphasis>
     être déclaré par référence, doit être incrémenté de la taille de données que
     votre filtre lit et modifie. Dans la plupart des cas, cela signifie que vous
     devrez incrémenter <parameter>consumed</parameter> avec <literal>$bucket->datalen</literal>
     pour chaque <literal>$bucket</literal>.
     Si le flux est en cours de fermeture (et par conséquent, cela sera le dernier
     passage dans la chaîne de filtres), le paramètre <parameter>closing</parameter> 
     vaudra &true; La méthode <methodname>filter</methodname> doit retourner l'une 
     des trois valeurs suivantes : 
     <informaltable>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>Valeur retournée</entry>
         <entry>Signification</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><constant>PSFS_PASS_ON</constant></entry>
         <entry>
          Indique la réussite ; les données sont dans le paramètre <parameter>out</parameter>, 
          une <literal>bucket brigade</literal>.
         </entry>
        </row>
        <row>
         <entry><constant>PSFS_FEED_ME</constant></entry>
         <entry>
          Indique que le filtre n'a aucune données à retourner, et requiert d'autres données du flux.
         </entry>
        </row>
        <row>
         <entry><constant>PSFS_ERR_FATAL</constant> (défaut)</entry>
         <entry>
          Indique que le flux a rencontré une erreur fatale, et ne peut continuer. 
          Si aucune valeur n'est retournée par cette méthode, 
          <constant>PSFS_ERR_FATAL</constant> est utilisé.
         </entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
   </para>
    
    <methodsynopsis>
     <type>void</type><methodname>oncreate</methodname>
     <void/>
    </methodsynopsis>
    <simpara>
     Cette méthode est appelée durant l'instanciation du filtre. Si votre 
     filtre alloue ou initialise d'autres ressources (comme des
     buffers), c'est le moment de le faire. Votre implémentation de cette méthode doit retourner
     &false; en cas d'erreur et &true; en cas de succès.
    </simpara>
    <para>
     <informaltable>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>Propriété</entry>
         <entry>Contenu</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><literal>FilterClass-&gt;filtername</literal></entry>
         <entry>
          Une chaîne contenant le nom du filtre est instancié.
          Les filtres peuvent être enregistrés sous de noms multiples ainsi qu'avec des jokers.
          Utilisez cette propriété pour déterminer qu'elle est le nom utilisé.
         </entry>
        </row>
        <row>
         <entry><literal>FilterClass-&gt;params</literal></entry>
         <entry>
          Le contenu du paramètre passé <parameter>params</parameter> à 
          la fonction <function>stream_filter_append</function> ou la fonction
          <function>stream_filter_prepend</function>.
         </entry> 
        </row>
       </tbody>
      </tgroup>
     </informaltable>
    </para>

    <methodsynopsis>
     <type>void</type><methodname>onclose</methodname>
     <void/>
    </methodsynopsis>
    <para>
     Cette méthode est appelée durant l'extinction du filtre (généralement,
     lorsque le flux est fermé), et est exécuté <emphasis>après</emphasis>
     l'appel de la fonction <literal>flush</literal>.  Si aucune ressource
     a été allouée ou créée durant <literal>onCreate()</literal>,
     c'est le moment de les libérer.
    </para>

    <para>
     L'exemple ci-dessous implémente un filtre appelé
     <literal>rot13</literal>, sur le flux <literal>foo-bar.txt</literal>,
     qui réalise un chiffrement de type <literal>ROT-13</literal> sur toutes les lettres 
     lues ou écrites dans le flux.
     <example> 
      <title>Filtre sur les lettres majuscules sur le flux <filename>foo-bar.txt</filename></title>
      <programlisting role="php">
<![CDATA[
<?php

/* Définition de la classe */
class strtoupper_filter extends php_user_filter {
  function filter($in, $out, &$consumed, $closing) 
  {
    while ($bucket = stream_bucket_make_writeable($in)) {
      $bucket->data = strtoupper($bucket->data);
      $consumed += $bucket->datalen;
      stream_bucket_append($out, $bucket);
    }
    return PSFS_PASS_ON;
  }
} 

/* Enregistrement de notre filtre avec PHP */
stream_filter_register("strtoupper", "strtoupper_filter")
    or die("Erreur lors de l'enregistrement du filtre");

$fp = fopen("foo-bar.txt", "w");

/* Attachement du filtre enregistré au flux que l'on vient d'ouvrir */
stream_filter_append($fp, "strtoupper");

fwrite($fp, "Ligne1\n");
fwrite($fp, "Mot - 2\n");
fwrite($fp, "Facile comme 123\n");

fclose($fp);

/* Lecture du contenu
 */
readfile("foo-bar.txt");

?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
LIGNE1
MOT - 2
FACILE COMME 123
]]>
      </screen>
     </example>
    </para>
    <para>
     <example>
      <title>Enregistrement d'une classe de filtre générique pour correspondre
      avec de multiples noms de filtres.</title>
      <programlisting role="php">
<![CDATA[
<?php

/* Définition de la classe*/
class string_filter extends php_user_filter {
  var $mode;

  function filter($in, $out, &$consumed, $closing) 
  {
    while ($bucket = stream_bucket_make_writeable($in)) {
      if ($this->mode == 1) {
        $bucket->data = strtoupper($bucket->data);
      } elseif ($this->mode == 0) {
        $bucket->data = strtolower($bucket->data);
      }

      $consumed += $bucket->datalen;
      stream_bucket_append($out, $bucket);
    }
    return PSFS_PASS_ON;
  }

  function onCreate() 
  {
    if ($this->filtername == 'str.toupper') {
      $this->mode = 1;
    } elseif ($this->filtername == 'str.tolower') {
      $this->mode = 0;
    } else {
      /* Quelques autres filtres str.* sont demandés,
          traitement de l'erreur avec PHP */
      return false;
    }

    return true;
  }
} 

/* Enregistrement de notre filtre avec PHP */
stream_filter_register("str.*", "string_filter")
    or die("Failed to register filter");

$fp = fopen("foo-bar.txt", "w");

/* Attachement du filtre enregistré au flux que l'on vient d'ouvrir
    Nous pouvons alternativement passer à str.tolower ici */
stream_filter_append($fp, "str.toupper");

fwrite($fp, "Ligne1\n");
fwrite($fp, "Mot - 2\n");
fwrite($fp, "Facile comme 123\n");

fclose($fp);

/* Lecture du contenu
 */
readfile("foo-bar.txt");

?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
LINE1
MOT - 2
FACILE COMME 123
]]>
      </screen>
     </example>
    </para>
    <simpara>
     Voir aussi
     <function>stream_wrapper_register</function>,
     <function>stream_filter_prepend</function> et
     <function>stream_filter_append</function>.
    </simpara>
   </refsect1>
  </refentry>


<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
