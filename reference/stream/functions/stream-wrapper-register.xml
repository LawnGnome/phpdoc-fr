<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.21 $ -->
<!-- EN-Revision: 1.16 Maintainer: yannick Status: ready -->
<!-- Reviewed: yes -->

  <refentry xml:id="function.stream-wrapper-register" xmlns="http://docbook.org/ns/docbook">
   <refnamediv>
    <refname>stream_wrapper_register</refname>
    <refpurpose>
     Enregistre une enveloppe URL, implémentée comme une classe PHP
    </refpurpose>
   </refnamediv>
   <refsect1>
    &reftitle.description;
    <methodsynopsis>
     <type>bool</type><methodname>stream_wrapper_register</methodname>
     <methodparam><type>string</type><parameter>protocol</parameter></methodparam>
     <methodparam><type>string</type><parameter>classname</parameter></methodparam>
    </methodsynopsis>
    <para>
     <function>stream_wrapper_register</function> permet d'implémenter
     des gestionnaires de protocole et de flux, à utiliser avec
     toutes les autres fonctions de fichiers, comme <function>fopen</function>,
     <function>fread</function> etc.
    </para>
    <para>
     Pour implémenter une enveloppe, il faut définir une classe avec
     la liste des membres définie ci-dessous. Lorsque quelqu'un ouvre
     le flux, PHP va créer une instance de la classe 
     <parameter>classname</parameter> et appeler les méthodes de cette
     instance. Il faut implémenter ces méthodes exactement comme 
     décrit ci-dessous : sinon, les comportements seront
     indéfinis.
    </para>
    <note>
     <simpara>
      Depuis PHP 5.0.0, l'instance de la classe <parameter>classname</parameter>
      contiendra une propriété <parameter>context</parameter>, faisant
      référence à la ressource de contexte qui peut être accédée
      avec la fonction <function>stream_context_get_options</function>.
      Si aucun contexte n'est passé à la fonction de création du flux, 
      <parameter>context</parameter> sera défini à &null;.
     </simpara>
    </note>    
    <para>
     <function>stream_wrapper_register</function> retourne &false; si
     le protocole <parameter>protocol</parameter> a déjà un gestionnaire
     attitré.
    </para>

    <methodsynopsis>
     <type>bool</type><methodname>stream_open</methodname>
     <methodparam><type>string</type><parameter>path</parameter></methodparam>
     <methodparam><type>string</type><parameter>mode</parameter></methodparam>
     <methodparam><type>int</type><parameter>options</parameter></methodparam>
     <methodparam><type>string</type><parameter>opened_path</parameter></methodparam>
    </methodsynopsis>
    <para>
     Cette méthode est appelée immédiatement après la création de votre
     flux. <parameter>path</parameter> spécifie l'URL qui doit être
     passée à la fonction <function>fopen</function> et ce que cet
     objet est supposé y lire. Vous pouvez utiliser <function>parse_url</function>
     pour l'analyser.
    </para>
    <para>
     <parameter>mode</parameter> est le mode d'ouverture du fichier,
     comme expliqué dans <function>fopen</function>. Vous êtes responsable
     de la vérification de la validité du paramètre <parameter>mode</parameter>
     avec le chemin <parameter>path</parameter> fourni.
    </para>
    <para>
     <parameter>options</parameter> contient des options supplémentaires,
     utilisées par les API de flux. Il peut contenir une ou plusieurs
     des options suivantes, combinées avec l'opérateur OR.
     <informaltable>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>Option</entry>
         <entry>Description</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><constant>STREAM_USE_PATH</constant></entry>
         <entry>Si <parameter>path</parameter> est relatif, recherche
         la ressources en utilisant la configuration de l'<option>include_path</option>.
         </entry>
        </row>
        <row>
         <entry><constant>STREAM_REPORT_ERRORS</constant></entry>
         <entry>Si cette option est activée, la classe est responsable 
         de la génération d'erreurs avec <function>trigger_error</function> 
         durant l'ouverture du flux. Si cette option n'est pas 
         activée, il ne faut générer aucune erreur.
         </entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
    </para>
    <para>
     Si le paramètre <parameter>path</parameter> est ouvert avec succès,
     et que <constant>STREAM_USE_PATH</constant> est activé dans le paramètre 
     <parameter>options</parameter>,
     il faut affecter à <parameter>opened_path</parameter> le chemin complet
     de la ressource ou du fichier qui a été réellement ouvert.
    </para>
    <para>
     Si la ressource demandée a été ouverte, il faut retourner
     &true;, ou, sinon, &false;
    </para>

    <methodsynopsis>
     <type>void</type><methodname>stream_close</methodname>
     <void/>
    </methodsynopsis>
    <para>
     Cette méthode est appelée lorsque le flux est fermé, grâce à la
     fonction <function>fclose</function>. Vous devez libérer
     toutes les ressources verrouillées ou réservées par le flux.
    </para>

    <methodsynopsis>
     <type>string</type><methodname>stream_read</methodname>
     <methodparam><type>int</type><parameter>count</parameter></methodparam>
    </methodsynopsis>
    <para>
     Cette méthode est appelée suite à l'utilisation des fonctions <function>fread</function>
     et <function>fgets</function>. Vous devez lire jusqu'à
     <parameter>count</parameter> octets de données à partir de
     la position courante d'écriture ou de lecture, sous la 
     forme de chaîne de caractères. S'il y a moins que
     <parameter>count</parameter> octets disponibles, vous
     devez en retourner autant que possible. Si aucune autre
     donnée n'est disponible, &false; sera retourné ou  
     une chaîne vide. Vous devez aussi tenir à jour la position 
     du pointeur d'écriture/lecture dans le flux, en ajoutant
     ou retranchant le nombre d'octets lus.
    </para>

    <methodsynopsis>
     <type>int</type><methodname>stream_write</methodname>
     <methodparam><type>string</type><parameter>data</parameter></methodparam>
    </methodsynopsis>
    <para>
     Cette méthode est appelée lorsque la fonction <function>fwrite</function>
     est utilisée. Vous devez stocker les données <parameter>data</parameter>
     dans le flux. S'il n'y a pas assez de place, essayez d'en
     stocker le maximum. Vous devriez aussi retourner le nombre d'octets que vous
     avez réussi à écrire, ou bien 0 si aucun n'a pu être stocké.
     Vous devez aussi tenir à jour la position 
     du pointeur d'écriture/lecture dans le flux, en ajoutant
     ou retranchant le nombre d'octets écrits.
    </para>
   
    <methodsynopsis>
     <type>bool</type><methodname>stream_eof</methodname>
     <void/>
    </methodsynopsis>
    <para>
     Cette méthode est appelée lorsque la fonction <function>feof</function>
     est utilisée. Vous devez retourner &true; si la position de lecture
     se situe à la fin du fichier et s'il n'y a plus de données
     disponibles pour la lecture, ou bien &false; sinon.
    </para>

    <methodsynopsis>
     <type>int</type><methodname>stream_tell</methodname>
     <void/>
    </methodsynopsis>
    <para>
     Cette méthode est appelée lorsque la fonction <function>ftell</function>
     est utilisée. Vous devez retourner la position actuelle du pointeur
     de lecture/écriture dans le flux.
    </para>

    <methodsynopsis>
     <type>bool</type><methodname>stream_seek</methodname>
     <methodparam><type>int</type><parameter>offset</parameter></methodparam>
     <methodparam><type>int</type><parameter>whence</parameter></methodparam>
    </methodsynopsis>
    <para>
     Cette méthode est appelée lorsque la fonction <function>fseek</function>
     est utilisée. Vous devez modifier la position du pointeur de lecture/écriture
     en fonction des paramètres d'offset <parameter>offset</parameter>
     et de direction <parameter>whence</parameter>. Reportez-vous
     à la fonction <function>fseek</function> pour plus de détails sur ces
     paramètres. Retournez &true; si la position a été modifiée, et 
     &false; sinon.
    </para>

    <methodsynopsis>
     <type>bool</type><methodname>stream_flush</methodname>
     <void/>
    </methodsynopsis>
    <para>
     Cette méthode est appelée lorsque la fonction <function>fflush</function>
     est utilisée. Si vous avez mis des données dans un système de cache pour
     votre flux, mais qu'elles ne sont pas encore stockées de manière pérenne,
     c'est le moment de le faire. Retournez 
     &true; si les données cachées ont pu être stockées avec succès
     (il n'y a plus de données à stocker), ou bien &false; si les
     données n'ont pu être stockées.
    </para>

    <methodsynopsis>
     <type>array</type><methodname>stream_stat</methodname>
     <void/>
    </methodsynopsis>
    <para>
     Cette méthode est appelée en réponse à la fonction <function>fstat</function>
     sur un flux, et retourne un tableau, avec les valeurs appropriées pour le 
     flux.
    </para>
 
  <methodsynopsis>
   <type>resource</type><methodname>stream_cast</methodname>
   <methodparam><type>int</type><parameter>cast_as</parameter></methodparam>
  </methodsynopsis>
  <para>
   Cette méthode est appelé en réponse à un appel à <function>stream_select</function>,
   sur le flux, et doit retourner la ressource sous-jacente utilisée par le
   gestionnaire, ou bien &false;. Le paramètre <parameter>cast_as</parameter> 
   peut être <constant>STREAM_CAST_FOR_SELECT</constant> si
   <function>stream_select</function> appelle la fonction 
   <function>stream_cast</function> ou 
   <constant>STREAM_CAST_AS_STREAM</constant> si
   <function>stream_cast</function> est appelé par d'autres fonctions.
  </para>
  <note>
   <simpara>
    Le gestionnaire stream_cast n'est pas supporté avant PHP 5.3.0.
   </simpara>
  </note>

  <methodsynopsis>
   <type>bool</type><methodname>stream_set_option</methodname>
   <methodparam><type>int</type><parameter>option</parameter></methodparam>
   <methodparam><type>int</type><parameter>arg1</parameter></methodparam>
   <methodparam><type>int</type><parameter>arg2</parameter></methodparam>
  </methodsynopsis>
  <para>
   Cette méthode est appelée pour configurer les options du flux.
   Les valeurs possibles pour le paramètres <parameter>option</parameter> sont :
   <simplelist>
    <member><constant>STREAM_OPTION_BLOCKING</constant> : la méthode est appelée
    en réponse à <function>stream_set_blocking</function>.
     <parameter>arg1</parameter> est le mode bloquant demandé.</member>
    <member><constant>STREAM_OPTION_READ_TIMEOUT</constant> : la méthode est 
    appelée en réponse à <function>stream_set_timeout</function>.
     <parameter>arg1</parameter> est le délai d'expiration, exprimé en secondes,
     et <parameter>arg2</parameter> est le délai d'expiration exprimé en microsecondes.</member>
    <member><constant>STREAM_OPTION_WRITE_BUFFER</constant> : la méthode est appelée
    en réponse à <function>stream_set_write_buffer</function>.
     <parameter>arg1</parameter> est le mode de buffer
     (<constant>STREAM_BUFFER_NONE</constant> ou
     <constant>STREAM_BUFFER_FULL</constant>) et <parameter>arg2</parameter>
     est la taille de buffer demandée.</member>
   </simplelist>
  </para>
  <para>
   <function>stream_set_option</function> doit retourner &false; en cas d'échec, 
   ou si <parameter>option</parameter> n'est pas implémenté, et &true; sinon.
  </para>
  <note>
   <simpara>
    Le gestionnaire stream_set_option n'est pas supporté avant PHP 5.3.0.
   </simpara>
  </note>

    <methodsynopsis>
     <type>bool</type><methodname>unlink</methodname>
     <methodparam><type>string</type><parameter>path</parameter></methodparam>
    </methodsynopsis>
    <para>
     Cette méthode est appelée en réponse à la fonction <function>unlink</function>
     avec une URL, et doit tenter de supprimer l'objet identifié par 
     <parameter>path</parameter>. La fonction doit retourner 
     &true; en cas de succès, et &false; en cas d'échec.
     Afin de retourner le bon message d'erreur, ne définissez pas
     cette méthode si votre gestionnaire ne le supporte pas.
    </para>
    <note>
     <simpara>
      La méthode enveloppe d'utilisateur <literal>unlink</literal> n'est pas supportée
      avant PHP 5.0.0.
     </simpara>
    </note>
         
    <methodsynopsis>
     <type>bool</type><methodname>rename</methodname>
     <methodparam><type>string</type><parameter>path_from</parameter></methodparam>
     <methodparam><type>string</type><parameter>path_to</parameter></methodparam>
    </methodsynopsis>
    <para>
     Cette méthode est appelée en réponse à la fonction <function>rename</function>
     avec une URL associée avec l'enveloppe et doit tenter de renommer
     l'objet identifié par <parameter>path_from</parameter> en 
     <parameter>path_to</parameter>. Cela doit retourner &true; en cas de succès ou
     &false; en cas d'erreur. 
     Afin de pouvoir retourner le message d'erreur approprié, ne définissez pas cette méthode
     si votre enveloppe ne supporte pas d'être renommé.
    </para>
    <note>
     <simpara>
      La méthode enveloppe d'utilisateur <literal>rename</literal> n'est pas supportée
      avant PHP 5.0.0.
     </simpara>
    </note>
         
    <methodsynopsis>
     <type>bool</type><methodname>mkdir</methodname>
     <methodparam><type>string</type><parameter>path</parameter></methodparam>
     <methodparam><type>int</type><parameter>mode</parameter></methodparam>
     <methodparam><type>int</type><parameter>options</parameter></methodparam>
    </methodsynopsis>
    <para>
     Cette méthode est appelée en réponse à la fonction <function>mkdir</function>
     avec une URL associée avec l'enveloppe et doit tenter de créer le répertoire
     spécifié par <parameter>path</parameter>.
     Cela doit retourner &true; en cas de succès ou &false; en cas d'erreur.
     Afin de pouvoir retourner le message d'erreur approprié, ne définissez pas cette méthode
     si votre enveloppe ne supporte pas la création de répertoire.
     Les valeurs possibles pour le paramètre <parameter>options</parameter>
     sont <constant>STREAM_REPORT_ERRORS</constant> et 
     <constant>STREAM_MKDIR_RECURSIVE</constant>.
    </para>
    <note>
     <simpara>
      La méthode enveloppe d'utilisateur <literal>mkdir</literal> n'est pas supportée
      avant PHP 5.0.0.
     </simpara>
    </note>

    <methodsynopsis>
     <type>bool</type><methodname>rmdir</methodname>
     <methodparam><type>string</type><parameter>path</parameter></methodparam>
     <methodparam><type>int</type><parameter>options</parameter></methodparam>
    </methodsynopsis>
    <para>
     Cette méthode est appelée en réponse à la fonction <function>rmdir</function>
     avec une URL associée avec l'enveloppe et doit tenter de supprimer
     le répertoire spécifié par <parameter>path</parameter>.
     Cela doit retourner &true; en cas de succès ou &false; en cas d'erreur.
     Afin de pouvoir retourner le message d'erreur approprié, ne définissez pas cette méthode
     si votre enveloppe ne supporte pas la suppression de répertoire.
     La valeur possible pour le paramètre <parameter>options</parameter>
     est <constant>STREAM_REPORT_ERRORS</constant>.
    </para>
    <note>
     <simpara>
      La méthode enveloppe d'utilisateur <literal>rmdir</literal> n'est pas supportée
      avant PHP 5.0.0.
     </simpara>
    </note>

    <methodsynopsis>
     <type>bool</type><methodname>dir_opendir</methodname>
     <methodparam><type>string</type><parameter>path</parameter></methodparam>
     <methodparam><type>int</type><parameter>options</parameter></methodparam>
    </methodsynopsis>
    <para>
     Cette méthode est appelée immédiatement lorsque votre flux
     est créé, pour examiner le contenu d'un dossier avec 
     <function>opendir</function>. <parameter>path</parameter> spécifie
     l'URL qui est passée à <function>opendir</function> et que cet objet
     doit explorer. Vous pouvez utiliser <function>parse_url</function>
     pour la scinder en morceaux.
    </para>

    <methodsynopsis>
     <type>array</type><methodname>url_stat</methodname>
     <methodparam><type>string</type><parameter>path</parameter></methodparam>
     <methodparam><type>int</type><parameter>flags</parameter></methodparam>
    </methodsynopsis>
    <para>
     Cette méthode est appelée en réponse à la fonction <function>stat</function>
     avec une URL associée avec l'enveloppe et doit retourner autant d'éléments en commun
     avec la fonction système que possible. Les valeurs non connues ou non disponibles doivent
     être définies en une valeur rationnelle (habituellement, &zero;).
    </para>
    <para>
     <parameter>flags</parameter> représente les options additionnelles définies
     par l'API. Il peut prendre une ou plusieurs des valeurs suivantes séparées par OR.
     <informaltable>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>Option</entry>
         <entry>Description</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><constant>STREAM_URL_STAT_LINK</constant></entry>
         <entry>
          Pour les ressources avec la possibilité de relier d'autres ressources (comme
          par exemple <literal>HTTP Location: forward</literal> ou un lien symbolique d'un
          système de fichiers). Cette option spécifie que seul les informations à propos du lien
          lui-même peuvent être retournées, et non pas les ressources pointées par le lien.
          Cette option est définie en réponse à l'appel à la fonction <function>lstat</function>,
          <function>is_link</function>, ou <function>filetype</function>.
         </entry>
        </row>
        <row>
         <entry><constant>STREAM_URL_STAT_QUIET</constant></entry>
         <entry>
          Si cette option est définie, votre enveloppe ne devra contenir aucune erreur.
          Si cette option n'est pas définie, vous êtes responsable du traitement des erreurs
          en utilisant la fonction <function>trigger_error</function> pendant l'évaluation 
          du chemin.  
         </entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
    </para>
         
    <methodsynopsis>
     <type>string</type><methodname>dir_readdir</methodname>
     <void/>
    </methodsynopsis>
    <para>
     Cette méthode est appelée en réponse à la fonction <function>readdir</function>
     et doit retourner une chaîne représentant le prochain fichier ouvert
     par <function>dir_opendir</function>.
    </para>

    <methodsynopsis>
     <type>bool</type><methodname>dir_rewinddir</methodname>
     <void/>
    </methodsynopsis>
    <para>
     Cette méthode est appelée en réponse à <function>rewinddir</function>
     et doit remettre à zéro les résultats de <function>dir_readdir</function>.
     i.e. : le prochain appel à <function>dir_readdir</function> doit retourner
     la première ligne située dans le dossier ouvert par <function>dir_opendir</function>.
    </para>

    <methodsynopsis>
     <type>bool</type><methodname>dir_closedir</methodname>
     <void/>
    </methodsynopsis>
    <para>
     Cette méthode est appelée en réponse à <function>closedir</function>.
     Vous devez libérer toutes les ressources qui ont été réservées
     durant l'ouverture et l'utilisation du dossier.
    </para>

    <para>
     L'exemple ci-dessous implémente un gestionnaire de protocole pour
     le protocole var://, qui permet l'écriture et la lecture de variables
     globales en utilisant un flux de fichier standard, et les fonctions
     classiques telles que <function>fread</function>.
     Le protocole var:// implémenté ci-dessous, étant donné l'URL
     <literal>var://foo</literal> va écrire ou lire les données dans 
     <varname>$GLOBALS["foo"]</varname>.

     <example> 
      <title>Une classe de flux pour accéder aux variables globales</title>
      <programlisting role="php">
<![CDATA[
<?php

class VariableStream {
    var $position;
    var $varname;
   
    function stream_open($path, $mode, $options, &$opened_path)
    {
        $url = parse_url($path);
        $this->varname = $url["host"];
        $this->position = 0;
        
        return true;
    }

    function stream_read($count)
    {
        $ret = substr($GLOBALS[$this->varname], $this->position, $count);
        $this->position += strlen($ret);
        return $ret;
    }

    function stream_write($data)
    {
        $left = substr($GLOBALS[$this->varname], 0, $this->position);
        $right = substr($GLOBALS[$this->varname], $this->position + strlen($data));
        $GLOBALS[$this->varname] = $left . $data . $right;
        $this->position += strlen($data);
        return strlen($data);
    }

    function stream_tell()
    {
        return $this->position;
    }

    function stream_eof()
    {
        return $this->position >= strlen($GLOBALS[$this->varname]);
    }

    function stream_seek($offset, $whence)
    {
        switch($whence) {
            case SEEK_SET:
                if ($offset < strlen($GLOBALS[$this->varname]) && $offset >= 0) {
                     $this->position = $offset;
                     return true;
                } else {
                     return false;
                }
                break;
                
            case SEEK_CUR:
                if ($offset >= 0) {
                     $this->position += $offset;
                     return true;
                } else {
                     return false;
                }
                break;
                
            case SEEK_END:
                if (strlen($GLOBALS[$this->varname]) + $offset >= 0) {
                     $this->position = strlen($GLOBALS[$this->varname]) + $offset;
                     return true;
                } else {
                     return false;
                }
                break;
                
            default:
                return false;
        }
    }
}

stream_wrapper_register("var", "VariableStream")
    or die("Failed to register protocol");

$myvar = "";
    
$fp = fopen("var://myvar", "r+");

fwrite($fp, "line1\n");
fwrite($fp, "line2\n");
fwrite($fp, "line3\n");

rewind($fp);
while(!feof($fp)) {
    echo fgets($fp);
}
fclose($fp);
var_dump($myvar);

?>
]]>
      </programlisting>
     </example>
    </para>
    
   </refsect1>

 <refsect1 role="changelog"><!-- {{{ -->
  &reftitle.changelog;
  <para>
   <informaltable>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>&Version;</entry>
       <entry>&Description;</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>5.0.0</entry>
       <entry>
        Ajout des méthodes <function>unlink</function>, <function>rename</function>,
        <function>mkdir</function> and <function>rmdir</function>.
       </entry>
      </row>
      <row>
       <entry>5.3.0</entry>
       <entry>
        Ajout des méthodes <function>stream_cast</function> 
        et <function>stream_set_option</function>.
       </entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>
  </para>
 </refsect1><!-- }}} -->


  </refentry>


<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
