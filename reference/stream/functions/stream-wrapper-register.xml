<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.4 $ -->
<!-- splitted from ./en/functions/filesystem.xml, last change in rev 1.141 -->
  <refentry id="function.stream-wrapper-register">
   <refnamediv>
    <refname>stream_wrapper_register</refname>
    <refpurpose>
     Enregistre une enveloppe URL, implémentée comme classe PHP
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <methodsynopsis>
     <type>bool</type><methodname>stream_wrapper_register</methodname>
     <methodparam><type>string</type><parameter>protocol</parameter></methodparam>
     <methodparam><type>string</type><parameter>classname</parameter></methodparam>
    </methodsynopsis>
    <para>
     <function>stream_wrapper_register</function> vous permet d'implémenter
     vos propres gestionnaires de protocoles et de flux, à utiliser avec
     toutes les autres fonctions de fichiers, comme <function>fopen</function>,
     <function>fread</function> etc...
    </para>
    <para>
     Pour implémenter une enveloppe, vous devez définir une classe avec
     la liste des membres définie ci-dessous. Lorsque quelqu'un ouvre
     votre flux, PHP va créer une instance de la classe 
     <parameter>classname</parameter> et appeler les méthodes de cette
     instance. Vous devez implémenter ces méthodes exactement comme 
     décrit ci-dessous : sinon, vous risquez de rencontrer des comportements
     indéfinis.
    </para>
    <para>
     <function>stream_wrapper_register</function> retourne &false; si
     le protocole <parameter>protocol</parameter> a déjà un gestionnaire
     attitré.
    </para>

    <methodsynopsis>
     <type>bool</type><methodname>stream_open</methodname>
     <methodparam><type>string</type><parameter>path</parameter></methodparam>
     <methodparam><type>string</type><parameter>mode</parameter></methodparam>
     <methodparam><type>int</type><parameter>options</parameter></methodparam>
     <methodparam><type>string</type><parameter>opened_path</parameter></methodparam>
    </methodsynopsis>
    <para>
     Cette méthode est appelée immédiatement après la création de votre
     flux. <parameter>path</parameter> spécifie l'URL qui doit être
     passée à la fonction <function>fopen</function> et ce que cet
     objet est supposé y lire. Vous pouvez utiliser <function>parse_url</function>
     pour l'analyser.
    </para>
    <para>
     <parameter>mode</parameter> est le mode d'ouverture du fichier,
     comme expliqué dans <function>fopen</function>.  Vous êtes responsable
     de la vérification de la validité du paramètre <parameter>mode</parameter>
     avec le chemin <parameter>path</parameter> fourni.
    </para>
    <para>
     <parameter>options</parameter> contient des options supplémentaires,
     utilisées par les API de flux. Il peut contenir une ou plusieurs
     des options suivantes, combinées par des OR.
     <informaltable>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>Option</entry>
         <entry>Description</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>STREAM_USE_PATH</entry>
         <entry>Si <parameter>path</parameter> est relatif, recherche
         la ressources en utilisant la configuration de l'include_path.
         </entry>
        </row>
        <row>
         <entry>STREAM_REPORT_ERRORS</entry>
         <entry>Si cette option est activée, vous êtes responsable 
         pour lever les erreurs avec <function>trigger_error</function> 
         durant l'ouverture du flux. Si cette option n'est pas 
         activée, vous ne devez lever aucune erreur.
         </entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
    </para>
    <para>
     Si le paramètre <parameter>path</parameter> est ouvert avec succès,
     et que STREAM_USE_PATH est activé dans le paramètre <parameter>options</parameter>,
     vous devez affecter à <parameter>opened_path</parameter> le chemin complet
     de la ressource ou du fichier que vous avez réellement ouvert.
    </para>
    <para>
     Si la ressource demandée a été ouverte, vous devez retourner
     &true;, ou sinon, vous devez retourner &false;
    </para>

    <methodsynopsis>
     <type>void</type><methodname>stream_close</methodname>
     <void/>
    </methodsynopsis>
    <para>
     Cette méthode est appelée lors que flux est fermée, grâce à la
     fonction <function>fclose</function>.  Vous devez libérez
     toutes les ressources réservées par le flux.
    </para>

    <methodsynopsis>
     <type>string</type><methodname>stream_read</methodname>
     <methodparam><type>int</type><parameter>count</parameter></methodparam>
    </methodsynopsis>
    <para>
     Cette méthod est appelée suite à l'utilisation des fonctions <function>fread</function>
     et <function>fgets</function>. Vous devez lire jusqu'à
     <parameter>count</parameter> octets de données à partir de
     la position courante d'écriture ou de lecture, sous la 
     forme de chaîne de caractères. Si il y a moins que
     <parameter>count</parameter> octets disponibles, vous
     devez en retourner autant que possible. Si aucune autre
     donnée n'est disponible, retournez soit &false; soit 
     une chaîne vide. Vous devez aussi tenir à jour la position 
     du pointeur d'écriture/lecture dans le flux, en ajoutant
     ou retranchant le nombre d'octets lus.
    </para>

    <methodsynopsis>
     <type>int</type><methodname>stream_write</methodname>
     <methodparam><type>string</type><parameter>data</parameter></methodparam>
    </methodsynopsis>
    <para>
     Cette méthode est appelée lorsque la fonction <function>fwrite</function>
     est utilisée. Vous devez stocker les données <parameter>data</parameter>
     dans le flux. Si il n'y a pas assez de place, essayez d'en
     stocker le maximum. Vous devriez aussi retourner le nombre d'octets que vous
     avez réussi à écrire, ou bien 0 si aucun n'a pu être stocké.
     Vous devez aussi tenir à jour la position 
     du pointeur d'écriture/lecture dans le flux, en ajoutant
     ou retranchant le nombre d'octets lus.
    </para>
   
    <methodsynopsis>
     <type>bool</type><methodname>stream_eof</methodname>
     <void/>
    </methodsynopsis>
    <para>
     Cette méthode est appelée lorsque la fonction <function>feof</function>
     est utilisée. Vous devez retourner &true; si la position de lecture
     se situe a la fin du fichier et si il n'y a plus de donnée
     disponible pour la lecture, ou bien &false; sinon.
    </para>

    <methodsynopsis>
     <type>int</type><methodname>stream_tell</methodname>
     <void/>
    </methodsynopsis>
    <para>
     Cette méthode est appelée lorsque la fonction <function>ftell</function>
     est utilisée. Vous devez retourner la position actuelle du pointeur
     de lecture / écriture.
    </para>

    <methodsynopsis>
     <type>bool</type><methodname>stream_seek</methodname>
     <methodparam><type>int</type><parameter>offset</parameter></methodparam>
     <methodparam><type>int</type><parameter>whence</parameter></methodparam>
    </methodsynopsis>
    <para>
     Cette méthode est appelée lorsque la fonction <function>fseek</function>
     est utilisée. Vous devez modifier la position du pointeur de lecture/
     écriture en fonction des paramètres d'offset <parameter>offset</parameter>
     et de direction <parameter>whence</parameter>. Reportez-vous
     à la fonction <function>fseek</function> pour plus de détails sur ces
     paramètres. Retournez &true; si la position a été modifiée, et 
     &false; sinon.
    </para>

    <methodsynopsis>
     <type>bool</type><methodname>stream_flush</methodname>
     <void/>
    </methodsynopsis>
    <para>
     Cette méthode est appelée lorsque la fonction <function>fflush</function>
     est utilisée. Si vous avez mis des données dans un système de cache pour
     votre flux, mais qu'ils ne sont pas encore stockés de manière pérenne,
     c'est le moment de le faire. Retournez 
     &true; si les données cachées ont pu être stockées avec succès
     (il n'y a plus de donnée à stocker), ou bien &false; si les
     données n'ont pu être stockées.
    </para>

    <methodsynopsis>
     <type>array</type><methodname>stream_stat</methodname>
     <void/>
    </methodsynopsis>
    <para>
     Cette méthode est appelée en réponse à la fonction <function>fstat</function>
     sur un flux, et retourne un tableau, avec les valeurs appropriées pour le 
     flux.
    </para>

    <methodsynopsis>
     <type>bool</type><methodname>unlink</methodname>
     <methodparam><type>string</type><parameter>path</parameter></methodparam>
    </methodsynopsis>
    <para>
     Cette méthode est appelée en réponse à la fonction <function>unlink</function>
     avec une URL, et doit tenter de supprimer l'objet identifié par 
     <parameter>path</parameter>. La fonction doit retourne 
     &true; en cas de succès, et &false; en cas d'échec.
     Afin de retourner le bon message d'erreur, ne définissez pas
     cette méthode si votre gestionnaire ne le supporte pas.
    </para>
    <note>
     <simpara>
      Userspace wrapper unlink method is not supported prior to 
      <literal>PHP 5.0.0</literal>.
     </simpara>
    </note>

<!--
    Note: url_stat() is not yet implemented.  
          ext/standard/filestat.c needs to route through wrappers first.

    <methodsynopsis>
     <type>array</type><methodname>url_stat</methodname>
     <methodparam><type>string</type><parameter>path</parameter></methodparam>
    </methodsynopsis>
    <para>
     This method is called in response to <function>stat</function>
     calls on the URL paths associated with the wrapper and should
     return as many elements in common with the system function as
     possible.  Unknown or unavailable values should be set to a
     rational value (usually <constant>0</constant>).
    </para>
-->

    <methodsynopsis>
     <type>bool</type><methodname>dir_opendir</methodname>
     <methodparam><type>string</type><parameter>path</parameter></methodparam>
     <methodparam><type>int</type><parameter>options</parameter></methodparam>
    </methodsynopsis>
    <para>
     Cette méthode est appelée immédiatement lorsque votre flux
     est créé, pour examiner le contenu d'un dossier avec 
     <function>opendir</function>. <parameter>path</parameter> spécifie
     l'URL qui est passée à <function>opendir</function> et que cet objet
     doit explorer. Vous pouvez utiliser <function>parse_url</function>
     pour la scinder en morceaux.
    </para>

    <methodsynopsis>
     <type>string</type><methodname>dir_readdir</methodname>
     <void/>
    </methodsynopsis>
    <para>
     Cette méthode est appelée en réponse à la fonction <function>readdir</function>
     et doit retourner une chaîne représentant le prochain fichier ouvert
     par <function>dir_opendir</function>.
    </para>

    <methodsynopsis>
     <type>bool</type><methodname>dir_rewinddir</methodname>
     <void/>
    </methodsynopsis>
    <para>
     Cette méthode st appelée en réponse à <function>rewinddir</function>
     et doit remettre à zéro les résultats de <function>dir_readdir</function>.
     i.e. : le prochain appel à <function>dir_readdir</function> doit retourner
     la première ligne située dans le dossier ouvert par <function>dir_opendir</function>.
    </para>

    <methodsynopsis>
     <type>bool</type><methodname>dir_closedir</methodname>
     <void/>
    </methodsynopsis>
    <para>
     Cette méthde est appelé en réponse à <function>closedir</function>.
     Vous devez libérer toutes les ressources qui ont été réservées
     durant l'ouverture et l'utilisation du dossier.
    </para>

    <para>
     L'exemple ci-dessous implémente un gestionnaire de protocole pour
     le protocole var://, qui permet l'écriture et la lecture de variables
     globales en utilisant un flux de fichier standard, et les fonctions
     classiques telles que <function>fread</function>.
     Le protocole var:// implémenté ci-dessous, étant donné l'URL
     "var://foo" va écrire ou lire les données dans $GLOBALS["foo"].

     <example> 
      <title>Une classe de flux pour accéder aux variables globales</title>
      <programlisting role="php">
<![CDATA[
<?php

class VariableStream {
    var $position;
    var $varname;
   
    function stream_open($path, $mode, $options, &$opened_path)
    {
        $url = parse_url($path);
        $this->varname = $url["host"];
        $this->position = 0;
        
        return true;
    }

    function stream_read($count)
    {
        $ret = substr($GLOBALS[$this->varname], $this->position, $count);
        $this->position += strlen($ret);
        return $ret;
    }

    function stream_write($data)
    {
        $left = substr($GLOBALS[$this->varname], 0, $this->position);
        $right = substr($GLOBALS[$this->varname], $this->position + strlen($data));
        $GLOBALS[$this->varname] = $left . $data . $right;
        $this->position += strlen($data);
        return strlen($data);
    }

    function stream_tell()
    {
        return $this->position;
    }

    function stream_eof()
    {
        return $this->position >= strlen($GLOBALS[$this->varname]);
    }

    function stream_seek($offset, $whence)
    {
        switch($whence) {
            case SEEK_SET:
                if ($offset < strlen($GLOBALS[$this->varname]) && $offset >= 0) {
                     $this->position = $offset;
                     return true;
                } else {
                     return false;
                }
                break;
                
            case SEEK_CUR:
                if ($offset >= 0) {
                     $this->position += $offset;
                     return true;
                } else {
                     return false;
                }
                break;
                
            case SEEK_END:
                if (strlen($GLOBALS[$this->varname]) + $offset >= 0) {
                     $this->position = strlen($GLOBALS[$this->varname]) + $offset;
                     return true;
                } else {
                     return false;
                }
                break;
                
            default:
                return false;
        }
    }
}

stream_wrapper_register("var", "VariableStream")
    or die("Failed to register protocol");

$myvar = "";
    
$fp = fopen("var://myvar", "r+");

fwrite($fp, "line1\n");
fwrite($fp, "line2\n");
fwrite($fp, "line3\n");

rewind($fp);
while(!feof($fp)) {
    echo fgets($fp);
}
fclose($fp);
var_dump($myvar);
?>
]]>
      </programlisting>
     </example>
    </para>
   </refsect1>
  </refentry>


<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
