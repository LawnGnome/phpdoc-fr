<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.8 $ -->
<!-- EN-Revision: 1.12 Maintainer: yannick Status: ready -->
  <refentry id="function.stream-wrapper-register">
   <refnamediv>
    <refname>stream_wrapper_register</refname>
    <refpurpose>
     Enregistre une enveloppe URL, implémentée comme une classe PHP
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <methodsynopsis>
     <type>bool</type><methodname>stream_wrapper_register</methodname>
     <methodparam><type>string</type><parameter>protocol</parameter></methodparam>
     <methodparam><type>string</type><parameter>classname</parameter></methodparam>
    </methodsynopsis>
    <para>
     <function>stream_wrapper_register</function> vous permet d'implémenter
     vos propres gestionnaires de protocoles et de flux, à utiliser avec
     toutes les autres fonctions de fichiers, comme <function>fopen</function>,
     <function>fread</function> etc.
    </para>
    <para>
     Pour implémenter une enveloppe, vous devez définir une classe avec
     la liste des membres définie ci-dessous. Lorsque quelqu'un ouvre
     votre flux, &php; va créer une instance de la classe 
     <parameter>classname</parameter> et appeler les méthodes de cette
     instance. Vous devez implémenter ces méthodes exactement comme 
     décrit ci-dessous : sinon, vous risquez de rencontrer des comportements
     indéfinis.
    </para>
    <note>
     <simpara>
      Depuis &php; 5.0.0, l'intance de la classe <parameter>classname</parameter>
      sera peuplé avec une propriété <parameter>context</parameter>
      référençant une <literal>ressource de contexte</literal> qui peut être accédée
      avec la fonction <function>stream_context_get_options</function>.
      Si aucun contexte n'est passé à la fonction de création du flux, 
      <parameter>context</parameter> sera défini à &null;.
     </simpara>
    </note>    
    <para>
     <function>stream_wrapper_register</function> retourne &false; si
     le protocole <parameter>protocol</parameter> a déjà un gestionnaire
     attitré.
    </para>

    <methodsynopsis>
     <type>bool</type><methodname>stream_open</methodname>
     <methodparam><type>string</type><parameter>path</parameter></methodparam>
     <methodparam><type>string</type><parameter>mode</parameter></methodparam>
     <methodparam><type>int</type><parameter>options</parameter></methodparam>
     <methodparam><type>string</type><parameter>opened_path</parameter></methodparam>
    </methodsynopsis>
    <para>
     Cette méthode est appelée immédiatement après la création de votre
     flux. <parameter>path</parameter> spécifie l'URL qui doit être
     passée à la fonction <function>fopen</function> et ce que cet
     objet est supposé y lire. Vous pouvez utiliser <function>parse_url</function>
     pour l'analyser.
    </para>
    <para>
     <parameter>mode</parameter> est le mode d'ouverture du fichier,
     comme expliqué dans <function>fopen</function>. Vous êtes responsable
     de la vérification de la validité du paramètre <parameter>mode</parameter>
     avec le chemin <parameter>path</parameter> fourni.
    </para>
    <para>
     <parameter>options</parameter> contient des options supplémentaires,
     utilisées par les API de flux. Il peut contenir une ou plusieurs
     des options suivantes, combinées par des OR.
     <informaltable>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>Option</entry>
         <entry>Description</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>STREAM_USE_PATH</entry>
         <entry>Si <parameter>path</parameter> est relatif, recherche
         la ressources en utilisant la configuration de l'include_path.
         </entry>
        </row>
        <row>
         <entry>STREAM_REPORT_ERRORS</entry>
         <entry>Si cette option est activée, vous êtes responsable 
         pour lever les erreurs avec <function>trigger_error</function> 
         durant l'ouverture du flux. Si cette option n'est pas 
         activée, vous ne devez lever aucune erreur.
         </entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
    </para>
    <para>
     Si le paramètre <parameter>path</parameter> est ouvert avec succès,
     et que STREAM_USE_PATH est activé dans le paramètre <parameter>options</parameter>,
     vous devez affecter à <parameter>opened_path</parameter> le chemin complet
     de la ressource ou du fichier que vous avez réellement ouvert.
    </para>
    <para>
     Si la ressource demandée a été ouverte, vous devez retourner
     &true;, ou sinon, vous devez retourner &false;
    </para>

    <methodsynopsis>
     <type>void</type><methodname>stream_close</methodname>
     <void/>
    </methodsynopsis>
    <para>
     Cette méthode est appelée lors que le flux est fermée, grâce à la
     fonction <function>fclose</function>.  Vous devez libérez
     toutes les ressources vérouillées ou réservées par le flux.
    </para>

    <methodsynopsis>
     <type>string</type><methodname>stream_read</methodname>
     <methodparam><type>int</type><parameter>count</parameter></methodparam>
    </methodsynopsis>
    <para>
     Cette méthode est appelée suite à l'utilisation des fonctions <function>fread</function>
     et <function>fgets</function>. Vous devez lire jusqu'à
     <parameter>count</parameter> octets de données à partir de
     la position courante d'écriture ou de lecture, sous la 
     forme de chaîne de caractères. S'il y a moins que
     <parameter>count</parameter> octets disponibles, vous
     devez en retourner autant que possible. Si aucune autre
     donnée n'est disponible, &false; sera retourné ou  
     une chaîne vide. Vous devez aussi tenir à jour la position 
     du pointeur d'écriture/lecture dans le flux, en ajoutant
     ou retranchant le nombre d'octets lus.
    </para>

    <methodsynopsis>
     <type>int</type><methodname>stream_write</methodname>
     <methodparam><type>string</type><parameter>data</parameter></methodparam>
    </methodsynopsis>
    <para>
     Cette méthode est appelée lorsque la fonction <function>fwrite</function>
     est utilisée. Vous devez stocker les données <parameter>data</parameter>
     dans le flux. S'il n'y a pas assez de place, essayez d'en
     stocker le maximum. Vous devriez aussi retourner le nombre d'octets que vous
     avez réussi à écrire, ou bien 0 si aucun n'a pu être stocké.
     Vous devez aussi tenir à jour la position 
     du pointeur d'écriture/lecture dans le flux, en ajoutant
     ou retranchant le nombre d'octets écrits.
    </para>
   
    <methodsynopsis>
     <type>bool</type><methodname>stream_eof</methodname>
     <void/>
    </methodsynopsis>
    <para>
     Cette méthode est appelée lorsque la fonction <function>feof</function>
     est utilisée. Vous devez retourner &true; si la position de lecture
     se situe à la fin du fichier et s'il n'y a plus de donnée
     disponible pour la lecture, ou bien &false; sinon.
    </para>

    <methodsynopsis>
     <type>int</type><methodname>stream_tell</methodname>
     <void/>
    </methodsynopsis>
    <para>
     Cette méthode est appelée lorsque la fonction <function>ftell</function>
     est utilisée. Vous devez retourner la position actuelle du pointeur
     de lecture / écriture dans le flux.
    </para>

    <methodsynopsis>
     <type>bool</type><methodname>stream_seek</methodname>
     <methodparam><type>int</type><parameter>offset</parameter></methodparam>
     <methodparam><type>int</type><parameter>whence</parameter></methodparam>
    </methodsynopsis>
    <para>
     Cette méthode est appelée lorsque la fonction <function>fseek</function>
     est utilisée. Vous devez modifier la position du pointeur de lecture/
     écriture en fonction des paramètres d'offset <parameter>offset</parameter>
     et de direction <parameter>whence</parameter>. Reportez-vous
     à la fonction <function>fseek</function> pour plus de détails sur ces
     paramètres. Retournez &true; si la position a été modifiée, et 
     &false; sinon.
    </para>

    <methodsynopsis>
     <type>bool</type><methodname>stream_flush</methodname>
     <void/>
    </methodsynopsis>
    <para>
     Cette méthode est appelée lorsque la fonction <function>fflush</function>
     est utilisée. Si vous avez mis des données dans un système de cache pour
     votre flux, mais qu'elles ne sont pas encore stockées de manière pérenne,
     c'est le moment de le faire. Retournez 
     &true; si les données cachées ont pu être stockées avec succès
     (il n'y a plus de donnée à stocker), ou bien &false; si les
     données n'ont pu être stockées.
    </para>

    <methodsynopsis>
     <type>array</type><methodname>stream_stat</methodname>
     <void/>
    </methodsynopsis>
    <para>
     Cette méthode est appelée en réponse à la fonction <function>fstat</function>
     sur un flux, et retourne un tableau, avec les valeurs appropriées pour le 
     flux.
    </para>

    <methodsynopsis>
     <type>bool</type><methodname>unlink</methodname>
     <methodparam><type>string</type><parameter>path</parameter></methodparam>
    </methodsynopsis>
    <para>
     Cette méthode est appelée en réponse à la fonction <function>unlink</function>
     avec une URL, et doit tenter de supprimer l'objet identifié par 
     <parameter>path</parameter>. La fonction doit retourner 
     &true; en cas de succès, et &false; en cas d'échec.
     Afin de retourner le bon message d'erreur, ne définissez pas
     cette méthode si votre gestionnaire ne le supporte pas.
    </para>
    <note>
     <simpara>
      La méthode enveloppe d'utilisateur <literal>unlink</literal> n'est pas supportée
      avant &php; 5.0.0.
     </simpara>
    </note>
         
    <methodsynopsis>
     <type>bool</type><methodname>rename</methodname>
     <methodparam><type>string</type><parameter>path_from</parameter></methodparam>
     <methodparam><type>string</type><parameter>path_to</parameter></methodparam>
    </methodsynopsis>
    <para>
     Cette méthode est appelée en réponse à la fonction <function>rename</function>
     avec une URL associée avec l'enveloppe et doit tenter de renommer
     l'objet identifié par <parameter>path_from</parameter> en 
     <parameter>path_to</parameter>. Celà doit retourner &true; en cas de succès ou
     &false; en cas d'erreur. 
     Afin de pouvoir retourner le message d'erreur approprié, ne définissez pas cette méthode
     si votre enveloppe ne supporte pas le renommage.
    </para>
    <note>
     <simpara>
      La méthode enveloppe d'utilisateur <literal>rename</literal> n'est pas supportée
      avant &php; 5.0.0.
     </simpara>
    </note>
         
    <methodsynopsis>
     <type>bool</type><methodname>mkdir</methodname>
     <methodparam><type>string</type><parameter>path</parameter></methodparam>
     <methodparam><type>int</type><parameter>mode</parameter></methodparam>
     <methodparam><type>int</type><parameter>options</parameter></methodparam>
    </methodsynopsis>
    <para>
     Cette méthode est appelée en réponse à la fonction <function>mkdir</function>
     avec une URL associée avec l'enveloppe et doit tenter de créer le répertoire
     spécifié par <parameter>path</parameter>.
     Celà doit retourner &ture; en cas de succès ou &false; en cas d'erreur.
     Afin de pouvoir retourner le message d'erreur approprié, ne définissez pas cette méthode
     si votre enveloppe ne supporte pas la création de répertoire.
     Les valeurs possibles pour le paramètre <parameter>options</parameter>
     sont <constant>STREAM_REPORT_ERRORS</constant> et 
     <constant>STREAM_MKDIR_RECURSIVE</constant>.
    </para>
    <note>
     <simpara>
      La méthode enveloppe d'utilisateur <literal>mkdir</literal> n'est pas supportée
      avant &php; 5.0.0.
     </simpara>
    </note>

    <methodsynopsis>
     <type>bool</type><methodname>rmdir</methodname>
     <methodparam><type>string</type><parameter>path</parameter></methodparam>
     <methodparam><type>int</type><parameter>options</parameter></methodparam>
    </methodsynopsis>
    <para>
     Cette méthode est appeléée en réponse à la fonction <function>rmdir</function>
     avec une URL associée avec l'enveloppe et doit tenter de supprimer
     le répertoire spécifié par <parameter>path</parameter>.
     Celà doit retourner &true; en cas de succès ou &false; en cas d'erreur.
     Afin de pouvoir retourner le message d'erreur approprié, ne définissez pas cette méthode
     si votre enveloppe ne supporte pas la suppression de répertoire.
     La valeur possible pour le paramètre <parameter>options</parameter>
     est <constant>STREAM_REPORT_ERRORS</constant>.
    </para>
    <note>
     <simpara>
      Userspace wrapper rmdir method is not supported prior to 
      <literal>PHP 5.0.0</literal>.
     </simpara>
    </note>

    <methodsynopsis>
     <type>bool</type><methodname>dir_opendir</methodname>
     <methodparam><type>string</type><parameter>path</parameter></methodparam>
     <methodparam><type>int</type><parameter>options</parameter></methodparam>
    </methodsynopsis>
    <para>
     Cette méthode est appelée immédiatement lorsque votre flux
     est créé, pour examiner le contenu d'un dossier avec 
     <function>opendir</function>. <parameter>path</parameter> spécifie
     l'URL qui est passée à <function>opendir</function> et que cet objet
     doit explorer. Vous pouvez utiliser <function>parse_url</function>
     pour la scinder en morceaux.
    </para>

    <methodsynopsis>
     <type>array</type><methodname>url_stat</methodname>
     <methodparam><type>string</type><parameter>path</parameter></methodparam>
     <methodparam><type>int</type><parameter>flags</parameter></methodparam>
    </methodsynopsis>
    <para>
     Cette méthode est appelée en réponse à la fonctio <function>stat</function>
     avec une URL associé avec l'enveloppe et doit retourner autant d'éléments en commun
     avec la fonction système que possible. Les valeurs non connues ou non disponibles doivent
     être définies en une valeur rationnelle (habituellement, &zero;).
    </para>
    <para>
     <parameter>flags</parameter> représente les options additionnelles définies
     par l'API. Il peut prendre une ou plusieurs des valeurs suivantes séparées par OR.
     <informaltable>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>Option</entry>
         <entry>Description</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>STREAM_URL_STAT_LINK</entry>
         <entry>
          Pour les ressources avec la possibilité de relier d'autres ressources (comme
          par exemple <literal>HTTP Location: forward</literal> ou un lien symbolique d'un
          système de fichier). Cette option spécifie que seul les informations à propo du lien
          lui-même peuvent être retournés, et non pas les ressources pointées par le lien.
          Cette option est définie en réponse à l'appel à la fonction <function>lstat</function>,
          <function>is_link</function>, ou <function>filetype</function>.
         </entry>
        </row>
        <row>
         <entry>STREAM_URL_STAT_QUIET</entry>
         <entry>
          Si cette option est définie, votre enveloppe ne devra contenir aucune erreur.
          Si cette option n'est pas définie, vous êtes responsable du traitement des erreurs
          en utilisant la fonction <function>trigger_error</function> pendant l'évaluation 
          du chemin.  
         </entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
    </para>
         
    <methodsynopsis>
     <type>string</type><methodname>dir_readdir</methodname>
     <void/>
    </methodsynopsis>
    <para>
     Cette méthode est appelée en réponse à la fonction <function>readdir</function>
     et doit retourner une chaîne représentant le prochain fichier ouvert
     par <function>dir_opendir</function>.
    </para>

    <methodsynopsis>
     <type>bool</type><methodname>dir_rewinddir</methodname>
     <void/>
    </methodsynopsis>
    <para>
     Cette méthode st appelée en réponse à <function>rewinddir</function>
     et doit remettre à zéro les résultats de <function>dir_readdir</function>.
     i.e. : le prochain appel à <function>dir_readdir</function> doit retourner
     la première ligne située dans le dossier ouvert par <function>dir_opendir</function>.
    </para>

    <methodsynopsis>
     <type>bool</type><methodname>dir_closedir</methodname>
     <void/>
    </methodsynopsis>
    <para>
     Cette méthode est appelée en réponse à <function>closedir</function>.
     Vous devez libérer toutes les ressources qui ont été réservées
     durant l'ouverture et l'utilisation du dossier.
    </para>

    <para>
     L'exemple ci-dessous implémente un gestionnaire de protocole pour
     le protocole var://, qui permet l'écriture et la lecture de variables
     globales en utilisant un flux de fichier standard, et les fonctions
     classiques telles que <function>fread</function>.
     Le protocole var:// implémenté ci-dessous, étant donné l'URL
     "var://foo" va écrire ou lire les données dans $GLOBALS["foo"].

     <example> 
      <title>Une classe de flux pour accéder aux variables globales</title>
      <programlisting role="php">
<![CDATA[
<?php

class VariableStream {
    var $position;
    var $varname;
   
    function stream_open($path, $mode, $options, &$opened_path)
    {
        $url = parse_url($path);
        $this->varname = $url["host"];
        $this->position = 0;
        
        return true;
    }

    function stream_read($count)
    {
        $ret = substr($GLOBALS[$this->varname], $this->position, $count);
        $this->position += strlen($ret);
        return $ret;
    }

    function stream_write($data)
    {
        $left = substr($GLOBALS[$this->varname], 0, $this->position);
        $right = substr($GLOBALS[$this->varname], $this->position + strlen($data));
        $GLOBALS[$this->varname] = $left . $data . $right;
        $this->position += strlen($data);
        return strlen($data);
    }

    function stream_tell()
    {
        return $this->position;
    }

    function stream_eof()
    {
        return $this->position >= strlen($GLOBALS[$this->varname]);
    }

    function stream_seek($offset, $whence)
    {
        switch($whence) {
            case SEEK_SET:
                if ($offset < strlen($GLOBALS[$this->varname]) && $offset >= 0) {
                     $this->position = $offset;
                     return true;
                } else {
                     return false;
                }
                break;
                
            case SEEK_CUR:
                if ($offset >= 0) {
                     $this->position += $offset;
                     return true;
                } else {
                     return false;
                }
                break;
                
            case SEEK_END:
                if (strlen($GLOBALS[$this->varname]) + $offset >= 0) {
                     $this->position = strlen($GLOBALS[$this->varname]) + $offset;
                     return true;
                } else {
                     return false;
                }
                break;
                
            default:
                return false;
        }
    }
}

stream_wrapper_register("var", "VariableStream")
    or die("Failed to register protocol");

$myvar = "";
    
$fp = fopen("var://myvar", "r+");

fwrite($fp, "line1\n");
fwrite($fp, "line2\n");
fwrite($fp, "line3\n");

rewind($fp);
while(!feof($fp)) {
    echo fgets($fp);
}
fclose($fp);
var_dump($myvar);

?>
]]>
      </programlisting>
     </example>
    </para>
    
   </refsect1>
  </refentry>


<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
