<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.19 $ -->
<!-- EN-Revision: 1.15 Maintainer: dams Status: ready -->
<!-- Reviewed: no -->

<!-- Purpose: basic.vartype -->
<!-- Membership: core -->

<reference xml:id="ref.classobj" xmlns="http://docbook.org/ns/docbook">
 <title>Classes et Objets</title>
 <titleabbrev>Classes et Objets</titleabbrev>
  <partintro>
    <section xml:id="classobj.intro">
     &reftitle.intro;
     <para>
      Ces fonctions vous donnent des informations sur les objets
      et les classes. Vous pouvez lire le nom de la classe qui
      est instanciée par un objet, ainsi que la liste des membres
      et des méthodes. En utilisant ces fonctions, vous pouvez
      non seulement connaître la classe d'un objet, mais aussi 
      tous ses ascendants (i.e. la classe qui est étendue par une
      autre classe).
     </para>
    </section>

   <section xml:id="classobj.requirements">
    &reftitle.required;
    &no.requirement;
   </section>

   <section xml:id="classobj.installation">
    &reftitle.install;
    &no.install;
   </section>

   <section xml:id="classobj.configuration">
    &reftitle.runtime;
    &no.config;
   </section>

   <section xml:id="classobj.resources">
    &reftitle.resources;
    &no.resource;
   </section>

   <section xml:id="classobj.constants">
    &reftitle.constants;
    &no.constants;
   </section>
  <section xml:id="classobj.examples">
     &reftitle.examples;
     <para>
   Dans cet exemple, on définit une classe de base, et une
   extension. La classe de base définit un légume, s'il est
   mangeable ou pas et sa couleur. La sous-classe
   <varname>epinard</varname> ajoute une méthode pour le cuisiner,
   et une autre pour savoir s'il est cuisiné.
     </para>
     <para>
      <example>
       <title>Fonctions d'objets : classes.inc</title>
       <programlisting role="php">
<![CDATA[
<?php

// classe de base, avec ses membres et ses méthodes
class Legume {

    var $edible;
    var $color;

    function Legume( $edible, $color="green" ) {
        $this->edible = $edible;
        $this->color = $color;
    }

    function is_edible() {
        return $this->edible;
    }

    function what_color() {
        return $this->color;
    }
    
} // fin de la classe Legume

// Extension la classe de base
class Epinard extends Legume {
    var $cuit = FALSE;
    function Epinard() {
        $this->Legume( TRUE, "green" );
    }
    function cuisine() {
        $this->cuit = TRUE;
    }

    function is_cooked() {
        return $this->cooked;
    }
    
} // fin de la classe Epinard

?>
]]>
       </programlisting>
      </example>
     </para>

  <para>
   Lorsqu'on instancie deux objets de ces classes et que l'on affiche
   leurs informations, on affiche aussi leur héritage. On définit ici
   des utilitaires qui servent essentiellement à afficher ces
   informations proprement.
  </para>
  <para>
   <example>
    <title>Fonctions d'objets : <filename>test_script.php</filename></title>
    <programlisting role="php">
<![CDATA[
<pre>
<?php

include "classes.inc";

// Fonctions utilitaires
function print_vars($obj) 
{
     foreach (get_object_vars($obj) as $prop => $val) {
          echo "\t$prop = $val\n";
     }
}

function print_methods($obj) 
{
    $arr = get_class_methods(get_class($obj));
    foreach ($arr as $method) {
        echo "\tfunction $method()\n";
    }
}

function class_parentage($obj, $class) {
    if (is_subclass_of($GLOBALS[$obj], $class)) {
        echo "L'objet $obj appartient à la classe ".get_class($$obj);
        echo " est une sous-classe de $class\n";
    } else {
        echo "L'objet $obj n'est pas une sous-classe de $class\n";
    }
}

// instantie 2 objets

$veggie = new Legume(true,"blue");
$leafy = new Epinard();

// affiche les informations sur ces objets
echo "légume : CLASS ".get_class($veggie)."\n";
echo "feuillues : CLASS ".get_class($leafy);
echo ", PARENT ".get_parent_class($leafy)."\n";

// affiche les propriétés du légume
echo "\nlégumes : Propriétés\n";
print_vars($veggie);

// et les méthodes des feuillus
echo "\nfeuillus : Méthodes\n";
print_methods($leafy);

  echo "\nParentée:\n";
class_parentage("leafy", "Epinard");
class_parentage("leafy", "Legume");
?>
</pre>
]]>
    </programlisting>
    <para>
     Il est important de noter que dans les exemples ci-dessus, 
     les objets <varname>$feuilles</varname> sont une instance de
     <classname>Epinard</classname> qui est une sous-classe de
     <classname>Legume</classname>, donc la dernière partie du script
     va afficher :
    </para>
    <screen>
<![CDATA[
[...]
    Parentée:
    L'objet feuilles n'est pas une sous classe epinard
    L'objet feuilles est une sous-classe de Legume
]]> 
    </screen>
   </example>
  </para>
 </section>
</partintro>
  
&reference.classobj.functions;

</reference>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->

