<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.16 $ -->
<!-- EN-Revision: 1.18 Maintainer: yannick Status: ready -->

  <refentry id="function.xslt-process">
   <refnamediv>
    <refname>xslt_process</refname>
    <refpurpose>
     Transforme des données <acronym>XML</acronym> avec <acronym>XSLT</acronym>
    </refpurpose>
   </refnamediv>
   <refsect1>
    &reftitle.description;
     <methodsynopsis>
      <type>mixed</type><methodname>xslt_process</methodname>
       <methodparam><type>resource</type><parameter>xh</parameter></methodparam>
       <methodparam><type>string</type><parameter>xmlcontainer</parameter></methodparam>
       <methodparam><type>string</type><parameter>xslcontainer</parameter></methodparam>
       <methodparam choice="opt"><type>string</type><parameter>resultcontainer</parameter></methodparam>
       <methodparam choice="opt"><type>array</type><parameter>arguments</parameter></methodparam>
       <methodparam choice="opt"><type>array</type><parameter>parameters</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>xslt_process</function> fait partie de la nouvelle vague de 
     fonctions <acronym>XSLT</acronym>. Elle vous permet de réaliser des 
     transformations <acronym>XSLT</acronym> en utilisant n'importe quelle
     type de source : des conteneurs. Cela se fait grâce à l'utilisation de
     buffers d'arguments : un concept issu de 
     <productname>Sablotron</productname> (actuellement, c'est le seul 
     processeur <acronym>XSLT</acronym> qui le supporte). Les conteneurs sont
     par défaut des fichiers qui contiennent le document à traiter. Le 
     conteneur de résultat est par défaut un fichier qui recevra le document 
     traité. Si le conteneur de résultat n'est pas fourni (l'argument vaut 
     alors &null;), le résultat sera retourné par la fonction.
    </para>
    <para>
     <warning>
      <simpara>
       Depuis &php; 4.0.6, cette fonction n'accepte plus de chaînes XML dans les
       paramètres <parameter>xmlcontainer</parameter> ou
       <parameter>xslcontainer</parameter>. Passer une chaîne contenant
       du XML dans un de ces paramètres engendra une erreur de segmentation
       dans les versions Sablotron supérieures ou égales à 0.95.
      </simpara>
     </warning>
    </para>
    <para>
     Les conteneurs peuvent aussi être modifiés via
     le tableau <parameter>arguments</parameter>.
    </para>
    <para>
     Le type le plus simple de transformation réalisable avec 
     <function>xslt_process</function> est la transformation d'un fichier
     <acronym>XML</acronym> avec un fichier <acronym>XSLT</acronym>, 
     en plaçant le résultat dans un troisième fichier.
     Faire cela avec Sablotron est très facile...
    </para>
    <example>
     <title>Utilisation de <function>xslt_process</function> pour transformer un fichier
     <acronym>XML</acronym> avec un fichier XSL en un autre fichier <acronym>XML</acronym></title>
     <programlisting role="php">
<![CDATA[
<?php

/* Allocation du processeur XSLT */
$xh = xslt_create();

/* Traitement du document */
if (xslt_process($xh, 'sample.xml', 'sample.xsl', 'result.xml')) {
    echo "Réussi. sample.xml a été transformé par sample.xsl en result.xml";
    echo ", result.xml contient ceci : \n<br />\n";
    echo "<pre>\n";
    readfile('result.xml');
    echo "</pre>\n";
} else {
    echo "Désolé, sample.xml n'a pu être transformé par sample.xsl en ";
    echo " result.xml. La raison est " . xslt_error($xh) . " et ";
    echo " le code d'erreur est " . xslt_errno($xh);
}

xslt_free($xh);

?>
]]>
     </programlisting>
    </example>
    <para>
     Même si cette fonctionnalité est très pratique, il arrive souvent qu'en environnement
     web, vous vouliez être capable d'afficher directement votre résultat. Par conséquent,
     si vous omettez le troisième argument de <function>xslt_process</function>, ou que
     vous fournissez la valeur &null; à la place, la fonction va automatiquement
     retourner le résultat de la transformation <acronym>XSLT</acronym>, au lieu de l'écrire dans un
     fichier.
    </para>
    <para>
     <example>
     <title>Utilisation de <function>xslt_process</function> pour transformer un fichier
     <acronym>XML</acronym> avec un fichier XSL et le placer dans une variable</title>
     <programlisting role="php">
<![CDATA[
<?php

/* Allocation d'un analyseur XSLT */
$xh = xslt_create();

/* Traitement du document */
$result = xslt_process($xh, 'sample.xml', 'sample.xsl');
if ($result) {
    echo "Réussi. sample.xml a été transformé par sample.xsl en result.xml";
    echo ", result.xml contient ceci : \n<br />\n";
    echo "<pre>\n";
    echo $result;
    echo "</pre>\n";
} else {
    echo "Désolé, sample.xml n'a pu être transformé par sample.xsl en ";
    echo " result.xml. La raison est " . xslt_error($xh) . " et ";
    echo " le code d'erreur est " . xslt_errno($xh);
}

xslt_free($xh);

?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Les deux cas de transformations <acronym>XSLT</acronym> ci-dessus sont 
     les cas les plus simples, quand on parle de transformation 
     <acronym>XSLT</acronym>, et ce sont les cas les plus courants, mais
     il existe des situations où vous obtenez vos données <acronym>XML</acronym> 
     et <acronym>XSLT</acronym> de sources externes comme des sockets ou 
     des bases de données. Dans ces cas, vous avez déjà les données dans une 
     variable, et en mode de production, écrire ces données dans des fichiers serait 
     trop inefficace. C'est là où la syntaxe de buffers d'arguments de <acronym>XSLT</acronym>
     prend la relève. Au lieu de fichier en terme d'arguments 
     <acronym>XML</acronym> et <acronym>XSLT</acronym>, vous pouvez
     passer des buffers d'arguments, qui sont alors substitués en valeur au
     cinquième argument de la fonction <function>xslt_process</function>. 
     L'exemple suivant vous montre comment traiter du 
     <acronym>XML</acronym> et du <acronym>XSLT</acronym> issus de variable,
     et de retrouver le résultat dans une troisième variable.
    </para>
    <para>
     <example>
     <title>Utilisation de <function>xslt_process</function> pour transformer une variable
     <acronym>XML</acronym> avec une autre variable XSL et placer le 
     résultat dans une variable</title>
     <programlisting role="php">
<![CDATA[
<?php
/* $xml et $xsl contiennent des données XML et XSL */

$arguments = array(
     '/_xml' => $xml,
     '/_xsl' => $xsl
);

/* Allocation d'un analyseur XSLT */
$xh = xslt_create();

/* Traitement du document */
$result = xslt_process($xh, 'arg:/_xml', 'arg:/_xsl', NULL, $arguments); 
if ($result) {
    echo "Réussi. sample.xml a été transformé par sample.xsl en result.xml";
    echo ", result.xml contient ceci : \n<br />\n";
    echo "<pre>\n";
    echo $result;
    echo "</pre>\n";
}
else {
    echo "Désolé, sample.xml n'a pu être transformé par sample.xsl en ";
    echo " result.xml. La raison est " . xslt_error($xh) . " et ";
    echo " le code d'erreur est " . xslt_errno($xh);
}
xslt_free($xh);
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Finalement, le dernier argument de <function>xslt_process</function>
     représente un tableau de tous les paramètres que vous souhaitez passer
     au document <acronym>XSLT</acronym>. Ces paramètres sont accessibles depuis le fichier
     XSL en utilisant l'instruction 
     <literal>&lt;xsl:param name=&quot;parameter_name&quot;&gt;</literal>.
     Les paramètres doivent être encodés au format UTF-8 
     et leur valeur sera interprétée comme une chaîne de 
     caractères par l'analyseur <productname>Sablotron</productname>. 
     En d'autres termes, vous ne pouvez pas passer des groupes de noeuds 
     (<literal>node-sets</literal>) comme paramètre au document <acronym>XSLT</acronym>.
    </para>
    <para>
     <example>
      <title>Passer des variables &php; à un fichier XSL</title>
      <programlisting role="php">
<![CDATA[
<?php

// XML string
$xml = '<?xml version="1.0"?>
<para>
 change me
</para>';

// XSL string
$xsl = '
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:output method="html" encoding="ISO-8859-1" indent="no" 
 omit-xml-declaration="yes"  media-type="text/html"/>
 <xsl:param name="myvar"/>
 <xsl:param name="mynode"/>
 <xsl:template match="/">
Ma variable PHP : <xsl:value-of select="$myvar"/><br />
Mon node set : <xsl:value-of select="$mynode"/>
 </xsl:template>
</xsl:stylesheet>';


$xh = xslt_create();

// le deuxième paramètre sera interprété comme une chaîne
$parameters = array (
  'myvar' => 'test',
  'mynode' => '<foo>bar</foo>'
);

$arguments = array (
  '/_xml' => $xml,
  '/_xsl' => $xsl
);

echo xslt_process($xh, 'arg:/_xml', 'arg:/_xsl', NULL, $arguments, $parameters);

?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Ma variable PHP : test<br />
Mon node set : &lt;foo&gt;bar&lt;/foo&gt;
]]>
      </screen>
     </example>
    </para>
    &note.xslt.windows;
   </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->