<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.24 $ -->
<!-- EN-Revision: 1.23 Maintainer: dams Status: ready -->
<!-- Reviewed: yes -->

<refentry xml:id="function.xslt-process" xmlns="http://docbook.org/ns/docbook">
 <refnamediv>
  <refname>xslt_process</refname>
  <refpurpose>Effectue une transformation <acronym>XSLT</acronym></refpurpose>
 </refnamediv>

 <refsect1 role="description">
  &reftitle.description;
  <methodsynopsis>
   <type>mixed</type><methodname>xslt_process</methodname>
   <methodparam><type>resource</type><parameter>xh</parameter></methodparam>
   <methodparam><type>string</type><parameter>xmlcontainer</parameter></methodparam>
   <methodparam><type>string</type><parameter>xslcontainer</parameter></methodparam>
   <methodparam choice="opt"><type>string</type><parameter>resultcontainer</parameter></methodparam>
   <methodparam choice="opt"><type>array</type><parameter>arguments</parameter></methodparam>
   <methodparam choice="opt"><type>array</type><parameter>parameters</parameter></methodparam>
  </methodsynopsis>
  <para>
   <function>xslt_process</function> fait partie de la nouvelle vague de
   fonctions <acronym>XSLT</acronym>. Elle vous permet de réaliser des
   transformations <acronym>XSLT</acronym> en utilisant n'importe quelle
   type de source : des conteneurs. Cela se fait grâce à l'utilisation de
   buffers d'arguments : un concept issu de
   <productname>Sablotron</productname> <acronym>XSLT</acronym> 
   (actuellement, c'est le seul processeur <acronym>XSLT</acronym> 
   qui le supporte). Les conteneurs sont, par défaut, des fichiers qui
   contiennent le document à traiter.
  </para>
 </refsect1>

 <refsect1 role="parameters">
  &reftitle.parameters;
  <para>
   <variablelist>
    <varlistentry>
     <term><parameter>xh</parameter></term>
     <listitem>
      <para>
       L'identifiant du processus <acronym>XSLT</acronym>, créé par la fonction
       <function>xslt_create</function>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>xmlcontainer</parameter></term>
     <listitem>
      <para>
       Chemin vers le fichier <acronym>XML</acronym> ou le marqueur pour
       l'argument <acronym>XML</acronym>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>xslcontainer</parameter></term>
     <listitem>
      <para>
       Chemin vers le fichier <acronym>XSL</acronym> ou 
       le marqueur pour l'argument <acronym>XML</acronym>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>resultcontainer</parameter></term>
     <listitem>
      <para>
       Le conteneur de résultat est, par défaut, un fichier qui recevra
       le document traité. Si le conteneur de résultat n'est pas fourni
       (l'argument vaut alors &null;), le résultat sera retourné par la
       fonction.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>arguments</parameter></term>
     <listitem>
      <para>
       Au lieu de fichiers comme arguments <acronym>XML</acronym> et
       <acronym>XSLT</acronym> à la fonction
       <function>xslt_process</function>, vous pouvez spécifier
       &quot;des marqueurs&quot; qui seront substitués par les valeurs
       données dans le tableau <parameter>arguments</parameter>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>parameters</parameter></term>
     <listitem>
      <para>
       Un tableau pour les paramètres de haut niveau, qui seront passés au
       document XSLT. Ces paramètres sont accessibles depuis le fichier
       XSL en utilisant l'instruction
       <literal>&lt;xsl:param name=&quot;parameter_name&quot;&gt;</literal>.
       Les paramètres doivent être encodés au format UTF-8
       et leur valeur sera interprétée comme une chaîne de
       caractères par l'analyseur <productname>Sablotron</productname>.
       En d'autres termes, vous ne pouvez pas passer des groupes de noeuds
       (<literal>node-sets</literal>) comme paramètres au document <acronym>XSLT</acronym>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
  <para>
   Les conteneurs peut également être définis via le tableau
   <parameter>arguments</parameter> (voir ci-dessous).
  </para>
 </refsect1>

 <refsect1 role="returnvalues">
  &reftitle.returnvalues;
  <para>
   &return.success; si le conteneur n'est pas spécifié - i.e.
   &null; - sinon, le résultat sera retourné.
  </para>
 </refsect1>

 <refsect1 role="changelog">
  &reftitle.changelog;
  <para>
   <informaltable>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>&Version;</entry>
       <entry>&Description;</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>4.0.6</entry>
       <entry>
        Cette fonction n'accepte plus de chaînes XML dans les
        paramètres <parameter>xmlcontainer</parameter> ou
        <parameter>xslcontainer</parameter>. Passer une chaîne contenant
        du XML dans un de ces paramètres engendrera une erreur de segmentation
        dans les versions Sablotron supérieures ou égales à 0.95.
       </entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>
  </para>
 </refsect1>

 <refsect1 role="examples">
  &reftitle.examples;
  <para>
   Le type le plus simple de transformation réalisable avec
   <function>xslt_process</function> est la transformation d'un fichier
   <acronym>XML</acronym> avec un fichier <acronym>XSLT</acronym>,
   en plaçant le résultat dans un troisième fichier <acronym>XML</acronym>.
   Faire cela avec <productname>Sablotron</productname> est très facile...
  </para>
  <example>
   <title>Utilisation de <function>xslt_process</function> pour transformer un fichier
   <acronym>XML</acronym> avec un fichier <acronym>XSL</acronym> en un autre fichier
   <acronym>XML</acronym></title>
   <programlisting role="php">
<![CDATA[
<?php

/* Allocation du processeur XSLT */
$xh = xslt_create();

/* Traitement du document */
if (xslt_process($xh, 'sample.xml', 'sample.xsl', 'result.xml')) {
    echo "Réussi. sample.xml a été transformé par sample.xsl en result.xml";
    echo ", result.xml contient ceci :\n<br />\n";
    echo "<pre>\n";
    readfile('result.xml');
    echo "</pre>\n";
} else {
    echo "Désolé, sample.xml n'a pu être transformé par sample.xsl en ";
    echo " result.xml. La raison est " . xslt_error($xh) . " et ";
    echo " le code d'erreur est " . xslt_errno($xh);
}

xslt_free($xh);

?>
]]>
   </programlisting>
  </example>
  <para>
   Même si cette fonctionnalité est très pratique, il arrive souvent qu'en environnement
   web, vous vouliez être capable d'afficher directement votre résultat. Par conséquent,
   si vous omettez le troisième argument de <function>xslt_process</function>, ou que
   vous fournissez la valeur &null; à la place, la fonction va automatiquement
   retourner le résultat de la transformation <acronym>XSLT</acronym>, au lieu de l'écrire
   dans un fichier.
  </para>
  <para>
   <example>
    <title>Utilisation de <function>xslt_process</function> pour transformer un fichier
    <acronym>XML</acronym> avec un fichier <acronym>XSL</acronym> et le placer dans une variable</title>
   <programlisting role="php">
<![CDATA[
<?php

/* Allocation d'un analyseur XSLT */
$xh = xslt_create();

/* Traitement du document */
$result = xslt_process($xh, 'sample.xml', 'sample.xsl');
if ($result) {
    echo "Réussi. sample.xml a été transformé par sample.xsl en result.xml";
    echo ", result.xml contient ceci : \n<br />\n";
    echo "<pre>\n";
    echo $result;
    echo "</pre>\n";
} else {
    echo "Désolé, sample.xml n'a pu être transformé par sample.xsl en ";
    echo " result.xml. La raison est " . xslt_error($xh) . " et ";
    echo " le code d'erreur est " . xslt_errno($xh);
}

xslt_free($xh);

?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Les deux cas de transformations <acronym>XSLT</acronym> ci-dessus sont
   les cas les plus simples, quand on parle de transformation
   <acronym>XSLT</acronym>, et ce sont les cas les plus courants, mais
   il existe des situations où vous obtenez vos données <acronym>XML</acronym>
   et <acronym>XSLT</acronym> de sources externes comme des sockets ou
   des bases de données. Dans ces cas, vous avez déjà les données dans une
   variable et, en mode de production, écrire ces données dans des fichiers serait
   trop inefficace. C'est là où la syntaxe de buffers d'arguments de <acronym>XSLT</acronym>
   prend la relève. Au lieu de fichiers en termes d'arguments
   <acronym>XML</acronym> et <acronym>XSLT</acronym>, vous pouvez
   passer des buffers d'arguments, qui sont alors substitués en valeur au
   cinquième argument de la fonction <function>xslt_process</function>.
   L'exemple suivant vous montre comment traiter du
   <acronym>XML</acronym> et du <acronym>XSLT</acronym> issus de variables,
   et de retrouver le résultat dans une troisième variable.
  </para>
  <para>
   <example>
    <title>Utilisation de <function>xslt_process</function> pour 
    transformer une variable <acronym>XML</acronym> avec une autre
    variable <acronym>XSL</acronym> et placer le résultat dans une variable</title>
   <programlisting role="php">
<![CDATA[
<?php
/* $xml et $xsl contiennent des données XML et XSL */

$arguments = array(
     '/_xml' => $xml,
     '/_xsl' => $xsl
);

/* Allocation d'un analyseur XSLT */
$xh = xslt_create();

/* Traitement du document */
$result = xslt_process($xh, 'arg:/_xml', 'arg:/_xsl', NULL, $arguments);
if ($result) {
    echo "Réussi. sample.xml a été transformé par sample.xsl en result.xml";
    echo ", result.xml contient ceci : \n<br />\n";
    echo "<pre>\n";
    echo $result;
    echo "</pre>\n";
}
else {
    echo "Désolé, sample.xml n'a pu être transformé par sample.xsl en ";
    echo " result.xml. La raison est " . xslt_error($xh) . " et ";
    echo " le code d'erreur est " . xslt_errno($xh);
}
xslt_free($xh);
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Passer des variables PHP à un fichier <acronym>XSL</acronym></title>
    <programlisting role="php">
<![CDATA[
<?php

// Chaîne XML
$xml = '<?xml version="1.0"?>
<para>
 change me
</para>';

// Chaîne XSL
$xsl = '
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:output method="html" encoding="ISO-8859-1" indent="no"
 omit-xml-declaration="yes"  media-type="text/html"/>
 <xsl:param name="myvar"/>
 <xsl:param name="mynode"/>
 <xsl:template match="/">
Ma variable PHP : <xsl:value-of select="$myvar"/><br />
Mon node set : <xsl:value-of select="$mynode"/>
 </xsl:template>
</xsl:stylesheet>';


$xh = xslt_create();

// le deuxième paramètre sera interprété comme une chaîne
$parameters = array (
  'myvar' => 'test',
  'mynode' => '<foo>bar</foo>'
);

$arguments = array (
  '/_xml' => $xml,
  '/_xsl' => $xsl
);

echo xslt_process($xh, 'arg:/_xml', 'arg:/_xsl', NULL, $arguments, $parameters);

?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Ma variable PHP : test<br>
Mon node set : &lt;foo&gt;bar&lt;/foo&gt;
]]>
    </screen>
   </example>
  </para>
 </refsect1>

 <refsect1 role="notes">
  &reftitle.notes;
  &note.xslt.windows;
 </refsect1>

</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->