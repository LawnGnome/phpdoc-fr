<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.14 $ -->
<!-- EN-Revision: 1.14 Maintainer: didou Status: partial -->
<!-- Purpose: remote.other -->
<!-- Membership: pecl, external -->
<!-- State: experimental -->
<!-- Reviewed: yes -->

 <reference xml:id="ref.java" xmlns="http://docbook.org/ns/docbook">
  <title>Intégration de Java avec &php;</title>
  <titleabbrev></titleabbrev>
  <partintro>
   <section xml:id="java.intro">
    &reftitle.intro;
    <para>
     Il y a deux moyens de connecter &php; et Java : soit en intégrant
     &php; dans un <link linkend="java.servlet">environnement de Servlet
     Java</link>, ce qui est la solution la plus stable et
     la plus efficace, soit en intégrant Java directement dans &php;.
     La première solution est fournie par le module SAPI qui s'interface avec
     un serveur de Servlet, la dernière par cette extension.
    </para>
    <para>
     L'extension Java fournit un moyen simple et efficace pour créer et
     invoquer des méthodes d'un objet Java depuis &php;. La JVM est créée
     avec JNI, et tout fonctionne en intra-processus.
    </para>
    &warn.experimental;
   </section>

   <section xml:id="java.requirements">
    &reftitle.required;
    <para>
     Vous avez besoin d'une Machine virtuelle Java installée sur votre
     machine pour utiliser cette extension.
    </para>
   </section>

   &reference.java.configure;

   &reference.java.ini;

   <section xml:id="java.resources">
    &reftitle.resources;
    &no.resource;
   </section>

   <section xml:id="java.constants">
    &reftitle.constants;
    &no.constants;
   </section>

   <section xml:id="java.examples">
    &reftitle.examples;
    <para>
     <example>
     <title>Exemple avec Java</title>
      <programlisting role="php">
<![CDATA[
<?php
// créer une instance de la classe Java java.lang.System dans PHP
$system = new Java('java.lang.System');

// accède aux propriétés
echo 'Java version=' . $system->getProperty('java.version') . ' <br />';
echo 'Java vendor=' . $system->getProperty('java.vendor') . '<br />';
echo 'OS=' . $system->getProperty('os.name') . ' ' .
             $system->getProperty('os.version') . ' on ' .
             $system->getProperty('os.arch') . '<br />';

// Exemple avec java.util.Date
$formater = new Java('java.text.SimpleDateFormat',
                      "EEEE, MMMM dd, yyyy 'at' h:mm:ss a zzzz");

echo $formater->format(new Java('java.util.Date'));
?>
]]>
      </programlisting>
     </example>
     <example>
     <title>Exemple AWT</title>
      <programlisting role="php">
<![CDATA[
<?php
// Cet exemple ne fonctionne qu'en mode CGI.

$frame  = new Java('java.awt.Frame', 'PHP');
$button = new Java('java.awt.Button', 'Hello Java World!');

$frame->add('North', $button);
$frame->validate();
$frame->pack();
$frame->visible = True;

$thread = new Java('java.lang.Thread');
$thread->sleep(10000);

$frame->dispose();
?>
]]>
      </programlisting>
     </example>

    Notes :

    <itemizedlist>
     <listitem>
      <simpara>
       <literal>new Java()</literal> crée une nouvelle instance d'une classe,
       si un constructeur valable est disponible. Si aucun paramètre n'est passé,
       et le constructeur par défaut est utile pour accéder à ces classes
       telles que "java.lang.System", qui fournissent leur fonctionnalités via
       des méthodes statiques.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Lors de l'accès aux membres d'une instance, &php; commencera par rechercher
       les membres Bean, puis les champs publics. En d'autres termes,
       "<literal>print $date.time</literal>" sera d'abord résolu par
       "<literal>$date.getTime()</literal>", puis par "<literal>$date.time</literal>";
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Les membres statiques et d'instance sont accessibles avec la même
       syntaxe. De plus, si un objet est de type "<literal>java.lang.Class</literal>",
       les membres statiques de la classe (champs et méthodes) sont accessibles.
      </simpara>
     </listitem>
     <listitem>
      <para>
       Les exceptions sont transformées en alertes &php;, et résultat NULL.
       Les alertes peuvent être supprimées en préfixant l'appel
       par l'opérateur <literal>&#62;</literal>. Les fonctions suivantes 
       peuvent être utilisées pour lire et effacer la dernière
       erreur remontée :
       <itemizedlist>
        <listitem><simpara><function>java_last_exception_get</function></simpara></listitem>
        <listitem><simpara><function>java_last_exception_clear</function></simpara></listitem>
       </itemizedlist>
      </para>
     </listitem>
     <listitem>
      <simpara>
       Les surcharges de fonctions sont des problèmes épineux,
       étant données les différences de type de valeurs entre les deux
/bin/bash: q: command not found
       mais efficace pour déterminer la meilleur fonction à utiliser.
      </simpara>
      <simpara>
       De plus, les noms de méthodes ne sont pas sensibles à la casse en
       &php;, ce qui augmente le nombre de conflits potentiels.
      </simpara>
      <simpara>
       Une fois qu'une méthode est sélectionnée, les paramètres sont
       transtypés, avec une perte d'information potentielle non négligeable
       (par exemple, les nombres à virgules flottante en double précisions
       seront convertis en booléen).
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Traditionnellement en &php;, les tableaux et les tables de hashage peuvent
       être interchangées, et fonctionnent de la même façon.
       Notez que les tables de hashage de &php; ne peuvent être indexées
       qu'avec des entiers ou des chaînes, et que le type primitif de 
       tableau de Java ne peut comporter de trous dans les index. Notez aussi
       que les valeurs sont passées par
       valeur, ce qui peut être coûteux en mémoire et en temps.
      </simpara>
     </listitem>
    </itemizedlist>
   </para>

   </section>
   
   <section xml:id="java.servlet">
    <title>Java Servlet SAPI</title>
    <para>
    L'interface &php; 4 sapi/servlet est construite sur un mécanisme défini
    par l'extension Java, qui permet à &php; d'être exécuté
    comme une servlet. L'avantage immédiat d'un point de vue &php; est que les
    serveurs web qui supportent les servlets gèrent rigoureusement les 
    machines virtuelles. Les instructions d'installation du module Servlet SAPI
    sont disponibles dans le fichier <filename>php4/sapi/README</filename>.

     Notes :

     <itemizedlist>
      <listitem>
       <simpara>
       Bien que ce code soit prévu pour fonctionner sur n'importe quel
       serveur à Servlet, il n'a été testé qu'avec le module Apache
       Jakarta/tomcat (jusqu'à aujourd'hui). Les remontées de bogues, les
       réussites et les patches nécessaires pour faire fonctionner ce code
       sur d'autres serveurs sont fortement encouragés !
       </simpara>
      </listitem>
      <listitem>
       <simpara>
       &php; a l'habitude de changer le dossier de travail. Le serveur SAPI/Servlet
       le changera à nouveau, mais tant que &php; fonctionnera, le moteur de servlet
       ne pourra pas charger de classes dans le CLASSPATH, si le dossier est
       spécifié avec un chemin relatif, ou ne pourra pas trouver le dossier
       d'administration et de compilation des tâches JSP.
       </simpara>
      </listitem>
     </itemizedlist>
    </para>
   </section>
  </partintro>

&reference.java.functions;   
  
 </reference>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->

