<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.10 $ -->
<!-- EN-Revision: 1.15 Maintainer: yannick Status: ready -->
 <reference id="ref.objaggregation">
  <title>Aggregation d'objets/Composition de fonctions</title>
  <titleabbrev>Aggregation d'objets</titleabbrev>

  <partintro>
    &warn.experimental;
    <section id="objaggregation.intro">
     &reftitle.intro;
     <para>
      En programmation objet, il est courant de rencontrer la combinaison
      de classes simples (et de leurs instances) en une classe plus complexe.
      C'est une strategie habile pour mettre en place des objets complexes,
      et des hierarchies d'objets. Ce système peut fonctionner comme une
      alternative dynamique à l'héritage multiple. Il y a deux solutions
      pour combiner deux classes, suivant la relation de leurs éléments
      constitutifs : L'<emphasis>Association</emphasis> et 
      l'<emphasis>Aggregation</emphasis>.
     </para>
     <para>
      Une <emphasis>Association</emphasis> est une combinaison d'éléments construits
      indépendamment et visibles à l'extérieur. Lorsque nous associons des classes ou
      objets, chacun garde une référence à l'autre partie de l'association. Lorsque
      nous associons des classes statiquement, une classe contient une référence
      à une instance de l'autre classe. Par exemple : 
      <example>
       <title>Association de classes</title>
       <programlisting role="php">
<![CDATA[
<?php
class DateTime {
   
   function DateTime() {
       // constructeur vide
   }

   function now() {
       return date("Y-m-d H:i:s");
   }
}

class Report {
   var $_dt = new DateTime();
   // autres propriétés ...

   function Report() {
       // initialisation du code ...
   }

   function generateReport() {
       $dateTime = $_dt->now();
       // autre code
   }

   // autres méthodes ...
}

$rep = new Report();
?>
]]>
       </programlisting>
      </example>
      Nous pouvons aussi associer des instances dynamiquement, en passant une référence au
      constructeur (ou par une autre méthode), ce qui permet de gérer dynamiquement 
      l'association entre les objets. Nous allons modifier l'exemple ci-dessus pour
      illustrer ce point : 
      <example>
       <title>Association d'objets</title>
       <programlisting role="php">
<![CDATA[
<?php
class DateTime {
   // identique au précédent exemple
}

class DateTimePlus {
   var $_format;
   
   function DateTimePlus($format="Y-m-d H:i:s") {
       $this->_format = $format;
   }

   function now() {
       return date($this->_format);
   }
}

class Report {
   var $_dt;    // Nous allons garder la référence à DateTime ici
   // autre propriété
  
   function Report() {
       // initialisation
   }

   function setDateTime(&$dt) {
       $this->_dt =& $dt;
   }

   function generateReport() {
       $dateTime = $this->_dt->now();
       // autre code ...
   }

   // autres méthodes ...
}

$rep = new Report();
$dt = new DateTime();
$dtp = new DateTimePlus("l, F j, Y (h:i:s a, T)");

// Génératino du rapport avec une simple date
$rep->setDateTime(&$dt);
echo $rep->generateReport();

// plus loin dans le code

// generation du rapport avec une date designée
$rep->setDateTime(&$dtp);
$output = $rep->generateReport();
// sauvegarde pour affichage dans la base 
// ... etc ... 
?>
]]>
       </programlisting>
      </example>
     </para>
     <para>
      L'<emphasis>Aggregation</emphasis>, d'un autre coté, implique
      l'encapsulation et le masquage des parties de la combinaison. Nous
      pouvons aggréger des classes en utilisant une méthode statique, grâce
      aux sous-classes (mais &php; ne supporte pas bien les sous classes), et
      dans ce cas, la définition de la classe aggrégée n'est pas accessible,
      sauf via les méthodes de la classe contenant. L'aggregation d'instances
      (aggrégation d'objets) implique la création dynamique de sous-objets
      à l'intérieur d'un autre objet, et dans le même temps, l'extension des
      capacités de l'objet principal (en terme de méthodes accessibles).
     </para>
     <para>
      L'aggrégation d'object est une méthode naturelle pour représenter des
      relations de type tout-partie (par exemple, une molécule est une aggrégation
      d'atomes), ou bien peut être utilisée pour obtenir un effet équivalent
      à l'héritage multiple, sans avoir à lier plusieurs classes et leurs
      interfaces. En fait, les aggrégations d'objets sont plus souples,
      car nous pouvons alors sélectionner les méthodes et les propriétés qui
      sont transmises à l'objet aggrégé.
     </para>
    </section>
    <section id="objaggregation.examples">
     &reftitle.examples;
     <para>
      Nous définissons trois classes, qui implémentent chacune une méthode de stockage
      différente : 
     </para>
     <para>
      <example>
       <title>storage_classes.inc</title>
       <programlisting role="php">
<![CDATA[
<?php
class FileStorage {
    var $data;

    function FileStorage($data) {
        $this->data = $data;
    }
    function write($name) {
        $fp = fopen(name, "w");
        fwrite($fp, $this->data);
        fclose($data);
    }
}

class WDDXStorage {
    var $data;
    var $version = "1.0";
    var $_id; // variable "privée" 

    function WDDXStorage($data) {
        $this->data = $data;
        $this->_id = $this->_genID();
    }

    function store() {
        if ($this->_id) {
            $pid = wddx_packet_start($this->_id);
            wddx_add_vars($pid, "this->data");
            $packet = wddx_packet_end($pid);
        } else {
            $packet = wddx_serialize_value($this->data);
        }
        $dbh = dba_open("varstore", "w", "gdbm");
        dba_insert(md5(uniqid("",true)), $packet, $dbh);
        dba_close($dbh);
    }

    // méthode privée
    function _genID() {
        return md5(uniqid(rand(),true));
    }
}

class DBStorage {
    var $data;
    var $dbtype = "mysql";

    function DBStorage($data) {
        $this->data = $data;
    }

    function save() {
        $dbh = mysql_connect();
        mysql_select_db("storage", $dbh);
        $serdata = serialize($this->data);
        mysql_query("insert into vars ('$serdata',now())", $dbh);
        mysql_close($dbh);
    }
}

?>
]]>
       </programlisting>
      </example>
     </para>
     <para>
     Puis, nous instantion quelques objets issue de ces classes, et nous
     réalisons des aggrégations et désaggrégations, tout en affichant
     quelques résultats : 
     </para>
     <para>
      <example>
       <title>test_aggregation.php</title>
       <programlisting role="php">
<![CDATA[
<?php
include "storageclasses.inc";

// quelques utilitaires

function p_arr($arr) {
    foreach($arr as $k=>$v)
        $out[] = "\t$k => $v";
    return implode("\n", $out);
}

function object_info($obj) {
    $out[] = "Classe : ".get_class($obj);
    foreach(get_object_vars($obj) as $var=>$val)
        if (is_array($val))
            $out[] = "propriété : $var (array)\n".p_arr($val);
        else
            $out[] = "propriété : $var = $val";
    foreach(get_class_methods($obj) as $method)
        $out[] = "méthode : $method";
    return implode("\n", $out);
}


$data = array(M_PI, "kludge != cruft");

// créons quelques objets simples
$fs = new FileStorage($data);
$ws = new WDDXStorage($data);

// affichons des informations sur ces objets
echo "\$fs object\n";
echo object_info($fs)."\n";
echo "\n\$ws object\n";
echo object_info($ws)."\n";

// maintenant, quelques aggrégations

echo "\nAggrégeons \$fs avec la classe WDDXStorage\n";
aggregate($fs, "WDDXStorage");
echo "L'objet \$fs \n";
echo object_info($fs)."\n";

echo "\nAggrégeons le résultat avec la classe DBStorage \n";
aggregate($fs, "DBStorage");
echo "L'objet \$fs \n";
echo object_info($fs)."\n";

echo "\nEt finalement, désaggrégeons WDDXStorage\n";
deaggregate($fs, "WDDXStorage");
echo "L'objet \$fs \n";
echo object_info($fs)."\n";

?>
]]>
       </programlisting>
      </example>
     </para>
     <para>
      Etudions maintenant le résultat du script pour comprendre les effets
      secondaires et les limitations des aggrégations d'objets en &php;.
      D'abord, nous avons créé <varname>$fs</varname> et <varname>$ws</varname>
      et ils fournissent le bon résultat (suivant la définition de leur classe).
      Notez que dans le but de l'aggrégation d'objets, 
      <emphasis>les éléments privés d'une classe ou 
      d'un objet doivent commencer par un souligné ("_")</emphasis>, 
      même s'il n'y a pas de distinction réelle entre un objet 
      privé et un objet public.
     </para>
     <para>
      <example>
       <title>Agregation d'objets</title>
       <programlisting>
<![CDATA[
L'objet $fs
Classe : filestorage
propriété : data (array)
     0 => 3.1415926535898
     1 => kludge != cruft
méthode : filestorage
méthode : write

L'objet $ws
Classe : wddxstorage
propriété : data (array)
     0 => 3.1415926535898
     1 => kludge != cruft
propriété : version = 1.0
propriété : _id = ID::9bb2b640764d4370eb04808af8b076a5
méthode : wddxstorage
méthode : store
méthode : _genid
]]>
       </programlisting>
      </example>
     </para>
     <para>
      Nous aggrégeons alors <varname>$fs</varname> avec la classe
      <classname>WDDXStorage</classname>, et nous affichons les informations.
      Nous pouvons aussi voir que même si l'objet <varname>$fs</varname> 
      est toujours du type <classname>FileStorage</classname>, il a maintenant
      la propriété <varname>$version</varname>, et la méthode 
      <function>store</function>, qui sont définies dans 
      <classname>WDDXStorage</classname>. Une chose importante à noter est 
      que les éléments privés n'ont pas été 
      agrégés, même s'ils sont présents dans l'objet 
      <varname>$ws</varname>. Un autre absent est le constructeur de 
      <classname>WDDXStorage</classname>, qu'il n'est pas logique d'aggréger.
     </para>
     <para>
      <example>
       <title>Résultat d'agrégation</title>
       <programlisting>
<![CDATA[
Aggrégeons \$fs avec la classe WDDXStorage
L'objet $fs
Classe : filestorage
propriété : data (array)
     0 => 3.1415926535898
     1 => kludge != cruft
propriété : version = 1.0
méthode : filestorage
méthode : write
méthode : store
]]>
       </programlisting>
      </example>
     </para>
     <para>
      Le processus d'aggrégation est cumulatif, ce qui fait que
      lorsque nous aggrégeons <varname>$fs</varname> avec la classe 
      <classname>DBStorage</classname>, nous générons un objet qui
      peut utiliser n'importe laquelle des méthodes de stockage de
      ces classes.
     </para>
     <para>
      <example>
       <title>Accumuliation dans une agrégation</title>
       <programlisting>
<![CDATA[
Aggrégeons le résultat avec la classe DBStorage
L'objet $fs 
Classe : filestorage
propriété : data (array)
     0 => 3.1415926535898
     1 => kludge != cruft
propriété : version = 1.0
propriété : dbtype = mysql
méthode : filestorage
méthode : write
méthode : store
méthode : save
]]>
       </programlisting>
      </example>
     </para>
     <para>
      Finalement, de la même façon que nous avons aggrégés 
      les méthodes et propriétés dynamiquement, nous pouvons aussi
      les désaggrégéer. Si vous désaggrégeons 
      la classe <classname>WDDXStorage</classname> de l'objet <varname>$fs</varname>, 
      nous allons obtenir : 
     </para>
     <para>
      <example>
       <title>Désagrégation d'objets</title>
       <programlisting>
<![CDATA[
Et finalement, désaggrégeons WDDXStorage
L'objet $fs
Classe : filestorage
propriété : data (array)
     0 => 3.1415926535898
     1 => kludge != cruft
propriété : dbtype = mysql
méthode : filestorage
méthode : write
méthode : save
]]>
       </programlisting>
      </example>
     </para>
     <para>
      Un point que nous n'avons pas mentionné ci-dessus et que l'aggrégation ne va
      pas écraser les méthodes ou propriétés déjà existantes dans l'objet principal.
      Par exemple, la classe <classname>FileStorage</classname> définit une
      propriété <varname>$data</varname>, et la classe
      <classname>WDDXStorage</classname> aussi. Mais cette dernière ne sera pas
      impliquée dans l'aggrégation.
     </para>
    </section>
  </partintro>

  &reference.objaggregation.functions;
 </reference>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->

