<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.10 $ -->
<!-- EN-Revision: 1.15 Maintainer: yannick Status: ready -->
  <refentry id="function.fsockopen">
   <refnamediv>
    <refname>fsockopen</refname>
    <refpurpose>Ouvre une socket de connexion Internet ou Unix</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>resource</type><methodname>fsockopen</methodname>
      <methodparam><type>string</type><parameter>target</parameter></methodparam>
      <methodparam><type>int</type><parameter>port</parameter></methodparam>
      <methodparam choice="opt"><type>int</type><parameter>errno</parameter></methodparam>
      <methodparam choice="opt"><type>string</type><parameter>errstr</parameter></methodparam>
      <methodparam choice="opt"><type>float</type><parameter>timeout</parameter></methodparam>
     </methodsynopsis>
     
    <para>
     Initalise une connexion par socket à la ressource spécifié par 
     <parameter>target</parameter>. &php; supporte les cibles
     dans les domaines Internet et Unix comme décrit dans 
     <xref linkend="transports"/>. Une liste des types de transports peut également
     être trouvée en utilisant la fonction <function>stream_get_transports</function>.
    </para>
    <note>
     <simpara>
      Si vous avez besoin de définir un délai limite pour lire/écrire des données
      à travers cette socket, utilisez la fonction <function>stream_set_timeout</function>,
      comme le paramètre <parameter>timeout</parameter> de la fonction
      <function>fsockopen</function> uniquement appliqué lors de la connexion de la
      socket.
     </simpara>
    </note>
    <para>
     Depuis &php; 4.3.0, si vous avez compilé le support OpenSSL, vous
     pouvez préfixé le paramètre <parameter>hostname</parameter> avec soit
     '<literal>ssl://</literal>' soit '<literal>tls://</literal>' pour utiliser
     une connexion SSL ou TLS avec le client à travers TCP/IP
     pour connecter l'hôte distant.
    </para>
    <para>
     <function>fsockopen</function> retourne un pointeur de fichier qui peut
     être utilisé avec d'autres fonctions fichiers, telles que
     <function>fgets</function>, <function>fgetss</function>,
     <function>fputs</function>, <function>fclose</function> et
     <function>feof</function>.
    </para>
    <para>
      Si l'appel échoue, <function>fsockopen</function> retourne &false;,
      et si les options <parameter>errno</parameter> et <parameter>errstr</parameter>
      ont été fournies, elles contiennent désormais les
      raisons de l'échec. Si l'erreur retournée est 0 et que la
      fonction retourne &false;, c'est une indication d'erreur. C'est probablement
      du à une erreur d'initialisation de la socket. Notez que
      <parameter>errno</parameter> et <parameter>errstr</parameter> sont
      toujours passées par référence.
    </para>
    <para>
     Suivant les environnements, le type 'domaine Unix' ou l'option
     <parameter>timeout</parameter> ne sont pas toujours disponibles.
    </para>
    <para>
     La socket sera ouverte par défaut en mode bloquant. Vous pouvez
     changer de mode en utilisant : <function>stream_set_blocking</function>.
     <example>
      <title>Exemple avec <function>fsockopen</function></title>
      <programlisting role="php">
<![CDATA[
<?php
$fp = fsockopen("www.example.com", 80, $errno, $errstr, 30);
if (!$fp) {
    echo "$errstr ($errno)<br />\n";
} else {
    $out = "GET / HTTP/1.1\r\n";
    $out .= "Host: www.example.com\r\n";
    $out .= "Connection: Close\r\n\r\n";

    fwrite($fp, $out);
    while (!feof($fp)) {
        echo fgets($fp, 128);
    }
    fclose($fp);
}
?>
]]>
      </programlisting>
     </example>
     L'exemple ci-dessous décrit comment lire la date et l'heure grâce à
     un service UDP "daytime" (port 13), sur votre propre machine.
     <example>
     <title>Utilisation d'une connexion UDP</title>
     <programlisting role="php">
<![CDATA[
<?php
$fp = fsockopen("udp://127.0.0.1", 13, $errno, $errstr);
if (!$fp) {
    echo "ERREUR: $errno - $errstr<br />\n";
} else {
    fwrite($fp, "\n");
    echo fread($fp, 26);
    fclose($fp);
}
?>
]]>
     </programlisting>
     </example>
     <warning>
      <simpara>
       Les sockets UDP semblent quelques fois avoir été ouvertes sans erreur,
       même si l'hôte distant n'est pas joignable. L'erreur n'apparait alors
       uniquement lorsque vous tentez de lire/écrire sur la socket.
       La raison de celà est qu'UDP est un protocole "connectionless",
       ce qui signifie que le système ne tentera pas d'établir un lien pour la socket
       tant qu'il ne doit pas recevoir/envoyer de données.
      </simpara>
     </warning>
     &ipv6.brackets;
     <note>
      <para>Le paramètre <parameter>timeout</parameter>
      a été introduit en &php; 3.0.9 et le support UDP en &php; 4.
      </para>
     </note>
     Voir aussi
     <function>pfsockopen</function>,
     <function>socket_set_blocking</function>,
     <function>socket_set_timeout</function>,
     <function>fgets</function>,
     <function>fgetss</function>,
     <function>fwrite</function>,
     <function>fclose</function>,
     <function>feof</function> et
     l'extension <link linkend="ref.curl">Curl</link>.
    </para>
   </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
