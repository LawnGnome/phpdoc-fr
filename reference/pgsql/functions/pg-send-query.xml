<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.5 $ -->
<!-- splitted from ./en/functions/pgsql.xml, last change in rev 1.2 -->
  <refentry id="function.pg-send-query">
   <refnamediv>
    <refname>pg_send_query</refname>
    <refpurpose>Exécute une requête PostGreSQL asynchrone</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>bool</type><methodname>pg_send_query</methodname>
      <methodparam><type>resource</type><parameter>connection</parameter></methodparam>
      <methodparam><type>string</type><parameter>query</parameter></methodparam>
     </methodsynopsis>
     <methodsynopsis>
      <type>bool</type><methodname>pg_send_query</methodname>
      <methodparam><type>string</type><parameter>query</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>pg_send_query</function> exécute la requête <parameter>query</parameter>
     sur la connexion <parameter>connection</parameter>, de manière asynchrone.
     Contrairement à <function>pg_query</function>, cette fonction permet d'envoyer
     plusieurs requêtes à un serveur PostgreSQL et de lire les résultats un par
     un, avec la fonction <function>pg_get_result</function>. L'exécution du script n'est
     pas bloquée durant l'exécution de la requête. Utilisez 
     <function>pg_connection_busy</function> pour vérifier si la connexion est
     encore occupée. Les requêtes peuvent être annulées avec 
     <function>pg_cancel_query</function>.
    </para>
    <para>
     Bien que l'on puiss envoyer plusieurs requêtes en même temps,
     il n'est pas possible d'envoyer plusieurs requêtes sur une connexion
     occupée. Si une requête est envoyée alors que la connexion est occupée,
     elle attendra que la requête précédente soit finie.
    </para>
    <para>
     <example>
      <title>Exécute une requête PostGreSQL asynchrone</title>
      <programlisting role="php">
<![CDATA[
<?php
    $dbconn = pg_connect("dbname=publisher") or die("Impossible de se connecter");

    if (!pg_connection_busy($dbconn)) {
        pg_send_query($dbconn,"select * from authors; select count(*) from authors;");
    }
    
    $res1 = pg_get_result($dbconn);
    echo "Premier appel à pg_get_result() : $res1\n";
    $rows1 = pg_num_rows($res1);
    echo "$res1 has $rows1 records\n\n";
    
    $res2 = pg_get_result($dbconn);
    echo "Second appel à pg_get_result() : $res2\n";
    $rows2 = pg_num_rows($res2);
    echo "$res2 has $rows2 records\n";
?>
]]>
      </programlisting>
      <para>
       L'exemple ci-dessus pourrait afficher : 
      </para>
      <screen>
<![CDATA[
Premier appel à pg_get_result() : Resource id #3
Resource id #3 has 3 records

Second appel à pg_get_result() : Resource id #4
Resource id #4 has 1 records
]]>
      </screen>
     </example> 
    </para>
    <para>
     Voir aussi
     <function>pg_query</function>,
     <function>pg_cancel_query</function>,
     <function>pg_get_result</function> et
     <function>pg_connection_busy</function>.
    </para>
   </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
