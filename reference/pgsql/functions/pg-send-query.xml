<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.11 $ -->
<!-- EN-Revision: 1.13 Maintainer: jsgoupil Status: ready -->
<refentry id="function.pg-send-query">
 <refnamediv>
  <refname>pg_send_query</refname>
  <refpurpose>
   Exécute une requête PostgreSQL asynchrone
  </refpurpose>
 </refnamediv>
 
 <refsect1 role="description">
  &reftitle.description;
  <methodsynopsis>
   <type>bool</type><methodname>pg_send_query</methodname>
   <methodparam><type>resource</type><parameter>connection</parameter></methodparam>
   <methodparam><type>string</type><parameter>query</parameter></methodparam>
  </methodsynopsis>
  <methodsynopsis>
   <type>bool</type><methodname>pg_send_query</methodname>
   <methodparam><type>string</type><parameter>query</parameter></methodparam>
  </methodsynopsis>
  <para>
   <function>pg_send_query</function> envoie une requête ou des requêtes de
   manière asynchrone à la connexion <parameter>connection</parameter>.
   Contrairement à <function>pg_query</function>, elle peut envoyer plusieurs
   requêtes à la fois au serveur PostgreSQL et obtenir les résultats un par un
   en utilisant <function>pg_get_result</function>.
  </para>
  <para> 
   L'exécution du script n'est pas bloquée durant l'exécution des requêtes. Utilisez 
   <function>pg_connection_busy</function> pour vérifier si la connexion est
   occupée (c'est-à-dire la requête est en train d'être exécutée). Les requêtes
   peuvent être annulées avec <function>pg_cancel_query</function>.
  </para>
  <para>
   Bien que l'on puisse envoyer plusieurs requêtes en même temps,
   il n'est pas possible d'envoyer plusieurs requêtes sur une connexion
   occupée. Si une requête est envoyée alors que la connexion est occupée,
   elle attendra que la requête précédente soit terminée et perdra tous ses
   résultats.
  </para>
 </refsect1>

 <refsect1 role="parameters">
  &reftitle.parameters;
  <para>
   <variablelist>
    <varlistentry>
     <term><parameter>connection</parameter></term>
     <listitem>
      <para>
       La ressource de connexion de la base de données PostgreSQL. Lorsque
       <parameter>connection</parameter> n'est pas présent, la connexion par
       défaut est utilisée. La connexion par défaut est la dernière connexion
       faite par <function>pg_connect</function> ou <function>pg_pconnect</function>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>query</parameter></term>
     <listitem>
      <para>
       La requête ou les requêtes SQL à être exécutées.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsect1>

 <refsect1 role="returnvalues">
  &reftitle.returnvalues;
  <para>&return.success;</para>
  <para>
   Utilisez <function>pg_get_result</function> pour déterminer les résultats
   de requête.
  </para>
 </refsect1>

 <refsect1 role="examples">
  &reftitle.examples;
  <para>
   <example>
    <title>Exemple avec <function>pg_send_query</function></title>
    <programlisting role="php">
<![CDATA[
<?php
  $dbconn = pg_connect("dbname=publisher") or die("Connexion impossible");

  if (!pg_connection_busy($dbconn)) {
      pg_send_query($dbconn,"select * from auteurs; select count(*) from auteurs;");
  }
    
  $res1 = pg_get_result($dbconn);
  echo "Premier appel de pg_get_result() : $res1\n";
  $rows1 = pg_num_rows($res1);
  echo "$res1 a $rows1 enregistrements\n\n";
    
  $res2 = pg_get_result($dbconn);
  echo "Second appel de pg_get_result() : $res2\n";
  $rows2 = pg_num_rows($res2);
  echo "$res2 a $rows2 enregistrements\n";
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Premier appel de pg_get_result() : Resource id #3
Resource id #3 a 3 enregistrements

Second appel de pg_get_result() : Resource id #4
Resource id #4 a 1 enregistrements
]]>
    </screen>
   </example> 
  </para>
 </refsect1>

 <refsect1 role="seealso">
  &reftitle.seealso;
  <para>
   <simplelist>
    <member><function>pg_query</function></member>
    <member><function>pg_cancel_query</function></member>
    <member><function>pg_get_result</function></member>
    <member><function>pg_connection_busy</function></member>
   </simplelist>
  </para>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
