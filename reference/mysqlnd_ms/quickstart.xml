<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 317178 Maintainer: jpauli Status: ready -->
<!-- Reviewed: no -->

<!-- Ce fichier n'a pas été mis à jour compétement.
Seuls les IDs ont été touchés pour permettre une compilation de la
documentation
-->

<chapter xml:id="mysqlnd-ms.quickstart" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Exemples et démarrage rapide</title>
 <para>
  Le plugin d'équilibrage de charge mysqlnd est simple d'utilisation.
  Le guide de démarrage rapide va présenter des cas d'utilisation classiques et donner
  des exemples pratiques. 
 </para>
 <para>
  Il est fortement recommandé de lire la manuel de référence en plus du guide de
  démarrage rapide. Le guide évite de parler des limites et des aspects théoriques.
  Avant d'utiliser le plugin dans des cas critiques, veillez à bien lire les autres
  sections. 
 </para>
 <para>
  The focus is on using PECL mysqlnd_ms for work with an asynchronous MySQL cluster,
  namelys MySQL replication. Generally speaking an asynchronous cluster is more
  difficult to use than a synchronous one. Thus, users of, for example, MySQL Cluster
  will find more information than needed.
 </para>
 <note>
   <para>
    The documentation has been updated to show the syntax used as of version
    1.1.0-beta. PECL/mysqlnd_ms 1.1.0-beta introduces many
    <link linkend="mysqlnd-ms.changes-one-one">changes</link>. Among
    others, it is using a new <literal>JSON</literal>
    based
    <link linkend="mysqlnd-ms.plugin-ini-json">plugin configuration file</link>
    format.
   </para>
  </note>
 <section xml:id="mysqlnd-ms.quickstart.configuration">
  <title>Configuration</title>
  <para>
   Le plugin est une extension PHP. Veuillez lire
   <link linkend="mysqlnd-ms.installation">les instructions d'installation</link> pour
   installer l'extension
   <link xlink:href="&url.pecl.package;mysqlnd_ms">PECL/mysqlnd_ms</link>.
  </para>
  <para>
   Compile or configure the PHP MySQL extension (API) (<link linkend="ref.mysqli">mysqli</link>,
   <link linkend="ref.pdo-mysql">PDO_MYSQL</link>,
   <link linkend="ref.mysql">mysql</link>) that you plan to use with support
   for the <link linkend="book.mysqlnd">mysqlnd</link> library. PECL/mysqlnd_ms
   is a plugin for the mysqlnd library. To use the plugin with any of the PHP
   MySQL extensions, the extension has to use the mysqlnd library.
  </para>
  <para>
   Ensuite, chargez l'extension dans PHP et activez le plugin en utilisant la directive
   de configuration <link linkend="ini.mysqlnd-ms.enable">mysqlnd_ms.enable</link>. 
  </para>
  <para>
   <example>
    <title>Activer le plugin (php.ini)</title>
    <programlisting role="ini">
<![CDATA[
mysqlnd_ms.enable=1
mysqlnd_ms.ini_file=/path/to/mysqlnd_ms_plugin.ini
]]>
    </programlisting>
    </example>
  </para>
  <para>
   The plugin uses its own configuration file. Use the PHP
   configuration directive
   <link linkend="ini.mysqlnd-ms.ini-file">mysqlnd_ms.ini_file</link>
   to set the full file path to the plugin-specific configuration file.
   This file must be readable by PHP (e.g., the web server user).
  </para>
  <para>
   Créez un fichier de configuration pour le plugin. Indiquez son chemin complet dans
   <link linkend="ini.mysqlnd-ms.ini-file">mysqlnd_ms.ini_file</link>.
  </para>
  <para>
   The plugins <link linkend="mysqlnd-ms.plugin-ini-json">configuration file</link>
   is <acronym>JSON</acronym> based. It is divided into one or more sections.
   Each section has a name, for example, <literal>myapp</literal>. Every section
   makes its own set of configuration settings.
  </para>
  <para>
    A section must, at a minimum, list the MySQL replication master server, and set
    a list of slaves. The plugin supports using only one master server per section.
    Multi-master MySQL replication setups are not yet fully supported.
    Use the configuration setting
    <link linkend="ini.mysqlnd-ms-plugin-config-v2.master">master</link>
    to set the hostname, and the port or socket of the MySQL master server.
    MySQL slave servers are configured using the
    <link linkend="ini.mysqlnd-ms-plugin-config-v2.slave">slave</link>
    keyword.
  </para>
  <para>
   <example>
    <title>Configuration minimale du plugin (mysqlnd_ms_plugin.ini)</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost"
            }
        },
        "slave": [

        ]
    }
}
]]>
    </programlisting>
    </example>
  </para>
  <para>
   Configuring a MySQL slave server list is required, although it may
   contain an empty list. It is recommended to always configure at
   least one slave server.
  </para>
  <para>
   Server lists can use <link linkend="mysqlnd-ms.plugin-ini-json.server-list-syntax">
   anonymous or non-anonymous syntax</link>. Non-anonymous
   lists include alias names for the servers, such as <literal>master_0</literal>
   for the master in the above example. The quickstart uses the
   more verbose non-anonymous syntax.
  </para>
  <para>
   <example>
    <title>Configuration minimale recommandée pour le plugin (mysqlnd_ms_plugin.ini)</title>
    <programlisting role="ini">
<![CDATA[
[myapp]
master[]=localhost:/tmp/mysql.sock
slave[]=192.168.2.27:3306
]]>
    </programlisting>
    </example>
  </para>
  <para>
   S'il existe au moins deux serveurs déclarés en configuration, le plugin peut commencer
   à équilibrer la charge entre les connections. La bascule entre les connections n'est
   pas tout le temps transparente et peut générer des problèmes. Voyez les références sur
   <link linkend="mysqlnd-ms.pooling">les pools de connections et les bascules</link>,
   <link linkend="mysqlnd-ms.transaction">la gestion des transactions</link>,
   <link linkend="mysqlnd-ms.failover">la reprise sur incident</link> 
   <link linkend="mysqlnd-ms.loadbalancing">l'équilibre de la charge</link> et 
   <link linkend="mysqlnd-ms.rwsplit">la découpe des lectures-écritures</link> pour les détails.
   Vous pouvez désormais continuer de lire ce guide démarrage. Les astuces
   et problèmes éventuels du plugin vont être détaillées par la suite.
  </para>
  <para>   
   Il est de la responsabilité de l'application de gérer les éventuels problèmes dûs à
   la bascule entre les connections. En configurant au moins un maitre et un esclave,
   vous vous assurez que le plugin basculera les connections, et vous détecterez les
   problèmes plus tôt.
  </para>
  <para>
   Les serveurs maitre et esclave que vous configurez peuvent être la même machine.
   Cela peut aider à détecter les erreurs dûes à la bascule entre les conneections,
   mais pas les erreurs dûes à la latence de la réplication. 
  </para>
  <para>
   <example>
    <title>Utiliser un seul serveur comme maitre et esclave (test seulement!)</title>
    <programlisting role="ini">
<![CDATA[
[myapp]
master[]=localhost:/tmp/mysql.sock
slave[]=127.0.0.1:3306
]]>
    </programlisting>
    </example>
  </para>
  
 </section>
 
 <section xml:id="mysqlnd-ms.quickstart.usage">
  <title>Exécuter des requêtes</title>
  <para>
   Le plugin peut être utilisé avec n'importe quelle extension PHP pour MySQL 
   (<link linkend="ref.mysqli">mysqli</link>,
   <link linkend="ref.mysql">mysql</link>,
   <link linkend="ref.pdo-mysql">PDO_MYSQL</link>) 
   compilée avec le support <link linkend="book.mysqlnd">mysqlnd</link>.
   PECL/mysqlnd_ms se branche sur la bibliothèque <link linkend="book.mysqlnd">mysqlnd</link>.
   Ceci ne change pas les API des extensions de PHP pour MySQL.
  </para>
  <para>
   Dès lors qu'une connection à MySQL est ouverte, le plugin compare l'hôte aux sections
   déclarées dans le fichier de configuration. Par exemple une section
   <literal>myapp</literal> sera chargée si une connection MySQL à l'hôte
   <literal>myapp</literal> est effectuée.
  </para>
  <para>
   <example>
    <title>Fichier de configuration du plugin (mysqlnd_ms_plugin.ini)</title>
    <programlisting role="ini">
<![CDATA[
[myapp]
master[]=localhost:/tmp/mysql.sock
slave[]=192.168.2.27:3306
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Ouvrir une connection sujette à équilibrage</title>
    <programlisting role="php">
<![CDATA[
<?php
/* La section "myapp" du fichier de configuration du plugin sera chargée */
$mysqli = new mysqli("myapp", "username", "password", "database");
$pdo = new PDO('mysql:host=myapp;dbname=database', 'username', 'password');
$mysql = mysql_connect("myapp", "username", "password");
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Les trois connections ouvertes dans l'exemple seront équilibrées en charge. Le plugin
   enverra les requêtes en lecture au serveur ayant l'IP <literal>192.168.2.27</literal>
   sur le port<literal>3306</literal>. Toutes les autres requêtes seront dirigées vers
   l'hôte maitre à <literal>localhost</literal> sur sa socket
   <literal>/tmp/mysql.sock</literal>. Le plugin utilisera le nom
   <literal>username</literal> et le mot de passe <literal>password</literal> pour se
   connecter à tout hôte déclaré dans la section <literal>myapp</literal>.
   Une fois connecté, le plugin va sélectionner <literal>database</literal> comme nom
   de base de données. Le nom d'utilisateur, le mot de passe et le nom de la base de
   données sont utilisés depuis les appels à l'API et utilisés pour tous les serveurs.
   En d'autres termes, vous devez utiliser les mêmes nom d'utilisateur et mot de passe
   pour tout serveur MySQL listé dans une section du fichier de configuration du plugin.
  </para>
  <para>
   The username, password and schema name are taken from the connect
   API calls and used for all servers. In other words: you must use the same
   username and password for every MySQL server listed in a plugin configuration
   file section. The is not a general limitation. As of PECL/mysqlnd_ms 1.1.0,
   it is possible to set the
   <link linkend="mysqlnd-ms.plugin-ini-json.server-config-keywords">username</link> and
   <link linkend="mysqlnd-ms.plugin-ini-json.server-config-keywords">password</link> for any server in the
   plugins configuration file, to be used instead of the credentials passed
   to the API call.
  </para>
  <para>
   Le plugin ne change pas l'API pour les requêtes en cours.
   <link linkend="mysqlnd-ms.rwsplit">la découpe des lectures-écritures</link>
   fonctionne par défaut. L'exemple suivant suppose qu'il y a peu de latence entre le
   maitre et l'esclave.
  </para>
  <para>
   <example>
    <title>Exécuter des requêtes</title>
    <programlisting role="php">
<![CDATA[
<?php
/* Equilibré selon la section "myapp" du fichier de configuration du plugin */
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli)
  /* Evidemment, votre propre gestion des erreurs serait meilleure... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* Requêtes lancées sur le maitre */
if (!$mysqli->query("DROP TABLE IF EXISTS test")) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}
if (!$mysqli->query("CREATE TABLE test(id INT)")) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}
if (!$mysqli->query("INSERT INTO test(id) VALUES (1)")) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}

/* lecture seule: requêtes lancées sur un esclave */
if (!($res = $mysqli->query("SELECT id FROM test")) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
} else {
 $row = $res->fetch_assoc(); 
 $res->close();
 printf("Slave returns id = '%s'\n", $row['id'];
}
$mysqli->close();
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Slave returns id = '1'
]]>
    </screen>
   </example>
  </para>
 </section>
 
 <section xml:id="mysqlnd-ms.quickstart.connectionpooling">
  <title>Etat de la connection</title>
  <para>
   Le plugin change la sémantique d'une connection MySQL pour PHP. Une connection n'est
   plus liée à un serveur MySQL unique, mais à un pool de connections. Le pool est
   représenté par au moins une connection maitre et zéro ou plusieurs connections esclaves.
  </para>
  <para>
   Chaque connection dans le pool possède son propre état.Par exemple, les variables SQL
   utilisateurs, les tables temporaires et les transactions font partie de l'état.
   Voyez la liste complète dans
   <link linkend="mysqlnd-ms.pooling">pools de connections et bascule</link>.
   Si le plugin décide de basculer de connection pour l'équilibre de la charge, l'application
   pourrait se retrouver avec des connections d'états différents. Les applications doivent
   faire attention à ce point !
  </para>
  <para>
   <example>
    <title>Config du plugin avec un maitre et un esclave</title>
    <programlisting role="ini">
<![CDATA[
[myapp]
master[]=localhost:/tmp/mysql.sock
slave[]=192.168.2.27:3306
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Problème possible: Etat de la connection et variables SQL utilisateurs</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli)
  /* Evidemment, votre propre gestion des erreurs serait meilleure... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* Connection 1, la connection a utilisé des variables SQL, pas de SELECT, donc maitre utilisé */
if (!$mysqli->query("SET @myrole='master'")) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}

/* Connection 2, sur un esclave car de type SELECT */
if (!($res = $mysqli->query("SELECT @myrole AS _role"))) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
} else {
 $row = $res->fetch_assoc();
 $res->close();
 printf("@myrole = '%s'\n", $row['_role']);
}
$mysqli->close();
?>
]]>
    </programlisting>
&example.outputs;
    <screen>
<![CDATA[
@myrole = ''
]]>
    </screen>
   </example>
  </para>
  <para>
   L'exemple ouvre une connection équilibrée et exécute deux requêtes. La première
   <literal>SET @myrole='master'</literal> n'est pas de type <literal>SELECT</literal>,
   elle est donc exécutée sur une connection à un maitre (ici il n'y en a qu'un seul).
   La requête change une variable SQL qui est donc liée à la connection. L'état de
   la connection au maitre vient donc de changer.
  </para>
  <para>
   La requête suivante, <literal>SELECT @myrole AS _role</literal> est lancée sur un
   esclave car elle est de type lecture seule (select). La connection à l'esclave ne possède
   elle, aucune variable SQL affectée, son état est donc différent de celui de la
   connection au maitre. Le script affiche donc en réponse
   <literal>@myrole = ''</literal>.
  </para>
  <para>
   Il est de la responsabilité du développeur de l'application de prendre garde aux états 
   des connections balancées. Le plugin ne surveille pas toutes les activités des connections,
   ceci serait beaucoup trop couteux en temps CPU.
  </para>
  <para>
   Ces problèmes peuvent être contournés grâce aux astuces SQL.
  </para>
  </section>
 
 <section xml:id="mysqlnd-ms.quickstart.sqlhints">
  <title>Astuces SQL</title>
  <para>
   Les astuces SQL peuvent être utilisées pour forcer le plugin à choisir un serveur particulier
   dans le pool. Ceci peut aider à palier aux problèmes de bascule entre les connections
   oude changement d'état des connections.
  </para>
  <para>
   Les astuces SQL sont des commentaires de la syntaxe SQL. Comme ils sont supposés être ignorés,
   ils n'interfèrent pas avec les serveurs MySQL, le proxy MySQL ou même un pare-feu.
  </para>
  <para>
   Trois astuces SQL sont supportées par le plugin : 
   <constant>MYSQLND_MS_MASTER_SWITCH</constant>,
   <constant>MYSQLND_MS_SLAVE_SWITCH</constant> et
   <constant>MYSQLND_MS_LAST_USED_SWITCH</constant>. 
   <constant>MYSQLND_MS_MASTER_SWITCH</constant> indique au plugin d'exécuter une requête sur le
   maitre, <constant>MYSQLND_MS_SLAVE_SWITCH</constant> force l'utilisation de l'esclave
   et <constant>MYSQLND_MS_MASTER_SWITCH</constant> exécutera la requête sur le même serveur
   que celui utilisé pour exécuter la requête précédente.
  </para>
  <para>
   Le plugin scanne le début de la requête pour rechercher une astuce SQL en commentaires.
   Les astuces SQL ne doivent être écrites qu'au tout début d'une requête pour être
   reconnues.
  </para>
   <para>
   <example>
    <title>Configuration du plugin avec un esclave et un maitre</title>
    <programlisting role="ini">
<![CDATA[
[myapp]
master[]=localhost:/tmp/mysql.sock
slave[]=192.168.2.27:3306
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Astuces SQL pour éviter les bascules de connection</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli)
  /* Evidemment, votre propre gestion des erreurs serait meilleure... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* Connection 1, la connection a utilisé des variables SQL, pas de SELECT, donc maitre utilisé */
if (!$mysqli->query("SET @myrole='master'")) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}

/* Connection 1, exécutée sur le maitre à cause de l'astuce SQL présente */
if (!($res = $mysqli->query(sprintf("/*%s*/SELECT @myrole AS _role", MYSQLND_MS_LAST_USED_SWITCH)))) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
} else {
 $row = $res->fetch_assoc();
 $res->close();
 printf("@myrole = '%s'\n", $row['_role']);
}
$mysqli->close();
?>
]]>
    </programlisting>
&example.outputs;
    <screen>
<![CDATA[
@myrole = 'master'
]]>
    </screen>
   </example>
  </para>
  <para>
   Dans l'exemple, la récupération des variables de la session précédente est résolue en
   utilisant <constant>MYSQLND_MS_LAST_USED_SWITCH</constant> pour éviter la bascule du maitre
   vers un esclave lors de l'exécution de la requête <literal>SELECT</literal>.
  </para>
  <para>
   Les astuces SQL peuvent aussi être utilisée pour lancer une requête <literal>SELECT</literal>
   sur le maitre. Par exemple, lorsque les esclaves sont derrière le maitre et que vous
   voulez selectionner des données fraiches.
  </para>
  <para>
   <example>
    <title>Latence de réplication</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli)
  /* Evidemment, votre propre gestion des erreurs serait meilleure... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* Force l'utilisation du maitre, le maitre a toujours des données fraiches */
if (!$mysqli->query(sprintf("/*%s*/SELECT critical_data FROM important_table", MYSQLND_MS_MASTER_SWITCH))) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}
?>
]]>
    </programlisting>    
   </example>
  </para>
  <para>
   Autre exemple concrêt : créer des tables sur un esclave. Si aucune astuce SQL n'est fournie,
   le plugin va envoyer les <literal>CREATE</literal> et <literal>INSERT</literal>
   vers le maitre. L'astuce <constant>MYSQLND_MS_SLAVE_SWITCH</constant> peut alors être
   utilisée pour forcer l'utilisation d'un esclave.
  </para>
  <para>
   <example>
    <title>Création de table sur un esclave</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli)
  /* Evidemment, votre propre gestion des erreurs serait meilleure... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* Force l'utilisation d'un esclave */
if (!$mysqli->query(sprintf("/*%s*/CREATE TABLE slave_reporting(id INT)", MYSQLND_MS_SLAVE_SWITCH))) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}
/* Continue en utilisant cette connection à l'esclave */
if (!$mysqli->query(sprintf("/*%s*/INSERT INTO slave_reporting(id) VALUES (1), (2), (3)", MYSQLND_MS_LAST_USED_SWITCH))) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}
/* N'utilisez pas MYSQLND_MS_SLAVE_SWITCH qui autoriserait la bascule vers un autre esclave ! */
if ($res = $mysqli->query(sprintf("/*%s*/SELECT COUNT(*) AS _num FROM slave_reporting", MYSQLND_MS_LAST_USED_SWITCH))) {
  $row = $res->fetch_assoc();
  $res->close();
  printf("There are %d rows in the table 'slave_reporting'", $row['_num']);
} else {
  printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}
$mysqli->close();
?>
]]>
    </programlisting>    
   </example>
  </para>
  <para>
   L'astuce SQL <constant>MYSQLND_MS_LAST_USED</constant> interdit la bascule de connection
   et force l'utilisation de la connection de la requête précédente.   
  </para>
 </section>
  
 <section xml:id="mysqlnd-ms.quickstart.transactions">
  <title>Transactions</title>
  <para>
   La version actuelle du plugin ne gère pas les trasactions. Les transactions SQL sont
   des opérations atomiques exécutées sur un seul et même serveur. Le plugin ne sait
   pas quand l'opération atomique commence et quand elle prend fin. Ainsi, il peut
   décider de basculer de connection au milieu d'une transaction.
  </para>
  <para>
   Vous devez utiliser des astuces SQL pour éviter un tel comportement.
  </para>
  <para>
   <example>
    <title>Configuration du plugin avec un esclave et un maitre</title>
    <programlisting role="ini">
<![CDATA[
[myapp]
master[]=localhost:/tmp/mysql.sock
slave[]=192.168.2.27:3306
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Utilisation des astuces SQL pour les transactions</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli)
  /* Evidemment, votre propre gestion des erreurs serait meilleure... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));
  
/* Pas un SELECT, utilisera le maitre */
if (!$mysqli->query("START TRANSACTION")) {
 /* Please use better error handling in your code */
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* Empêche le changement de connection! */
if (!$mysqli->query(sprintf("/*%s*/INSERT INTO test(id) VALUES (1)", MYSQLND_MS_LAST_USED_SWITCH)))) { 
 /* Utilisez un ROLLBACK dans votre code, pas juste un die() */
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error)); 
}
if ($res = $mysqli->query(sprintf("/*%s*/SELECT COUNT(*) AS _num FROM test", MYSQLND_MS_LAST_USED_SWITCH)))) {
  $row = $res->fetch_assoc();
  $res->close();
  if ($row['_num'] > 1000) {
   if (!$mysqli->query(sprintf("/*%s*/INSERT INTO events(task) VALUES ('cleanup')", MYSQLND_MS_LAST_USED_SWITCH)))) {
     die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
   }
  }  
} else {
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}
if (!$mysqli->query(sprintf("/*%s*/UPDATE log SET last_update = NOW()", MYSQLND_MS_LAST_USED_SWITCH)))) {
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}
if (!$mysqli->query(sprintf("/*%s*/COMMIT", MYSQLND_MS_LAST_USED_SWITCH)))) {
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

$mysqli->close();
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Depuis PHP 5.4.0 la bibliothèque <literal>mysqlnd</literal> permet au plugin de
   surveiller le statut de l'<literal>autocommit</literal>, si celui-ci est utilisé via
   des appels à l'API plutot que via une requête du type <literal>SET AUTOCOMMIT=0</literal>.
   Ceci rend le plugin sensible et réactif aux transactions.
  </para>
  <para>
    Si vous utilisez PHP 5.4.0, les appels de l'API pour gérer l'<literal>autocommit</literal>
    et le paramètre expérimental
    <link linkend="ini.mysqlnd-ms-plugin-config-v2.trx-stickiness"><literal>trx_stickiness=master</literal></link>
    permettent au plugin de désactiver l'équilibrage de charge et la bascule entre les
    connections si <literal>autocommit</literal> est désactivé, et de diriger les requêtes vers
    le maitre. Ceci évite la bascule de connection au milieu d'une transaction. Une fois que
    <literal>autocommit</literal> est réactivé, le plugin reprend l'équilibrage de charge.
  </para>
  <para>
   <example>
    <title>Paramètre expérimental trx_stickiness</title>
    <programlisting role="ini">
<![CDATA[
[myapp]
master[]=localhost:/tmp/mysql.sock
slave[]=192.168.2.27:3306
trx_stickiness=master
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Gestion propre des transactions</title>
    <programlisting role="php">
<![CDATA[
<?php
if (version_compare(PHP_VERSION, "5.3.99", "<"))
  die("This feature requires PHP 5.3.99, you are using " . PHP_VERSION);
  
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli)
  /* Evidemment, votre propre gestion des erreurs serait meilleure... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* Désactive autocommit, le plugin utilisera le maitre pour toutes les requêtes */
$mysqli->autocommit(FALSE);

if (!$mysqli->query("INSERT INTO test(id) VALUES (1)")) { 
 /* Utilisez un ROLLBACK dans votre code, pas juste un die() */
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error)); 
}
if ($res = $mysqli->query("SELECT COUNT(*) AS _num FROM test")) {
  $row = $res->fetch_assoc();
  $res->close();
  if ($row['_num'] > 1000) {
   if (!$mysqli->query("INSERT INTO events(task) VALUES ('cleanup')")) {
     die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
   }
  }  
} else {
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}
if (!$mysqli->query("UPDATE log SET last_update = NOW()")) {
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}
if (!$mysqli->commit()) {
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* Le plugin sait que la trasaction est terminée, il reprend l'équilibrage de charge */
$mysqli->autocommit(TRUE);
$mysqli->close();
?>
]]>
    </programlisting>
   </example>
  </para>
  <note>
   <para>
    La directive de configuration du plugin
    <link linkend="ini.mysqlnd-ms-plugin-config-v2.trx-stickiness"><literal>trx_stickiness=master</literal></link>
    est expérimentale. Elle requiert PHP 5.4.0.
   </para>
  </note>
 </section>
 <section xml:id="mysqlnd-ms.quickstart.qos-consistency">
  <title>Service level and consistency</title>
  <note>
   <title>Version requirement</title>
   <para>
    Service levels have been introduced in PECL mysqlnd_ms version 1.2.0-alpha.
    <function>mysqlnd_ms_set_qos</function>
    is available with PHP 5.4.0 or newer.
   </para>
  </note>
  <para>
   Different types of MySQL cluster solutions offer different service and
   data consistency levels to their users. An asynchronous MySQL replication cluster
   offers eventual consistency by default. A read executed on an asynchronous slave
   may return current, stale or no data at all, depending on whether the slave
   has replayed all changesets from the master or not.
  </para>
  <para>
   Applications using an MySQL replication cluster need to be designed to work
   correctly with eventual consistent data. In some cases, however, stale data
   is not acceptable. In those cases only certain slaves or even only master accesses are
   allowed to achieve the required quality of service from the cluster.
  </para>
  <para>
   As of PECL mysqlnd_ms 1.2.0 the plugin is capable of selecting
   MySQL replication nodes automatically that deliver session consistency or
   strong consistency. Session consistency means that one client can read its writes.
   Other clients may or may not see the clients' write. Strong consistency means
   that all clients will see all writes from the client.
  </para>
  <para>
   <example>
    <title>Session consistency: read your writes</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        }
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Requesting session consistency</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli)
  /* Of course, your error handling is nicer... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* read-write splitting: master used */
if (!$mysqli->query("INSERT INTO orders(order_id, item) VALUES (1, 'christmas tree, 1.8m')")) {
   /* Please use better error handling in your code */
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* Request session consistency: read your writes */
if (!mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_SESSION))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* Plugin picks a node which has the changes, here: master */
if (!$res = $mysqli->query("SELECT item FROM orders WHERE order_id = 1"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

var_dump($res->fetch_assoc());

/* Back to eventual consistency: stale data allowed */
if (!mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_EVENTUAL))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* Plugin picks any slave, stale data is allowed */
if (!$res = $mysqli->query("SELECT item, price FROM specials"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Service levels can be set in the plugins configuration file and at runtime
   using <function>mysqlnd_ms_set_qos</function>.
   In the example the function is used to enforce
   session consistency (read your writes) for all future statements until further notice.
   The <literal>SELECT</literal> statement on the <literal>orders</literal> table
   is run on the master to ensure the previous write can be seen by the client.
   Read-write splitting logic has been adapted to fulfill the service level.
  </para>
  <para>
   After the application has read its changes from the <literal>orders</literal> table
   it returns to the default service level, which is eventual consistency. Eventual
   consistency puts no restrictions on choosing a node for statement execution.
   Thus, the <literal>SELECT</literal> statement on the <literal>specials</literal>
   table is executed on a slave.
  </para>
  <para>
   The new functionality supersedes the use of SQL hints and the
   <literal>master_on_write</literal> configuration option. In many cases
   <function>mysqlnd_ms_set_qos</function> is easier to use, more powerful
   improves portability.
  </para>
  <para>
   <example>
    <title>Maximum age/slave lag</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        },
        "failover" : "master"
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Limiting slave lag</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli)
  /* Of course, your error handling is nicer... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* Read from slaves lagging no more than four seconds */
$ret = mysqlnd_ms_set_qos($mysqli,
         MYSQLND_MS_QOS_CONSISTENCY_EVENTUAL,
         MYSQLND_MS_QOS_OPTION_AGE, 4);

if (!$ret)
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* Plugin picks any slave, which may or may not have the changes */
if (!$res = $mysqli->query("SELECT item, price FROM daytrade"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));


/* Back to default: use of all slaves and masters permitted */
if (!mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_EVENTUAL))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   The eventual consistency service level can be used with an optional
   parameter to set a maximum slave lag for choosing slaves. If set,
   the plugin checks <literal>SHOW SLAVE STATUS</literal> for all
   configured slaves. In case of the example, only slaves
   for which <literal>Slave_IO_Running=Yes</literal>,
   <literal>Slave_SQL_Running=Yes</literal> and
   <literal>Seconds_Behind_Master &lt;= 4</literal>
   is true are considered for executing the statement
   <literal>SELECT item, price FROM daytrade</literal>.
  </para>
  <para>
   Checking <literal>SHOW SLAVE STATUS</literal> is done transparently from
   an applications perspective. Errors, if any, are reported as
   warnings. No error will be set on the connection handle. Even if all
   <literal>SHOW SLAVE STATUS</literal> SQL statements executed by
   the plugin fail, the execution of the users statement is not stopped, given
   that master fail over is enabled. Thus, no application changes are required.
  </para>
  <note>
   <title>Expensive and slow operation</title>
   <para>
    Checking <literal>SHOW SLAVE STATUS</literal> for all slaves adds overhead
    to the application. It is an expensive and slow background operation.
    Try to minimize the use of it. Unfortunately, a MySQL replication cluster
    does not give clients the possibility to request a list of candidates
    from a central instance.
    Thus, a more efficient way of checking the slaves lag is not available.
   </para>
   <para>
    Please, note the limitations and properties of <literal>SHOW SLAVE STATUS</literal>
    as explained in the MySQL reference manual.
   </para>
  </note>
  <para>
   To prevent mysqlnd_ms from emitting a warning if no slaves can be found
   that lag no more than the defined number of seconds behind the master,
   it is necessary to enable master fail over in the plugins configuration file.
   If no slaves  can be found and fail over is turned on, the plugin
   picks a master for  executing the statement.
  </para>
  <para>
   If no slave can be found and fail over is turned off, the plugin emits
   a warning, it does not execute the statement and it sets an error
   on the connection.
  </para>
  <para>
   <example>
    <title>Fail over not set</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        }
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>No slave within time limit</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli)
  /* Of course, your error handling is nicer... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* Read from slaves lagging no more than four seconds */
$ret = mysqlnd_ms_set_qos($mysqli,
         MYSQLND_MS_QOS_CONSISTENCY_EVENTUAL,
         MYSQLND_MS_QOS_OPTION_AGE, 4);

if (!$ret)
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* Plugin picks any slave, which may or may not have the changes */
if (!$res = $mysqli->query("SELECT item, price FROM daytrade"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));


/* Back to default: use of all slaves and masters permitted */
if (!mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_EVENTUAL))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
PHP Warning:  mysqli::query(): (mysqlnd_ms) Couldn't find the appropriate slave connection. 0 slaves to choose from. Something is wrong in %s on line %d
PHP Warning:  mysqli::query(): (mysqlnd_ms) No connection selected by the last filter in %s on line %d
[2000] (mysqlnd_ms) No connection selected by the last filter
]]>
    </screen>
   </example>
  </para>
  <note>
   <title>Fail over logic is work in progress</title>
   <para>
    The details of the fail over logic may change in future versions.
   </para>
  </note>
 </section>
 <section xml:id="mysqlnd-ms.quickstart.gtid">
  <title>Global transaction IDs</title>
  <note>
   <title>Version requirement</title>
   <para>
    Global transaction ID injection has been introduced in mysqlnd_ms version 1.2.0-alpha.
    The feature is not required for synchronous clusters, such as MySQL Cluster.
    Use it with asynchronous clusters such as classical MySQL replication.
   </para>
  </note>
  <para>
   In its most basic form a global transaction ID (GTID) is a counter in a table on the
   master. The counter is incremented whenever a transaction is comitted on the master.
   Slaves replicate the table. The counter serves two puposes. In case of a
   master failure, it helps the database administrator to identify the most recent slave
   for promoting it to the new master. The most recent slave is the one with the
   highest counter value. Applications can use the global transaction ID to search
   for slaves which have replicated a certain write (identified by a global transaction ID)
   already.
  </para>
  <para>
   PECL/mysqlnd_ms can inject SQL for every comitted transaction to increment a GTID counter.
   The so created GTID is accessible by the application to identify an applications
   write operation. This enables the plugin to deliver session consistency (read your writes)
   service level by not only quering masters but also slaves which have replicated
   the change already. Read load is taken away from the master.
  </para>
  <para>
   Client-side global transaction ID emulation has some limitations. Please,
   read the <link linkend="mysqlnd-ms.gtid">concepts section</link>
   carefully to fully understand the principles and ideas
   behind it, before using in production environments. The background knowledge
   is not required to continue with the quickstart.
  </para>
  <para>
   First, create a counter table on your master server and insert a record into it.
   The plugin does not assist creating the table.
   Database administrators must make sure it exists. Depending on the error
   reporting mode, the plugin will silently ignore the lack of the table or bail out.
  </para>
  <para>
   <example>
    <title>Create counter table on master</title>
    <programlisting role="sql">
<![CDATA[
CREATE TABLE `trx` (
  `trx_id` int(11) DEFAULT NULL,
  `last_update` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=latin1
INSERT INTO `trx`(`trx_id`) VALUES (1);
]]>
    </programlisting>
   </example>
  </para>
  <para>
   In the plugins configuration file set the SQL to update the
   global transaction ID table using <literal>on_commit</literal>
   from the <literal>global_transaction_id_injection</literal>
   section. Make sure the table name used for the <literal>UPDATE</literal>
   statement is fully qualified. In the example,
   <literal>test.trx</literal> is used to refer to table <literal>trx</literal>
   in the schema (database) <literal>test</literal>. Use the table that was created in
   the previous step. It is important to set the fully qualified table name
   because the connection on which the injection is done may use a different
   default database. Make sure the user that opens the connection
   is allowed to execute the <literal>UPDATE</literal>.
  </para>
  <para>
   Enable reporting of errors that may occur when mysqlnd_ms does global
   transaction ID injection.
  </para>
  <para>
   <example>
    <title>Plugin config: SQL for client-side GTID injection</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        },
        "global_transaction_id_injection":{
            "on_commit":"UPDATE test.trx SET trx_id = trx_id + 1",
            "report_error":true
        }
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Transparent global transaction ID injection</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli)
  /* Of course, your error handling is nicer... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* auto commit mode, transaction on master, GTID must be incremented */
if (!$mysqli->query("DROP TABLE IF EXISTS test"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* auto commit mode, transaction on master, GTID must be incremented */
if (!$mysqli->query("CREATE TABLE test(id INT)"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* auto commit mode, transaction on master, GTID must be incremented */
if (!$mysqli->query("INSERT INTO test(id) VALUES (1)"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* auto commit mode, read on slave, no increment */
if (!($res = $mysqli->query("SELECT id FROM test")))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

var_dump($res->fetch_assoc());
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
array(1) {
  ["id"]=>
  string(1) "1"
}
]]>
    </screen>
   </example>
  </para>
  <para>
   The example runs three statements in auto commit mode on the master, causing
   three transactions on the master. For every such statement, the plugin will
   inject the configured <literal>UPDATE</literal> transparently before executing
   the users SQL statement. When the script ends the global
   transaction ID counter on the master has been incremented by three.
  </para>
  <para>
   The fourth SQL statement executed in the example, a <literal>SELECT</literal>,
   does not trigger an increment. Only transactions (writes) executed on a master
   shall increment the GTID counter.
  </para>
  <note>
   <title>SQL for global transaction ID: efficient solution wanted!</title>
   <para>
    The SQL used for the client-side global transaction ID emulation is inefficient.
    It is optimized for clearity not for performance. Do not use it for production
    environments. Please, help finding an efficient solution for inclusion in the manual.
    We appreciate your input.
   </para>
  </note>
  <para>
   <example>
    <title>Plugin config: SQL for fetching GTID</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        },
        "global_transaction_id_injection":{
            "on_commit":"UPDATE test.trx SET trx_id = trx_id + 1",
            "fetch_last_gtid" : "SELECT MAX(trx_id) FROM test.trx",
            "report_error":true
        }
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Obtaining GTID after injection</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli)
  /* Of course, your error handling is nicer... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* auto commit mode, transaction on master, GTID must be incremented */
if (!$mysqli->query("DROP TABLE IF EXISTS test"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

printf("GTID after transaction %s\n", mysqlnd_ms_get_last_gtid($mysqli));

/* auto commit mode, transaction on master, GTID must be incremented */
if (!$mysqli->query("CREATE TABLE test(id INT)"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

printf("GTID after transaction %s\n", mysqlnd_ms_get_last_gtid($mysqli));
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
GTID after transaction 7
GTID after transaction 8
]]>
    </screen>
   </example>
  </para>
  <para>
   Applications can ask PECL mysqlnd_ms for a global transaction ID which
   belongs to the last write operation performed by the application.
   The function <function>mysqlnd_ms_get_last_gtid</function> returns the
   GTID obtained when executing the SQL statement from
   the <literal>fetch_last_gtid</literal> entry of the
   <literal>global_transaction_id_injection</literal> section from
   the plugins configuration file. The function may be called
   after the GTID has been incremented.
  </para>
  <para>
   Applications are adviced not to run the SQL
   statement themselves as this bares the risk of accidently causing an implicit
   GTID increment. Also, if the function is used, it is easy to migrate
   an application from one SQL statement for fetching a transaction ID to another,
   for example, if any MySQL server ever features built-in global transaction ID support.
  </para>
  <para>
   The quickstart shows a SQL statement which will return a GTID equal or greater
   to that created for the previous statement. It is exactly the GTID created
   for the previous statement if no other clients have incremented the GTID in the
   time span between the statement execution and the <literal>SELECT</literal>
   to fetch the GTID. Otherwise, it is greater.
  </para>
  <para>
   <example>
    <title>Plugin config: Checking for a certain GTID</title>
    <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        },
        "global_transaction_id_injection":{
            "on_commit":"UPDATE test.trx SET trx_id = trx_id + 1",
            "fetch_last_gtid" : "SELECT MAX(trx_id) FROM test.trx",
            "check_for_gtid" : "SELECT trx_id FROM test.trx WHERE trx_id >= #GTID",
            "report_error":true
        }
    }
}
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Session consistency service level and GTID combined</title>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli)
  /* Of course, your error handling is nicer... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* auto commit mode, transaction on master, GTID must be incremented */
if (!$mysqli->query("DROP TABLE IF EXISTS test") ||
    !$mysqli->query("CREATE TABLE test(id INT)") ||
    !$mysqli->query("INSERT INTO test(id) VALUES (1)"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* GTID as an identifier for the last write */
$gtid = mysqlnd_ms_get_last_gtid($mysqli);

/* Session consistency (read your writes): try to read from slaves not only master */
if (false == mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_SESSION, MYSQLND_MS_QOS_OPTION_GTID, $gtid)) {
	die(sprintf("[006] [%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* Either run on master or a slave which has replicated the INSERT */
if (!($res = $mysqli->query("SELECT id FROM test"))) {
	die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

var_dump($res->fetch_assoc());
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   A GTID returned from <function>mysqlnd_ms_get_last_gtid</function>
   can be used as an option for the session consistency service level.
   Session consistency delivers read your writes. Session consistency can
   be requested by calling
   <function>mysqlnd_ms_set_qos</function>.
   In the example, the plugin will execute the <literal>SELECT</literal>
   statement either on the master or on a slave which has replicated
   the previous <literal>INSERT</literal> already.
  </para>
  <para>
   PECL mysqlnd_ms will transparently check every configured slave if
   it has replicated the <literal>INSERT</literal> by checking the slaves
   GTID table. The check is done running the SQL set with the
   <literal>check_for_gtid</literal> option from the
   <literal>global_transaction_id_injection</literal> section of
   the plugins configuration file. Please note, that this is a slow and
   expensive procedure. Applications should try to use it sparsely and only
   if read load on the master becomes to high otherwise.
  </para>
 </section>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
