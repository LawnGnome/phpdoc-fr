<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 317106 Maintainer: jpauli Status: ready -->
<!-- Reviewed: no -->

<chapter xml:id="mysqlnd-ms.concepts" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Concepts</title>
 <section xml:id="mysqlnd-ms.architecture">
  <title>Architecture</title>
  <para>
   Le plugin mysqlnd de réplication et de répartition de charge est implémenté sous
   forme d'extension PHP. Il est écrit en C et agit sous PHP et durant la phase de
   démarrage de l'interpréteur PHP (phase d'initialisation des modules) il est enregistré
   comme plugin <link linkend="book.mysqlnd">mysqlnd</link> pour remplacer des fonctions
   C spécifiques.
  </para>
  <para>
   Au déroulement de PHP, il inspecte les requêtes envoyées depuis mysqlnd(PHP) au serveur
   MySQL. Si une requête est reconnue comme étant de type lecture seule, elle sera aiguillée
   vers un des serveurs esclaves configurés. Ceci est le cas pour les requêtes commençant
   par <literal>SELECT</literal>, au moyen de l'astuce SQL <literal>/*ms=slave*/</literal> ou alors
   si un esclave a été choisi pour exécuter la requête précédente et qu'elle utilisait l'astuce
   SQL <literal>/*ms=last_used*/</literal>. Dans tous les autres cas, la requête sera envoyée au
   serveur maitre.
  </para>
  <para>
   Le plugin se charge en interne d'ouvrir et fermer des connexions au maitre et aux esclaves.
   Du point de vue de l'application, il n'y a qu'une seule connexion visible. Cependant, en interne,
   cette connexion est représentée par un groupe de connexions gérées par le plugin.
   Le plugin aiguille les requêtes vers le maitre ou les esclaves en utilisant de multiples
   connexions.
  </para>
  <para>
    Les connexions aux bases de données ont des états, par exemple, le statut des transactions,
   lejeu de caractères, les tables temporaires. Le plugin va tenter de garder les états des
   connexions de manière transparente pour les requêtes qu'il traite, lorsque cela lui est
   possible. Dans les cas contraires, comme par exemple via l'utilisation de
   <literal>BEGIN TRANSACTION</literal>, le plugin laisse l'utilisateur gérer les connexions.
   Voyez les détails ci-après.
  </para>
  
 </section>

 <section xml:id="mysqlnd-ms.pooling">
  <title>Groupe de connexions et bascule entre les connexions</title>
  <para>
   Le plugin de réplication et répartition de charge change la sémantique d'une
   connexion MySQL de PHP. Les API existantes des extensions PHP pour MySQL
   (<link linkend="ref.mysqli">mysqli</link>,
  <link linkend="ref.mysql">mysql</link>,
  <link linkend="ref.pdo-mysql">PDO_MYSQL</link>) sont inchangées, mais leur
   comportement est modifié lorsque le plugin est utilisé. Les applications
   existantes n'ont pas de changement à opérer pour utiliser la nouvelle API,
   mais elles devront peut-être être modifiées en ce qui concerne le comportement
   du plugin.
  </para>
  <para>
   Le plugin casse la relation un-à-un entre une connexion
   <link linkend="ref.mysqli">mysqli</link>,
   <link linkend="ref.mysql">mysql</link>,
   <link linkend="ref.pdo-mysql">PDO_MYSQL</link> et la connexion physique à
   MySQL. Lorsque le plugin est utilisé, la connexion de
   <link linkend="ref.mysqli">mysqli</link>,
   <link linkend="ref.mysql">mysql</link>,
   <link linkend="ref.pdo-mysql">PDO_MYSQL</link> représente en fait un groupe
   de connexions vers un serveur maitre MySQL et des serveurs esclaves.
   Le plugin aiguille les requêtes vers le serveur maitre ou un des esclaves.
   A un moment donné, une connexion vue depuis PHP peut pointer vers le maitre
   et juste après vers un esclave, ou alors toujours le maitre.
  </para>
  <para>
   Chaque connexion MySQL possède un état, et les différentes connexions, gérées dans
   un groupe par le plugin, peuvent avoir chacune des états différents. Lorsque le
   plugin bascule d'une connexion à une autre, l'état est susceptible de changer.
   L'application doit prendre cela en compte.
  </para>
  <para>
   La liste suivante indique ce qui est caractérisé par un état de connexion.
  </para>
  <para>
    <itemizedlist>
     <listitem>
      <simpara>
       Les statuts des transactions
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Les tables temporaires
      </simpara>
    </listitem>
    <listitem>
      <simpara>
       Les verrous des tables
      </simpara>
    </listitem>
    <listitem>
     <simpara>
      Les variables de session (MySQL) système ou utilisateur
     </simpara>
    </listitem>
    <listitem>
      <simpara>
       Les requêtes préparées
      </simpara>
    </listitem>
    <listitem>
      <simpara>
       Les variables <literal>HANDLER</literal>
      </simpara>
    </listitem>
    <listitem>
      <simpara>
       Les verrous retournés par <literal>GET_LOCK()</literal>
      </simpara>
    </listitem>
   </itemizedlist>
  </para>
  <para>
   Le plugin va tenter de conserver l'intégrité des états de connexions dans le groupe
   uniquement si ces connexions sont totalement sous son contrôle ou pour des raisons
   de sécurité. Quelques actions changeant l'état d'une connexion entrent dans cette catégorie.
   Le plugin répercute les appels clients suivants sur toutes les connexions ouvertes dans
   le groupe: <literal>change_user</literal>,
   <literal>select_db</literal>, <literal>set_charset</literal>,
   <literal>set_server_option</literal>, <literal>set_client_option</literal>,
   <literal>autocommit</literal>. 
  </para>
  <para>
   Le plugin <quote>ne se souvient pas</quote> des paramètres, et ne les applique pas aux futures
   connexions. C'est important de s'en souvenir, notamment dans le cas de l'utilisation de
   <link linkend="ini.mysqlnd-ms-plugin-config.lazy_connections">connexions économes</link> (lazy).
   Les connexions économes ("lazy") sont uniquement effectuées lorsque nécessaire, et ce type de
   connexions est utilisé par défaut par le plugin.
  </para>
  <para>
   La bascule entre les connexions se passe juste avant l'exécution des requêtes. Le plugin ne bascule
   pas la connexion courante jusqu'à ce qu'une autre requête arrive à exécution.
  </para>
  <para>
   S'il vous plait, documentez vous correctement sur le manuel de référence de MySQL concernant
   la réplications et ses incidences. Vous pouvez rencontrer des restrictions qui ne sont pas dûes
   à PHP ni au plugin, mais qui sont des caractéristiques du système de réplication de MySQL.
  </para>
 </section>

 <section xml:id="mysqlnd-ms.transaction">
  <title>Gestion des transactions</title>
  <para>
   La gestion des transactions est impactée en profondeur. Une transaction est une unité logique
   lancée par le serveur. Cette unité peut se composer d'une ou plusieurs requêtes.
  </para>
  <para>
    Par défaut, le plugin ne se soucie pas des transactions SQL. Il est donc possible qu'il
    décide de basculer de connexions dans le cadre de la répartition de charge, et ceci peut
   arriver au milieu d'une transaction. C'est contre la nature même d'une transaction SQL, le
   plugin n'est donc pas au courant des transactions par défaut.
  </para>
  <para>
    Les applications qui utilisent des transactions SQL avec le plugin doivent utiliser des
   astuces SQL (artefacts) pour désactiver la bascule automatique de connexion effectuée par
   le plugin. Voyez les détails dans les sections d'exemple.
  </para>
  <para>
    La dernière version de <literal>mysqlnd</literal>, dans
    PHP 5.4.0, permet au plugin de redéfinir l'appel C
    <literal>trx_autocommit()</literal> pour détecter le statut du mode
    <literal>autocommit</literal>. Les extensions MySQL de PHP
    envoient une requête de type <literal>SET AUTOCOMMIT=0|1</literal>
    ou utilisent l'appel <literal>trx_autcommit()</literal> pour contrôler le paramètre
    <literal>autocommit</literal>. Si une extension utilise l'appel
    <literal>trx_autocommit()</literal>, alors le plugin peut être au courant de l'état
    des transactions. Ce n'est pas le cas si du SQL est utilisé pour changer le mode
    autocommit. 
  </para>
  <para>
    L'option de configuration du plugin expérimentale <literal>trx_stickiness=master</literal>
    peut être utilisée pour rendre le plugin sensible aux transactions, en PHP 5.4.0.
    Grâce à ça, le plugin arrête la répartition de charge si l'autocommit est désactivé,
    et la réactive dans le cas contraire.
  </para>
 </section>
 
 <section xml:id="mysqlnd-ms.failover">
  <title>Gestion des incidents (Failover)</title>
  <para>
   La gestion des incidents de connexion est laissée à l'utilisateur. L'application
   est responsable de la vérification des valeurs de retour des fonctions concernant
   les bases de données, et doit réagir en cas de detection d'erreur. Par exemple, si le
   plugin reconnait une requête de type lecture-seule  et l'aiguille vers un serveur esclave
   dont la connexion n'est pas disponible, il renverra une erreur.
  </para>
  <para>
   C'est à l'application de gérer l'erreur, et, si besoin, de re-présenter la requête
   afin qu'elle soit re-prise en charge par le plugin et aiguillée vers un autre serveur.
   Le plugin ne se charge pas de ça lui-même, car il pourrait risquer d'impacter l'état des
   connexions, ce qui n'est pas du tout désirable. Par exemple, l'application peut avoir
   envoyé une requête comportant des variables de session MySQL, celles-ci sont
   dépendantes de la connexion utilisée. Une telle requête ne pourrait donc être
   prise en charge par un mécanisme automatique implémenté dans le plugin.
   L'application doit donc gérer ces cas-là, et aucune gestion des incidents de connexion
   n'est implémentée à l'intérieur du plugin.
  </para>
  <para>
    Un utilisateur ne changeant pas le statut d'une connexion après l'avoir ouverte peut activer
    la gestion des incidents pour le maitre. 
  </para>
  <para>
    Cette gestion des incidents se configure dans le fichier de configuration du plugin au moyen
    de la directive
    <literal><link linkend="ini.mysqlnd-ms-plugin-config.failover">failover</link></literal>.
  </para>
 </section>
 
 <section xml:id="mysqlnd-ms.loadbalancing">
  <title>Répartition de charge</title>
  <para>
    Il existe quatre stratégies de répartition pour distribuer les requêtes de
   type lecture-seule aux serveurs MySQL esclaves: 
    <literal>random</literal>, <literal>random_once</literal> (défaut),
    <literal>roundrobin</literal>, <literal>user</literal>.
  </para>
  <para>
    La stratégie à adopter peut se configurer au moyen de la directive de configuration
    du plugin 
    <link linkend="ini.mysqlnd-ms-plugin-config.pick">pick[]</link>.
  </para>
 </section>
 
 <section xml:id="mysqlnd-ms.rwsplit">
  <title>Séparation des lectures et écritures</title>
  <para>
   Le plugin envoie les requêtes de type lecture seule sur un des esclaves de réplication
   configurés, et les autres requêtes sur le maitre. Les requêtes sont considérées de type
   lecture seule si elle commencent par <literal>SELECT</literal>, si elles comportent
   l'astuce SQL <literal>/*ms=slave*/</literal> ou si un esclave a été choisi lors de la
   dernière requête et que l'astuce SQL <literal>/*ms=last_used*/</literal> est employée.
   Dans tous les autres cas, la requête sera aiguillée vers le serveur maitre.
  </para>  
  <para>
   Les astuces SQL représentent des commentaires SQL spéciaux. Le plugin vérifie toutes les
   requêtes à la recherche de telles astuces. Les astuces SQL sont décrites dans les
   <link linkend="mysqlnd-ms.constants">constantes</link> exportées par l'extension. Les
   autres organes éventuellement présents dans le mécanisme de réplication (serveur MySQL,
   firewalls SQL ou proxies SQL) ne sont pas affectés par les astuces SQL car ils sont sensés
   ignorer les commentaires SQL.
  </para>
  <para>
   L'implémentation interne du séparateur de requêtes lecture/écriture peut être remplacée
   par la votre, voyez <function>mysqlnd_ms_set_user_pick_server</function>.
  </para>
  <para>
   Une implémentation personnalisée du séparateur de requêtes lecture/écriture peut demander
   au plugin où envoyer la requête, en appelant <function>mysqlnd_ms_is_select</function>.
  </para>
  <note>
   <para>
    Le séparateur de requêtes lecture/écriture interne ne gère pas les requêtes multiples qui
    sont vues comme une seule requête. Le séparateur va vérifier le début de la requête pour savoir
    vers quel serveur l'envoyer. Si, par exemple, une requête multiple commence par
    <literal>SELECT 1 FROM DUAL; INSERT INTO test(id) VALUES (1); ...</literal>
    le plugin l'enverra vers un esclave, alors que cette requête n'est pas de type lecture seule.
   </para>
  </note> 
 </section>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
