<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 332747 Maintainer: yannick Status: ready -->
<!-- Reviewed: no -->

<refentry xml:id="function.password-hash" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <refnamediv>
  <refname>password_hash</refname>
  <refpurpose>Crée une clé de hachage pour un mot de passe</refpurpose>
 </refnamediv>

 <refsect1 role="description">
  &reftitle.description;
  <methodsynopsis>
   <type>string</type><methodname>password_hash</methodname>
   <methodparam><type>string</type><parameter>password</parameter></methodparam>
   <methodparam><type>integer</type><parameter>algo</parameter></methodparam>
   <methodparam choice="opt"><type>array</type><parameter>options</parameter></methodparam>
  </methodsynopsis>
  <para>
   La fonction <function>password_hash</function> crée une nouvelle
   clé de hachage en utilisant un algorithme de hachage fort en une pass.
   La fonction <function>password_hash</function> est compatible avec la fonction
   <function>crypt</function>. Aussi, un mot de passe haché par la fonction
   <function>crypt</function> peut être utilisé avec la fonction
   <function>password_hash</function>.
   
  </para>
  <simpara>
   Les algorithmes suivants sont actuellement supportés :
  </simpara>
  <para>
   <itemizedlist>
    <listitem>
     <simpara>
      <constant>PASSWORD_DEFAULT</constant> - Utilisation de l'algorithme bcrypt (par défaut depuis
      PHP 5.5.0). Notez que cette constante est appelée à changer dans le temps, au fur et à mesure
      que de nouveaux et forts algorithmes sont ajoutés à PHP. Aussi, la longueur du résultat
      issu de cet identifiant peut changer dans le temps. Toutefois, il est recommandé de stocker
      le résultat dans une colonne de la base de données qui peut contenir au moins 60 caractères
      (255 caractères peut être un très bon choix).
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <constant>PASSWORD_BCRYPT</constant> - Utilisation de l'algorithme <constant>CRYPT_BLOWFISH</constant>
      pour créer la clé de hachage. Ceci va créer une clé de hachage standard <function>crypt</function>
      utilisant l'identifiant "$2y$". Le résultat sera toujours une chaîne de 60 caractères, &return.falseforfailure;.
     </simpara>
     <para>
      Options supportées :
     </para>
     <itemizedlist>
      <listitem>
       <para>
        <literal>salt</literal> - pour fournir manuellement un salt à utiliser lors du hachage du
        mot de passe. Notez que cette option va écraser tout salt généré automatiquement.
       </para>
       <para>
        Si omis, un salt aléatoire sera généré par la fonction <function>password_hash</function>
        pour chaque mot de passe haché. C'est le mode de fonctionnement prévu.
       </para>
      </listitem>
      <listitem>
       <para>
        <literal>cost</literal> - détermine le coût algorithmique qui doit être utilisé.
        Des exemples de ces valeurs peuvent être trouvés sur la page de la documentation
        de la fonction <function>crypt</function>.
       </para>
       <para>
        Si omis, la valeur par défaut <literal>10</literal> sera utilisée. C'est un bon compromis,
        mais vous pourriez vouloir l'augmenter suivant votre architecture.
       </para>
      </listitem>
     </itemizedlist>
    </listitem>
   </itemizedlist>
  </para>
 </refsect1>

 <refsect1 role="parameters">
  &reftitle.parameters;
  <variablelist>
   <varlistentry>
    <term><parameter>password</parameter></term>
    <listitem>
     <para>
      &password.parameter.password;
     </para>
      <caution>
       <para>
        L'utilisation de la constante <constant>PASSWORD_BCRYPT</constant>
        pour le paramètre <parameter>algo</parameter> fera que le paramètre
        <parameter>password</parameter> sera tronqué à une longueur maximale de
        72 caractères. Cela ne survient que si vous utilisez le même salt
        pour hasher les chaînes avec cette algorithme, avec une longueur supérieure
        à 72 octets, ce qui ferait que les hashs seraient identiques.
       </para>
      </caution>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><parameter>algo</parameter></term>
    <listitem>
     <para>
      &password.parameter.algo;
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><parameter>options</parameter></term>
    <listitem>
     <para>
      &password.parameter.options;
     </para>
     <para>
      Si omis, un salt aléatoire sera créé et le cost par défaut sera
      utilisé.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1 role="returnvalues">
  &reftitle.returnvalues;
  <para>
   Retourne le mot de passe haché, &return.falseforfailure;.
  </para>
  <para>
   L'algorithme utilisé, le coût et le salt sont retournés comme partis
   du hash. Aussi, toutes les informations utiles pour vérifier le hash
   y sont inclus. Ceci permet à la fonction <function>password_verify</function>
   de vérifier le hash sans avoir besoin de stockage séparé pour les informations
   concernant le salt ou l'algorithme.
  </para>
 </refsect1>

 <refsect1 role="examples">
  &reftitle.examples;
  <para>
   <example>
    <title>Exemple avec <function>password_hash</function></title>
    <programlisting role="php">
<![CDATA[
<?php
/**
 * Nous voulons juste hacher notre mot de passe en utiliant l'algorithme par défaut.
 * Actuellement, il s'agit de BCRYPT, et produira un résultat sous forme de chaîne de
 * caractères d'une longueur de 60 caractères.
 *
 * Gardez à l'esprit que DEFAULT peut changer dans le temps, aussi, vous devriez vous
 * y préparer en autorisant un stockage supérieur à 60 caractères (255 peut être un bon choix)
 */

echo password_hash("rasmuslerdorf", PASSWORD_DEFAULT)."\n";
?>
]]>
    </programlisting>
    &example.outputs.similar;
    <screen>
<![CDATA[
$2y$10$.vGA1O9wmRjrwAVXD98HNOgsNpDczlqm3Jq7KnEd1rVAGv3Fykk1a
]]>
    </screen>
   </example>
  </para>
  <para>
   <example>
    <title>Exemple avec <function>password_hash</function> en définissant manuellement l'option cost</title>
    <programlisting role="php">
<![CDATA[
<?php
/**
 * Dans ce cas, nous souhaitons augmenter le "cost" par défaut pour BCRYPT à la valeur 12.
 * Notez que nous passons également à l'algorithme BCRYPT, qui produit toujours un résultat
 * de 60 caractères.
 */

$options = [
    'cost' => 12,
];
echo password_hash("rasmuslerdorf", PASSWORD_BCRYPT, $options)."\n";
?>
]]>
    </programlisting>
    &example.outputs.similar;
    <screen>
<![CDATA[
$2y$12$QjSH496pcT5CEbzjD/vtVeH03tfHKFy36d4J0Ltp3lRtee9HDxY3K
]]>
    </screen>
   </example>
  </para>
  
  <para>
   <example>
    <title>Exemple avec <function>password_hash</function> et une définition du salt manuelle</title>
    <programlisting role="php">
<![CDATA[
<?php
/**
 * Notez que le salt est généré aléatoirement.
 * Ne jamais utiliser un salt statique, ou un qui ne serait pas généré aléatoirement.
 *
 * Pour la grande majorité des cas, laissez la fonction password_hash générer le salt
 * aléatoirement à votre place
 */
$options = [
    'cost' => 11,
    'salt' => mcrypt_create_iv(22, MCRYPT_DEV_URANDOM),
];
echo password_hash("rasmuslerdorf", PASSWORD_BCRYPT, $options)."\n";
?>
]]>
    </programlisting>
    &example.outputs.similar;
    <screen>
<![CDATA[
$2y$11$q5MkhSBtlsJcNEVsYh64a.aCluzHnGog7TQAKVmQwO9C8xb.t89F.
]]>
    </screen>
   </example>
  </para>
  <para>
   <example>
    <title>Exemple avec <function>password_hash</function> et un bon "cost"</title>
    <programlisting role="php">
<![CDATA[
<?php
/**
 * Ce code va tester votre serveur pour déterminer quel serait le meilleur "cost".
 * Vous souhaitez définir le "cost" le plus élevé possible sans trop ralentir votre serveur.
 * 10 est une bonne base, mais une valeur plus élevée est aussi un bon choix à partir
 * du moment où votre serveur est suffisament rapide !
 */
$timeTarget = 0.2; 

$cost = 9;
do {
    $cost++;
    $start = microtime(true);
    password_hash("test", PASSWORD_BCRYPT, ["cost" => $cost]);
    $end = microtime(true);
} while (($end - $start) < $timeTarget);

echo "Valeur de 'cost' la plus appropriée : " . $cost . "\n";
?>
]]>
    </programlisting>
    &example.outputs.similar;
    <screen>
<![CDATA[
Valeur de 'cost' la plus appropriée : 11
]]>
    </screen>
   </example>
  </para>
 </refsect1>
 
 <refsect1 role="notes">
  &reftitle.notes;
  <caution>
   <para>
    Il est vivement recommandé de ne pas générer vous-même votre propre salt pour cette fonction.
    La fonction va générer un salt sécurisé automatiquement pour vous si vous n'en spécifiez pas un !
   </para>
  </caution>
  <note>
   <para>
    Il est recommandé de tester cette fonction sur vos serveurs, et d'ajuster le paramètre "cost"
    afin que l'exécution de cette fonction prenne approximativement entre 0.1 et 0.5 secondes.
    Le script dans l'exemple ci-dessus vous aide à choisir une bonne valeur suivant votre
    architecture matérielle.
   </para>
  </note>
  <note>
   <simpara>
    La mise à jour des algorithmes supportés par cette fonction (ou le changement à celui par
    défaut) doit suivre les règles suivantes :
   </simpara>
   <para>
    <itemizedlist>
     <listitem>
      <simpara>
       Chaque nouvel algorithme doit faire parti du coeur de PHP pendant au moins 1 version complète
       avant de prétendre à devenir l'algorithme par défaut. Aussi, si, par exemple, un nouvel
       algorithme est ajouté en version 5.5.5, il ne sera éligible comme algorithme par défaut qu'à
       partir de PHP 5.7 (sachant que 5.6 sera la première version complète). Mais si un algorithme
       différent a été ajouté en 5.6.0, il sera aussi éligible comme algorithme par défaut
       à partir de la version 5.7.0.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       L'algorithme par défaut ne peut être changé que lors d'une version complète (5.6.0, 6.0.0, etc...)
       et non pendant une version de révision. La seule exception à ce principe de base serait une
       urgence, par exemple, lors de la découverte d'un bogue critique au niveau de la sécurité
       dans l'algorithme par défaut.
      </simpara>
     </listitem>
    </itemizedlist>
   </para>
  </note>
 </refsect1>

 <refsect1 role="seealso">
  &reftitle.seealso;
  <para>
   <simplelist>
    <member><function>password_verify</function></member>
    <member><function>crypt</function></member>
    <member><link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="&url.password.compat;">l'implémentation en espace utilisateur</link></member>
   </simplelist>
  </para>
 </refsect1>

</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
