<?xml version="1.0" encoding="iso-8859-1"?>
<!-- splitted from ./fr/functions/ming.xml, last change in rev 1.7 -->
<!-- last change to 'swfaction' in en/ tree in rev 1.24 -->
  <refentry id="function.swfaction">
   <refnamediv>
    <refname>SWFAction</refname>
    <refpurpose>Crée une nouvelle action.</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>new</type><methodname>swfaction</methodname>
      <methodparam><type>string</type><parameter>script</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>swfaction</function> crée une nouvelle action, et
     compile le script <parameter>script</parameter>.
    </para>
    <para>
     La syntaxe du script est basée sur le langage C, mais il utilise
     aussi beaucoup de notions propres à SWF : le bytecode SWF est trop
     simpliste pour faire l'essentiel de ce que l'on veut. Par exemple,
     il n'est pas possible de faire des fonctions sans descendre profondément
     dans les entrailles de la machine, car le bytecode de saut est écrit
     en dur. Pas moyen de pousser une adresse dans la pile, ou de dépiler -
     Chaque fonction doit savoir exactement où elle retourne.
    </para>
    <para>
     Alors, que reste-t-il? Le compilateur reconnaît les mots suivants :
     <itemizedlist>
      <listitem>
       <simpara>
        break
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        for
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        continue
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        if
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        else
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        do
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        while
       </simpara>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     Il n'y a pas de type de données : toutes les valeurs de SWF sont stockées comme
     des chaînes de caractères. Les fonctions suivantes peuvent être utilisées dans
     les expressions :
     <variablelist>
      <varlistentry>
       <term>time()</term>
       <listitem>
	    <simpara>
    	 Retourne le nombre de milli-secondes depuis le début de
    	 l'animation.
	    </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>random(seed)</term>
       <listitem>
	    <simpara>
	     Retourne un nombre pseudo-aléatoire, entre 0 et seed.
	    </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>length(expr)</term>
       <listitem>
	    <simpara>
	     Retourne la taille de l'expression donnée.
	    </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>int(number)</term>
       <listitem>
	    <simpara>
	     Retourne le nombre number, arrondi à l'entier inférieur le plus proche.
	    </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>concat(expr, expr)</term>
       <listitem>
	    <simpara>
	     Retourne la concaténation des deux expressions.
	    </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>ord(expr)</term>
       <listitem>
	    <simpara>
	     Retourne le code ASCII du caractère expr.
	    </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>chr(num)</term>
       <listitem>
	    <simpara>
	     Retourne le caractère pour le code ASCII num.
	    </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>substr(string, location, length)</term>
       <listitem>
	    <simpara>
	     Retourne la sous-chaîne, extraite de string, de longueur
	     length et commençant au caractère location.
	    </simpara>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
    <para>
     De plus, les commandes suivantes sont accessibles :
     <variablelist>
      <varlistentry>
       <term>duplicateClip(clip, name, depth)</term>
       <listitem>
	    <simpara>
	     Duplique le sprite nommé clip. La nouvelle animation a le nouveau nom
	     name et la profondeur depth.
	    </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>removeClip(expr)</term>
       <listitem>
	    <simpara>
	     Supprime l'animation nommée expr.
	    </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>trace(expr)</term>
       <listitem>
	    <simpara>
	     Ecrit l'expression expr dans le fichier de d'historique.
	     Il est peut probable que le navigateur ou le lecteur ne fasse
	     quoi que ce soit avec.
	    </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>startDrag(target, lock, [left, top, right, bottom])</term>
       <listitem>
	    <simpara>
	     Comment à déplacer l'animation target. L'argument lock indique
	     si le déplacement verrouille la souris (utilisez 0, &false;)
	     ou  1 (&true;)). Les paramètres optionnels
	     délimitent la zone de déplacement.
	    </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>stopDrag()</term>
       <listitem>
	    <simpara>
	     Cesse le déplacement de l'animation.
	    </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>callFrame(expr)</term>
       <listitem>
	    <simpara>
	     Appelle l'image expr comme une fonction.
	    </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>getURL(url, target, [method])</term>
       <listitem>
	    <simpara>
	     Charge l'URL url dans l'objet target. target peut être l'image courante
	     (je pense) ou une des valeurs magiques "_level0" (remplace l'animation
	     courante) ou "_level1" (charge une nouvelle animation à la place de
	     la courante). L'argument optionnel method peut être post ou get, si vous
	     voulez envoyer des variables au serveur.
	    </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>loadMovie(url, target)</term>
       <listitem>
	    <simpara>
	     La même chose que ci-dessus, plus ou moins. En fait, je ne sais pas
	     trop quelle est la différence.
	    </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>nextFrame()</term>
       <listitem>
	    <simpara>
	     Va à l'image suivante.
	    </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>prevFrame()</term>
       <listitem>
	    <simpara>
	     Va à l'image précédente.
	    </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>play()</term>
       <listitem>
	    <simpara>
	     Joue l'animation.
	    </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>stop()</term>
       <listitem>
	    <simpara>
	     Cesse de jouer l'animation.
	    </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>toggleQuality()</term>
       <listitem>
	    <simpara>
	     Passe de haute en basse qualité (et vice-versa).
	    </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>stopSounds()</term>
       <listitem>
	    <simpara>
	     Cesse de jouer les sons.
	    </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>gotoFrame(num)</term>
       <listitem>
	    <simpara>
	     Va à l'image numéro num. Les images sont numérotées à
	     partir de 0.
	    </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>gotoFrame(name)</term>
       <listitem>
	    <simpara>
	     Va à l'image nommée name. Ce qui est carrément cool, car
	     les labels ne sont pas encore supportés pour les images.
	    </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>setTarget(expr)</term>
       <listitem>
	    <simpara>
	     Modifie le contexte de l'action. C'est ce qu'ils disent, mais
	     je n'ai pas trop d'idées là-dessus.
	    </simpara>
       </listitem>
      </varlistentry>
     </variablelist>
     Et il y a un truc bizarre : l'expression frameLoaded(num) peut être
     utilise dans les conditions if et dans les boucles while pour
     vérifier si une image a été chargée. En tous cas, c'est ce qu'il est
     supposé faire, mais je ne l'ai jamais testé, et je doute sérieusement
     que cela fonctionne. Vous pouvez utiliser plutôt /:framesLoaded à la place.
    </para>
    <para>
     Les sprites ont des propriétés. Vous pouvez les lire toutes
     (vraiment?), en modifier quelques unes. Les voici :
      <itemizedlist>
       <listitem>
        <simpara>
         x
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         y
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         xScale
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         yScale
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         currentFrame - (lecture seule)
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         totalFrames - (lecture seule)
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         alpha - Niveau de transparence
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         visible - 1=on, 0=off (?)
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         width - (lecture seule)
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         height - (lecture seule)
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         rotation
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         target - (lecture seule) (???)
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         framesLoaded - (lecture seule)
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         name
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         dropTarget - (lecture seule) (???)
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         url - (lecture seule) (???)
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         highQuality - 1=high, 0=low (?)
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         focusRect - (???)
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         soundBufTime - (???)
        </simpara>
       </listitem>
      </itemizedlist>
      Modifier la position d'un sprite est aussi simple que
      <literal>/box.x = 100;</literal>. Pourquoi le slash initial?
      C'est comme cela que Flash garde la trace des sprites dans les
      animations, un peu comme des fichiers sous Unix. Si le sprite
      qui s'appelle box a lui-même un autre sprite appelé biff, vous
      pouvez y accéder avec la commande <literal>/box/biff.x = 100;</literal>.
      En tous cas, ça marche pour moi. Corrigez moi si c'est faux!.
    </para>
    <para>
     Cet exemple simple va déplacer le gros carré rouge dans la fenêtre.
     <example>
      <title>Exemple avec <function>swfaction</function></title>
      <programlisting role="php">
&lt;?php
 $s = new SWFShape();
  $f = $s-&gt;addFill(0xff, 0, 0);
  $s-&gt;setRightFill($f);
  $s-&gt;movePenTo(-500,-500);
  $s-&gt;drawLineTo(500,-500);
  $s-&gt;drawLineTo(500,500);
  $s-&gt;drawLineTo(-500,500);
  $s-&gt;drawLineTo(-500,-500);
  $p = new SWFSprite();
  $i = $p-&gt;add($s);
  $i-&gt;setDepth(1);
  $p-&gt;nextFrame();
  for($n=0; $n&lt;5; ++$n)
  {
    $i-&gt;rotate(-15);
    $p-&gt;nextFrame();
  }
  $m = new SWFMovie();
  $m-&gt;setBackground(0xff, 0xff, 0xff);
  $m-&gt;setDimension(6000,4000);
  $i = $m-&gt;add($p);
  $i-&gt;setDepth(1);
  $i-&gt;moveTo(-500,2000);
  $i-&gt;setName("box");
  $m-&gt;add(new SWFAction("/box.x += 3;"));
  $m-&gt;nextFrame();
  $m-&gt;add(new SWFAction("gotoFrame(0); play();"));
  $m-&gt;nextFrame();
  header('Content-type: application/x-shockwave-flash');
  $m-&gt;output();
?&gt;
      </programlisting>
     </example>
    </para>
    <para>
     Cet exemple suit votre souris sur l'écran.
     <example>
      <title>Exemple avec <function>swfaction</function></title>
      <programlisting role="php">
&lt;?php
  $m = new SWFMovie();
  $m-&gt;setRate(36.0);
  $m-&gt;setDimension(1200, 800);
  $m-&gt;setBackground(0, 0, 0);
  /* sprite de suivi de souris : vide, mais il suit la souris
  de manière à ce que nous connaissions ses coordonnées*/
  $i = $m-&gt;add(new SWFSprite());
  $i-&gt;setName('mouse');
  $m-&gt;add(new SWFAction("
    startDrag('/mouse', 1); /* '1' signifie verrouiller la souris */
  "));
  /* On peut tout simplement virer l'anti-aliasing, car il n'y a
  que des gros carrés, finalement */
  $m-&gt;add(new SWFAction("
    this.quality = 0;
  "));
  /* boîte de morphing */
  $r = new SWFMorph();
  $s = $r-&gt;getShape1();
  /* Notez que ce n'est pas pratique pour les formes habituelles.
  Aucune idée de pourquoi */
  $s-&gt;setLeftFill($s-&gt;addFill(0xff, 0xff, 0xff));
  $s-&gt;movePenTo(-40, -40);
  $s-&gt;drawLine(80, 0);
  $s-&gt;drawLine(0, 80);
  $s-&gt;drawLine(-80, 0);
  $s-&gt;drawLine(0, -80);
  $s = $r-&gt;getShape2();
  $s-&gt;setLeftFill($s-&gt;addFill(0x00, 0x00, 0x00));
  $s-&gt;movePenTo(-1, -1);
  $s-&gt;drawLine(2, 0);
  $s-&gt;drawLine(0, 2);
  $s-&gt;drawLine(-2, 0);
  $s-&gt;drawLine(0, -2);
  /* sprite contenant la boîte de morphing -
     c'est juste un scénario avec une boîte de morphing */
  $box = new SWFSprite();
  $box-&gt;add(new SWFAction("
    stop();
  "));
  $i = $box-&gt;add($r);
  for($n=0; $n&lt;=20; ++$n)
  {
    $i-&gt;setRatio($n/20);
    $box-&gt;nextFrame();
  }
  /* ce conteneur nous permet d'utiliser la même action plusieurs fois */
  $cell = new SWFSprite();
  $i = $cell-&gt;add($box);
  $i-&gt;setName('box');
  $cell-&gt;add(new SWFAction("
    setTarget('box');
    /* ...x signifie abscisse du parent, c'est-à-dire (..).x */
    dx = (/mouse.x + random(6)-3 - ...x)/5;
    dy = (/mouse.y + random(6)-3 - ...y)/5;
    gotoFrame(int(dx*dx + dy*dy));
  "));
  $cell-&gt;nextFrame();
  $cell-&gt;add(new SWFAction("
    gotoFrame(0);
    play();
  "));
  $cell-&gt;nextFrame();
  /* finalement, ajoutons quelques cellules à l'animation */
  for($x=0; $x&lt;12; ++$x)
  {
    for($y=0; $y8; ++$y)
    {
      $i = $m-&gt;add($cell);
      $i-&gt;moveTo(100*$x+50, 100*$y+50);
    }
  }
  $m-&gt;nextFrame();
  $m-&gt;add(new SWFAction("
    gotoFrame(1);
    play();
  "));
  header('Content-type: application/x-shockwave-flash');
  $m-&gt;output();
?&gt;
      </programlisting>
     </example>
    </para>
    <para>
     La même chose que ci-dessus, mais en couleurs.
     <example>
      <title>Exemple avec <function>swfaction</function></title>
      <programlisting role="php">
&lt;?php
  $m = new SWFMovie();
  $m-&gt;setDimension(11000, 8000);
  $m-&gt;setBackground(0x00, 0x00, 0x00);
  $m-&gt;add(new SWFAction("
this.quality = 0;
/frames.visible = 0;
startDrag('/mouse', 1);
  "));
  // sprite de suivi de souris
  $t = new SWFSprite();
  $i = $m-&gt;add($t);
  $i-&gt;setName('mouse');
  $g = new SWFGradient();
  $g-&gt;addEntry(0, 0xff, 0xff, 0xff, 0xff);
  $g-&gt;addEntry(0.1, 0xff, 0xff, 0xff, 0xff);
  $g-&gt;addEntry(0.5, 0xff, 0xff, 0xff, 0x5f);
  $g-&gt;addEntry(1.0, 0xff, 0xff, 0xff, 0);
  // gradient
  $s = new SWFShape();
  $f = $s-&gt;addFill($g, SWFFILL_RADIAL_GRADIENT);
  $f-&gt;scaleTo(0.03);
  $s-&gt;setRightFill($f);
  $s-&gt;movePenTo(-600, -600);
  $s-&gt;drawLine(1200, 0);
  $s-&gt;drawLine(0, 1200);
  $s-&gt;drawLine(-1200, 0);
  $s-&gt;drawLine(0, -1200);
  // on en fait un sprite pour utiliser la fonction multColor()
  $p = new SWFSprite();
  $p-&gt;add($s);
  $p-&gt;nextFrame();
  // Ajoute la forme ici, chaque forme dans une couleur différente
  $q = new SWFSprite();
  $q-&gt;add(new SWFAction("gotoFrame(random(7)+1); stop();"));
  $i = $q-&gt;add($p);
  $i-&gt;multColor(1.0, 1.0, 1.0);
  $q-&gt;nextFrame();
  $i-&gt;multColor(1.0, 0.5, 0.5);
  $q-&gt;nextFrame();
  $i-&gt;multColor(1.0, 0.75, 0.5);
  $q-&gt;nextFrame();
  $i-&gt;multColor(1.0, 1.0, 0.5);
  $q-&gt;nextFrame();
  $i-&gt;multColor(0.5, 1.0, 0.5);
  $q-&gt;nextFrame();
  $i-&gt;multColor(0.5, 0.5, 1.0);
  $q-&gt;nextFrame();
  $i-&gt;multColor(1.0, 0.5, 1.0);
  $q-&gt;nextFrame();
  // Enfin, le code de l'action
  $p = new SWFSprite();
  $i = $p-&gt;add($q);
  $i-&gt;setName('frames');
  $p-&gt;add(new SWFAction("
dx = (/:mousex-/:lastx)/3 + random(10)-5;
dy = (/:mousey-/:lasty)/3;
x = /:mousex;
y = /:mousey;
alpha = 100;
  "));
  $p-&gt;nextFrame();
  $p-&gt;add(new SWFAction("
this.x = x;
this.y = y;
this.alpha = alpha;
x += dx;
y += dy;
dy += 3;
alpha -= 8;
  "));
  $p-&gt;nextFrame();
  $p-&gt;add(new SWFAction("prevFrame(); play();"));
  $p-&gt;nextFrame();
  $i = $m-&gt;add($p);
  $i-&gt;setName('frames');
  $m-&gt;nextFrame();
  $m-&gt;add(new SWFAction("
lastx = mousex;
lasty = mousey;
mousex = /mouse.x;
mousey = /mouse.y;
++num;
if(num == 11)
  num = 1;
removeClip('char' &amp; num);
duplicateClip(/frames, 'char' &amp; num, num);
  "));
  $m-&gt;nextFrame();
  $m-&gt;add(new SWFAction("prevFrame(); play();"));
  header('Content-type: application/x-shockwave-flash');
  $m-&gt;output();
?&gt;
      </programlisting>
     </example>
    </para>
    <para>
     Cet exemple simple gère le clavier (vous devrez cependant
     cliquer dans la fenêtre pour lui donner le focus, et vous
     devrez aussi laisser votre souris dans la fenêtre. Si vous
     savez comment faire cela automatiquement, dites-le moi!).
     <example>
      <title>Exemple avec <function>swfaction</function></title>
      <programlisting role="php">
&lt;?php
  /* Le sprite n'a qu'une lettre par image */
  $p = new SWFSprite();
  $p-&gt;add(new SWFAction("stop();"));
  $chars = "abcdefghijklmnopqrstuvwxyz".
	   "ABCDEFGHIJKLMNOPQRSTUVWXYZ".
           "1234567890!&#64;#$%^&amp;*()_+-=/[]{}|;:,.&lt;&gt;?`~";
  $f = new SWFFont("_sans");
  for($n=0; $nremove($i);
    $t = new SWFTextField();
    $t-&gt;setFont($f);
    $t-&gt;setHeight(240);
    $t-&gt;setBounds(600,240);
    $t-&gt;align(SWFTEXTFIELD_ALIGN_CENTER);
    $t-&gt;addString($c);
    $i = $p-&gt;add($t);
    $p-&gt;labelFrame($c);
    $p-&gt;nextFrame();
  }
  /* région de clic pour le bouton : toute la fenêtre */
  $s = new SWFShape();
  $s-&gt;setFillStyle0($s-&gt;addSolidFill(0, 0, 0, 0));
  $s-&gt;drawLine(600, 0);
  $s-&gt;drawLine(0, 400);
  $s-&gt;drawLine(-600, 0);
  $s-&gt;drawLine(0, -400);
  /* le bouton s'assure des touches pressées, et envoie le bon
     sprite à l'image de droite */
  $b = new SWFButton();
  $b-&gt;addShape($s, SWFBUTTON_HIT);
  for($n=0; $naddAction(new SWFAction("
setTarget('/char');
gotoFrame('$c');
    "), SWFBUTTON_KEYPRESS($c));
  }
  $m = new SWFMovie();
  $m-&gt;setDimension(600,400);
  $i = $m-&gt;add($p);
  $i-&gt;setName('char');
  $i-&gt;moveTo(0,80);
  $m-&gt;add($b);
  header('Content-type: application/x-shockwave-flash');
  $m-&gt;output();
?&gt;
      </programlisting>
     </example>
    </para>
   </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
