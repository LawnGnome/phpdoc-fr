<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.16 $ -->
<!-- EN-Revision: 1.10 Maintainer: yannick Status: ready -->
<!-- Reviewed: yes -->
  <refentry id="function.swfaction">
   <refnamediv>
    <refname>SWFAction</refname>
    <refpurpose>Crée une nouvelle action</refpurpose>
   </refnamediv>
   <refsect1>
    &reftitle.description;
     <methodsynopsis>
      <type>SWFAction</type><methodname>swfaction</methodname>
      <methodparam><type>string</type><parameter>script</parameter></methodparam>
     </methodsynopsis>
    &warn.experimental.func;
    <para>
     <function>SWFAction</function> crée une nouvelle action et
     compile le script <parameter>script</parameter>.
    </para>
    <para>
     La syntaxe du script est basée sur le langage C, mais celui-ci utilise
     aussi beaucoup de notions propres à SWF : le bytecode SWF est trop
     simpliste pour faire l'essentiel de ce que l'on veut. Par exemple,
     il n'est pas possible de faire des fonctions sans descendre profondément
     dans les entrailles de la machine, car le bytecode de saut est écrit
     en dur. Pas moyen de pousser une adresse dans la pile, ou de dépiler -
     Chaque fonction doit savoir exactement où elle retourne.
    </para>
    <para>
     Alors, que reste-t-il ? Le compilateur reconnaît les mots suivants :
     <itemizedlist>
      <listitem>
       <simpara>
        break
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        for
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        continue
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        if
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        else
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        do
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        while
       </simpara>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     Il n'y a pas de type de données : toutes les valeurs de SWF sont stockées comme
     des chaînes de caractères. Les fonctions suivantes peuvent être utilisées dans
     les expressions :
     <variablelist>
      <varlistentry>
       <term>time()</term>
       <listitem>
        <simpara>
         Retourne le nombre de milli-secondes depuis le début de
         l'animation.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>random(seed)</term>
       <listitem>
        <simpara>
         Retourne un nombre pseudo-aléatoire, entre 0 et seed.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>length(expr)</term>
       <listitem>
        <simpara>
         Retourne la taille de l'expression donnée.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>int(number)</term>
       <listitem>
        <simpara>
         Retourne le nombre number, arrondi à l'entier inférieur le plus proche.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>concat(expr, expr)</term>
       <listitem>
        <simpara>
         Retourne la concaténation des deux expressions.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>ord(expr)</term>
       <listitem>
        <simpara>
         Retourne le code ASCII du caractère expr.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>chr(num)</term>
       <listitem>
        <simpara>
         Retourne le caractère pour le code ASCII num.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>substr(string, location, length)</term>
       <listitem>
        <simpara>
         Retourne la sous-chaîne, extraite de <parameter>string</parameter>, de longueur
         <parameter>length</parameter> et commençant au caractère 
         <parameter>location</parameter>.
        </simpara>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
    <para>
     De plus, les commandes suivantes sont accessibles :
     <variablelist>
      <varlistentry>
       <term>duplicateClip(clip, name, depth)</term>
       <listitem>
        <simpara>
         Duplique le sprite nommé <parameter>clip</parameter>. La nouvelle animation a le nouveau nom
         <parameter>name</parameter> et la profondeur <parameter>depth</parameter>.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>removeClip(expr)</term>
       <listitem>
        <simpara>
         Supprime l'animation nommée expr.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>trace(expr)</term>
       <listitem>
        <simpara>
         Ecrit l'expression expr dans le fichier d'historique.
         Il est peut probable que le navigateur ou le lecteur fasse
         quoi que ce soit avec.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>startDrag(target, lock, [left, top, right, bottom])</term>
       <listitem>
        <simpara>
         Commence à déplacer l'animation <parameter>target</parameter>. L'argument 
         <parameter>lock</parameter> indique
         si le déplacement verrouille la souris (utilisez 0, &false;)
         ou  1 (&true;)). Les paramètres optionnels
         délimitent la zone de déplacement.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>stopDrag()</term>
       <listitem>
        <simpara>
         Cesse le déplacement de l'animation.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>callFrame(expr)</term>
       <listitem>
        <simpara>
         Appelle l'image expr comme une fonction.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>getURL(url, target, [method])</term>
       <listitem>
        <simpara>
         Charge l'URL url dans l'objet target. <parameter>target</parameter> correspond
         à l'élément target du document HTML (comme "_top" ou "_blank").
         L'argument optionnel <parameter>method</parameter> peut être POST ou GET, si 
         vous voulez envoyer des variables au serveur.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>loadMovie(url, target)</term>
       <listitem>
        <simpara>
         Charge l'URL url dans l'objet target. <parameter>target</parameter> peut être l'image courante
         (je pense) ou une des valeurs magiques "_level0" (remplace l'animation
         courante) ou "_level1" (charge une nouvelle animation à la place de
         la courante).
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>nextFrame()</term>
       <listitem>
        <simpara>
         Va à l'image suivante.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>prevFrame()</term>
       <listitem>
        <simpara>
         Va à l'image précédente.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>play()</term>
       <listitem>
        <simpara>
         Joue l'animation.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>stop()</term>
       <listitem>
        <simpara>
         Cesse de jouer l'animation.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>toggleQuality()</term>
       <listitem>
        <simpara>
         Passe de haute en basse qualité (et vice-versa).
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>stopSounds()</term>
       <listitem>
        <simpara>
         Cesse de jouer les sons.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>gotoFrame(num)</term>
       <listitem>
        <simpara>
         Va à l'image numéro <parameter>num</parameter>. Les images sont numérotées à
         partir de 0.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>gotoFrame(name)</term>
       <listitem>
        <simpara>
         Va à l'image nommée <parameter>name</parameter>. Ce qui est carrément cool, car
         les labels ne sont pas encore supportés pour les images.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>setTarget(expr)</term>
       <listitem>
        <simpara>
         Modifie le contexte de l'action. C'est ce qu'ils disent, mais
         je n'ai pas trop d'idées là-dessus.
        </simpara>
       </listitem>
      </varlistentry>
     </variablelist>
     Et il y a un truc bizarre : l'expression frameLoaded(num) peut être
     utilisée dans les conditions if et dans les boucles while pour
     vérifier si une image a été chargée. En tous cas, c'est ce qu'elle est
     supposé faire, mais je ne l'ai jamais testée, et je doute sérieusement
     que cela fonctionne. Vous pouvez utiliser plutôt /:framesLoaded à la place.
    </para>
    <para>
     Les sprites ont des propriétés. Vous pouvez les lire toutes
     (vraiment?), en modifier quelques-unes. Les voici :
      <itemizedlist>
       <listitem>
        <simpara>
         x
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         y
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         xScale
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         yScale
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         currentFrame - (lecture seule)
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         totalFrames - (lecture seule)
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         alpha - Niveau de transparence
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         visible - 1=on, 0=off (?)
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         width - (lecture seule)
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         height - (lecture seule)
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         rotation
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         target - (lecture seule) (???)
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         framesLoaded - (lecture seule)
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         name
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         dropTarget - (lecture seule) (???)
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         url - (lecture seule) (???)
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         highQuality - 1=high, 0=low (?)
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         focusRect - (???)
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         soundBufTime - (???)
        </simpara>
       </listitem>
      </itemizedlist>
      Modifier la position d'un sprite est aussi simple que
      <literal>/box.x = 100;</literal>. Pourquoi le slash initial ?
      C'est comme cela que Flash garde la trace des sprites dans les
      animations, un peu comme des fichiers sous Unix. Si le sprite
      qui s'appelle box a lui-même un autre sprite appelé biff, vous
      pouvez y accéder avec la commande <literal>/box/biff.x = 100;</literal>.
      En tous cas, ça marche pour moi. Corrigez-moi si c'est faux!.
    </para>
    <para>
     Cet exemple simple va déplacer le gros carré rouge dans la fenêtre.
     <example>
      <title>Exemple avec <function>swfaction</function></title>
      <programlisting role="php">
<![CDATA[
<?php
  $s = new SWFShape();
  $f = $s->addFill(0xff, 0, 0);
  $s->setRightFill($f);

  $s->movePenTo(-500, -500);
  $s->drawLineTo(500, -500);
  $s->drawLineTo(500, 500);
  $s->drawLineTo(-500, 500);
  $s->drawLineTo(-500, -500);

  $p = new SWFSprite();
  $i = $p->add($s);
  $i->setDepth(1);
  $p->nextFrame();

  for ($n=0; $n<5; ++$n) {
    $i->rotate(-15);
    $p->nextFrame();
  }

  $m = new SWFMovie();
  $m->setBackground(0xff, 0xff, 0xff);
  $m->setDimension(6000, 4000);

  $i = $m->add($p);
  $i->setDepth(1);
  $i->moveTo(-500,2000);
  $i->setName("box");

  $m->add(new SWFAction("/box.x += 3;"));
  $m->nextFrame();
  $m->add(new SWFAction("gotoFrame(0); play();"));
  $m->nextFrame();

  header('Content-type: application/x-shockwave-flash');
  $m->output();
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Cet exemple suit votre souris sur l'écran.
     <example>
      <title>Exemple avec <function>swfaction</function></title>
      <programlisting role="php">
<![CDATA[
<?php

$m = new SWFMovie();
$m->setRate(36.0);
$m->setDimension(1200, 800);
$m->setBackground(0, 0, 0);

/* sprite de suivi de souris : vide, mais il suit la souris
  de manière à ce que nous connaissions ses coordonnées */

$i = $m->add(new SWFSprite());
$i->setName('mouse');

$m->add(new SWFAction("
  startDrag('/mouse', 1); /* '1' signifie verrouiller la souris */
"));

/*  On peut tout simplement virer l'anti-aliasing, car il n'y a
  que des gros carrés, finalement */

$m->add(new SWFAction("
  this.quality = 0;
"));

/* boîte de morphing */
$r = new SWFMorph();
$s = $r->getShape1();

/* Notez que ce n'est pas pratique pour les formes habituelles.
  Aucune idée de pourquoi */
$s->setLeftFill($s->addFill(0xff, 0xff, 0xff));
$s->movePenTo(-40, -40);
$s->drawLine(80, 0);
$s->drawLine(0, 80);
$s->drawLine(-80, 0);
$s->drawLine(0, -80);

$s = $r->getShape2();

$s->setLeftFill($s->addFill(0x00, 0x00, 0x00));
$s->movePenTo(-1, -1);
$s->drawLine(2, 0);
$s->drawLine(0, 2);
$s->drawLine(-2, 0);
$s->drawLine(0, -2);

/* sprite contenant la boîte de morphing -
    c'est juste un scénario avec une boîte de morphing */

$box = new SWFSprite();
$box->add(new SWFAction("
  stop();
"));
$i = $box->add($r);

for ($n=0; $n<=20; ++$n) {
  $i->setRatio($n/20);
  $box->nextFrame();
}

/* ce conteneur nous permet d'utiliser la même action plusieurs fois */

$cell = new SWFSprite();
$i = $cell->add($box);
$i->setName('box');

$cell->add(new SWFAction("

  setTarget('box');

  /* ...x représente les x coordonnées du parent, i.e. (..).x */
  dx = (/mouse.x + random(6)-3 - ...x)/5;
  dy = (/mouse.y + random(6)-3 - ...y)/5;
  gotoFrame(int(dx*dx + dy*dy));

"));

$cell->nextFrame();
$cell->add(new SWFAction("

  gotoFrame(0);
  play();

"));

$cell->nextFrame();

/* finalement, ajoutons quelques cellules à l'animation */

for ($x=0; $x<12; ++$x) {
  for ($y=0; $y<8; ++$y) {
    $i = $m->add($cell);
    $i->moveTo(100*$x+50, 100*$y+50);
  }
}

$m->nextFrame();

$m->add(new SWFAction("

  gotoFrame(1);
  play();

"));

header('Content-type: application/x-shockwave-flash');
$m->output();
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     La même chose que ci-dessus, mais en couleurs.
     <example>
      <title>Exemple avec <function>swfaction</function></title>
      <programlisting role="php">
<![CDATA[
<?php

$m = new SWFMovie();
$m->setDimension(11000, 8000);
$m->setBackground(0x00, 0x00, 0x00);

$m->add(new SWFAction("

this.quality = 0;
/frames.visible = 0;
startDrag('/mouse', 1);

"));

// sprite de suivi de souris
$t = new SWFSprite();
$i = $m->add($t);
$i->setName('mouse');

$g = new SWFGradient();
$g->addEntry(0, 0xff, 0xff, 0xff, 0xff);
$g->addEntry(0.1, 0xff, 0xff, 0xff, 0xff);
$g->addEntry(0.5, 0xff, 0xff, 0xff, 0x5f);
$g->addEntry(1.0, 0xff, 0xff, 0xff, 0);

// gradient
$s = new SWFShape();
$f = $s->addFill($g, SWFFILL_RADIAL_GRADIENT);
$f->scaleTo(0.03);
$s->setRightFill($f);
$s->movePenTo(-600, -600);
$s->drawLine(1200, 0);
$s->drawLine(0, 1200);
$s->drawLine(-1200, 0);
$s->drawLine(0, -1200);

// on en fait un sprite pour utiliser la fonction multColor()
$p = new SWFSprite();
$p->add($s);
$p->nextFrame();

// Ajoute la forme ici, chaque forme dans une couleur différente
$q = new SWFSprite();
$q->add(new SWFAction("gotoFrame(random(7)+1); stop();"));
$i = $q->add($p);

$i->multColor(1.0, 1.0, 1.0);
$q->nextFrame();
$i->multColor(1.0, 0.5, 0.5);
$q->nextFrame();
$i->multColor(1.0, 0.75, 0.5);
$q->nextFrame();
$i->multColor(1.0, 1.0, 0.5);
$q->nextFrame();
$i->multColor(0.5, 1.0, 0.5);
$q->nextFrame();
$i->multColor(0.5, 0.5, 1.0);
$q->nextFrame();
$i->multColor(1.0, 0.5, 1.0);
$q->nextFrame();

// Enfin, le code de l'action
$p = new SWFSprite();
$i = $p->add($q);
$i->setName('frames');
$p->add(new SWFAction("

dx = (/:mousex-/:lastx)/3 + random(10)-5;
dy = (/:mousey-/:lasty)/3;
x = /:mousex;
y = /:mousey;
alpha = 100;

  "));
$p->nextFrame();

$p->add(new SWFAction("

this.x = x;
this.y = y;
this.alpha = alpha;
x += dx;
y += dy;
dy += 3;
alpha -= 8;

  "));
$p->nextFrame();

$p->add(new SWFAction("prevFrame(); play();"));
$p->nextFrame();

$i = $m->add($p);
$i->setName('frames');
$m->nextFrame();

$m->add(new SWFAction("

lastx = mousex;
lasty = mousey;
mousex = /mouse.x;
mousey = /mouse.y;

++num;

if (num == 11)
  num = 1;

removeClip('char' & num);
duplicateClip(/frames, 'char' & num, num);

  "));

$m->nextFrame();
$m->add(new SWFAction("prevFrame(); play();"));

header('Content-type: application/x-shockwave-flash');
$m->output();
?>
]]>
      </programlisting>
     </example>
    </para>
    <!-- 
    <para>
     Cet exemple simple gère le clavier (vous devrez cependant
     cliquer dans la fenêtre pour lui donner le focus, et vous
     devrez aussi laisser votre souris dans la fenêtre. Si vous
     savez comment faire cela automatiquement, dites-le moi!).
     <example>
      <title>Exemple avec <function>swfaction</function></title>
      <programlisting role="php">
<![CDATA[
<?php

/* Le sprite n'a qu'une lettre par image */
$p = new SWFSprite();
$p->add(new SWFAction("stop();"));
$chars = "abcdefghijklmnopqrstuvwxyz".
           "ABCDEFGHIJKLMNOPQRSTUVWXYZ".
           "1234567890!@#$%^&*()_+-=/[]{}|;:,.<>?`~";
$f = new SWFFont("_sans");
for($n=0; $nremove($i) ) {
  $t = new SWFTextField();
  $t->setFont($f);
  $t->setHeight(240);
  $t->setBounds(600,240);
  $t->align(SWFTEXTFIELD_ALIGN_CENTER);
  $t->addString($c);
  $i = $p->add($t);
  $p->labelFrame($c);
  $p->nextFrame();
}
/* région de clic pour le bouton : toute la fenêtre */
$s = new SWFShape();
$s->setFillStyle0($s->addSolidFill(0, 0, 0, 0));
$s->drawLine(600, 0);
$s->drawLine(0, 400);
$s->drawLine(-600, 0);
$s->drawLine(0, -400);
/* le bouton s'assure des touches pressées, et envoie le bon
    sprite à l'image de droite */
$b = new SWFButton();
$b->addShape($s, SWFBUTTON_HIT);
for($n=0; $naddAction(new SWFAction("
setTarget('/char');
gotoFrame('$c');
    "), SWFBUTTON_KEYPRESS($c));
}
$m = new SWFMovie();
$m->setDimension(600,400);
$i = $m->add($p);
$i->setName('char');
$i->moveTo(0,80);
$m->add($b);
header('Content-type: application/x-shockwave-flash');
$m->output();

?>
]]>
      </programlisting>
     </example>
    </para>
    -->
   </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
