<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.1 $ -->
<!-- splitted from ./en/functions/exec.xml, last change in rev 1.28 -->
  <refentry id="function.proc-open">
   <refnamediv>
    <refname>proc_open</refname>
    <refpurpose>
     Ex&eacute;cute une commande et ouvre les pointeurs de fichiers pour les entr&eacute;es sorties
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>resource</type><methodname>proc_open</methodname>
      <methodparam><type>string</type><parameter>cmd</parameter></methodparam>
      <methodparam><type>array</type><parameter>descriptorspec</parameter></methodparam>
      <methodparam><type>array</type><parameter>pipes</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>proc_open</function> est similaire &agrave; <function>popen</function>
     mais fournie un plus grand degr&eacute; de contr&ocirc;le sur l'ex&eacute;cution du programme.
     <parameter>cmd</parameter> est la commande qui doit &ecirc;tre ex&eacute;cut&eacute;e par le shell.
     <parameter>descriptorspec</parameter> est un tableau index&eacute;, dont les cl&eacute;s
     repr&eacute;sentent le num&eacute;ro de descripteur, et la valeur repr&eacute;sente la m&eacute;thode
     avec laquelle &php; va passer ce descripteur au processus fils.
     <parameter>pipes</parameter> recevra un tableau index&eacute; de pointeurs de
     fichiers, qui correspondent aux sorties dans &php; de tous les pipes
     qui sont cr&eacute;&eacute;s. La valeur retourn&eacute;e est une ressource, qui repr&eacute;sente le
     processus. Il faudra la d&eacute;tuire avec la fonction <function>proc_close</function>
     lorsque vous aurez fini.
    </para>
    <para>
     <example>
      <title>Exemple avec <function>proc_open</function></title>
      <programlisting role="php">
<![CDATA[
<?php
$descriptorspec = array(
   0 => array("pipe", "r"),  // stdin est un pipe o&ugrave; le processus va lire
   1 => array("pipe", "w"),  // stdout est un pipe o&ugrave; le processus va &eacute;crire
   2 => array("file", "/tmp/error-output.txt", "a"), // stderr est un fichier
);
$process = proc_open("php", $descriptorspec, $pipes);
if (is_resource($process)) {
    // $pipes ressemble &agrave; : 
    // 0 => fichier accessible en &eacute;criture, connect&eacute; &agrave; l'entr&eacute;e standard du prcessus fils
    // 1 => fichier accessible en lecture, connect&eacute; &agrave; la sortie standard du prcessus fils
    // Toute erreur sera ajout&eacute;e au fichier /tmp/error-output.txt

    fwrite($pipes[0], "<?php echo \"Bonjour le monde!\"; ?>");
    fclose($pipes[0]);

    while(!feof($pipes[1])) {
        echo fgets($pipes[1], 1024);
    }
    fclose($pipes[1]);
    // Il est important que vous fermiez les pipes avant d'appeler
    // proc_close() afin d'&eacute;viter un verrouillage.
    $return_value = proc_close($process);

    echo "La commande a retourn&eacute;e $return_value\n";
}
?>
]]>
     </programlisting>
     </example>
    </para>
    <para>
     Les num&eacute;ros de descripteurs de fichiers de <parameter>descriptorspec</parameter> 
     ne sont pas limit&eacute;es &agrave; 0, 1 et 2 : vous pouvez sp&eacute;cifier n'importe quel
     num&eacute;ro de descripteur valide, et il sera pass&eacute; au processus fils. Cela 
     permettra &agrave; votre script d'inter op&eacute;rer avec d'autres scripts, et d'&ecirc;tre
     ex&eacute;cut&eacute; comme "co-processus". En particulier, c'est tr&egrave;s pratique pour
     passer des mots de passes &agrave; des programmes comme PGP, GPG et openssl,
     avec une m&eacute;thode tr&egrave;s prot&eacute;g&eacute;e. C'est aussi pratique pour lire des
     informations de statut fournies par ces programmes, sur des descripteurs
     auxiliaires.
    </para>
    <note>
     <para>
      Compatibilit&eacute; Windows : les descripteurs au-dela de 2 (stderr) sont
      accessibles au processus fils, sous la forme de pointeurs h&eacute;ritables, mais
      comme l'architecture Windows n'associe pas de nombre aux descripteurs
      de bas niveau, le processus fils n'a (actuellement) aucun moyen 
      d'y acc&eacute;der. Stdin, stdout et stderr fonctionnent comme d'habitude.
     </para>
    </note>
    <note>
     <para>
      Cette fonction a &eacute;t&eacute; introduite en PHP 4.3.0.
     </para>
    </note>
    <note>
     <para>
      Si vous n'avez besoin que d'un processus uni-directionnel,
      <function>popen</function> sera plus pratique, car plus simple &agrave; 
      utiliser.
     </para>
    </note>

    <para>
     Voir aussi
     <function>exec</function>, 
     <function>system</function>,
     <function>passthru</function>, 
     <function>popen</function>,
     <function>escapeshellcmd</function>, et 
     <link linkend="language.operators.execution">l'op&eacute;rateur de backticks</link>.
    </para>

   </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
