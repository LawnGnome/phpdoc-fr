<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.6 $ -->
<!-- EN-Revision: 1.9 Maintainer: dams Status: ready -->
  <refentry id="function.proc-open">
   <refnamediv>
    <refname>proc_open</refname>
    <refpurpose>
     Exécute une commande et ouvre les pointeurs de fichiers pour les entrées sorties
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>resource</type><methodname>proc_open</methodname>
      <methodparam><type>string</type><parameter>cmd</parameter></methodparam>
      <methodparam><type>array</type><parameter>descriptorspec</parameter></methodparam>
      <methodparam><type>array</type><parameter>pipes</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>proc_open</function> est similaire à <function>popen</function>
     mais fournit un plus grand degré de contrôle sur l'exécution du programme.
     <parameter>cmd</parameter> est la commande qui doit être exécutée par le shell.
     <parameter>descriptorspec</parameter> est un tableau indexé, dont les clés
     représentent le numéro de descripteur et la valeur la méthode
     avec laquelle &php; va passer ce descripteur au processus fils.
     <parameter>pipes</parameter> recevra un tableau indexé de pointeurs de
     fichiers qui correspondent aux sorties dans &php; de tous les pipes
     qui sont créés. La valeur retournée est une ressource qui représente le
     processus. Il faudra la détuire avec la fonction <function>proc_close</function>
     lorsque vous aurez fini.
    </para>
    <para>
     <example>
      <title>Exemple avec <function>proc_open</function></title>
      <programlisting role="php">
<![CDATA[
<?php
$descriptorspec = array(
   0 => array("pipe", "r"),  // stdin est un pipe où le processus va lire
   1 => array("pipe", "w"),  // stdout est un pipe où le processus va écrire
   2 => array("file", "/tmp/error-output.txt", "a"), // stderr est un fichier
);
$process = proc_open("php", $descriptorspec, $pipes);
if (is_resource($process)) {
    // $pipes ressemble à : 
    // 0 => fichier accessible en écriture, connecté à l'entrée standard du processus fils
    // 1 => fichier accessible en lecture, connecté à la sortie standard du processus fils
    // Toute erreur sera ajoutée au fichier /tmp/error-output.txt

    fwrite($pipes[0], "<?php echo     "Bonjour le monde!\"; ?>");
    fclose($pipes[0]);

    while(!feof($pipes[1])) {
        echo fgets($pipes[1], 1024);
    }
    fclose($pipes[1]);
    // Il est important que vous fermiez les pipes avant d'appeler
    // proc_close() afin d'éviter un verrouillage.
    $return_value = proc_close($process);

    echo "La commande a retourné $return_value\n";
}
?>
]]>
     </programlisting>
     </example>
    </para>
    <para>
     &php; 5RC2 introduit le suppport pty pour les systèmes avec Unix98 ptys. 
     Cela permet à votre script d'interagir avec des applications qui
     s'attendent à dialoguer avec un terminal. Un pty fonctionne comme un pipe,
     mais est bi-directionnel : il n'y a pas besoin de spécifier de mode lecture
     ou écriture. L'exemple ci-dessous montre comment utiliser un pty. Notez
     que tous les pointeurs de fichier ne doivent pas ncéessairement dialoguer
     avec le pty. Notez aussi que seul un pty est créé, même si pty est
     spécifié 3 fois. Dans les futures versions de &php; il sera possible de faire
     plus que simplement lire et écrire dans un pty.
    </para>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
// Crée un pseudo terminal pour le processus fils
$descriptorspec = array(
   0 => array("pty"),
   1 => array("pty"),
   2 => array("pty")
);
$process = proc_open("cvs -d:pserver:cvsread@cvs.php.net:/repository login", $descriptorspec, $pipes);
if (is_resource($process)) {
   // Travaille sur la documentation PHP ici
}
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Les numéros de descripteurs de fichiers de <parameter>descriptorspec</parameter> 
     ne sont pas limités à 0, 1 et 2 : vous pouvez spécifier n'importe quel
     numéro de descripteur valide, et il sera passé au processus fils. Cela 
     permettra à votre script d'inter opérer avec d'autres scripts, et d'être
     exécuté comme "co-processus". En particulier, c'est très pratique pour
     passer des mots de passes à des programmes comme PGP, GPG et openssl,
     avec une méthode très protégée. C'est aussi pratique pour lire des
     informations de statut fournies par ces programmes, sur des descripteurs
     auxiliaires.
    </para>
    <note>
     <para>
      Compatibilité Windows : les descripteurs au-dela de 2 (stderr) sont
      accessibles au processus fils, sous la forme de pointeurs héritables, mais
      comme l'architecture Windows n'associe pas de nombre aux descripteurs
      de bas niveau, le processus fils n'a (actuellement) aucun moyen 
      d'y accéder. Stdin, stdout et stderr fonctionnent comme d'habitude.
     </para>
    </note>
    <note>
     <para>
      Si vous n'avez besoin que d'un processus uni-directionnel,
      <function>popen</function> sera plus pratique, car plus simple à 
      utiliser.
     </para>
    </note>
    <para>
     Voir aussi
     <function>stream_select</function>,
     <function>exec</function>,
     <function>system</function>,
     <function>passthru</function>,
     <function>popen</function>,
     <function>escapeshellcmd</function> et
     les <link linkend="language.operators.execution">opérateurs backtick</link>.
    </para>
   </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
