<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.23 $ -->
<!-- EN-Revision: 1.17 Maintainer: dams Status: ready -->
<!-- Reviewed: no -->

  <refentry id="function.array-multisort">
   <refnamediv>
    <refname>array_multisort</refname>
    <refpurpose>Tri multi-dimensionnel de tableaux</refpurpose>
   </refnamediv>
   <refsect1>
    &reftitle.description;
    <methodsynopsis>
     <type>bool</type><methodname>array_multisort</methodname>
     <methodparam><type>array</type><parameter>ar1</parameter></methodparam>
     <methodparam choice="opt"><type>mixed</type><parameter>arg</parameter></methodparam>
     <methodparam choice="opt"><type>mixed</type><parameter>...</parameter></methodparam>
     <methodparam choice="opt"><type>array</type><parameter>...</parameter></methodparam>
     <!-- Les paramètre n'ont pas besoin d'être passés par référence -->
    </methodsynopsis>
    <para>
     &return.success;
    </para>
    <para>
     <function>array_multisort</function> sert à trier simultanément
     plusieurs tableaux, ou bien à trier un tableau multi-dimensionnel,
     suivant l'une ou l'autre de ses dimensions.
    </para>
    <para>
     Les clés associatives (&string;) seront maintenues, mais 
     les clés numériques seront réindexées.
    </para>
    
   <para>
    Les tableaux passés en arguments <parameter>ar1</parameter>, 
    <parameter>arg</parameter>, <parameter>...</parameter> sont traités comme
    les colonnes d'une table, triées par lignes (un peu comme la clause SQL 
    <literal>ORDER BY</literal>). Le premier tableau est la clé primaire de 
    tri. Les valeurs du premier tableau qui sont égales, sont triées grâce 
    au tableau suivant, et ainsi de suite...
   </para>
   <para>
    La structure des arguments de <function>array_multisort</function> est
    un peu inhabituelle, mais elle est plus souple. Le premier argument 
    <emphasis>doit</emphasis> être un tableau. Par la suite, chaque argument
    peut être soit un tableau, soit une option de tri prise parmi les valeurs
    suivantes :
   </para>
   <para>
    Options de tri :
    <itemizedlist>
     <listitem>
      <simpara><constant>SORT_ASC</constant> : Tri en ordre ascendant</simpara>
     </listitem>
     <listitem>
      <simpara><constant>SORT_DESC</constant> : Tri en ordre descendant</simpara>
     </listitem>
    </itemizedlist>
   </para>
   <para>
    Options de type de tri :
    <itemizedlist>
     <listitem>
      <simpara>
        <constant>SORT_REGULAR</constant> : comparaison normale des valeurs
      </simpara>
     </listitem>
     <listitem>
      <simpara>
        <constant>SORT_NUMERIC</constant> : comparaison numérique des valeurs
      </simpara>
     </listitem>
     <listitem>
      <simpara>
        <constant>SORT_STRING</constant> : Comparaison alphabétique des valeurs
      </simpara>
     </listitem>
    </itemizedlist>
   </para>
   <para>
    Une seule option de tri de chaque type peut être appliquée
    après un tableau. Une option ne s'applique qu'au tableau
    précédent. Tous les autres sont mis par défaut
    à <constant>SORT_ASC</constant> et <constant>SORT_REGULAR</constant>.
   </para>
   
   <para>
    <example>
     <title>Trier plusieurs tableaux</title>
     <programlisting role="php">
<![CDATA[
<?php
$ar1 = array("10", 100, 100, "a");
$ar2 = array(1, 3, "2", 1);
array_multisort($ar1, $ar2);

var_dump($ar1);
var_dump($ar2);
?>
]]>
     </programlisting>
     <para>
      Dans cet exemple, après le tri, le premier
      tableau contient 10, "a", 100, 100. Le deuxième tableau
      contient 1, 1, "2", 3. Les entrées du second tableau
      correspondant aux valeurs jumelles du premier
      tableau (100 et 100), sont aussi triées.
     </para>
     <screen>
<![CDATA[
array(4) {
  [0]=> string(2) "10"
  [1]=> string(1) "a"
  [2]=> int(100)
  [3]=> int(100)
}
array(4) {
  [0]=> int(1)
  [1]=> int(1)
  [2]=> string(1) "2"
  [3]=> int(3)
}
]]>     
     </screen>
    </example>
   </para>
   
   <para>
    <example>
     <title>Classer un tableau multi-dimensionnel</title>
     <programlisting role="php">
<![CDATA[
<?php
$ar = array(
       array("10", 11, 100, 100, "a"), 
       array(   1,  2, "2",   3,   1)
      );
array_multisort($ar[0], SORT_ASC, SORT_STRING,
                $ar[1], SORT_NUMERIC, SORT_DESC);
var_dump($ar);
?>
]]>
     </programlisting>
     <para>
      Dans cet exemple, après le tri, le premier tableau contient
      10, 100, 100, 11, "a" (tri alphabétique, ordre croissant); Le
      deuxième tableau contient 1, 3, "2", 2, 1 (tri
      numérique, ordre décroissant).
     </para>
     <screen>
<![CDATA[
array(2) {
  [0]=> array(5) {
    [0]=> string(2) "10"
    [1]=> int(100)
    [2]=> int(100)
    [3]=> int(11)
    [4]=> string(1) "a"
  }
  [1]=> array(5) {
    [0]=> int(1)
    [1]=> int(3)
    [2]=> string(1) "2"
    [3]=> int(2)
    [4]=> int(1)
  }
}
]]>
     </screen>
    </example>
   </para>

    <para>
     <example>
      <title>Classer les résultats d'une base de données</title>
      <para>
       Dans cet exemple, chaque élément du tableau <varname>data</varname>
       représente une ligne de la table. Ce type de données est typique d'un
       enregistrement de base de données.
      </para>
      <para>
       Exemple de données :
      </para>
      <screen>
<![CDATA[
volume | edition
-------+--------
    67 |       2
    86 |       1
    85 |       6
    98 |       2
    86 |       6
    67 |       7
]]>
      </screen>
      <para>
       Les données sont sous forme de tableau, appelé <varname>data</varname>. 
       Cela est généralement issu, par exemple, par la fonction 
       <function>mysql_fetch_assoc</function>.
      </para>
      <programlisting role="php">
<![CDATA[
<?php
$data[] = array('volume' => 67, 'edition' => 2);
$data[] = array('volume' => 86, 'edition' => 1);
$data[] = array('volume' => 85, 'edition' => 6);
$data[] = array('volume' => 98, 'edition' => 2);
$data[] = array('volume' => 86, 'edition' => 6);
$data[] = array('volume' => 67, 'edition' => 7);
?>
]]>
      </programlisting>
      <para>
       Dans cet exemple, nous allons trier la colonne
       <varname>volume</varname> par ordre décroissant, et
       la colonne <varname>edition</varname> par ordre croissant.
      </para>
      <para>
       Nous avons un tableau de lignes, mais 
       <function>array_multisort</function> nécessite un tableau de colonnes, 
       donc nous utilisons le code suivant pour obtenir les colonnes et 
       ainsi effectuer le tri.
      </para>
      <programlisting role="php">
<![CDATA[
<?php
// Obtient une liste de colonnes
foreach ($data as $key => $row) {
    $volume[$key]  = $row['volume'];
    $edition[$key] = $row['edition'];
}

// Tri les données par volume décroissant, edition croissant
// Ajoute $data en tant que dernier paramètre, pour trier par la clé commune
array_multisort($volume, SORT_DESC, $edition, SORT_ASC, $data);
?>
]]>
      </programlisting>
      <para>
       L'enregistrement est maintenant trié et ressemble à cela :
      </para>
      <screen>
<![CDATA[
volume | edition
-------+--------
    98 |       2
    86 |       1
    86 |       6
    85 |       6
    67 |       2
    67 |       7
]]>
      </screen>
     </example>
    </para>

    <para>
     <example>
      <title>Tri non sensible à la casse</title>
      <para>
       <constant>SORT_STRING</constant> et
       <constant>SORT_REGULAR</constant> sont sensibles à la casse, les chaînes
       de caractères commençant avec une lettre en majuscule viendront avant
       les chaînes de caractères commençant par une lettre en minuscule.
      </para>
      <para>
       Pour effectuer une recherche insensible à la casse, effectuez le tri
       sur une copie minuscule des colonnes du tableau original.
      </para>
      <programlisting role="php">
<![CDATA[
<?php
$array = array('Alpha', 'atomic', 'Beta', 'bank');
$array_lowercase = array_map('strtolower', $array);

array_multisort($array_lowercase, SORT_ASC, SORT_STRING, $array);

print_r($array);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Array
(
    [0] => Alpha
    [1] => atomic
    [2] => bank
    [3] => Beta
)
]]>
      </screen>
     </example>
    </para>

   </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
