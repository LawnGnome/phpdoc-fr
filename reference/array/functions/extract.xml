<?xml version="1.0" encoding="iso-8859-1"?>
<!-- splitted from ./fr/functions/array.xml, last change in rev 1.30 -->
<!-- last change to 'extract' in en/ tree in rev 1.2 -->
 <refentry id="function.extract">
  <refnamediv>
   <refname>extract</refname>
   <refpurpose>
    Importe les variables dans la table des symboles
   </refpurpose>
  </refnamediv>
  <refsect1>
   <title>Description</title>
    <methodsynopsis>
     <type>int</type><methodname>extract</methodname>
     <methodparam><type>array</type><parameter>var_array</parameter></methodparam>
     <methodparam choice="opt"><type>int</type><parameter>extract_type</parameter></methodparam>
     <methodparam choice="opt"><type>string</type><parameter>prefix</parameter></methodparam>
    </methodsynopsis>
   <para>
    <function>extract</function> sert &agrave; exporter un tableau vers
    la table des symboles. Elle prend un tableau associatif
    <parameter>var_array</parameter>, cr&eacute;e les variables dont les
    noms sont les index de ce tableau, et leur affecte la valeur associ&eacute;e.
    Pour chaque paire cl&eacute;/valeur, <function>extract</function> cr&eacute;e
    une variable, avec les param&egrave;tres <parameter>extract_type</parameter>
    et <parameter>prefix</parameter>.
   </para>
   <note>
    <para>
     Depuis la version 4.0.5, <function>extract</function> retourne le nombre de
     variables extraites.
    </para>
   </note>
    <note>
     <para>
      <constant>EXTR_IF_EXISTS</constant> et <constant>EXTR_PREFIX_IF_EXISTS</constant> 
      ont été introduites en &php; version 4.2.0.
     </para>
    </note>
    <note>
     <para>
      <constant>EXTR_REFS</constant> a été introduite en &php; 4.3.0.
     </para>
    </note>
   <para>
    <function>extract</function> v&eacute;rifie l'existence de la variable avant
    de la cr&eacute;er. Le traitement des collisions est
    d&eacute;termin&eacute; par <parameter>extract_type</parameter>.
    Ce param&egrave;tre peut prendre une des valeurs suivantes :
    <variablelist>
    <varlistentry>
    <term><constant>EXTR_OVERWRITE</constant></term>
    <listitem>
     <simpara>
      Lors d'une collision, r&eacute;&eacute;crire la variable existante.
     </simpara>
    </listitem>
    </varlistentry>
    <varlistentry>
    <term><constant>EXTR_SKIP</constant></term>
    <listitem>
     <simpara>
      Lors d'une collision, ne pas r&eacute;&eacute;crire la variable existante.
     </simpara>
    </listitem>
    </varlistentry>
    <varlistentry>
    <term><constant>EXTR_PREFIX_SAME</constant></term>
    <listitem>
     <simpara>
      Lors d'une collision, ajouter le pr&eacute;fixe <parameter>prefix</parameter>,
      et cr&eacute;er une nouvelle variable.
     </simpara>
    </listitem>
    </varlistentry>
    <varlistentry>
    <term><constant>EXTR_PREFIX_ALL</constant></term>
    <listitem>
     <simpara>
      Ajouter le pr&eacute;fixe <parameter>prefix</parameter>, et cr&eacute;er
      une nouvelle variable.
     </simpara>
    </listitem>
    </varlistentry>
    <varlistentry>
    <term><constant>EXTR_PREFIX_INVALID</constant></term>
    <listitem>
     <simpara>
      Pr&eacute;fixer uniquement les variables aux noms invalides ou num&eacute;riques
      avec le pr&eacute;fixe <parameter>prefix</parameter>. Ceci a
      &eacute;t&eacute; ajout&eacute; en PHP 4.0.5.
     </simpara>
    </listitem>
    </varlistentry>
     <varlistentry>
       <term><constant>EXTR_IF_EXISTS</constant></term>
       <listitem>
        <simpara>
         Écrase la variable uniquement si elle existe déjà dans la
         table des symboles, et sinon, ne rien faire. Ceci est 
         pratique pour définir une liste de variables valides, puis
         d'extraire du tableau les valeurs que vous avez déjà définies
         grâce à <varname>$_REQUEST</varname>, par exemple.
         Cette option a été ajoutée en &php; 4.2.0.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><constant>EXTR_PREFIX_IF_EXISTS</constant></term>
       <listitem>
        <simpara>
         Ne crée que des variables préfixées, si la version non préfixée
         de la même variable existe dans la table des symboles courante.
         Cette option a été ajoutée en &php; 4.2.0.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><constant>EXTR_REFS</constant></term>
       <listitem>
        <simpara>
         Extrait les variables sous forme de références. Cela signifie que
         les valeurs des variables importées font toujours référence aux
         valeurs des variables d'orgine dans le paramètre 
         <parameter>var_array</parameter>. Vous pouvez utiliser cette
         option seule, ou bien la combiner avec d'autres option avec
         l'opérateur OR, dans le paramètre <parameter>extract_type</parameter>. 
         Cette option a été ajoutée en &php; 4.3.0.
        </simpara>
       </listitem>
      </varlistentry>
    </variablelist>
   </para>
   <para>
    Si <parameter>extract_type</parameter> est omis, <function>extract</function>
    utilise <constant>EXTR_OVERWRITE</constant> par d&eacute;faut.
   </para>
   <para>
    Notez que <parameter>prefix</parameter> n'est n&eacute;cessaire que pour
    les valeurs de <parameter>extract_type</parameter> suivantes :
    <constant>EXTR_PREFIX_SAME</constant>, <constant>EXTR_PREFIX_ALL</constant>, 
    <constant>EXTR_PREFIX_INVALID</constant> ou <constant>EXTR_PREFIX_IF_EXISTS</constant>. 
    Le r&eacute;sultat pr&eacute;fix&eacute; n'est pas un nom de variable valide,
    il ne sera pas import&eacute; dans la table des symboles.
   </para>
   <para>
    <function>extract</function> retourne le nombre de variables r&eacute;ellement
    import&eacute;es dans la table des symboles.
   </para>
   <para>
    Une utilisation possible de la fonction <function>extract</function> est l'exportation
    vers la table des symboles de tableaux de variables retourn&eacute;s
    par <function>wddx_deserialize</function>.
   </para>
   <para>
    <example>
     <title>Exemple avec <function>extract</function></title>
     <programlisting role="php">
<![CDATA[
<?php
/* Supposons que $var_array est un tableau retourn&eacute; 
   par wddx_deserialize() */
  $taille = "grand";
  $var_array = array("couleur" => "bleu",
                     "taille"  => "moyen",
                     "forme" => "sphere");
  extract($var_array, EXTR_PREFIX_SAME, "wddx");
  print "$couleur, $taille, $forme, $wddx_taille\n";
?>
]]>
     </programlisting>
    </example>
   </para>
    <para>
     The above example will produce:
     <programlisting>
<![CDATA[
bleu, grand, sphere, moyen
]]>
     </programlisting>
    </para>
   <para>
    La variable $taille n'a pas &eacute;t&eacute; r&eacute;&eacute;crite, car on
    avait sp&eacute;cifi&eacute; le param&egrave;tre <constant>EXTR_PREFIX_SAME</constant>, qui a permis
    la cr&eacute;ation $wddx_size. Si <constant>EXTR_SKIP</constant> avait &eacute;t&eacute;
    utilis&eacute;, alors $wddx_size n'aurait pas &eacute;t&eacute;
    cr&eacute;&eacute;. Avec <constant>EXTR_OVERWRITE</constant>, $taille aurait pris la valeur "moyen",
    et avec <constant>EXTR_PREFIX_ALL</constant>, les variables cr&eacute;&eacute;es seraient
    $wddx_couleur, $wddx_taille, et $wddx_forme.
   </para>
    <para>
     Vous devez utiliser un tableau associatif. Un tableau indexé numériquement
     ne produira aucun résultat, à moins que vous n'utilisiez l'option
     <constant>EXTR_PREFIX_ALL</constant> ou <constant>EXTR_PREFIX_INVALID</constant>.
    </para>
    <para>
     Voir aussi
     <function>compact</function>.
    </para>
  </refsect1>
 </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
