<?xml version="1.0" encoding="iso-8859-1"?>
<!-- splitted from ./fr/functions/array.xml, last change in rev 1.30 -->
<!-- last change to 'extract' in en/ tree in rev 1.2 -->
 <refentry id="function.extract">
  <refnamediv>
   <refname>extract</refname>
   <refpurpose>
    Importe les variables dans la table des symboles
   </refpurpose>
  </refnamediv>
  <refsect1>
   <title>Description</title>
    <methodsynopsis>
     <type>int</type><methodname>extract</methodname>
     <methodparam><type>array</type><parameter>var_array</parameter></methodparam>
     <methodparam choice="opt"><type>int</type><parameter>extract_type</parameter></methodparam>
     <methodparam choice="opt"><type>string</type><parameter>prefix</parameter></methodparam>
    </methodsynopsis>
   <para>
    <function>extract</function> sert &agrave; exporter un tableau vers
    la table des symboles. Elle prend un tableau associatif
    <parameter>var_array</parameter>, cr&eacute;e les variables dont les
    noms sont les index de ce tableau, et leur affecte la valeur associ&eacute;e.
    Pour chaque paire cl&eacute;/valeur, <function>extract</function> cr&eacute;e
    une variable, avec les param&egrave;tres <parameter>extract_type</parameter>
    et <parameter>prefix</parameter>.
   </para>
   <note>
    <para>
     Depuis la version 4.0.5, <function>extract</function> retourne le nombre de
     variables extraites.
    </para>
   </note>
   <para>
    <function>extract</function> v&eacute;rifie l'existence de la variable avant
    de la cr&eacute;er. Le traitement des collisions est
    d&eacute;termin&eacute; par <parameter>extract_type</parameter>.
    Ce param&egrave;tre peut prendre une des valeurs suivantes :
    <variablelist>
    <varlistentry>
    <term>EXTR_OVERWRITE</term>
    <listitem>
     <simpara>
      Lors d'une collision, r&eacute;&eacute;crire la variable existante.
     </simpara>
    </listitem>
    </varlistentry>
    <varlistentry>
    <term>EXTR_SKIP</term>
    <listitem>
     <simpara>
      Lors d'une collision, ne pas r&eacute;&eacute;crire la variable existante.
     </simpara>
    </listitem>
    </varlistentry>
    <varlistentry>
    <term>EXTR_PREFIX_SAME</term>
    <listitem>
     <simpara>
      Lors d'une collision, ajouter le pr&eacute;fixe <parameter>prefix</parameter>,
      et cr&eacute;er une nouvelle variable.
     </simpara>
    </listitem>
    </varlistentry>
    <varlistentry>
    <term>EXTR_PREFIX_ALL</term>
    <listitem>
     <simpara>
      Ajouter le pr&eacute;fixe <parameter>prefix</parameter>, et cr&eacute;er
      une nouvelle variable.
     </simpara>
    </listitem>
    </varlistentry>
    <varlistentry>
    <term>EXTR_PREFIX_INVALID</term>
    <listitem>
     <simpara>
      Pr&eacute;fixer uniquement les variables aux noms invalides ou num&eacute;riques
      avec le pr&eacute;fixe <parameter>prefix</parameter>. Ceci a
      &eacute;t&eacute; ajout&eacute; en PHP 4.0.5.
     </simpara>
    </listitem>
    </varlistentry>
    </variablelist>
   </para>
   <para>
    Si <parameter>extract_type</parameter> est omis, <function>extract</function>
    utilise EXTR_OVERWRITE par d&eacute;faut.
   </para>
   <para>
    Notez que <parameter>prefix</parameter> n'est n&eacute;cessaire que pour
    les valeurs de <parameter>extract_type</parameter> suivantes :
    EXTR_PREFIX_SAME, EXTR_PREFIX_ALL ou EXTR_PREFIX_INVALID. Le r&eacute;sultat
    pr&eacute;fix&eacute; n'est pas un nom de variable valide,
    il ne sera pas import&eacute; dans la table des symboles.
   </para>
   <para>
    <function>extract</function> retourne le nombre de variables r&eacute;ellement
    import&eacute;es dans la table des symboles.
   </para>
   <para>
    Une utilisation possible de la fonction <function>extract</function> est l'exportation
    vers la table des symboles de tableaux de variables retourn&eacute;s
    par <function>wddx_deserialize</function>.
   </para>
   <para>
    <example>
     <title>Exemple avec <function>extract</function></title>
     <programlisting role="php">
&lt;?php
/* Supposons que $var_array est un tableau retourn&eacute; par
   <function>wddx_deserialize</function> */
  $taille = "grand";
  $var_array = array("couleur" =&gt; "bleu",
                     "taille"  =&gt; "moyen",
                     "forme" =&gt; "sphere");
  extract($var_array, EXTR_PREFIX_SAME, "wddx");
  print "$couleur, $taille, $forme, $wddx_taille\n";
?&gt;
     </programlisting>
    </example>
   </para>
   <para>
    L'exemple ci-dessus va afficher
    <computeroutput>
    bleu, large, sphere, moyen
    </computeroutput>
   </para>
   <para>
    La variable $taille n'a pas &eacute;t&eacute; r&eacute;&eacute;crite, car on
    avait sp&eacute;cifi&eacute; le param&egrave;tre EXTR_PREFIX_SAME, qui a permis
    la cr&eacute;ation $wddx_size. Si EXTR_SKIP avait &eacute;t&eacute;
    utilis&eacute;, alors $wddx_size n'aurait pas &eacute;t&eacute;
    cr&eacute;&eacute;. Avec EXTR_OVERWRITE, $taille aurait pris la valeur "moyen",
    et avec EXTR_PREFIX_ALL, les variables cr&eacute;&eacute;es seraient
    $wddx_couleur, $wddx_taille, et $wddx_forme.
   </para>
  </refsect1>
 </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
