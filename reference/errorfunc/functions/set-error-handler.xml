<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.38 $ -->
<!-- EN-Revision: 1.43 Maintainer: yannick Status: ready -->
<!-- Reviewed: yes -->

<refentry xml:id="function.set-error-handler" xmlns="http://docbook.org/ns/docbook">
 <refnamediv>
  <refname>set_error_handler</refname>
  <refpurpose>Spécifie une fonction utilisateur comme gestionnaire d'erreurs</refpurpose>
 </refnamediv>

 <refsect1 role="description">
  &reftitle.description;
  <methodsynopsis>
   <type>mixed</type><methodname>set_error_handler</methodname>
   <methodparam><type>callback</type><parameter>error_handler</parameter></methodparam>
   <methodparam choice="opt"><type>int</type><parameter>error_types</parameter><initializer>E_ALL | E_STRICT</initializer></methodparam>
  </methodsynopsis>
  <para>
   <function>set_error_handler</function> choisit la fonction utilisateur
   <parameter>error_handler</parameter> pour gérer les erreurs dans un script.
  </para>
  <para>
   <function>set_error_handler</function> peut être utilisé pour définir
   votre propre manière de gérer les erreurs durant l'exécution, par exemple
   pour une application dans laquelle vous devez nettoyer les données/fichiers
   lorsqu'une erreur survient ou lorsque vous devez déclencher une erreur sous
   certaines conditions (en utilisant <function>trigger_error</function>).
  </para>
  <para>
   Il faut se rappeler que la fonction standard de traitement des erreurs
   de PHP est alors complètement ignorée.
   <function>error_reporting</function>
   n'aura plus d'effet, et votre fonction de gestion des
   erreurs sera toujours appelée. Vous pourrez toujours lire la valeur
   de l'erreur courante de <link linkend="ini.error-reporting">error_reporting</link> et
   faire réagir la fonction de gestion des erreurs en fonction.
   Cette remarque est notamment valable si la commande a été
   préfixée par <link linkend="language.operators.errorcontrol">@</link>.
  </para>
  <para>
   Notez aussi qu'il est alors confié à cette fonction de
   terminer le script (<function>die</function>) si nécessaire. Si la
   fonction de gestion des erreurs se termine normalement, l'exécution
   du script se poursuivra avec l'exécution de la prochaine commande.
  </para>
  <para>
   Les types d'erreur suivants ne peuvent pas être gérés avec cette fonction : 
   <constant>E_ERROR</constant>, <constant>E_PARSE</constant>,
   <constant>E_CORE_ERROR</constant>, <constant>E_CORE_WARNING</constant>,
   <constant>E_COMPILE_ERROR</constant>,
   <constant>E_COMPILE_WARNING</constant> ainsi que la plupart des
   <constant>E_STRICT</constant> d'un fichier lorsque 
   <function>set_error_handler</function> est appelé.
  </para>
  <para>
   Si une erreur survient avant que le script ne soit exécuté (par exemple
   un téléchargement de fichier), le gestionnaire d'erreurs personnalisé ne pourra
   pas être appelé, car il n'est pas encore enregistré.
  </para>
 </refsect1>

 <refsect1 role="parameters">
  &reftitle.parameters;
  <para>
   <variablelist>
    <varlistentry>
     <term><parameter>error_handler</parameter></term>
     <listitem>
      <para>
       La fonction utilisateur doit accepter deux paramètres :
       le code d'erreur et une chaîne décrivant le code d'erreur. Depuis,
       trois paramètres optionnels sont fournis en même temps :
       le fichier dans lequel l'erreur est survenue, la ligne à laquelle
       l'erreur est survenue, et le contexte dans lequel l'erreu est survenue
       (un tableau contenant la liste des symboles lors de l'erreur). La fonction
       peut être décrite comme ceci :
      </para>
      <para>
       <methodsynopsis>
        <methodname><replaceable>handler</replaceable></methodname>
        <methodparam><type>int</type><parameter>errno</parameter></methodparam>
        <methodparam><type>string</type><parameter>errstr</parameter></methodparam>
        <methodparam choice="opt"><type>string</type><parameter>errfile</parameter></methodparam>
        <methodparam choice="opt"><type>int</type><parameter>errline</parameter></methodparam>
        <methodparam choice="opt"><type>array</type><parameter>errcontext</parameter></methodparam>
       </methodsynopsis>
       <variablelist>
        <varlistentry>
         <term><parameter>errno</parameter></term>
         <listitem>
          <simpara>
           Le premier paramètre <parameter>errno</parameter>, contient le
           niveau d'erreur, sous la forme d'un entier.
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><parameter>errstr</parameter></term>
         <listitem>
          <simpara>
           Le second paramètre <parameter>errstr</parameter>, contient le
           message d'erreur, sous forme de chaîne.
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><parameter>errfile</parameter></term>
         <listitem>
          <simpara>
           Le troisième paramètre, optionnel, <parameter>errfile</parameter>,
          contient le nom du fichier dans lequel l'erreur a été identifiée.
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><parameter>errline</parameter></term>
         <listitem>
          <simpara>
           Le quatrième paramètre, optionnel, <parameter>errline</parameter>,
           contient le numéro de ligne à laquelle l'erreur a été identifiée.
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><parameter>errcontext</parameter></term>
         <listitem>
          <simpara>
           Le cinquième paramètre, optionnel, <parameter>errcontext</parameter>,
           est un tableau qui pointe sur la table des symboles actifs lors
           de l'erreur. En d'autres termes, <parameter>errcontext</parameter>
           contient un tableau avec toutes les variables qui existaient lorsque
           l'erreur a été déclenchée.
           La fonction de gestion d'erreurs de l'utilisateur ne doit pas
           modifier le contexte d'erreur.
          </simpara>
         </listitem>
        </varlistentry>
       </variablelist>
      </para>
      <para>
       Si la fonction retourne &false;, alors le gestion d'erreurs normal continue.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>error_types</parameter></term>
     <listitem>
      <para>
       Sert de masque pour appeler la fonction 
       <parameter>error_handler</parameter> de la même façon que l'option de
       configuration <link linkend="ini.error-reporting">error_reporting</link>
       contrôle les erreurs qui sont affichées. Sans le masque,
       <parameter>error_handler</parameter> sera appelé pour toutes les erreurs,
       quelque soit la valeur de
       <link linkend="ini.error-reporting">error_reporting</link>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsect1>

 <refsect1 role="returnvalues">
  &reftitle.returnvalues;
  <para>
   Retourne une chaîne contenant le dernier gestionnaire d'errers (si il existe).
   Si le gestionnaire d'erreurs interne est utilisé, &null; est retourné.
   &null; est également retourné dans le cas d'une erreur, comme une fonction
   de rappel incorrecte. Si le gestionnaire d'erreurs précédent est une méthode
   d'une classe, cette fonction retournera un tableau indexé de la classe et du
   nom de la méthode.
  </para>
 </refsect1>

 <refsect1 role="changelog">
  &reftitle.changelog;
  <para>
   <informaltable>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>&Version;</entry>
       <entry>&Description;</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>5.2.0</entry>
       <entry>
        Le gestionnaire d'erreurs doit retourner &false; pour
        peupler la variable <varname>$php_errormsg</varname>.
       </entry>
      </row>
      <row>
       <entry>5.0.0</entry>
       <entry>
        Le paramètre <parameter>error_types</parameter> a été introduit.
       </entry>
      </row>
      <row>
       <entry>4.3.0</entry>
       <entry>
        Au lieu d'un nom de fonction, un tableau contenant une référence à un objet
        ainsi qu'un nom de méthode peut aussi être passé au paramètre
        <parameter>error_handler</parameter>.
       </entry>
      </row>
      <row>
       <entry>4.0.2</entry>
       <entry>
        Trois paramètres optionnels pour le paramètre <parameter>error_handler</parameter>
        de la fonction utilisateur ont été introduits. C'est le nom du fichier, le numéro de ligne
        ainsi que le contexte.
       </entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>
  </para>
 </refsect1>

 <refsect1 role="examples">
  &reftitle.examples;
  <para>
   <example>
    <title>Gestionnaire d'erreurs avec <function>set_error_handler</function> et 
     <function>trigger_error</function></title>
    <para>
     L'exemple ci-dessous illustre l'interception d'erreurs internes avec
     génération d'erreur et son exploitation dans une fonction utilisateur :
    </para>
    <programlisting role="php">
<![CDATA[
<?php
// Gestionnaire d'erreurs
function myErrorHandler($errno, $errstr, $errfile, $errline)
{
    switch ($errno) {
    case E_USER_ERROR:
        echo "<b>Mon ERREUR</b> [$errno] $errstr<br />\n";
        echo "  Erreur fatale sur la ligne $errline dans le fichier $errfile";
        echo ", PHP " . PHP_VERSION . " (" . PHP_OS . ")<br />\n";
        echo "Arrêt...<br />\n";
        exit(1);
        break;

    case E_USER_WARNING:
        echo "<b>Mon ALERTE</b> [$errno] $errstr<br />\n";
        break;

    case E_USER_NOTICE:
        echo "<b>Mon AVERTISSEMENT</b> [$errno] $errstr<br />\n";
        break;

    default:
        echo "Type d'erreur inconnu : [$errno] $errstr<br />\n";
        break;
    }

    /* Ne pas exécuter le gestionnaire interne de PHP */
    return true;
}

// Fonction pour tester la gestion d'erreur
function scale_by_log($vect, $scale)
{
    if (!is_numeric($scale) || $scale <= 0) {
        trigger_error("log(x) for x <= 0 is undefined, you used: scale = $scale", E_USER_ERROR);
    }

    if (!is_array($vect)) {
        trigger_error("Type d'entrée incorrect, tableau de valeurs attendu", E_USER_WARNING);
        return null;
    }

    $temp = array();
    foreach($vect as $pos => $value) {
        if (!is_numeric($value)) {
            trigger_error("La valeur à la position $pos n'est pas un nombre, utilisation 0 (zéro)", E_USER_NOTICE);
            $value = 0;
        }
        $temp[$pos] = log($scale) * $value;
    }
    return $temp;
  }

// Configuration du gestionnaire d'erreurs
$old_error_handler = set_error_handler("myErrorHandler");

// Génération de quelques erreurs. Commençons par créer un tableau
echo "vector a\n";
$a = array(2, 3, "foo", 5.5, 43.3, 21.11);
print_r($a);

// Générons maintenant un second tableau
echo "----\nvector b - a notice (b = log(PI) * a)\n";
/* Valeur à la position $pos n'est pas un nombre, utilisation de 0 (zéro) */
$b = scale_by_log($a, M_PI);
print_r($b);

// Ceci est un problème, nous avons utilisé une chaîne au lieu d'un tableau
echo "----\nvector c - a warning\n";
/* Type d'entrée incorrect, tableau de valeurs attendu */
$c = scale_by_log("non un tablau", 2.3);
var_dump($c); // NULL

// Ceci est une erreur critique : le logarithme de zéro ou d'un nombre négatif est indéfini
echo "----\nvector d - fatal error\n";
/* log(x) pour x <= 0 est indéfini, vous utilisez : scale = $scale" */
$d = scale_by_log($a, -2.5);
var_dump($d); // Jamais atteint
?>
]]>
    </programlisting>
    &example.outputs.similar;
    <screen>
<![CDATA[
vector a
Array
(
    [0] => 2
    [1] => 3
    [2] => foo
    [3] => 5.5
    [4] => 43.3
    [5] => 21.11
)
----
vector b - a notice (b = log(PI) * a)
<b>Mon AVERTISSEMENT</b> [1024] La valeur à la position 2 n'est pas un nombre, utilisation de 0 (zéro)<br />
Array
(
    [0] => 2.2894597716988
    [1] => 3.4341896575482
    [2] => 0
    [3] => 6.2960143721717
    [4] => 49.566804057279
    [5] => 24.165247890281
)
----
vector c - an warning
<b>Mon ALERTE</b> [512] Entrée incorrect, tableau de valeurs attendu<br />
NULL
----
vector d - fatal error
<b>Mon ERREUR</b> [256] log(x) for x <= 0 est indéfini, vous utilisez : scale = -2.5<br />
Erreur fatale sur la ligne 36 dans le fichier trigger_error.php, PHP 4.0.2 (Linux)<br />
Abandon...<br />
]]>
    </screen>
   </example>
  </para>
 </refsect1>

 <refsect1 role="seealso">
  &reftitle.seealso;
  <para>
   <simplelist>
    <member><classname>ErrorException</classname></member>
    <member><function>error_reporting</function></member>
    <member><function>restore_error_handler</function></member>
    <member><function>trigger_error</function></member>
    <member><link linkend="errorfunc.constants">Constantes de niveau d'erreur</link></member>
    <member>&seealso.callback;</member>
   </simplelist>
  </para>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->