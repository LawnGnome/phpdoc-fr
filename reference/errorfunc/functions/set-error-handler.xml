<?xml version="1.0" encoding="iso-8859-1"?>
<!-- splitted from ./fr/functions/errorfunc.xml, last change in rev 1.10 -->
<!-- last change to 'set-error-handler' in en/ tree in rev 1.1 -->
  <refentry id="function.set-error-handler">
   <refnamediv>
    <refname>set_error_handler</refname>
    <refpurpose>
     Choisi une fonction utilisateur comme gestionnaire d'erreurs
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>string</type><methodname>set_error_handler</methodname>
      <methodparam><type>callback</type><parameter>error_handler</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>set_error_handler</function> choisit la fonction utilisateur
     <parameter>error_handler</parameter> pour gérer
     les erreurs dans un script. Retourne un pointeur sur l'ancienne fonction
     de gestion des erreurs (s'l y en avait une), ou &false;, en cas d'erreur.
     <function>set_error_handler</function> sert à définir votre
     propre gestionnaire d'erreurs, qui prendra en charge leur traitement durant
     l'exécution d'un script. Cela peut être utile lorsque vous
     devez repérer des erreurs critiques lors d'un nettoyage de bases, ou
     bien si vous souhaitez générer une erreur dans certaines
     conditions (avec <function>trigger_error</function>).
    </para>
    <para>
     La fonction utilisateur doit accepter deux arguments : le code de l'erreur
     et une chaîne décrivant l'erreur. L'exemple ci-dessous montre
     le traitement d'exceptions en déclenchant des erreurs, et en les
     gérant avec une fonction utilisateur.
    </para>
    <note>
     <simpara>
      Au lieu d'un nom de fonction, vous pouvez utiliser un tableau contenant
      deux éléments, une référence sur un objet et un nom de méthode. Cette
      fonctionnalité a été ajoutée en PHP 4.3.0.
     </simpara>
    </note>
    <note>
     <para>
      Les types d'erreur suivants ne peuvent pas être gérés avec cette fonction : 
      <constant>E_ERROR</constant>, <constant>E_PARSE</constant>,
      <constant>E_CORE_ERROR</constant>, <constant>E_CORE_WARNING</constant>,
      <constant>E_COMPILE_ERROR</constant> et
      <constant>E_COMPILE_WARNING</constant>.
     </para>
    </note>
    <para>
     L'exemple ci-dessous illustre l'interception d'erreurs internes avec
     génération d'erreur et son exploitation dans une fonction utilisateur : 
     <example>
      <title>
       Traitement des erreurs avec <function>set_error_handler</function> et
       <function>trigger_error</function>
      </title>
      <programlisting role="php">
<![CDATA[
<?php

// redéfini les constantes utilisateur (PHP 4 Uniquement)
define ("FATAL",E_USER_ERROR);
define ("ERROR",E_USER_WARNING);
define ("WARNING",E_USER_NOTICE);

// configure le niveau de rapport d'erreur pour ce script
error_reporting (FATAL | ERROR | WARNING);

// gestionnaire d'erreurs
function myErrorHandler ($errno, $errstr, $errfile, $errline) {
  switch ($errno) {
  case FATAL:
    echo "<b>FATAL</b> [$errno] $errstr<br>\n";
    echo "  Fatal error in line ".$errline." of file ".$errfile;
    echo ", PHP ".PHP_VERSION." (".PHP_OS.")<br>\n";
    echo "Aborting...<br>\n";
    exit(1);
    break;
  case ERROR:
    echo "<b>ERROR</b> [$errno] $errstr<br>\n";
    break;
  case WARNING:
    echo "<b>WARNING</b> [$errno] $errstr<br>\n";
    break;
    default:
    echo "Unkown error type: [$errno] $errstr<br>\n";
    break;
  }
}

// fonction pour tester la gestion d'erreur
function scale_by_log ($vect, $scale) {
  if ( !is_numeric($scale) || $scale <= 0 )
    trigger_error("log(x) for x <= 0 is undefined, you used: scale = $scale",
      FATAL);
  if (!is_array($vect)) {
    trigger_error("Incorrect input vector, array of values expected", ERROR);
    return null;
  }
  for ($i=0; $i<count($vect); $i++) {
    if (!is_numeric($vect[$i]))
      trigger_error("Value at position $i is not a number, using 0 (zero)", 
        WARNING);
    $temp[$i] = log($scale) * $vect[$i];
  }
  return $temp;
}

// Configuration du gestionnaire d'erreurs
$old_error_handler = set_error_handler("myErrorHandler");

// génération de quelques erreurs. Commençons par créer un tableau
echo "vecteur a \n";
$a = array(2,3,"foo",5.5,43.3,21.11);
print_r($a);

// générons maintenant un autre tableau, avec des alertes
echo "----\nvecteur b - une alerte (b = log(PI) * a)\n";
$b = scale_by_log($a, M_PI);
print_r($b);

// ceci est un problème, nous avons utilisé une chaîne au lieu d'un tableau
echo "----\nvecteur c - une erreur\n";
$c = scale_by_log("not array",2.3);
var_dump($c);

// Ceci est une erreur critique : le logarithme de zéro ou d'un nombre négatif est indéfini
echo "----\nvecteur d - erreur fatale\n";
$d = scale_by_log($a, -2.5);

?>
]]>
     </programlisting>
    </example>
    L'exécution du script devrait donner ceci :
    <example>
     <title>
      Résultat de <function>set_error_handler</function> et <function>trigger_error</function>
     </title>
     <programlisting>
<![CDATA[
vecteur a 
Array
(
    [0] => 2
    [1] => 3
    [2] => foo
    [3] => 5.5
    [4] => 43.3
    [5] => 21.11
)
----
vecteur b - une alerte (b = log(PI) * a)
<b>WARNING</b> [1024] Value at position 2 is not a number, using 0 (zero)<br>
Array
(
    [0] => 2.2894597716988
    [1] => 3.4341896575482
    [2] => 0
    [3] => 6.2960143721717
    [4] => 49.566804057279
    [5] => 24.165247890281
)
----
vecteur c - une erreur
<b>ERROR</b> [512] Incorrect input vector, array of values expected<br>
NULL
----
vecteur d - erreur fatale
<b>FATAL</b> [256] log(x) for x <= 0 is undefined, you used: scale = -2.5<br>
  Fatal error in line 37 of file /Users/imac/-, PHP 5.0.0-dev (Darwin)<br>
Aborting...<br>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Il faut se rappeler que la fonction standard de traitement des erreurs
    de PHP est alors complètement ignorée.
    <function>error_reporting</function>
    n'aura plus d'effet, et votre fonction de gestion des
    erreurs sera toujours appelée. Vous pourrez toujours lire la valeur
    de l'erreur courante de <function>error_reporting</function> et
    faire réagir la fonction de gestion des erreurs en fonction.
    Cette remarque est notamment valable si la commande a été
    préfixée par <link linkend="language.operators.errorcontrol">&#64;</link>
    (0 sera retourné).
   </para>
   <para>
    Notez aussi qu'il est alors confié à cette fonction de
    terminer le script (<function>die</function>) si nécessaire. Si la
    fonction de gestion des erreurs se termine normalement, l'exécution
    du script se poursuivra avec l'exécution de la prochaine commande.
   </para>
   <note>
     <para>
     Si une erreur survient avant que le script ne soit exécuté (par exemple
     un téléchargement de fichier), le gestionnaire d'erreurs personnalisé ne pourra
     pas être appelé, car il n'est pas encore enregistré.
     </para>
    </note>
   <para>
    Voir aussi 
    <function>error_reporting</function>,
    <function>restore_error_handler</function>,
    <function>trigger_error</function> et 
    <link linkend="errorfunc.constants">les constantes de niveau
    d'erreurs</link>.
   </para>
  </refsect1>
 </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
