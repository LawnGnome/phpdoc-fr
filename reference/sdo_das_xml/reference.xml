<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.6 $ -->
<!-- EN-Revision: 1.21 Maintainer: yannick Status: ready -->
<!-- Purpose: xml -->
<!-- Membership: pecl -->
<!-- State: experimental -->
<!-- Reviewed: no -->

<reference xml:id="ref.sdo-das-xml" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Fonctions de Service d'Accès de Données SDO XML</title>
 <titleabbrev>SDO DAS XML</titleabbrev>

 <partintro>
  
  <section xml:id="sdo-das-xml.intro">
   &reftitle.intro;
   <para>
    Afin d'utiliser le Service d'Accès de Données XML pour les Objets de
    Service de Données, vous aurez besoin de comprendre certains concepts
    derrière le SDO : les graphiques de données, les objets de données, XPath
    et ses expressions, et ainsi de suite.
    Si vous n'êtes pas familier avec ces idées, vous devriez jeter un oeil sur
    <link linkend='ref.sdo'>la section sur SDO</link>.
   </para>
   <para>
    Le travail de XML DAS est de déplacer les données entre l'application et
    un fichier source XML, qui peut être soit un fichier ou une adresse URL.
    SDO est créé et maintenu en accord avec un modèle qui définit les
    types des noms et quels noms de propriétés chaque type doit avoir.
    Pour les données qui proviennent d'un fichier XML, le modèle SDO
    est construit depuis un fichier de schéma écrit dans un langage XML
    (un fichier xsd). Ce schéma est habituellement passé à la méthode créée
    lorsque l'objet XMLDAS est initialisé. La
    <link xlink:href='&url.ibm.sdo;'>spécification SDO 2.0</link>
    définit le lien entre les types XML et les types SDO. Il y a
    quelques limitations dans le support &php; - tout ce qui se
    trouve dans la spécification ne peut pas être fait - et ces limitations
    sont énumérées dans une section suivante.
   </para>

  <section xml:id="sdo-das-xml.requirements">
   &reftitle.required;
   <para>
    Le Service d'Accès de Données requiert &php; 5.1.0 ou supérieur. Il est
    fonctionnel avec l'extension SDO et requiert que SDO soit installée. Voyez
    les
    <link linkend="sdo.installation">instructions d'installation SDO</link>
    pour plus de détails sur comment faire cela.
   </para>
  </section>

  <section xml:id="sdo-das-xml.installation">
   &reftitle.install;
   <para>
    Le Service d'Accès de Données et empaqueté et installé avec
    l'<link linkend='ref.sdo'>extension SDO</link>. Référez-vous à
    <link linkend="sdo.installation">instructions d'installation SDO</link>.
   </para>
  </section>

  <section xml:id='sdo-das-xml.examples'>
   &reftitle.examples;
   <para>
    La plupart des exemples suivants sont basés sur l'<link
    linkend="sdo.sample.sequence">exemple de la lettre</link> décrite dans la
    <link linkend="ref.sdo">documentation SDO</link>. Les exemples assument
    que le Schéma XML pour la lettre est contenu dans un fichier
    <filename>lettre.xsd</filename> et que l'instance de la lettre est dans le
    fichier <filename>lettre.xml</filename>. Ces deux fichiers sont reproduits
    ici :
   </para>
   <para>
    <programlisting role="xml">
<![CDATA[
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"
  xmlns:lettre="http://lettreSchema"
  targetNamespace="http://lettreSchema">
  <xsd:element name="lettres" type="lettre:FormLettre"/>
  <xsd:complexType name="FormLettre" mixed="true">
    <xsd:sequence>
      <xsd:element name="date" minOccurs="0" type="xsd:string"/>
      <xsd:element name="prenom" minOccurs="0" type="xsd:string"/>
      <xsd:element name="nomFamille" minOccurs="0" type="xsd:string"/>
    </xsd:sequence>
  </xsd:complexType>
</xsd:schema>
]]>
    </programlisting>
   </para>

   <para>
    <programlisting role="xml">
<![CDATA[
<lettre:lettres xmlns:lettre="http://lettreSchema">
  <date>1er Mars 2005</date>
  Mutual of Omaha
  Wild Kingdom, USA
  Chère
  <prenom>Casy</prenom>
  <nomFamille>Crocodile</nomFamille>
  S'il vous plaît, achetez plus de requin imperméable.
  Votre prime est passée date.
</lettre:lettres>
]]>
    </programlisting>
   </para>
   <example>
    <title>Chargement, modification et sauvegarde d'un document XML</title>
    <para>
     L'exemple suivant montre comment un document XML peut être chargé
     provenant d'un fichier, altéré et récrit.
    </para>
    <programlisting role="php" xml:id="sdo-das-xml.examples.loadfromfile">
     <![CDATA[
<?php
/**
* Charge, met à jour et sauvegarde un document XML
 */
try {
   $xmldas = SDO_DAS_XML::create("letter.xsd");
   $document = $xmldas->loadFile("letter.xml");
   $root_data_object = $document->getRootDataObject();
   $root_data_object->date = "September 03, 2004";
   $root_data_object->firstName = "Anantoju";
   $root_data_object->lastName = "Madhu";
   $xmldas->saveFile($document, "letter-out.xml");
   echo "Nouveau fichier écrit :\n";
   print file_get_contents("letter-out.xml");
} catch (SDO_Exception $e) {
   print($e->getMessage());
}
?>
]]>
    </programlisting>
    <para>
     Une instance du XML DAS est la première obtenue de la méthode
     <function>SDO_DAS_XML::create</function> qui est une méthode statique de
     la classe <classname>SDO_DAS_XML</classname>.
     L'emplacement du xsd est passé en paramètre.
     Une fois que nous avons une instance de XML DAS initialisée avec un
     schéma donné, nous pouvons l'utiliser pour charger l'instance du document
     en utilisant la méthode <function>loadFile</function>.
     Il y a aussi la méthode <function>loadString</function> si vous
     voulez charger une instance de document XML provenant d'une chaîne de
     caractères.
     Si l'instance du document se charge correctement, un objet de type
     <classname>SDO_DAS_XML_Document</classname> sera retourné sur lequel vous
     pourrez appeler la méthode <function>getRootDataObject</function> pour
     obtenir l'objet de données SDO qui est la racine de votre graphique de
     données SDO. Vous pouvez alors utiliser les opérations SDO pour changer
     le graphique SDO. Dans cet exemple, nous modifions les propriétés
     <varname>date</varname>, <varname>prenom</varname> et
     <varname>nomFamille</varname>.
     Ensuite, nous utilisons la méthode
     <function>saveFile</function> pour écrire les changements dans
     un fichier système.
     La méthode saveFile a un argument optionnel qui, s'il est spécifié,
     fera que le XML DAS formatera le XML en utilisant cet argument pour indenter
     chaque changement dans le niveau du document.
    </para>

    <para>
     This will write the following to <filename>letter-out.xml</filename>.
    </para>

    <programlisting role="xml" xml:id="sdo-das-xml.examples.loadfromfile.output">
<![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<FormLetter xmlns="http://letterSchema" xsi:type="FormLetter" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
 <date>September 03, 2004</date>
 Mutual of Omaha
 Wild Kingdom, USA
 Dear
 <firstName>Anantoju</firstName>
 <lastName>Madhu</lastName>
 Please buy more shark repellent.
 Your premium is past due.
</FormLetter>
]]>
    </programlisting>
   </example>
   <example>
    <title>Création d'un nouveau document XML</title>
    <para>
     L'exemple précédent charge le document depuis un fichier.
     Cet exemple montre comment créer un graphique de données
     SDO en mémoire. Dans cet exemple, il est sauvegardé dans une
     chaîne XML. En outre, vu que la lettre contient à la fois du contenu structuré
     et non-structuré, on utilise
     l'<link linkend="sdo.sample.sequence">API séquence</link>
     pour assigner les propriétés pour construire le graphique des données.
    </para>
    <programlisting role="php" xml:id="sdo-das-xml.examples.create">
<![CDATA[
<?php
/**
* Création d'un document XML
*/
try {
   $xmldas = SDO_DAS_XML::create("letter.xsd");
   try {
      $doc = $xmldas->createDocument();
      $rdo = $doc->getRootDataObject();
      $seq = $rdo->getSequence();
      $seq->insert("April 09, 2005", NULL, 'date');
      $seq->insert("Acme Inc. ", NULL, NULL);
      $seq->insert("United Kingdom. ");
      $seq->insert("Dear", NULL, NULL);
      $seq->insert("Tarun", NULL, "firstName");
      $seq->insert("Nayaraaa", NULL, "lastName");
      $rdo->lastName = "Nayar";
      $seq->insert("Please note that your order number ");
      $seq->insert(12345);
      $seq->insert(" has been dispatched today. Thanks for your business with us.");
      print($xmldas->saveString($doc));
   } catch (SDO_Exception $e) {
   print($e);
   }
} catch (SDO_Exception $e) {
   print("Problème lors de la création du document XML : " . $e->getMessage());
}
?>
]]>
    </programlisting>
   </example>
   <para>
    La méthode <function>createDocument</function> du XLM DAS
    retourne un objet document avec une donnée racine simple correspondant
    à un élément du document vide. Le nom de l'élément du document
    est connu du fichier de schéma. S'il y a le moindre doute quant à la valeur
    de l'élément du document, par exemple lorsque plus d'un schéma
    a été chargé dans le même XML DAS, le nom de l'élément et l'URI de
    l'espace de noms peuvent être passés à la méthode
    <function>createDocument</function>.
   </para>
   <para>
    Ceci affichera (les retours à la ligne ont été insérés pour une meilleure lisibilité) :
   </para>
   <programlisting role="xml" xml:id="sdo-das-xml.examples.create.output">
<![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<FormLetter xmlns="http://letterSchema" xsi:type="FormLetter" 
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
 <date>April 09, 2005</date>
 Acme Inc. United Kingdom. 
 Dear
 <firstName>Tarun</firstName>
 <lastName>Nayar</lastName>
 Please note that your order number 12345 has been 
 dispatched today. Thanks for your business with us.
</FormLetter>
]]>
   </programlisting>
   <example>
    <title>Définission des propriétés du document XML</title>
    <para>
     Ce troisième exemple montre comment définir la version XML
     ainsi que l'encodage de l'objet document. Ceci sera utilisé
     lors de l'écriture du document XML. Si aucune déclaration XML
     n'est désirée (peut-être voulez-vous générer du XML sous
     la forme d'une chaîne à incorporer quelque part), alors, vous
     pouvez utiliser la méthode <function>setXMLDeclaration</function>
     pour supprimer la déclaration.
    </para>
    <programlisting role="php" xml:id="sdo-das-xml.examples.Example3">
<![CDATA[
<?php
/**
* Illustration des appels qui contrôlent la déclaration XML
*/
$xmldas = SDO_DAS_XML::create("letter.xsd");
$document = $xmldas->loadFile("letter.xml");
$document->setXMLVersion("1.1");
$document->setEncoding("ISO-8859-1");
print($xmldas->saveString($document));
?>
]]>
    </programlisting>
    <para>
     La version et l'encodage du XML sont définis dans la déclaration XML
     en haut du document XML.
    </para>
    <programlisting role="xml" xml:id="sdo-das-xml.examples.sdo_das_xml_document.output">
<![CDATA[
<?xml version="1.1" encoding="ISO-8859-1"?>
.../...
]]>
    </programlisting>
   </example>

   <example>
    <title>Utilisation d'un type ouvert</title>
    <para>
     Ce quatrième exemple illustre l'utilisation d'un type ouvert SDO
     ainsi que l'utilisation de la méthode
     <function>createDataObject</function>. Pour cet exemple, nous
     utilisons les deux schémas suivants :
    </para>
    <para>
     <programlisting role="xml">
<![CDATA[
<schema
         xmlns="http://www.w3.org/2001/XMLSchema">
 <element name="jungle">
  <complexType>
   <sequence>
    <any minOccurs="0" maxOccurs="unbounded"/>
   </sequence>
  </complexType>
 </element>
</schema>
]]>
     </programlisting>
    </para>
    <para>
     Notez la présence de l'élément
     <varname>any</varname>
     dans la définission. Ce premier schéma définit
     le type complexe <varname>jungle</varname>
     qui contient une séquence de n'importe quel autre type.
     Les autres types que cet exemple utilise, sont définis
     dans un second fichier de schéma :
    </para>
    <para>
     <programlisting role="xml">
<![CDATA[
<schema xmlns= "http://www.w3.org/2001/XMLSchema">

 <complexType name="snakeType">
  <sequence>
   <element name= "name" type="string"/>
   <element name= "length" type="positiveInteger" />
  </sequence>
 </complexType>

 <complexType name="bearType">
  <sequence>
   <element name= "name" type="string"/>
   <element name= "weight" type="positiveInteger" />
  </sequence>
 </complexType>

 <complexType name="pantherType">
  <sequence>
   <element name= "name" type="string"/>
   <element name= "colour" type="string" />
  </sequence>
 </complexType>

</schema>
]]>
     </programlisting>
    </para>
    <para>
     Voici l'exemple de code &php; qui utilise ces deux fichiers de schéma :
    </para>
    <para>
     <programlisting role="php" xml:id="sdo-das-xml.examples.Example4">
<![CDATA[
<?php

/**
* Illustration de types ouverts et de l'utilisaton de la méthode addTypes()
*/

$xmldas = SDO_DAS_XML::create();
$xmldas->addTypes("jungle.xsd"); // ceci est un type ouvert, i.e. la xsd spécifiée peut contenir le type "any"
$xmldas->addTypes('animalTypes.xsd');

$baloo  = $xmldas->createDataObject('','bearType');
$baloo->name = "Baloo";
$baloo->weight = 800;

$bagheera = $xmldas->createDataObject('','pantherType');
$bagheera->name = "Bagheera";
$bagheera->colour = 'inky black';

$kaa = $xmldas->createDataObject('','snakeType');
$kaa->name = "Kaa";
$kaa->length = 25;

$document = $xmldas->createDocument();
$do = $document->getRootDataObject();
$do->bear = $baloo;
$do->panther = $bagheera;
$do->snake = $kaa;

print($xmldas->saveString($document,2));

?>
]]>
     </programlisting>
    </para>
    <para>
     Ces deux fichiers de schéma sont chargés dans le XML DAS avec les méthodes
     <function>create</function> et <function>addTypes</function>.
     La méthode <function>createDataObject</function> est utilisée pour
     créer les trois objets de données. Dans chaque cas, l'URI de l'espace de noms
     et le nom du type sont passés à la méthode <function>createDataObject</function> :
     dans cet exemple, l'URI de l'espace de nom est vide car aucun espace de noms
     n'est utilisé dans ce schéma. Une fois que les trois objets - représentant
     un ours, une penthère et un serpent - ont été créés, un objet document est créé
     avec la méthode <function>createDocument</function>. Dans ce cas,
     il n'y a aucune ambiguité sur l'élément document - vu que le second fichier de
     schéma définit uniquement des types complexes, l'élément document ne
     peut être que l'élément global <varname>jungle</varname> défini dans
     le premier schéma. Ce document aura un objet racine simple correspondant
     à un élément document <varname>jungle</varname> vide.
     Vu que c'est un type ouvert, les propriétés peuvent y être ajoutées.
     Lorsque le premier assignement est effectué sur <varname>$do->bear</varname>,
     une propriété <varname>bear</varname> est ajoutée à l'objet racine :
     de la même façon que pour les deux assignements suivants.
     Lorsque le document est écrit via la méthode
     <function>saveString</function>, le document résultant sera :
    </para>
    <para>
     <programlisting role="xml">
<![CDATA[
  <?xml version="1.0" encoding="UTF-8"?>
  <jungle xsi:type="jungle" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <bear xsi:type="bearType">
  <name>Baloo</name>
  <weight>800</weight>
 </bear>
 <panther xsi:type="pantherType">
  <name>Bagheera</name>
  <colour>inky black</colour>
 </panther>
 <snake xsi:type="snakeType">
  <name>Kaa</name>
  <length>25</length>
 </snake>
</jungle>
]]>
     </programlisting>
    </para>
   </example>
   <example>
    <title>Trouver ce que vous voulez dans un document</title>
    <para>
     Cet exemple illustre comment trouver un nom d'élément et l'espace
     de noms d'un élément du document depuis un objet XML Document, le
     type SDO et l'espace de noms depuis l'élément racine de données XML.
     Ceci peut être difficle à comprendre car il y a 4 méthodes à appeler :
     deux peuvent être exécutées sur l'objet Document, et deux sur n'importe
     quelle donnée y compris l'objet racine. Parceque les règles qui définissent
     la façon dont le modèle SDO est dérivé du modèle XML, lorsque l'objet
     de données concerné est l'objet racine qui représente l'objet document
     pour le document, seulement trois valeurs possibles peuvent revenir
     de l'appels des quatres méthodes.
    </para>
    <para>
     Les deux appels de méthodes qui peuvent être exécutés sur le document sont
     <function>getRootElementName</function> et <function>getRootEelementURI</function>.
     Elles retournent respectivement le nom de l'élément et l'espace de noms de l'élément document.
    </para>
    <para>
     Les deux appels de méthodes qui peuvent être exécutés sur tous les objets
     de données sont <function>getTypeName</function> et
     <function>getTypeNamespaceURI</function>.
     Elles retournent respectivement le nom du type SDO et l'espace de noms du type de l'objet de données.
    </para>
    <para>
     Dans tous les cas, l'appel à la méthode <function>getRootElementURI</function>
     sur l'objet document retournera la même valeur que l'appel à la méthode
     <function>getNamespaceURI</function> sur l'objet racine.
     Les informations sont toutes dérivées depuis les premières lignes du fichier
     schéma, où il y a trois sortes distinctes d'informations.
     Pour illustrer ceci, voici les premières lignes du fichier
     letter.xsd qui nous avons utilisé plus haut.
    </para>
    <programlisting role="xml">
<![CDATA[
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"
xmlns:letter="http://letterSchema"
targetNamespace="http://letterSchema">

<xsd:element name="letters" type="letter:FormLetter"/>

<xsd:complexType name="FormLetter" mixed="true">
.../...
]]>
    </programlisting>
    <para>
     Les trois valeurs importantes sont :
    <itemizedlist>
    <listitem>
    <para>
    <varname>letters</varname>, le nom de l'élément document
   </para>
  </listitem>
  <listitem>
   <para>
    <varname>FormLetter</varname>, le nom du type complexe de l'élément document.
    C'est également le nom du type SDO de l'objet racine.
   </para>
  </listitem>
  <listitem>
   <para>
    <varname>http://letterSchema</varname>, l'espace de noms auquel l'élément document appartient.
    C'est également l'URI de l'espace de noms du type SDO de l'objet racine.
   </para>
  </listitem>
 </itemizedlist>
 C'est une partie des règles XML-SDO qui, lorsque le modèle SDO
 est construit depuis le fichier schéma, sont utilisé pour récupérer
 le nom du type et l'URI de l'espace de noms des types SDO pour
 l'élément racine pour les types complexes de l'élément document,
 lorsqu'ils existent. Dans cet exemple, le nom du type de l'objet
 racine est FormLetter. Dans le cas où il n'y a pas de définission de
 type complexe séparé pour l'élément document, lorsque le type
 est défini en ligne et qu'il est anonyme, le nom du type SDO
 sera le même que le nom de l'élément.
</para>
<para>
 Le programme suivant charge le document lettre et vérifie les valeurs
 retournées de chaque des quatres appels.
</para>
<programlisting role="php" xml:id="sdo-das-xml.examples.Example5">
<![CDATA[
<?php
$xmldas = SDO_DAS_XML::create("letter.xsd");
$document = $xmldas->loadFile("letter.xml");
$root_do = $document->getRootDataObject();

/**
* Le "root element name" est le nom de l'élément de l'élément document
* dans ce cas 'letters'
* Ceci correspond à l'attribut 'name' de l'élément document dans le fichier xsd et correspond
* au nom de l'élément depuis le XML
*/
echo "Le nom de l'élément document est " . $document->getRootElementName() . "\n";
assert($document->getRootElementName() == 'letters'); // une propriété du document

/**
* Le "root element URI" est l'espace de noms du nom de l'élément de l'élément document
* dans ce cas 'http://letterSchema' vu que 'letters' est dans l'espace de noms.
* Il est récupéré depuis le xsd et correspond à l'espace de noms récupéré du XML
*/
echo "L'élément document est dans l'espace de noms " . $document->getRootElementURI() . "\n";
assert($document->getRootElementURI() == 'http://letterSchema'); // une propriété du document

/**
* Le nom du type est récupéré depuis le modèle SDO
* Les règles XML-SDO utilisées pour cela sont :
*   Le nom du type complexe s'il existe (ici, c'est le cas)
*   Le nom de l'élément document s'il n'y a pas de type complexe
* Il est récupéré depuis le xsd
*/
echo "Le nom du type de l'objet racine est " . $root_do->getTypeName() . "\n";
assert($root_do->getTypeName() == 'FormLetter');

/**
* Le type de l'espace de noms est récupéré depuis le modèle SDO
* Les règles XML-SDO assurent que ce sera toujours le même que l'URI de
* l'espace de noms de l'élément document
*/
echo "L'URI de l'espace de noms de l'objet racine est " . $root_do->getTypeNamespaceURI() . "\n";
assert($root_do->getTypeNamespaceURI() == 'http://letterSchema'); 

?>
]]>
</programlisting>
<para>
 Ce programme affichera :
</para>
<programlisting role="xml" xml:id="sdo-das-xml.examples.Example5.output">
<![CDATA[
Le nom de l'élément document est letters
L'élément document est dans l'espace de noms http://letterSchema
Le nom du type de l'objet racine est FormLetter
L'URI de l'espace de noms de l'objet racine est http://letterSchema
]]>
</programlisting>
</example>
 <example>
 <title>Affichage du modèle SDO</title>
 <para>
  Le XML DAS fournit une signification simple pour voir quels types et
  propriétés ont été chargés. L'instruction &php; "print" ou "echo"
  affichera les types et les propriétés.
 </para>
 <programlisting role="php" xml:id="sdo-das-xml.examples.Example6">
<![CDATA[
<?php
/**
* Affichage du modèle
*/

$xmldas = SDO_DAS_XML::create("letter.xsd");
print $xmldas;

?>
]]>
 </programlisting>
  <para>
   L'affichage de ce programme sera :
  </para>
  <programlisting role="xml" xml:id="sdo-das-xml.examples.Example6.output">
<![CDATA[
object(SDO_XML_DAS)#1 {
18 types have been defined. The types and their properties are::
1. commonj.sdo:BigDecimal
2. commonj.sdo:BigInteger
3. commonj.sdo:Boolean
4. commonj.sdo:Byte
5. commonj.sdo:Bytes
6. commonj.sdo:ChangeSummary
7. commonj.sdo:Character
8. commonj.sdo:DataObject
9. commonj.sdo:Date
10. commonj.sdo:Double
11. commonj.sdo:Float
12. commonj.sdo:Integer
13. commonj.sdo:Long
14. commonj.sdo:Short
15. commonj.sdo:String
16. commonj.sdo:URI
17. http://letterSchema:FormLetter
- date (commonj.sdo:String)
- firstName (commonj.sdo:String)
- lastName (commonj.sdo:String)
18. http://letterSchema:RootType
- letters (http://letterSchema:FormLetter)
]]>
  </programlisting>
 </example>
</section>

<!-- class definition section -->
<section xml:id='sdo-das-xml.classes'>
 &reftitle.classes;
 <para>
  Le XML DAS fournit deux classes principales.
  La première est SDO_DAS_XML qui est la classe principale utilisée
  pour récupérer les données depuis le source XML et utilisée
  pour écrire les données.
  La seconde est la classe SDO_DAS_XML_Document
  qui représente les données du document XML.
 </para>
 <para>
  Il y a également quelques classes d'exceptions qui peuvent
  être lançées si des erreurs sont trouvées lors d'une recherche
  ou de l'analyse du fichier xsd ou du fichier XML.
 </para>

 <section xml:id='sdo-das-xml.class.sdo_das_xml'>
  <title>
   <classname>SDO_DAS_XML</classname>
  </title>
  <para>
   C'est la classe principale de XML DAS, qui est utilisée pour
   récupérer les données depuis le source XML mais également
   pour écrire les données.
  </para>
  <section xml:id='sdo-das-xml.class.SDO_DAS_XML.methods'>
   &reftitle.methods;
   <itemizedlist>
    <listitem>
     <para>
     <link linkend='function.SDO-DAS-XML-create'>create</link>
     C'est une méthode statique disponible dans la classe SDO_DAS_XML.
     Utilisée pour construire l'objet SDO_DAS_XML.
    </para>
   </listitem>
   <listitem>
    <para>
     <link linkend='function.SDO-DAS-XML-addTypes'>addTypes</link>
     Fonctionne de la même manière que la méthode <function>create</function>
     mais utilisée pour ajouter de contenu d'un second fichier schéma dans
     un XML DAS qui a déjà été créé.
    </para>
   </listitem>
   <listitem>
    <para>
     <link linkend='function.SDO-DAS-XML-createDataObject'>createDataObject</link>
     Peut être utilisée pour construire l'objet de données SDO d'un type donnée.
    </para>
   </listitem>
   <listitem>
    <para>
     <link linkend='function.SDO-DAS-XML-createDocument'>createDocument</link>
     Peut être utilisée pour construire l'objet Document XML.
    </para>
   </listitem>
   <listitem>
    <para>
     <link linkend='function.SDO-DAS-XML-loadFile'>loadFile</link>
     Charge une instance XML depuis un ficiher. Ce fichier peut
     être en local ou sur un hôte distant.
    </para>
   </listitem>
   <listitem>
    <para>
     <link linkend='function.SDO-DAS-XML-loadString'>loadString</link>
     la même chose que la méthode ci-dessus. Charge l'instance XML
     qui est disponible sous la forme d'une chaîne de caractères.
    </para>
   </listitem>
   <listitem>
    <para>
     <link linkend='function.SDO-DAS-XML-saveFile'>saveFile</link>
     sauvegarde l'objet SDO_DAS_XML_Document en tant qu'un fichier XML.
    </para>
   </listitem>
   <listitem>
    <para>
     <link linkend='function.SDO-DAS-XML-saveString'>saveString</link>
     sauvegarde l'objet SDO_DAS_XML_Document en tant qu'une chaîne de caractères.
    </para>
   </listitem>
  </itemizedlist>
 </section>
</section>

<section xml:id='sdo-das-xml.class.sdo_das_xml_document'>
 <title>
  <classname>SDO_DAS_XML_Document</classname>
 </title>
 <para>
  Cette classe peut être utilisée pour récupérer le nom et l'espace de noms
  de l'élément document et pour récupérer l'objet racine du document.
  De plus, elle peut également être utilisée pour définir la version XML
  et l'encodage du document de sortie.
 </para>
 <section xml:id='sdo-das-xml.class.SDO_DAS_XML_Document.methods'>
  &reftitle.methods;
  <itemizedlist>
   <listitem>
    <para>
     <link linkend='function.SDO-DAS-XML-Document-getRootDataObject'>getRootDataObject</link>
     récupère l'objet racine DataObject.
    </para>
   </listitem>
   <listitem>
    <para>
     <link linkend='function.SDO-DAS-XML-Document-getRootElementName'>getRootElementName</link>
     récupère le nom de l'objet racine DataObject.
    </para>
   </listitem>
   <listitem>
    <para>
     <link linkend='function.SDO-DAS-XML-Document-getRootElementURI'>getRootElementURI</link>
     récupère l'URI de l'objet racine DataObject.
    </para>
   </listitem>
   <listitem>
    <para>
     <link linkend='function.SDO-DAS-XML-Document-setEncoding'>setEncoding</link>
     définit l'encodage en fonction de la valeur fournie.
    </para>
   </listitem>
   <listitem>
    <para>
     <link linkend='function.SDO-DAS-XML-Document-setXMLDeclaration'>setXMLDeclaraion</link>
     pour définir/supprimer la déclaration XML.
    </para>
   </listitem>
   <listitem>
    <para>
     <link linkend='function.SDO-DAS-XML-Document-setXMLVersion'>setXMLVersion</link>
     définit la version XML en fonction de la valeur fournie.
    </para>
   </listitem>
  </itemizedlist>
 </section>
</section>

<section xml:id='sdo-das-xml.class.sdo_das_xml_parserexception'>
 <title>
  <classname>SDO_DAS_XML_ParserException</classname>
 </title>
 <para>
  Est une sous classe de
  <classname>SDO_Exception</classname>.
  Lançée pour toutes les erreurs d'analyse lors du chargement
  des fichiers xsd/xml.
 </para>
</section>

<section xml:id='sdo-das-xml.class.sdo_das_xml_fileexception'>
 <title>
  <classname>SDO_DAS_XML_FileException</classname>
 </title>
 <para>
  Est une sous classe de
  <classname>SDO_Exception</classname>.
  Lançée par toutes les méthodes qui chargent des données depuis
  un fichier, lorsque le fichier ne peut être trouvé.
 </para>
</section>
</section>

<section xml:id='sdo-das-xml.limitations'>
 <title>Limitations avec la spécification SDO 2.0</title>
 <para>
  Les <link xlink:href='&url.ibm.sdo;'>spécifications SDO 2.0</link> définissent la
  concordance entre les types XML et les types SDO. Avec Java SDO, la
  concordance est implémentée par le XMLHelper. Avec SDO pour &php;, cette
  concordance est implémentée par les Services d'Accès de Données XML. Le
  XML DAS implémente la concordance décrite dans les spécifications SDO 2.0
  avec les restrictions suivantes :
 </para>

 <procedure xml:id='sdo-das-xml.limitations.simpletypes'>
  <title>Types Simples XML</title>
  <step>
   <para>
    Type Simple avec sdoJava:instanceClass
    - aucun support &php; fourni
   </para>
  </step>
  <step>
   <para>
    Type simple avec sdoJava:extendedInstanceClass
    - aucun support &php; fourni
   </para>
  </step>
  <step>
   <para>
    Type Simple avec une liste de itemType.
   </para>
  </step>
  <step>
   <para>
    Type Simple avec union.
   </para>
  </step>
 </procedure>
 <procedure xml:id='sdo-das-xml.limitations.complextypes'>
  <title>Types Complex XML</title>
  <step>
   <para>
    Type complexe avec sdo:aliasName
    - aucun support &php; pour ces types d'alias SDO.
   </para>
  </step>
 </procedure>

 <procedure xml:id='sdo-das-xml.limitations.attribute'>
  <title>Attribut XSD</title>
  <step>
   <para>
    Attribut avec sdo:aliasName
    - aucun support &php; pour les alias des propriétés SDO.
   </para>
  </step>
  <step>
   <para>
    Attribut avec une valeur par défaut
    - aucun support &php; pour les propriétés par défaut SDO.
   </para>
  </step>
  <step>
   <para>
    Attribut avec une valeur fixe
    - aucun support &php; pour les propriétés SDO en lecture-seules ou les valeurs par défaut.
   </para>
  </step>
  <step>
   <para>
    Attribut référençant un DataObject avec
    sdo:propertyType - aucun support pour sdo:propertyType="...".
   </para>
  </step>
  <step>
   <para>
    Attribut avec des propriétés bi-directionnelles d'un DataObject avec
    sdo:oppositeProperty et sdo:propertyType
    - aucun support &php; pour l'opposition SDO.
   </para>
  </step>
 </procedure>

  <procedure xml:id='sdo-das-xml.limitations.elements'>
   <title>Éléments XSD</title>
   <step>
    <para>
     Élément avec sdo:aliasName
     - aucun support &php; pour les alias de propriétés SDO.
    </para>
   </step>
   <step>
    <para>
     Élément avec un groupe de substitution.
    </para>
   </step>
  </procedure>

  <procedure xml:id='sdo-das-xml.limitations.elementsimpletype'>
   <title>Éléments XSD avec un type simple</title>
   <step>
    <para>
     Élément de SimpleType avec une valeur par défaut
     - aucun support &php; pour les valeurs par défaut SDO
    </para>
   </step>
   <step>
    <para>
     Élément de SimpleType avec une valeur fixe
     - aucun support &php; pour les propriétés en lecture-seules SDO ou les valeurs par défaut.
    </para>
   </step>
   <step>
    <para>
     Élément de SimpleType avec sdo:string
     - aucun support pour sdo:string="true".
    </para>
   </step>
   <step>
    <para>
     Élément référençant un objet DataObject avec
     sdo:propertyType  - aucun support pour sdo:propertyType="..."
    </para>
   </step>
   <step>
    <para>
     Élément avec une référence bi-directionnelle pour un object
     DataObject avec sdo:oppositeProperty et sdo:propertyType
     - aucun support &php; pour l'opposition SDO.
    </para>
   </step>
  </procedure>
 </section>
 </section>
</partintro>
&reference.sdo-das-xml.functions;
</reference>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->