<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.16 $ -->
<!-- EN-Revision: 1.18 Maintainer: didou Status: ready -->
<!-- Reviewed: yes -->
  <refentry id="function.unserialize">
   <refnamediv>
    <refname>unserialize</refname>
    <refpurpose>
     Crée une variable &php; à partir d'une valeur linéarisée
    </refpurpose>
   </refnamediv>
   <refsect1>
    &reftitle.description;
    <methodsynopsis>
     <type>mixed</type><methodname>unserialize</methodname>
     <methodparam><type>string</type><parameter>str</parameter></methodparam>
    </methodsynopsis>
    <simpara>
     <function>unserialize</function> prend une variable linéarisée
     (voir <function>serialize</function>) et la convertit en variable &php;.
     La valeur convertie est retournée par la fonction, et peut être de
     type <type>boolean</type>, &integer;, <type>float</type>,
     <type>string</type>, <type>array</type> ou <type>object</type>.
     Si la chaîne passée ne peut être délinéarisée, cette fonction retourne
     &false; et une erreur <literal>E_NOTICE</literal> est émise.
    </simpara>
    <warning>
     <para>
      &false; est retourné dans les cas ou il y a une erreur et dans la
      délinéarisation de la valeur linéarisée &false;. Le cas spécial peut
      être analysé en comparant <parameter>str</parameter> avec
      <literal>serialize(false)</literal> ou en attrapant l'erreur
      <literal>E_NOTICE</literal> émise.
     </para>
    </warning>
    <note>
     <title>Directive <option>unserialize_callback_func</option></title>
     <para>
      Il est possible de définir une fonction de callback qui sera
      appelée si une classe indéfinie est utilisée lors 
      de la délinéarisation
      (ce qui évitera de voir l'objet recevoir le type 
      d'objet incomplet <type>object</type> "<literal>__PHP_Incomplete_Class</literal>").
      Utilisez dans votre fichier &php.ini; ou le fichier &htaccess;, 
      ou encore avec la fonction <function>ini_set</function>, pour définir
      une fonction <literal>unserialize_callback_func()</literal>. Chaque fois 
      qu'une classe non-définie sera instanciée, cette fonction sera appelée. 
      Pour désactiver cette fonctionnalité, laissez la simplement 
      vide. Notez aussi que cette directive n'est disponible que depuis &php; 4.2.0. 
     </para>
    </note>
    <para>
     Si la variable délinéarisée est un objet, après avoir réussi à le
     reconstruire, &php; appellera automatiquement la méthode
     <literal>__wakeup()</literal> si elle existe.
     <example>
      <title>Exemple avec la directive <option>unserialize_callback_func</option></title>
      <programlisting role="php">
<![CDATA[
<?php
$serialized_object='O:1:"a":1:{s:5:"value";s:3:"100";}';

// directive unserialize_callback_func disponible depuis PHP 4.2.0
ini_set('unserialize_callback_func','moncallback'); 

// configure votre fonction de callback : moncallback

function moncallback($classname)
{
    // Incluez simplement un fichier contenant votre définition de classe
    // vous saurez quelle classe grâce à $classname
}
?>
]]>
      </programlisting>
     </example>
    </para>
    <note>
     <para>
      En &php; 3, les méthodes ne sont pas préservées lors de la
      délinéarisation d'un objet. Cette limitation a été levée en &php; 4 et 
      stocke désormais les méthodes et les membres. Voyez le chapitre sur
      la <link linkend="language.oop.serialization">Linéarisation des objets</link>
      du chapitre <link linkend="language.oop">Classes et
      Objets</link>.
     </para>
    </note>
    <para>
     <example>
      <title>Exemple avec <function>unserialize</function></title>
      <programlisting role="php">
<![CDATA[
<?php
// Ici, on utilise <function>unserialize</function> pour charger les données de sessions
// depuis la base de données, dans $session_data. Cet exemple complète
// celui fourni avec <function>serialize</function>.
$conn = odbc_connect("webdb", "php", "chicken");
$stmt = odbc_prepare($conn, "SELECT data FROM sessions WHERE id = ?");
$sqldata = array($PHP_AUTH_USER);
if (!odbc_execute($stmt, &$sqldata) || !odbc_fetch_into($stmt, &$tmp)) {
    // si la préparation ou la lecture échouent, on crée un tableau vide
    $session_data = array();
} else {
    // les données sauvées sont dans $tmp[0].
    $session_data = unserialize($tmp[0]);
    if (!is_array($session_data)) {
        // Erreur... initialisation d'un tableau vide
        $session_data = array();
    }
}
?>
]]>
      </programlisting>
     </example>
    </para>
   <para>
    Voir aussi
    <function>serialize</function>.
   </para>
   </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
