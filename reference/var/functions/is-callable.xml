<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.7 $ -->
<!-- EN-Revision: 1.8 Maintainer: yannick Status: ready -->
  <refentry id="function.is-callable">
   <refnamediv>
    <refname>is_callable</refname>
    <refpurpose>
     Détermine si l'argument peut être appelé comme fonction
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>bool</type><methodname>is_callable</methodname>
      <methodparam><type>mixed</type><parameter>var</parameter></methodparam>
      <methodparam choice="opt"><type>bool</type><parameter>syntax_only</parameter></methodparam>
      <methodparam choice="opt"><type>string</type><parameter>c&amp;allable_name</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>is_callable</function> vérifie qu'une variable
     peut être appelée comme fonction. Cette fonction peut vérifier qu'une
     variable contient un nom de fonction valide, ou bien qu'elle contient
     un tableau, avec un objet et un nom de méthode.
    </para>
    <para>
     Le paramètre <parameter>var</parameter> peut être le nom d'une fonction
     stockée dans une variable de chaîne, ou un objet, et un nom de méthode
     pour cet objet, sous la forme : 
     <screen>array($unObjet, 'NomDeMethode' )</screen>
    </para>
    <para>
     Si l'argument <parameter>syntax_only</parameter> vaut &true;, la
     fonction ne va vérifier que si <parameter>var</parameter> peut être
     une fonction ou une méthode. Il va simplement rejeter les variables
     qui ne sont pas des chaînes, ou des tableaux qui n'ont pas la bonne
     structure pour être utilisé comme fonction de callback. Les tableaux
     valides sont supposés n'avoir que deux entrées, le premier étant un
     objet ou une chaîne, et de second une chaîne.
    </para>
    <para>
     L'argument <parameter>callable_name</parameter> reçoit le nom
     à utiliser. Dans l'exemple ci-dessous, il vaut
     <literal>"uneClasse:uneMethode"</literal>.  Notez que, bien que
     <literal>uneClasse:uneMethode()</literal> puisse être appelé sous forme
     statique, ce n'est pas le cas.
    </para>
    <para>
    <example>
     <title>Exemple avec <function>is_callable</function></title>
     <programlisting role="php">
<![CDATA[
<?php
//  Comment vérifier qu'une variable peut être appelée 
//  comme fonction?

//
//  Variable simple contenant une fonction
//

function uneFonction() {
}

$fonctionVariable = 'uneFonction';

var_dump( is_callable( $fonctionVariable, false, $callable_name ));  // bool(true)

echo $callable_name, "\n";  // uneFonction

//
//  Tableu contenant une méthode
//

class uneClasse {

  function uneMethode() {
  }

}

$unObjet = new uneClasse();

$methodeVariable = array($unObjet, 'uneMethode' );

var_dump(is_callable($methodeVariable, true, $callable_name ));  //  bool(true)

echo $callable_name, "\n";  //  uneClasse:uneMethode

?>
]]>
     </programlisting>
    </example>   
   </para>
  </refsect1>
 </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
