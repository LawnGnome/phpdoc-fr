<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.8 $ -->
<!-- EN-Revision: 1.7 Maintainer: yannick Status: ready -->
<refentry id="function.sqlite-popen">
 <refnamediv>
  <refname>sqlite_popen</refname>
  <refpurpose>
  Ouvre une connexion SQlite persistante. La base sera créée si elle n'existe pas</refpurpose>
 </refnamediv>
 <refsect1>
  <title>Description</title>
  <methodsynopsis>
   <type>resource</type><methodname>sqlite_popen</methodname>
   <methodparam><type>string</type><parameter>filename</parameter></methodparam>
   <methodparam choice="opt"><type>int</type><parameter>mode</parameter></methodparam>
   <methodparam choice="opt"><type>string</type><parameter>&amp;error_message</parameter></methodparam>
  </methodsynopsis>
  <simpara>
   <function>sqlite_popen</function> fonctionne exactement comme 
   <function>sqlite_open</function>, hormis le fait qu'elle utilise le mécanisme
   de ressources persistantes de &php;. Pour des détails sur la signification
   des paramètres, voyez la fonction <function>sqlite_open</function>.
  </simpara>
  <para>
   <function>sqlite_popen</function> va d'abord vérifier qu'il reste une connexion
   persistante déjà ouverte pour le fichier <parameter>filename</parameter>.
   Si elle peut en trouver une, elle l'utilisera, et sinon, elle ouvrira une nouvelle connexion.
  </para>
  <para>
   L'intérêt de cette méthode est que vous évitez de relire la base, les schémas
   de tables et d'index, pour chaque page exécutée par un serveur web SAPI
   persistant (tous les SAPI, sauf les CGI et CLI).
  </para>
  <note>
   <simpara>
    Si vous utilisez une connexion persistante et que la base de données est
    modifiée par un autre processus (via une table de cron, par exemple), et
    que le processus recrée la base en l'écrasant, soit par effacement et reconstruction,
    ou par déplacement d'une nouvelle version à la place de l'ancienne, 
    vous pourriez obtenir des comportements inattendus lorsque vous utiliserez
    une vielle connexion persistante sur une nouvelle base.
   </simpara>
   <simpara>
    Pour éviter cette situation, faîtes que vos processus parallèles ouvrent
    les bases et fassent leurs modifications dans une transaction.
   </simpara>
  </note>
  <para>
   Voir aussi
   <function>sqlite_open</function>,
   <function>sqlite_close</function> et
   <function>sqlite_query</function>.
  </para>
 </refsect1>
</refentry>
<!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 vim600: syn=xml fen fdm=syntax fdl=2 si
 vim: et tw=78 syn=sgml
 vi: ts=1 sw=1
 -->
