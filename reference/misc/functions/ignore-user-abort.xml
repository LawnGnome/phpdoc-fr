<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.16 $ -->
<!-- EN-Revision: 1.10 Maintainer: yannick Status: ready -->
<!-- Reviewed: yes -->

<refentry xml:id="function.ignore-user-abort" xmlns="http://docbook.org/ns/docbook">
 <refnamediv>
  <refname>ignore_user_abort</refname>
  <refpurpose>Active l'interruption de script sur déconnexion du visiteur</refpurpose>
 </refnamediv>

 <refsect1 role="description">
  &reftitle.description;
  <methodsynopsis>
   <type>int</type><methodname>ignore_user_abort</methodname>
   <methodparam choice="opt"><type>string</type><parameter>setting</parameter></methodparam>
  </methodsynopsis>
  <para>
   Active l'option décidant si, lors de la déconnexion du client, le script doit poursuivre
   son exécution ou non.
  </para>
 </refsect1>

 <refsect1 role="parameters">
  &reftitle.parameters;
  <para>
   <variablelist>
    <varlistentry>
     <term><parameter>setting</parameter></term>
     <listitem>
      <para>
       Si non définit, la fonction ne retournera que la configuration actuelle.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsect1>

 <refsect1 role="returnvalues">
  &reftitle.returnvalues;
  <para>
   Retourne la configuration précédente, sous la forme d'un booléen.
  </para>
 </refsect1>

 <refsect1 role="examples">
  &reftitle.examples;
  <para>
   <example>
    <title>Example avec <function>ignore_user_abort</function></title>
    <programlisting role="php">
<![CDATA[
<?php
// Ignore la déconnexion de l'utilisateur et autorise
// le script à continuer de s'exécuter
ignore_user_abort(true);
set_time_limit(0);

echo 'Test du gestionnaire de connexion de PHP';

// Exécution d'une boucle infinie surveillant
// l'activité de l'utilisateur. Soit il click en dehors
// de la page, soit il click sur le boutton "Stop".
while(1)
{
        // La connexion a-t-elle échouée ?
        if(connection_status() != CONNECTION_NORMAL)
        {
                break;
        }

        // On attend 10 secondes
        sleep(10);
}

// Si c'est atteint, alors l'instruction 'break' 
// sera lancée depuis la boucle infinie

// Aussi, nous pouvons à ce niveau entrer des informations dans l'historique,
// ou exécuter d'autres taches nécessaires, sans pour autant être dépendant
// du navigateur.
?>
]]>
    </programlisting>
   </example>
  </para>
 </refsect1>

 <refsect1 role="notes">
  &reftitle.notes;
  <para>
   PHP ne détecte pas le fait que l'utilisateur stoppe la connexion
   avant qu'une tentative d'envoi est effectuée au client. La simple
   utilisation d'un "echo" ne garantie pas que l'information est envoyée,
   voir la fonction <function>flush</function>.
  </para>
 </refsect1>

 <refsect1 role="seealso">
  &reftitle.seealso;
  <para>
   <simplelist>
    <member><function>connection_aborted</function></member>
    <member><function>connection_status</function></member>
    <member>
     <link linkend="features.connection-handling">Gestionnaire de connexion</link>
     pour une description complète du gestionnaire de connexion en PHP.
    </member>
   </simplelist>
  </para>
 </refsect1>

</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->