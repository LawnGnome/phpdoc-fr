<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.12 $ -->
<!-- EN-Revision: 1.5 Maintainer: dams Status: ready -->
  <refentry id="function.pack">
   <refnamediv>
    <refname>pack</refname>
    <refpurpose>Compacte des données dans une chaîne binaire</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
     <type>string</type><methodname>pack</methodname>
     <methodparam><type>string</type><parameter>format</parameter></methodparam>
     <methodparam choice="opt"><type>mixed</type><parameter>args</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>pack</function> compacte les arguments <parameter>args</parameter>
     dans une chaîne binaire, suivant le format <parameter>format</parameter>. 
     <function>pack</function> retourne la chaîne binaire.
    </para>
    <para>
     L'idée vient du Perl et tout le formatage fonctionne de
     la même façon qu'en Perl, mais quelques formats manquent
     encore (comme, "u" ). La chaîne de format est composée
     d'une série de codes de formats, suivis par un quantificateur
     optionnel. Le quantificateur peut être un entier, ou *
     pour la répétition indéfinie. Pour les formats a,
     A, h et H, le quantificateur spécifie combien de
     caractères d'un argument sont pris; pour &#64;, c'est
     la position absolue où placer les données,
     et pour le reste, c'est le nombre de répétitions.
     Actuellement, les formats suivants sont implémentés.
    </para>
    <para>
     <table>
      <title>Caractères de formatage pour <function>pack</function></title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>Code</entry>
         <entry>Description</entry>
        </row>
       </thead>
       <tbody>
        <row><entry>a</entry><entry>Une chaîne complétée avec &null;</entry></row>
        <row><entry>A</entry><entry>Une chaîne complétée avec espace (SPACE)</entry></row>
        <row><entry>h</entry><entry>Chaîne hexadécimale h, bit de poids faible en premier.</entry></row>
        <row><entry>H</entry><entry>Chaîne hexadécimale H, bit de poids fort en premier.</entry></row>
        <row><entry>c</entry><entry>caractère signé</entry></row>
        <row><entry>C</entry><entry>caractère non signé</entry></row>
        <row><entry>s</entry><entry>entier court signé (toujours sur 16 bits, ordre des bits dépendant de la machine).</entry></row>
        <row><entry>S</entry><entry>entier court non signé (toujours 16 bits, ordre des bits dépendant de la machine).</entry></row>
        <row><entry>n</entry><entry>entier court signé (toujours 16 bits, ordre des bits big endian)</entry></row>
        <row><entry>v</entry><entry>entier cours non signé (toujours 16 bits, ordre des bits little endian)</entry></row>
        <row><entry>i</entry><entry>entier signé (taille et ordre des bits dépendants de la machine)</entry></row>
        <row><entry>I</entry><entry>entier non signé (taille et ordre des bits dépendants de la machine)</entry></row>
        <row><entry>l</entry><entry>entier long signé (toujours 32 bits, ordre des bits dépendant de la machine)</entry></row>
        <row><entry>L</entry><entry>entier long non signé (toujours 32 bits, ordre des bits dépendant de la machine)</entry></row>
        <row><entry>N</entry><entry>entier long non signé (toujours 32 bits, ordre des bits big endian)</entry></row>
        <row><entry>V</entry><entry>entier long non signé (toujours 32 bits, ordre des bits little endian)</entry></row>
        <row><entry>f</entry><entry>nombre à virgule flottante (taille et représentation dépendantes de la machine)</entry></row>
        <row><entry>d</entry><entry>nombre à virgule flottante double (taille et représentation dépendantes de la machine)</entry></row>
        <row><entry>x</entry><entry>caractère NUL</entry></row>
        <row><entry>X</entry><entry>Recule d'un caractère</entry></row>
        <row><entry>@</entry><entry>Remplit avec des NUL jusqu'à la position absolue</entry></row>
       </tbody>
      </tgroup>
     </table>
    </para>
    <para>
     <example>
      <title>Compactage d'une chaîne</title>
      <programlisting role="php">
<![CDATA[
<?php
  $binarydata = pack ("nvc*", 0x1234, 0x5678, 65, 66);
?>
]]>
      </programlisting>
      <para>
       La chaîne binaire résultante aura 6 octets de long,
       et contiendra la séquence 0x12, 0x34, 0x78, 0x56, 0x41, 0x42.
      </para>
     </example>
    </para>
    <para>
     Notez que la distinction entre signé et non signé
     n'affecte que la fonction <function>unpack</function>, tandis que
     la fonction <function>pack</function> fournira le même
     résultat pour les deux formats.
    </para>
    <para>
     De plus, notez que &php; enregistre de manière interne et
     intégrale les valeurs : cette représentation
     dépend de la machine.  Si vous essayez d'enregistrer une
     valeur trop grande, elle risque d'être convertie et de
     donner lieu à des effets de bords vicieux.
    </para>
    <para>
     Voir aussi
     <function>unpack</function>.
    </para>
   </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
