<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 308208 Maintainer: yannick Status: ready -->
<!-- Reviewed: yes -->

<refentry xml:id="function.unpack" xmlns="http://docbook.org/ns/docbook">
 <refnamediv>
  <refname>unpack</refname>
  <refpurpose>Déconditionne des données depuis une chaîne binaire</refpurpose>
 </refnamediv>

 <refsect1 role="description">
  &reftitle.description;
  <methodsynopsis>
   <type>array</type><methodname>unpack</methodname>
   <methodparam><type>string</type><parameter>format</parameter></methodparam>
   <methodparam><type>string</type><parameter>data</parameter></methodparam>
  </methodsynopsis>
  <para>
   Déconditionne les données <parameter>data</parameter>
   depuis une chaîne binaire avec le format <parameter>format</parameter>.
  </para>
  <para>
   Les données déconditionnées sont stockées dans un
   tableau. Pour cela, il faut donner un nom à chaque
   format utilisé et les séparer par des slash (/). Si
   un argument de répétition est présent, alors chacune des
   clés du tableau aura un numéro de séquence derrière le
   nom fourni.
  </para>
 </refsect1>

 <refsect1 role="parameters">
  &reftitle.parameters;
  <para>
   <variablelist>
    <varlistentry>
     <term><parameter>format</parameter></term>
     <listitem>
      <para>
       Voir la fonction <function>pack</function> pour une explication des codes de format.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>data</parameter></term>
     <listitem>
      <para>
       Les données conditionnées.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsect1>

 <refsect1 role="returnvalues">
  &reftitle.returnvalues;
  <para>
   Retourne un tableau associatif contenant les éléments déconditionnés
   d'une chaîne binaire.
  </para>
 </refsect1>

 <refsect1 role="examples">
  &reftitle.examples;
  <para>
   <example>
    <title>Exemple avec <function>unpack</function></title>
    <programlisting role="php">
<![CDATA[
<?php
$binarydata = "\0x04\0x00\0xa0\0x00";
$array = unpack("cchar/nint", $binarydata);
?>
]]>
    </programlisting>
    <para>
     Le tableau résultant contiendra les entrées
     <literal>"chars"</literal> avec les valeurs
     <literal>4</literal> et <literal>"int"</literal>
     avec <literal>160</literal>.
    </para>
   </example>
  </para>

  <para>
   <example>
    <title>Exemple avec <function>unpack</function> et un argument de répétition</title>
    <programlisting role="php">
 <![CDATA[
 <?php
 $array = unpack("c2chars/nint", $binarydata);
 ?>
 ]]>
     </programlisting>
     <para>
      Le tableau résultant contiendra les entrées "chars1",
      "chars2" et "int".
     </para>
    </example>
   </para>
  </refsect1>

 <refsect1 role="notes">
  &reftitle.notes;
  <caution>
   <para>
    Il faut noter que PHP gère les valeurs en interne
    sous forme signée. Si vous déconditionnez
    une valeur qui est aussi grande que la taille utilisée
    en interne par PHP, le résultat se trouvera être
    un nombre négatif, même s'il a été
    déconditionné avec l'option <literal>" non signé "</literal>.
   </para>
  </caution>
  <caution>
   <para>
    Attention, si vous ne nommez pas un élément, une chaîne vide
    sera utilisée. Si vous ne nommez pas plus d'un élément, cela
    signifie que quelques données seront écrasées lorsque les
    clés sont identiques, comme ceci :
   </para>
   <para>
    <example>
     <title>Exemple avec <function>unpack</function> avec des clés non nommées</title>
     <programlisting role="php">
<![CDATA[
<?php
$binarydata = "\x32\x42\x00\xa0";
$array = unpack("c2/n", $binarydata);
var_dump($array);
?>
]]>
     </programlisting>
     <para>
      Le tableau résultant contiendra les entrées "1" avec la valeur
      <literal>160</literal> et "2" avec <literal>66</literal>. La première
      valeur depuis le spécificateur <literal>c</literal> est écrasé
      par la première valeur depuis le spécificateur <literal>n</literal>.
     </para>
    </example>
   </para>
  </caution>
 </refsect1>

 <refsect1 role="seealso">
  &reftitle.seealso;
  <para>
   <simplelist>
    <member><function>pack</function></member>
   </simplelist>
  </para>
 </refsect1>

</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->