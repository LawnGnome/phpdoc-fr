<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 292277 Maintainer: yannick Status: ready -->
<!-- Reviewed: no -->

<chapter xml:id="mongo.datatypes" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Types de données</title>
 <para>
  MongoDB permet aux développeurs de sauvegarder et de requérir des données
  en utilisant tous les types basiques de PHP, comme les tableaux, les tableaux
  associatifs, les objets mais aussi en utilisant toutes les classes fournies
  par le driver PHP MongoDB (pour les expressions rationnelles, les dates
  et les autres applications spécialisées).
 </para>
 <para>
  MongoDB utilise un format de stoquage appelé "BSON" (<literal>Binary
  Serializable Object Notation</literal>) qui est similaire à JSON mais en
  plus compact et est plus riche en types. Ci-dessous, nous avons listés
  la taille exacte en octets de chaque type (ou les informations nécessaires
  pour calculer leurs tailles, dans le cas de types variables en longueur).
  Gardez à l'esprit que ces tailles n'incluent pas les noms des champs.
  La taille d'un objet peut être calculée manuellement, mais c'est plus facile
  pour un développeur d'appeler la fonction <function>bson_encode</function>
  et de prendre la longueur de la chaîne résultante.
 </para>
 <para>
  Exemple de calcul manuel d'un taille BSON pour sauvegarder l'objet
  array("x" => null, "y" => 40) :
  <programlisting>
<![CDATA[
4 bytes (object size)

1 byte  (type of "x" field)
2 bytes ("x" and "\0")
0 bytes (for null)

1 byte  (type of "y" field)
2 bytes ("y" and "\0")
4 bytes (for an integer)

1 byte  (end-of-object byte)
-----------------------
15 bytes
]]>
  </programlisting>
 </para>
 
 <section>
  <title>Types simples</title>
  <para>
   Les types internes sont :
  </para>
  <para>
   <informaltable>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Type</entry>
       <entry>Description</entry>
       <entry>Taille en MongoDB (octets)</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>&null;</entry>
       <entry>Suffisamment explicite.</entry>
       <entry>0</entry>
      </row>
      <row>
       <entry>boolean</entry>
       <entry>&true; et &false;</entry>
       <entry>1</entry>
      </row>
      <row>
       <entry>int</entry>
       <entry>Valeurs entières.</entry>
       <entry>4</entry>
      </row>
      <row>
       <entry>float</entry>
       <entry>Valeurs doubles.</entry>
       <entry>8</entry>
      </row>
      <row>
       <entry>string</entry>
       <entry>Chaînes de caractères UTF-8.</entry>
       <entry>Longueur de la chaîne + 1</entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>
  </para>
 </section>
 
 <section>
  <title>Tableaux et objets</title>
  
  <para>
   Les tableaux et les objets peuvent également être sauvegardés dans la
   base de données. Les tableaux avec des clés numériques ascendantes
   seront sauvegardés comme des tableaux, tout le reste sera sauvegardé
   comme des objets.
  </para>
  
  <programlisting role="php">
<![CDATA[
<?php

// $scores sera sauvegardé comme un tableau
$scores = array(98, 100, 73, 85);
$collection->insert(array("scores" => $scores);

// $scores sera sauvegardé comme un objet
$scores = array("quiz1" => 98, "midterm" => 100, "quiz2" => 73, "final" => 85);
$collection->insert(array("scores" => $scores);

?>
]]>
  </programlisting>
  
  <para>
   Si vous interrogez la base de données sur ces objets, vous lirez ceci :
   <programlisting>
<![CDATA[
> db.students.find()
{ "_id" : ObjectId("4b06beada9ad6390dab17c43"), "scores" : [ 98, 100, 73, 85 ] }
{ "_id" : ObjectId("4b06bebea9ad6390dab17c44"), "scores" : { "quiz1" : 98, "midterm" : 100, "quiz2" : 73, "final" : 85 } }
]]>
   </programlisting>
  </para>
  
  <para>
   La base de données peut également sauvegardée des objets PHP arbitraires
   (y compris s'ils sont retournés comme des tableaux associatifs). Les champs
   sont utilisés pour la paire clé/valeur. Par exemple, un message d'un blog
   peut ressembler à ceci :
   <programlisting role="php">
<![CDATA[
<?php

// La classe gérant les messages d'un blog
class Post {

  var $author;
  var $content;
  var $comments = array();
  var $date;

  public function __construct($author, $content) {
    $this->author = $author;
    $this->content = $content;
    $this->date = new MongoDate();
  }

  public function setTitle($title) {
    $this->title = $title;
  }

}

// Création d'un message simple et insertion en base de données
$post1 = new Post("Adam", "This is a blog post");

$blog->insert($post1);


// Il n'y a rien qui restreint le type du champ "author", aussi, nous pouvez
// le rendre imbriqué
$author = array("name" => "Fred", "karma" => 42);
$post2 = new Post($author, "This is another blog post.");

// Nous créons un champ supplémentaire en définissant le titre
$post2->setTitle("Second Post");

$blog->insert($post2);

?>
]]>
   </programlisting>
  </para>
  
  <para>
   Depuis le shell de la base de données, nous pourrions voir quelque chose comme :
   <programlisting>
<![CDATA[
> db.blog.find()
{ "_id" : ObjectId("4b06c263edb87a281e09dad8"), "author" : "Adam", "content" : "This is a blog post", "comments" : [ ], "date" : "Fri Nov 20 2009 11:22:59 GMT-0500 (EST)" }
{ "_id" : ObjectId("4b06c282edb87a281e09dad9"), "author" : { "name" : "Fred", "karma" : 42 }, "content" : "This is a blog post", "comments" : [ ], "date" : "Fri Nov 20 2009 11:23:30 GMT-0500 (EST)", "title" : "Second Post" }
]]>
   </programlisting>
  </para>
 </section>
 
 <section>
  <title>Types MongoDB</title>
  
  <para>
   Le driver Mongo PHP définit également quelques types à utiliser
   avec la base de données. Repportez-vous à la documentation de la
   classe pour plus de détails ainsi que des exemples.
  </para>
  <para>
   <informaltable>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Type</entry>
       <entry>Description</entry>
       <entry>Taille en MongoDB (octets)</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><classname>MongoBinData</classname></entry>
       <entry>Données binaires.</entry>
       <entry>Nombre d'octets des données binaires + 5</entry>
      </row>
      <row>
       <entry><classname>MongoCode</classname></entry>
       <entry>Code JavaScript.</entry>
       <entry>Longueur de la chaîne de code + taille de l'objet représentant le scope.</entry>
      </row>
      <row>
       <entry><classname>MongoDate</classname></entry>
       <entry>Dates et heures. Stoquées sous la forme d'un nombre de millisecondes
        depuis l'époque Unix.</entry>
       <entry>8</entry>
      </row>
      <row>
       <entry><classname>MongoId</classname></entry>
       <entry>Identifiant unique de document :
        <itemizedlist>
         <listitem>
          <para>4 octets d'un timestamp</para>
          <para>
           2 enregistrements ne peuvent avoir le même identifiant s'ils sont
           insérés à des moments différents.
          </para>
         </listitem>
         <listitem>
          <para>3 octets de l'identifiant de la machine</para>
          <para>
           2 enregistrements ne peuvent avoir le même identifiant s'ils sont
           insérés à des moments différents.
          </para>
         </listitem>
         <listitem>
          <para>2 octets de l'identifiant du thread</para>
          <para>
           2 enregistrements ne peuvent avoir le même identifiant s'ils sont
           insérés à des moments différents.
          </para>
         </listitem>
         <listitem>
          <para>3 octets d'une valeur d'incrémentation</para>
          <para>
           À chaque fois qu'un identifiant est créé, un compteur global
           est incrémenté et utilisé comme valeur d'incrémentation pour
           le prochain identifiant.
          </para>
         </listitem>
        </itemizedlist>
        Aussi, 2 enregistrements ne peuvent avoir le même identifiant sauf si
        un seul processus sur une seule machine gère l'insertion de 256^3
        (soit plus de 16 millions) documents en une seule seconde, ce qui aura
        pour effet de faire échouer le champ d'incrémentation.
       </entry>
       <entry>12</entry>
      </row>
      <row>
       <entry><classname>MongoMinKey</classname></entry>
       <entry>Valeur toujours plus petit que n'importe quelle autre valeur.</entry>
       <entry>Longueur de la chaîne de code + taille de l'objet représentant le scope.</entry>
      </row>
      <row>
       <entry><classname>MongoMaxKey</classname></entry>
       <entry>Code JavaScript.</entry>
       <entry>Valeur toujours plus grande que n'importe quelle autre valeur.</entry>
      </row>
      <row>
       <entry><classname>MongoRegex</classname></entry>
       <entry>Expressions rationnelles.</entry>
       <entry>
        Nombre de caractères de l'expression rationnelle + nombre de drapeaux
       </entry>
      </row>
      <row>
       <entry><classname>MongoTimestamp</classname></entry>
       <entry>Timestamp fragmenté</entry>
       <entry>8</entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>
  </para>
 </section>
 
 <section>
  <title>Types non supportés</title>
  
  <para>Type supportés par Mongo mais pas par le driver PHP :</para>
  <para>
   <informaltable>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Type</entry>
       <entry>Description</entry>
       <entry>Taille en MongoDB (octets)</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>long</entry>
       <entry>
        Vu que PHP ne supporte pas les entiers sur 8 octets, le type "long"
        récupéré depuis la base de données est converti en type "doubles".
        Les entiers seront toujours sauvegardés dans la base de données sous
        4 octets (même sur les machines qui supportent le 8 octets) et les
        doubles seront sauvegardés sous 8 octets, aussi, il n'y a aucun moyen
        de sauvegarder un type "long" dans la base de données avec le driver PHP.
       </entry>
       <entry>8</entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>
  </para>
 </section>
 
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
