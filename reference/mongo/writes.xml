<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 317663 Maintainer: yannick Status: ready -->
<!-- Reviewed: no -->

<section xml:id="mongo.writes" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Écritures</title>

 <section>
  <title>Les opérations sécurisées</title>
  <para>
   Par défaut, le driver n'attend pas la réponse de la base de données
   pour écrire (insertion, mise à jour et suppression). Cela signifie
   que les écritures peuvent être exécutées très rapidement, mais vous
   ne savez pas si elles ont réussi ou pas. Les écritures peuvent
   échouer pour plusieurs raisons : s'il y a un problème réseau, si
   un serveur de base de données n'est plus accessible, ou si l'écriture
   est tout simplement invalide (e.g., l'écriture sur une collection système).
  </para>
  <para>
   Pour récupérer une réponse de la base de données, vous devez
   utiliser l'option <literal>safe</literal> disponible pour tous les
   types d'écriture. Cette option s'assure que la base de données a bien pris
   en compte l'écriture avant d'en retourner le succès de l'opération.
   Si l'écriture échoue, elle lancera une exception <function>MongoCursorException</function>
   contenant la raison de l'échec.
  </para>
  <para>
   Lors du développement, vous devriez toujours utiliser des écritures
   sécurisées (afin de vous protéger des erreurs courantes, comme la duplication
   de clés, et autres). En production, les écritures non sécurisées doivent
   être utilisées pour les données qui ne sont pas importantes. Ce genre de données
   dépend de l'application, mais c'est généralement des données automatiques
   (à contrario des données générées par les utilisateurs), comme un suivi
   des clics ou des localisations GPS, pour lesquelles des centaines
   d'enregistrements sont insérés à la seconde.
  </para>
  <para>
   Pour effectuer des écritures sécurisées sans trop vous pénalisez en terme
   de performance, il est recommandé de faire des écritures sécurisées à la fin
   d'une série d'écritures. Par exemple :
  </para>
  <programlisting role="php">
<![CDATA[

$collection->insert($someDoc);
$collection->update($criteria, $newObj);
$collection->insert($somethingElse);
$collection->remove($something, array("safe" => true));

]]>
  </programlisting>
  <para>
   Ensuite, si la dernière écriture lance une exception, vous savez qu'il y a un
   problème avec votre base de données.
  </para>
  <para>
   Il y a quelques autres options disponibles pour s'assurer de la sécurité des
   écritures. Vous pouvez spécifier <literal>"fsync" =&gt; true</literal> pour
   forcer la base de données à se synchroniser sur le disque (par défaut, MongoDB
   s'y synchronise une fois par minute).
  </para>
  <para>
   La façon la plus sécurisée de réaliser des écriture est d'utiliser
   la réplication et de spécifier le nombre de serveurs qui doivent recevoir
   cette écriture avant que le processus ne retourne le succès de l'opération.
   (Vous devriez toujours utiliser la réplication en production ; reportez-vous à la
   section sur la connexion pour plus de détails sur le jeu de réplication)
  </para>
  <programlisting role="php">
<![CDATA[

$collection->insert($someDoc, array("safe" => 3));

]]>
  </programlisting>
  <para>
   Si vous spécifiez <literal>"safe" =&gt; N</literal>, le serveur MongoDB
   s'assurera qu'au moins <literal>N</literal> serveurs ont une copie
   de l'écriture avant de retourner le succès de l'opération. Ainsi, si
   <literal>N</literal> vaut 3, le serveur principal et 2 esclaves doivent
   avoir reçus l'écriture avec succès.
  </para>
 </section>

 <section>
  <title>Mise à jour d'objets imbriqués</title>
  <para>
   Supposez que vous souhaitez modifier le nom de l'auteur de ce commentaire,
   dans ce document :

   <programlisting>
<![CDATA[
{
    "_id" : ObjectId("4b06c282edb87a281e09dad9"),
    "content" : "this is a blog post.",
    "comments" :
    [
        {
            "author" : "Mike",
            "comment" : "I think that blah blah blah...",
        },
        {
            "author" : "John",
            "comment" : "I disagree."
        }
    ]
}
]]>
   </programlisting>

   Afin de modifier le champ interne, nous utilisons $set
   (ainsi, tous les autres champs ne seront pas supprimés)
   avec l'index du commentaire à modifier :

   <programlisting role="php">
<![CDATA[
<?php

$blog->update($criteria, array('$set' => array("comments.1" => array("author" => "Jim"))));

?>
]]>
   </programlisting>
  </para>
 </section>

 <section>
  <title>L'opérateur de position</title>
  <para>
   L'opérateur de position <literal>$</literal> est utile pour mettre à jour les objets
   qui sont des tableaux. Dans l'exemple ci-dessus, supposons que nous ne connaissons
   pas l'index du commentaire que nous souhaitons modifier, mais juste que nous
   souhaitons modifier "John" en "Jim". Nous pouvons ici utiliser <literal>$</literal> pour arriver à nos fins.
  </para>
  <programlisting role="php">
<![CDATA[
<?php

$blog->update(
    array("comments.author" => "John"),
    array('$set' => array('comments.$.author' => "Jim")));

?>
]]>
  </programlisting>
 </section>
</section>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->

