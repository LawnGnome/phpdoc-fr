<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 307768 Maintainer: yannick Status: ready -->
<!-- Reviewed: no -->

<section xml:id="mongo.queries" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Interrogation</title>
  <section>
  <title>Distribution des requêtes aux esclaves</title>

  <note>
   <title>1.1.0+</title>
   <para>
    Si vous utilisez un
    <link xlink:href="&url.mongodb.replica;">jeux de réplication</link>
    ainsi que la version 1.1.0 ou suivante du driver, le driver peut automatiquement
    acheminer les lectures sur les esclaves. Ce comportement n'existe pas
    dans les précédentes versions du driver et  <emphasis>ne peut pas</emphasis>
    être utilisé avec un serveur principal/esclave normal.
   </para>
  </note>

  <para>
   Par défaut, le driver envoie toutes les requêtes au serveur principal.
   Si vous définissez l'option "slaveOkay", le driver enverra toutes les
   requêtes à un serveur non-principal, si c'est possible. L'option
   "slaveOkay" peut être définie à plusieurs niveaux :
   <link linkend="mongo.setslaveokay">à la connexion</link>,
   <link linkend="mongodb.setslaveokay">à la base de données</link>,
   <link linkend="mongocollection.setslaveokay">à la collection</link>, et
   <link linkend="mongocursor.slaveokay">au niveau du curseur</link>.
   Chaque classe hérite de la configuration "slaveOkay" de la classe supérieure, aussi,
   si vous faîtes :
  </para>

  <programlisting role="php">
<![CDATA[
<?php

$db->setSlaveOkay(true);
$c = $db->myCollection;

$cursor = $c->find();

?>
]]>
  </programlisting>

  <para>
   alors la requête sera exécutée sur un esclave (le collection hérite de
   "slaveOkay" depuis la base de données et le curseur en hérite de la collection).
  </para>

  <section>
   <title>Comment les esclaves sont choisis ?</title>

   <para>
    Chaque instance de <classname>Mongo</classname> prend son propre esclave,
    choisi de façon aléatoire depuis les esclaves disponibles. Il en est de
    même si vous utilisez des connexions persistantes. Aussi, si vous
    faîtes quelque chose comme :
   </para>
   <programlisting role="php">
<![CDATA[
<?php

// connexion à un jeu de réplication avec les membres ip0, ip1 et ip2
// ip0 est le principal, ip1 et ip2 sont les secondaires
$m1 = new Mongo("mongodb://ip0", array("replicaSet" => true, "persist" => "x"));
echo "L'esclave m1 est : ".$m1->getSlave()."\n";

// utilisation de la même connexion que $m1
$m2 = new Mongo("mongodb://ip0", array("replicaSet" => true, "persist" => "x"));
echo "L'esclave m2 est : ".$m2->getSlave()."\n";

?>
]]>
   </programlisting>
   <para>
    nous pourrions constater quelque chose comme :
   </para>
   <screen>
L'esclave m1 est : ip2
L'esclave m2 est : ip1
   </screen>

   <para>
    Si nous continuons de créer de nouvelles instances de la classe
    <classname>Mongo</classname>, nous constaterions toujours une distribution
    entre ip1 et ip2. Gardez à l'esprit que tous les secondaires listés par
    la commande <function>isMaster</function> seront dans la réserve de serveurs
    pouvant être utilisés pour la lecture (y compris ceux dont la priorité est de 0
    ou ceux dont slaveDelay est défini). Si vous avez des serveurs pour lesquels
    vous ne voulez pas y effectuer de lecture, soit vous devez redirigez
    manuellement la lecture, soit vous devez ajouter les cacher via l'option
    de configuration du jeu de réplications des serveurs.
   </para>

   <para>
    Les esclaves sont choisis pour chaque instante et ne changent pas
    (tant qu'aucune erreur n'intervient à votre jeux de réplication).
   </para>

   <para>
    Le driver connait le statut courant de ces membres
    en exécutant la méthode <function>Mongo::getHosts</function>.
   </para>

   <para>
    Si aucun serveur non-principal n'est disponible, le driver enverra
    la lecture vers le serveur principal (y compris si "slaveOkay" est défini).
    Un serveur est considéré comme accessible si son statut vaut 2 (SECONDARY)
    et sa santé, 1. Vous pouvez vérifier ces valeurs avec la méthode
    <function>Mongo::getHosts</function> (quelques champs ont été volontairement
    supprimés pour plus de lisibilité) :
   </para>
   <programlisting>
<![CDATA[
Array
(
    [ubuntu:27017] => Array
        (
            [_id] => 0
            [name] => ip0
            [health] => 1
            [state] => 1
            [stateStr] => PRIMARY
        )

    [ubuntu:27019] => Array
        (
            [_id] => 2
            [name] => ip1
            [health] => 1
            [state] => 2
            [stateStr] => SECONDARY
        )

    [ubuntu:27018] => Array
        (
            [_id] => 1
            [name] => ip2
            [health] => 1
            [state] => 2
            [stateStr] => SECONDARY
        )

)
]]>
   </programlisting>
   <para>
    Le jeu ci-dessus contient 2 serveurs accessibles, "ip1" et "ip2".
    Si ces 2 serveurs deviennent inaccessibles ou obsolètes, les
    lectures seront dirigées vers "ip0".
   </para>

   <para>
    Si vous aimez toucher à ce que vous ne devriez pas, vous pouvez
    forcer le driver à utiliser un esclave différent en appelant la
    méthode <function>Mongo::switchSlave</function>. Ceci choisira
    alternativement un nouvel esclave à utiliser et ne devrait pas
    être utilisé sauf si vous savez ce que vous faîtes.
   </para>

  </section>
  <section>
   <title>Diverses notes</title>

   <para>
    Les écritures sont toujours envoyés au serveur principal. Les commandes
    de base de données, y compris celles en lecture seule, sont également
    toujours envoyés au serveur principal.
   </para>

   <para>
    La santé et le statut d'un esclave est vérifié toutes les 5 secondes ou bien
    lorsque la prochaine opération intervient après 5 secondes. La configuration
    est également re-vérifiée lorsque le driver a un problème à atteindre un serveur.
    Vous pouvez manuellement forcer le driver à mettre à jour le statut
    en appelant la méthode <function>Mongo::getHosts</function>.
   </para>
   
   <para>
    Notez qu'un serveur non-principal peut être derrière le principal dans les
    opérations, ainsi, votre application doit admettre de recevoir des données
    non mises à jour (ou vous devez utiliser l'option w pour toutes les écritures).
   </para>
  </section>

 </section> 
 
 <section>
  <title>Interrogation sur un _id</title>
  <para>
   Chaque objet inséré se voit assigné automatiquement un champ unique _id,
   qui est bien utile pour être utilisé dans les requêtes..
  </para>
  <para>
   Supposez que vous voulez trouver un document que vous venez tout juste d'insérer.
   L'insertion ajoute un champ _id au document, aussi, vous pouvez effectuer votre
   requête de la sorte :
   <programlisting role="php">
<![CDATA[
<?php

$person = array("name" => "joe");

$people->insert($person);

// Maintenant, $joe a un champ _id
$joe = $people->findOne(array("_id" => $person['_id']));

?>
]]>
   </programlisting>
  </para>
  <para>
   Tant que l'utilisateur ne l'a pas spécifié autrement, le champ _id
   est un <classname>MongoId</classname>. L'erreur la plus courante
   est d'essayer d'utiliser une chaîne qui correspond à un
   <classname>MongoId</classname>. Gardez à l'esprit que cet identifiant
   a 2 types de données différents, et ne correspond pas l'un l'autre,
   de la même façon que la chaîne "array()" n'est pas la même chose
   qu'un tableau vide. Par exemple :
   <programlisting role="php">
<![CDATA[
<?php

$person = array("name" => "joe");

$people->insert($person);

// Convertion de l'_id en une chaîne
$pid = $person['_id'] . "";

// ECHEC - $pid est une chaîne, et non un MongoId
$joe = $people->findOne(array("_id" => $pid));

?>
]]>
   </programlisting>
  </para>
 </section>
 
 <section>
  <title>Les tableaux</title>
  <para>
   Les tableaux sont spéciaux à plus d'un titre. Tout d'abord, il y a 2 types
   utilisés par MongoDB : des tableaux "normaux" et des tableaux associatifs.
   Les tableaux associatifs peuvent avoir plusieurs types de clés et de valeurs.
   Les tableaux "normaux" sont définis comme tableaux dans ces indices numériques
   ascendants, en commençant par 0 et s'incrémentant de 1 pour chaque élément.
   Ces 2 types correspondent à ce que vous connaissez déjà comme type en PHP.
  </para>
  
  <para>
   Actuellement, si vous voulez sauvegarder la liste des récompenses
   dans un document, vous pouvez :
  </para>
  
  <programlisting role="php">
<![CDATA[
<?php

$collection->save(array("awards" => array("gold", "silver", "bronze")));

?>
]]>
  </programlisting>
  <para>
   Les requêtes peuvent effectuer des recherches directement dans les éléments.
   Supposez que nous souhaitons trouver tous les documents dont l'élément du
   tableau est à une valeur fournie. Par exemple, les documents sont la
   récompense est l'or, comme ceci :
  </para>
  <programlisting>
<![CDATA[
{ "_id" : ObjectId("4b06c282edb87a281e09dad9"), "awards" : ["gold", "silver", "bronze"]}
]]>
  </programlisting>
  <para>
   Ceci peut être effectué avec une requête simple, en ignorant le fait que "awards"
   est un tableau :
  </para>
  <programlisting role="php">
<![CDATA[
<?php

$cursor = $collection->find(array("awards" => "gold"));

?>
]]>
  </programlisting>
  
  <para>
   Supposez que vous interrogez la base de données avec un objet plus complexe,
   dont chaque élément du tableau sont eux-mêmes des objets, comme ceci :
  </para>
  
  <programlisting>
<![CDATA[
{ 
     "_id" : ObjectId("4b06c282edb87a281e09dad9"), 
     "awards" : 
     [
        {
            "first place" : "gold"
        },
        {
            "second place" : "silver" 
        },
        {
            "third place" :  "bronze"
        }
     ]
}
]]>
  </programlisting>
  <para>
  Continuons d'ignorer que c'est un tableau. Nous pouvons utiliser
  la notation basée sur les points pour interroger le sous-objet :
  </para>
  <programlisting role="php">
<![CDATA[
<?php

$cursor = $collection->find(array("awards.first place" => "gold"));

?>
]]>
  </programlisting>
  <para>
   Notez qu'il importe peu qu'il y ait un espace dans le nom du champ
   (bien qu'il convient de ne pas en mettre, juste pour rendre le code
   plus lisible).
  </para>
  
  <para>
   Vous pouvez également utiliser un tableau contenant plusieurs valeurs
   à chercher. Actuellement, si nous cherchons les documents "gold" et "copper",
   nous pouvons le faire comme ceci :
  </para>
  
  <programlisting role="php">
<![CDATA[
<?php

$cursor = $collection->find(array("awards" => array('$in' => array("gold", "copper"))));

?>
]]>
  </programlisting>
  
 </section>
</section>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
