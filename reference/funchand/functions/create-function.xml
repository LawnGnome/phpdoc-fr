<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.14 $ -->
<!-- EN-Revision: 1.9 Maintainer: yannick Status: ready -->
<!-- Reviewed: no -->

<refentry xml:id="function.create-function" xmlns="http://docbook.org/ns/docbook">
 <refnamediv>
  <refname>create_function</refname>
  <refpurpose>Crée une fonction anonyme (style lambda)</refpurpose>
 </refnamediv>

 <refsect1 role="description">
  &reftitle.description;
  <methodsynopsis>
   <type>string</type><methodname>create_function</methodname>
   <methodparam><type>string</type><parameter>args</parameter></methodparam>
   <methodparam><type>string</type><parameter>code</parameter></methodparam>
  </methodsynopsis>
  <para>
   Crée une fonction anonyme, à partir des paramètres passés, et retourne
   un nom de fonction unique.
  </para>
 </refsect1>
 <refsect1 role="parameters">
  &reftitle.parameters;
  <para>
   Généralement, les arguments <parameter>args</parameter> sont
   présentés sous la forme d'une chaîne à guillemets simples, et la même
   recommandation vaut pour <parameter>code</parameter>.
   La raison de l'utilisation des guillemets simples est de proteger
   les noms de variables du remplacement par leur valeur. Si vous utilisez
   les guillemets doubles, n'oubliez pas d'échapper les noms
   de variables (i.e. <literal>\$avar</literal>).
   <variablelist>
    <varlistentry>
     <term><parameter>args</parameter></term>
     <listitem>
      <para>
       Les arguments de la fonction.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>code</parameter></term>
     <listitem>
      <para>
       Le code de la fonction.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsect1>

 <refsect1 role="returnvalues">
  &reftitle.returnvalues;
  <para>
   Retourne un nom de fonction unique, sous la forme d'une &string;,
   ou &false; si une erreur survient.
  </para>
 </refsect1>

 <refsect1 role="examples">
  &reftitle.examples;
  <para>
   <example>
    <title>
     Création d'une fonction anonyme avec <function>create_function</function>
    </title>
    <para>
     Vous pouvez utiliser cette fonction pour (par exemple) créer
     une fonction à partir d'informations récoltées
     durant l'exécution :
    </para>
    <programlisting role="php">
<![CDATA[
<?php
$newfunc = create_function('$a,$b', 'return "ln($a) + ln($b) = " . log($a * $b);');
echo "Nouvelle fonction anonyme  : $newfunc\n";
echo $newfunc(2, M_E) . "\n";
// affichera :
// Nouvelle fonction anonyme : lambda_1
// ln(2) + ln(2.718281828459) = 1.6931471805599
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Ou, pour pouvoir appliquer une fonction générique
   à une liste d'arguments.
  </para>
  <para>
   <example>
    <title>
     Traitement générique par fonction avec
     <function>create_function</function>
    </title>
    <programlisting role="php">
<![CDATA[
<?php
function process($var1, $var2, $farr)
{
    foreach ($farr as $f) {
        echo $f($var1, $var2) . "\n";
    }
}

// Création d'une série de fonction mathématiques
$f1 = 'if ($a >=0) {return "b*a^2 = ".$b*sqrt($a);} else {return false;}';
$f2 = "return \"min(b^2+a, a^2,b) = \".min(\$a*\$a+\$b,\$b*\$b+\$a);";
$f3 = 'if ($a > 0 && $b != 0) {return "ln(a)/b = ".log($a)/$b; } else { return false; }';
$farr = array(
    create_function('$x,$y', 'return "un peu de trigo : ".(sin($x) + $x*cos($y));'),
    create_function('$x,$y', 'return "une hypoténuse : ".sqrt($x*$x + $y*$y);'),
    create_function('$a,$b', $f1),
    create_function('$a,$b', $f2),
    create_function('$a,$b', $f3)
    );

echo "\nUtilisation de la première liste de fonctions anonymes\n";
echo "paramétres : 2.3445, M_PI\n";
process(2.3445, M_PI, $farr);

// Maintenant une liste de fonction sur chaîne de caractères
$garr = array(
    create_function('$b,$a', 'if (strncmp($a, $b, 3) == 0) return "** \"$a\" '.
    'and \"$b\"\n** Look the same to me! (looking at the first 3 chars)";'),
    create_function('$a,$b', '; return "CRCs : " . crc32($a) . " , ".crc32(b);'),
    create_function('$a,$b', '; return "similarité (a,b) = " . similar_text($a, $b, &$p) . "($p%)";')
    );
echo "\nUtilisation de la seconde liste de fonctions anonymes\n";
process("Twas brilling and the slithy toves", "Twas the night", $garr);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Utilisation de la première liste de fonctions anonymes
paramétres : 2.3445, M_PI
un peu de trigo : -1.6291725057799
une hypoténuse : 3.9199852871011
b*a^2 = 4.8103313314525
min(b^2+a, a^2,b) = 8.6382729035898
ln(a/b) = 0.27122299212594

Utilisation de la seconde liste de fonctions anonymes
** "Twas the night" and "Twas brilling and the slithy toves"
** Ces chaînes se ressemblent ! (regardez les trois premiers caractères)
CRCs : -725381282 , 1908338681
similarité (a,b) = 11(45.833333333333%)
]]>
    </screen>
   </example>
  </para>
  <para>
   Mais l'utilisation la plus courante des fonctions lambda est la
   fonction de callback, par exemple, lors de l'utilisation de
   <function>array_walk</function> ou <function>usort</function>
  </para>
  <para>
   <example>
    <title>Utilisation de fonctions anonymes comme fonction de callback</title>
    <programlisting role="php">
<![CDATA[
<?php
$av = array("the ", "a ", "cette ", "une certaine ");
array_walk($av, create_function('&$v,$k', '$v = $v . "maison";'));
print_r($av);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Array
(
  [0] => la maison
  [1] => une maison
  [2] => cette maison
  [3] => une certaine maison
)
]]>
    </screen>
    <para>
     un tableau de chaînes de caractères ordonnées de la plus courte à la plus longue
    </para>
    <programlisting role="php">
<![CDATA[
<?php

$sv = array("petite", "longue", "une très longue chaîne", "une phrase toute entière");
print_r($sv);

?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Array
(
  [0] => petite
  [1] => longue
  [2] => une très longue chaîne
  [3] => une phrase toute entière
)
]]>
    </screen>
    <para>
     ordonnées de la plus longue à la plus courte
    </para>
    <programlisting role="php">
<![CDATA[
<?php

usort($sv, create_function('$a,$b','return strlen($b) - strlen($a);'));
print_r($sv);

?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Array
(
  [0] => une phrase toute entière
  [1] => une très longue chaîne
  [2] => longue
  [3] => petite
)
]]>
    </screen>
   </example>
  </para>
 </refsect1>

</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->