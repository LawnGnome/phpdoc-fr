<?xml version='1.0' encoding='iso-8859-1'?>
<!-- $Revision: 1.17 $ -->
<!-- EN-Revision: 1.45 Maintainer: yannick Status: ready -->
<!-- Purpose: database.abstract -->
<!-- Membership: pecl, bundled -->

<reference id="ref.pdo">
 <title>Fonctions PDO</title>
 <titleabbrev>PDO</titleabbrev>

 <partintro>
  <section id="pdo.intro">
   &reftitle.intro;
   <para>
    L'extension <acronym>PHP Data Objects</acronym> (PDO) défint
    une excellente interface pour accéder à une base de données depuis &php;.
    Chaque pilote de base de données implémenté dans l'interface PDO peut utiliser
    des fonctionnalités spécifiques à chaque des bases de données
    en utilisant des extensions de fonctions. Notez que vous ne pouvez
    exécuter aucune fonction de base de données en utilisant l'extension PDO
    par elle-même ; vous devez utiliser un <link linkend="pdo.drivers">driver
    PDO spécifique à la base de données</link> pour accéder au serveur de base
    de données.
   </para>
   <para>
    PDO fournit une interface d'abstraction à l'accès de données, ce qui signifie que vous utilisez
    les mêmes fonctions pour exécuter des requêtes ou récupérer les données quelque
    soit la base de données utilisée. PDO ne fournit <emphasis>pas</emphasis>
    une abstraction de base de données : il ne réécrit pas le SQL, n'émule pas des fonctionnalités
    manquantes. Vous devriez utiliser une interface d'abstraction complète si vous avez
    besoin de celà.
   </para>
   <para>
    PDO est fournit avec &php; 5.1 et est disponible en tant qu'extension PECL pour &php; 5.0 ;
    DO requiert les nouvelles fonctionnalités OO fournies par &php; 5 et donc, ne fonctionne
    pas avec les versions antérieures de &php;.
   </para>
  </section>

  <section id="pdo.installation">
   &reftitle.install;
   <procedure id='pdo.install.unix51up'>
    <title>&php; 5.1 et supérieur sur les systèmes Unix</title>
    <step>
     <para>
      Si vous exécutez une version 5.1 de &php;, PDO est inclut dans cette distribution ;
      il devrait être automatiquement activé lorsque vous lancerez le script de configuration de &php;.
      Il est recommandé de compiler PDO en tant qu'extension partagée, ce qui vous permettera
      de mettre à jour PDO via PECL. Il est également recommandé d'activer le support zlib
      (pour l'installeur PEAR) lors de la compilation de &php;. Vous devriez également avoir besoin
      d'activer le driver PDO correspondant à la base de données de votre choix ; consultez la
      documentation pour les <link linkend="pdo.drivers">drivers PDO spécifiques à une base
      de données</link> pour plus d'informations.
      <screen>
<![CDATA[
./configure --with-zlib --enable-pdo=shared
]]>
      </screen>
     </para>
    </step>
    <step>
     <para>
      Après avoir installé PDO en tant que module partagé, vous devez éditer votre
      fichier &php.ini; afin que l'extension PDO soit chargé automatiquement lorsque
      &php; est lancé. Vous devez y activer également le driver spécifique à votre base
      de données ; assurez-vous qu'ils sont listés après la ligne pdo.so, car PDO
      doit être initialisé avant le chargement des extensions spécifiques à la base de données.
      Si vous avez compiler les extensions statiquement, vous pouvez sauter cette étape.
      <screen>
<![CDATA[
extension=pdo.so
]]>
      </screen>
     </para>
    </step>
    <step>
     <para>
      Le fait d'avoir PDO en tant que module partagé vous permet d'exécuter
      la commande <command>pear upgrade pdo</command> pour mettre à jour
      votre version de PDO sans pour autant avoir besoin de recompiler complètement &php;.
      Notez que si vous faîtes celà, vous devez également mettre à jour votre driver PDO
      spécifique à votre base de données dans le même temps.
     </para>
    </step>
   </procedure>

   <procedure id='pdo.install.pecl'>
    <title>&php; 5.0 et supérieur sur les systèmes Unix</title>
    <step>
     <para>
      PDO est disponible en tant qu'extension PECL depuis
      <ulink url='&url.pecl.package;pdo'>&url.pecl.package;pdo</ulink>.
      L'installation peut être faite via la commande <command>pear</command> ;
      ceci est activé par défaut lorsque vous configurez &php;. Vous devriez vous assurer
      que &php; a été configuré avec --with-zlib pour pouvoir utiliser
      la commande <command>pear</command> afin de gérer les paquets compressés.
     </para>
    </step>

    <step>
     <para>
      Éxécutez la commande suivante pour télécharger, compiler et installer
      la dernière version stable de PDO :
      <screen>
<![CDATA[
pear install pdo
]]>
      </screen>
     </para>
    </step>
    <step>
     <para>
      Si PDO est toujours en version BETA (et au moment de l'écriture de ces lignes, il l'est),
      vous devez demander à l'utilitaire PEAR de récupérer le paquet BETA.
      Au lieu d'éxécuter la commande ci-dessus, lançez la commande suivante :
      <screen>
<![CDATA[
pear install pdo-beta
]]>
      </screen>
     </para>
    </step>
    <step>
     <para>
      La commande <command>pear</command> installe automatiquement
      le module PDO dans votre dossier d'extensions &php;. Pour activer l'extension
      PDO sous les systèmes Linux ou Unix, vous devez ajouter la ligne suivante
      dans votre fichier &php.ini; :
      <screen>
<![CDATA[
extension=pdo.so
]]>
      </screen>
     </para>
     <para>
      Pour plus d'informations sur la compilation de paquets PECL, consultez la section
      sur l'<link linkend="install.pecl">installation de PECL</link> du manuel.
     </para>
    </step>
   </procedure>

   <procedure id='pdo.install.win32php51'>
    <title>Utilisateurs de Windows avec &php; 5.1 et supérieur</title>
    <step>
     <para>
      PDO ainsi que tous les drivers principaux intéragissent avec &php; en tant
      qu'extensions partagées, et ont tout simplement besoin d'être activés en
      édiant le fichier &php.ini; :
      <screen>
<![CDATA[
extension=php_pdo.dll
]]>
      </screen>
     </para>
    </step>
    <step>
     <para>
      Ensuite, choisissez les autres fichiers DLL spécifiques à votre base de données
      et utilisez soit la fonction <function>dl</function> pour les charger
      au moment de l'éxécution ou activer-les dans le fichier &php.ini; en dessous
      de la ligne <filename>php_pdo.dll</filename>. Par exemple :
      <screen>
<![CDATA[
extension=php_pdo.dll
extension=php_pdo_firebird.dll
extension=php_pdo_mssql.dll
extension=php_pdo_mysql.dll
extension=php_pdo_oci.dll
extension=php_pdo_oci8.dll
extension=php_pdo_odbc.dll
extension=php_pdo_pgsql.dll
extension=php_pdo_sqlite.dll  
]]>
      </screen>
     </para>
     <para>
      Ces bibliothèques DDLs doivent exister dans le dossier système
      <link linkend="ini.extension-dir">extension_dir</link>.
     </para>
    </step>
   </procedure>
  </section>

  &reference.pdo.ini;

  <section id="pdo.drivers">
   <title>Drivers PDO</title>
   <para>
    Les drivers suivants sont actuellement implémentés dans l'interface PDO :
    <informaltable>
     <tgroup cols='2'>
      <thead>
       <row>
        <entry>Nom du driver</entry>
        <entry>Bases de données supportées</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><link linkend="ref.pdo-dblib">PDO_DBLIB</link></entry>
        <entry>FreeTDS / Microsoft SQL Server / Sybase</entry>
       </row>
       <row>
        <entry><link linkend="ref.pdo-firebird">PDO_FIREBIRD</link></entry>
        <entry>Firebird/Interbase 6</entry>
       </row>
       <row>
        <entry><link linkend="ref.pdo-mysql">PDO_MYSQL</link></entry>
        <entry>MySQL 3.x/4.0</entry>
       </row>
       <row>
        <entry><link linkend="ref.pdo-oci">PDO_OCI</link></entry>
        <entry>Oracle Call Interface</entry>
       </row>
       <row>
        <entry><link linkend="ref.pdo-odbc">PDO_ODBC</link></entry>
        <entry>ODBC v3 (IBM DB2 unixODBC et win32 ODBC)</entry>
       </row>
       <row>
        <entry><link linkend="ref.pdo-pgsql">PDO_PGSQL</link></entry>
        <entry>PostgreSQL</entry>
       </row>
       <row>
        <entry><link linkend="ref.pdo-sqlite">PDO_SQLITE</link></entry>
        <entry>SQLite 3 et SQLite 2</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>
  </section>

  <section id='pdo.connections'>
   <title>Connexions et gestionnaire de connexion</title>
   <para>
    Les connexions sont établies en créant des instances de la classe de base de PDO.
    Peut importe quel driver vous voulez utiliser ; vous utilisez toujours le nom
    de la classe PDO. Le constructeur accepte des paramètres pour spécifier
    la source de la base de données (connue en tant que DSN) et optionnellement,
    le nom d'utilisateur et le mot de passe (s'il y en a un).
   </para>
   <para>
    <example>
     <title>Connexion à MySQL</title>
     <programlisting role='php'>
<![CDATA[
<?php
$dbh = new PDO('mysql:host=localhost;dbname=test', $user, $pass);
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    S'il y a des erreurs de connexion, un objet <literal>PDOException</literal>
    est lançé. Vous pouvez attrapper cette exception si vous voulez gérer
    cette erreur, ou laisser le gestionnaire globale d'exception défini
    via la fonction <function>set_exception_handler</function> la traiter.
   </para>
   <para>
    <example>
     <title>Gestion des erreurs de connexion</title>
     <programlisting role='php'>
<![CDATA[
<?php
try {
   $dbh = new PDO('mysql:host=localhost;dbname=test', $user, $pass);
   foreach ($dbh->query('SELECT * from FOO') as $row) {
      print_r($row);
   }
   $dbh = null;
} catch (PDOException $e) {
print "Erreur ! : " . $e->getMessage() . "<br/>";
die();
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <warning>
    <para>
     Si votre application n'attrappe pas les exceptions lançées depuis le constructeur PDO,
     l'action par défaut du moteur zend est de terminer le script et d'afficher une trace.
     Cette trace devrait révéler des détails complets sur la connexion à la base de données,
     incluant le nom d'utilisateur et le mot de passe. Il en est donc de votre responsabilité
     d'attrapper cette exception, soit explicitement (via l'instruction <literal>catch</literal>)
     ou implicitement via la fonction <function>set_exception_handler</function>.
    </para>
   </warning>
   <para>
    Lorsque la connexion à la base de données a réussi, une instance de la classe
    PDO est retourné à votre script. La connexion est active tant que l'objet PDO
    l'est. Pour clôre la connexion, vous devez détruire l'objet en vous assurant que
    toutes ses références sont effacées--vous pouvez faire celà en assignant &null;
    à la variable gérant l'objet. Si vous ne le faîtes pas explicitement, &php; fermera
    automatiquement la connexion lorsque le script arrivera à la fin.
   </para>
   <para>
    <example>
     <title>Fermeture d'un connexion</title>
     <programlisting role='php'>
<![CDATA[
<?php
$dbh = new PDO('mysql:host=localhost;dbname=test', $user, $pass);
// utiliser la connexion ici


// et maintenant, fermez-la !
$dbh = null;
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Beaucoup d'applications web utilisent des connexions persistantes aux serveurs
    de base de données. Les connexions persistantes ne sont pas fermées à la fin du
    script, mais sont mises en cache et réutilisées lorsqu'un autre script demande une connexion
    en utilisant les mêmes paramètres. Le cache des connexions persistantes
    vous permet d'éviter d'établir une nouvelle connexion à chaque fois qu'un
    script doit accéder à une base de données, rendant l'application web plus rapide.
   </para>
   <para>
    <example>
     <title>Connexions persistantes</title>
     <programlisting role='php'>
<![CDATA[
<?php
$dbh = new PDO('mysql:host=localhost;dbname=test', $user, $pass, array(
   PDO::ATTR_PERSISTENT => true
));
?>
]]>
     </programlisting>
    </example>
   </para>
   <note>
    <para>
     Si vous utilisez le driver PDO ODBC et que votre bibliothèque ODBC supporte
     le pool de connexion ODBC (unixODBC et Windows le supportent tous les deux ;
     peut être plus), alors, il est recommandé de ne pas utiliser les connexions persistantes
     PDO mais plutôt laisser le pool de connexion ODBC mettre en cache les connexions.
     Le pool de connexion ODBC est partagé avec les autres modules dans le processus ;
     si PDO met en cache la connexion, alors, cette connexion ne sera jamais retournée
     par le pool de connexion ODBC, faisant que plusieurs connexions sont créées pour
     les autres modules.
    </para>
   </note>
  </section>

  <section id='pdo.transactions'>
   <title>Transactions et validation automatique (auto-commit)</title>
   <para>
    Maintenant que vous êtes connecté via PDO, vous devez comprendre
    comme PDO gère les transactions avant d'exécuter des requêtes. Si vous n'avez
    jamais utilisé les transactions, elles offrent 4 fonctionnalités majeures :
    Automatisme, Consistence, Isolation et Durabilité (ACID). En d'autres termes,
    n'importe quel travail mené à bien dans une transaction, même s'il est effectué
    par étapes, est garanti pour être appliqué à la base de données sans risque, et sans
    interférence pour les autres connexions, quand il est validé. Le travail des transactions
    peut également être automatiquement annulé à votre demande (en supposant que
    vous n'avez encore rien validé), ce qui rend la gestion des erreurs bien plus
    simple dans vos scripts.
   </para>
   <para>
    Les transactions sont typiquement implémentées pour appliquer
    toutes vos modifications en une seule fois ; ceci a le bel effet d'éprouver
    drastiquement l'efficacité de vos mises à jour. Dans d'autres termes,
    les transactions rendent vos scripts plus rapides et potentiellement plus
    robuste (vous devez les utiliser correctement pour avoir ces bénéfices).
   </para>
   <para>
    Malheureusement, toutes les bases de données ne supportent pas les transactions,
    donc, PDO doit s'exécuter en mode "auto-commit" lorsque vous ouvrez pour la première
    fois la connexion. Le mode "auto-commit" signifie que toutes les requêtes que vous
    exécutez ont leurs transactions implicites, si la base de données le supporte ou
    aucune transaction si la base de données ne les supporte pas. Si vous avez besoin
    d'une transaction, vous devez utiliser la méthode <function>PDO::beginTransaction</function>
    pour l'initialiser. Si le driver utilisé ne supporte pas les transactions, une exception
    PDO sera lançé (en accord avec votre gestionnaire d'erreurs : ceci est toujours
    une erreur sérieuse). Une fois que vous êtes dans une transaction, vous devez utiliser
    la fonction <function>PDO::commit</function> ou la fonction <function>PDO::rollBack</function>
    pour la terminer, suivant le succès de votre code durant la transaction.
   </para>
   <para>
    Lorsque le script se termine ou lorsque la connexion est sur le point de se fermer,
    si vous avez une transaction en cours, PDO l'annulera automatiquement.
    Ceci est une mesure de sécurité afin de garantir le consistence de vos données
    dans le cas où le script se termine d'une façon inatendue--si vous ne validez pas
    explicitement la transaction, alors, on présume que quelque chose s'est mal passé
    et l'annulation de la transaction intervient afin de garantir la sécurité de vos données.
   </para>
   <warning>
    <para>
     L'annulation automatique intervient si vous avez initialisé la transaction via
     <function>PDO::beginTransaction</function>. Si vous avez manuellement
     exécuté une requête qui commence une transaction, PDO n'a aucun moyen de
     le savoir et donc, n'annulera pas automatiquement cette transaction si quelque
     chose s'est mal passé.
    </para>
   </warning>
   <para>
    <example>
     <title>Exécution d'un groupe dans une transaction</title>
     <para>
      Dans l'exemple suivant, supposons que nous allons crééer un jeu d'entrées
      pour un nouvel employé, dont le numéro d'ID sera 23.
      En plus des données basiques sur cette personne, vous devons également
      lui enregistrer son salaire. Il est très simple d'effectuer deux mises à jour
      séparées, mais en les enfermant dans les appels des fonctions
      <function>PDO::beginTransaction</function> et
      <function>PDO::commit</function>, nous garantissons que personne
      ne pourra voir ces modifications tant qu'elles ne seront pas complètes.
      Si quelque chose tourne mal, le block de capture annulera toutes les
      modifications effectuées depuis le début de la transaction et affichera
      un message d'erreur.
     </para>
     <programlisting role='php'>
<![CDATA[
<?php
try {
    $dbh = new PDO('odbc:SAMPLE', 'db2inst1', 'ibmdb2',
        array(PDO::ATTR_PERSISTENT => true));
    echo "Connecté\n";
    $dbh->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);

    $dbh->beginTransaction();
    $dbh->exec("insert into staff (id, first, last) values (23, 'Joe', 'Bloggs')");
    $dbh->exec("insert into salarychange (id, amount, changedate) 
    values (23, 50000, NOW())");
    $dbh->commit();

} catch (Exception $e) {
    $dbh->rollBack();
    echo "Échec : " . $e->getMessage();
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Vous n'êtes pas limité dans le nombre de mises à jour dans une transaction ;
    vous pouvez également y effectuer des requêtes complexes et bien sûr, utiliser
    ces informations pour construire d'autres mises à jour et requêtes ; durant l'activité
    de la transaction, vous êtes garantie que personne d'autre ne peut effectuer des
    modifications alors que vous êtes au milieu de vos modifications. En réalité,
    ceci n'est pas 100% correct, mais celà reste une très bonne introduction aux
    transactions.
   </para>
  </section>

  <section id='pdo.prepared-statements'>
   <title>Requêtes préparées et procédures stockées</title>
   <para>
    La plupart des bases de données supporte le concepte des requêtes préparées.
    Qu'est-ce donc ? Vous pouvez les voir comme une sorte de template compilée
    pour le SQL que vous voulez exécuter, qui peut être personnalisé en utilisant
    des variables en guise de paramètres. Les requêtes préparées offrent
    deux fonctionnalités essentielles :
   </para>
   <itemizedlist>
    <listitem>
     <simpara>
      La requête ne doit être analysée (ou préparée) qu'une seule fois, mais peut
      être exécutée plusieurs fois avec des paramètres identiques ou différents.
      Lorsque la requête est préparée, la base de données va analyser, compiler
      et optimiser son plan pour exécuter la requête. Pour les requêtes complexes,
      ce processus peut prendre assez de temps, ce qui peut ralentir vos applications
      si vous devez répéter la même requête plusieurs fois avec différents paramètres.
      En utilisant les requêtes préparées, vous évitez ainsi de répéter le cycle
      analyser/compilation/optimisation. Pour résumé, les requêtes préparées
      utilisent moins de ressource et s'exécutent plus rapidement.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Les paramètres pour préparer les requêtes n'ont pas besoin d'être entre
      guillemets ; le driver le gère pour vous. Si votre application utilise exclusivement
      les requêtes préparées, vous pouvez être sûr qu'aucune injection SQL
      n'est possible (Cependant, si vous construisez d'autres parties de la requête
      en vous basant sur des entrées utilisateurs, vous continuez à prendre un risque).
     </simpara>
    </listitem>
   </itemizedlist>
   <para>
    Les requêtes préparées sont tellement pratiques que c'est l'unique fonctionnalité
    que PDO émule pour les drivers qui ne les supportent pas. Ceci assure de pouvoir
    utiliser la même technique pour accéder aux données, sans se soucier des capacités
    de la base de données.
   </para>
   <para>
    <example>
     <title>Insertions répétitives en utilisant les requêtes préparées</title>
     <simpara>
      Cet exemple effectue une requête INSERT en y substituant un
      <literal>nom</literal> et une <literal>valeur</literal> pour les marqueurs nommés.
     </simpara>
     <programlisting role='php'>
<![CDATA[
<?php
$stmt = $dbh->prepare("INSERT INTO REGISTRY (nom, valeur) VALUES (:nom, :valeur)");
$stmt->bindParam(':nom', $nom);
$stmt->bindParam(':valeur', $valeur);

// insertion d'une ligne
$nom = 'one';
$valeur = 1;
$stmt->execute();

// insertion d'une autre ligne avec des valeurs différentes
$nom = 'two';
$valeur = 2;
$stmt->execute();
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>Insertions répétées en utilisant des requêtes réparées</title>
     <simpara>
      Cet exemple effectue une requête INSERT en y substituant un <literal>nom</literal>
      et une <literal>valeur</literal> pour les marqueurs <literal>?</literal>.
     </simpara>
     <programlisting role='php'>
<![CDATA[
<?php
$stmt = $dbh->prepare("INSERT INTO REGISTRY (nom, valeur) VALUES (?, ?)");
$stmt->bindParam(1, $nom);
$stmt->bindParam(2, $valeur);

// insertion d'une ligne
$nom = 'one';
$valeur = 1;
$stmt->execute();

// insertion d'une autre ligne avec différentes valeurs
$nom = 'two';
$valeur = 2;
$stmt->execute();
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>Récupération des données en utilisant des requêtes préparées</title>
     <simpara>
      Cet exemple récupère des données basées sur la valeur d'une clé fournie
      par un formulaire. L'entrée utilisateur est automatiquement échappée, il n'y a
      donc aucun risque d'attaque par injection SQL.
     </simpara>
     <programlisting role='php'>
<![CDATA[
<?php
$stmt = $dbh->prepare("SELECT * FROM REGISTRY where name = ?");
if ($stmt->execute(array($_GET['name']))) {
while ($row = $stmt->fetch()) {
print_r($row);
}
}
?>
         ]]>
     </programlisting>
    </example>
   </para>
   <para>
    Si le driver de la base de données le supporte, vous pouvez également lier
    des paramètres aussi bien pour l'entrée que pour la sortie. Les paramètres de sortie
    sont utilisés typiquement pour récupérer les valeurs d'une procédure stockée.
    Les paramètres de sortie sont un peu plus complexe à utiliser que les paramètres d'entrée
    car vous devez savoir la longueur d'un paramètre donné pourra atteindre lorsque vous
    le liez. Si la valeur retournée est plus longue que la taille qui vous auriez suggéré,
    une erreur sera émise.
   </para>

   <para>
    <example>
     <title>Appel d'une procédure stockée avec un paramètre de sortie</title>
     <programlisting role='php'>
<![CDATA[
<?php
$stmt = $dbh->prepare("CALL sp_returns_string(?)");
$stmt->bindParam(1, $return_value, PDO::PARAM_STR, 4000);

// Appel de la procédure stockée
$stmt->execute();

print "La procédure a retourné : $return_value\n";
?>
]]>
     </programlisting>
    </example>
   </para>

   <para>
    Vous devez également spécifier les paramètres qui gèrent les valeurs
    aussi bien pour l'entrée que pour la sortie ; la synthaxe est similaire aux
    paramètres de sortie. Dans le prochain exemple, la chaîne 'Bonjour' est passée
    à la procédure stockée et lorsqu'elle retourne la valeur, 'Bonjour' est remplacé
    par la valeur retournée par la procédure.
   </para>

   <para>
    <example>
     <title>Appel d'une procédure stockée avec un paramètre d'entrée/sortie</title>
     <programlisting role='php'>
<![CDATA[
<?php
$stmt = $dbh->prepare("CALL sp_takes_string_returns_string(?)");
$value = 'hello';
$stmt->bindParam(1, $value, PDO::PARAM_STR|PDO::PARAM_INPUT_OUTPUT, 4000); 

// appel de la procédure stockée
$stmt->execute();

print "La procédure a retourné : $value\n";
?>
]]>
     </programlisting>
    </example>
   </para>
  </section>

  <section id='pdo.error-handling'>
   <title>Erreurs et gestionnaire des erreurs</title>
   <para>
    PDO offre la possibilité de gérer les erreurs de 3 façons différentes, pour
    coller au mieux au style de votre application.
   </para>
   <itemizedlist>
    <listitem>
     <para>
      <constant>PDO::ERRMODE_SILENT</constant>
     </para>
     <para>
      C'est le mode par défaut. PDO définit simplement le code erreur pour vous
      afin de l'inspecter en utilisant les méthodes <function>PDO::errorCode</function>
      et <function>PDO::errorInfo</function> sur la requête ou sur les objets
      de la base de données ; si l'erreur est issue d'un appel à un objet de requête,
      vous devriez invoquer les méthodes <function>PDOStatement::errorCode</function>
      ou <function>PDOStatement::errorInfo</function> sur cet objet. Si l'erreur
      est issue d'un appel sur un objet de la base de données, vous devriez invoquer
      à la place les méthodes de cet objet.
     </para>
    </listitem>
    <listitem>
     <para>
      <constant>PDO::ERRMODE_WARNING</constant>
     </para>
     <para>
      En plus de définir le code erreur, PDO émettra un message de niveau E_WARNING.
      Ce comportement est très utile lors de la phase de test/débogage, si vous voulez
      juste voir le problème qui survient sans pour autant stopper le flot de l'application.
     </para>
    </listitem>
    <listitem>
     <para>
      <constant>PDO::ERRMODE_EXCEPTION</constant>
     </para>
     <para>
      En plus de définir le code erreur, PDO lancera une exception
      <classname>PDOException</classname> et y définit ces propriétés
      pour refléter le code erreur et l'information sur l'erreur. Ce comportement
      est utile également durant la période de débogage car il va stopper
      l'application à l'endroit même de l'erreur et pointer l'endroit où
      se trouve potentionnellement l'erreur dans votre code (souvenez-vous :
      les transactions sont automatiquement annulées si l'exception fait
      que le script se termine).
     </para>
     <para>
      Le mode lançant des exceptions est également utile pour structurer
      la gestion de vos erreurs plus clairement que par la traditionnelle
      gestion des erreurs de &php; et avec moins de code, plutôt que le mode
      silencieux et l'analyse explicite des valeurs retournées par chaque appel
      à la base de données.
     </para>
     <para>
      Lisez la documentation sur les <link linkend='language.exceptions'>exceptions</link>
      pour plus de détails sur les exceptions en &php;.
     </para>
    </listitem>
   </itemizedlist>
   <para>
    PDO standardise les codes erreurs en utilisant SQL-92 SQLSTATE ; les drivers
    individuels PDO sont responsables du mapping de leurs propres codes
    avec les codes SQLSTATE appropriées. La méthode <function>PDO::errorCode</function>
    retourne un seul code SQLSTATE. Si vous avez besoin de plus d'informations sur
    une erreur, PDO fournit également la méthode <function>PDO::errorInfo</function>
    qui retourne un tableau contenant le code SQLSTATE, le code erreur spécifique
    du driver et la chaîne erreur spécifique au driver.
   </para>
  </section>

  <section id='pdo.lobs'>
   <title>Les objets larges (LOBs)</title>
   <para>
    À un moment dans votre application, vous pourriez avoir besoin de stocker de
    larges données dans votre base de données. "Large" signifie typiquement
    des données d'environ 4ko ou plus, bien que certaines bases de données peuvent
    gérer plus de 32ko avant que les données deviennent "larges". Les objets larges
    peuvent être de nature textuelle ou binaire. PDO vous permet de travailler
    avec ce type de larges données en utilisant le code type
    <constant>PDO::PARAM_LOB</constant> dans vos appels aux fonctions
    <function>PDOStatement::bindParam</function> ou
    <function>PDOStatement::bindColumn</function>.
    <constant>PDO::PARAM_LOB</constant> demande à PDO de mapper les données
    en un flux que vous pourrez manipuler en utilisant
    l'<link linkend='ref.stream'>API &php; sur les flux</link>.
   </para>
   <para>
   </para>
   <para>
    <example>
     <title>Affichage d'une image depuis une base de données</title>
     <para>
      Cet exemple lie un LOB dans une variable nommée $lob et l'envoie
      au navigateur en utilisant la fonction <function>fpassthru</function>.
      Vû qu'un LOB est représenté en un flux, les fonctions comme
      <function>fgets</function>, <function>fread</function> et
      <function>stream_get_contents</function> peuvent être utilisées sur ce flux.
     </para>
     <programlisting role='php'>
<![CDATA[
<?php
$db = new PDO('odbc:SAMPLE', 'db2inst1', 'ibmdb2');
$stmt = $db->prepare("select contenttype, imagedata from images where id=?");
$stmt->execute(array($_GET['id']));
$stmt->bindColumn(1, $type, PDO::PARAM_STR, 256);
$stmt->bindColumn(2, $lob, PDO::PARAM_LOB);
$stmt->fetch(PDO::FETCH_BOUND);

header("Content-Type: $type");
fpassthru($lob);
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>Insertion d'une image dans une base de données</title>
     <para>
      Cet exemple ouvre un fichier et passe le pointeur de fichier à PDO
      pour l'insérer en tant que LOB. PDO fera son possible pour récupérer
      le contenu du fichier et l'insérer dans la base de données de la
      manière la plus efficace possible.
     </para>
     <programlisting role='php'>
<![CDATA[
<?php
$db = new PDO('odbc:SAMPLE', 'db2inst1', 'ibmdb2');
$stmt = $db->prepare("insert into images (id, contenttype, imagedata) values (?, ?, ?)");
$id = get_new_id(); // fonction pour allouer un nouvel ID

// assumons que nous récupérons un fichier depuis un formulaire
// vous pouvez trouver plus de détails dans la documentation de PHP

$fp = fopen($_FILES['file']['tmp_name'], 'rb');

$stmt->bindParam(1, $id);
$stmt->bindParam(2, $_FILES['file']['type']);
$stmt->bindParam(3, $fp, PDO::PARAM_LOB);

$stmt->beginTransaction();
$stmt->execute();
$stmt->commit();
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>Insertion d'une image dans une base de données Oracle</title>
     <para>
      Oracle requiet une synthaxe légèrement différente pour y insérer un LOB
      depuis un fichier. Il est également essentielle d'effectuer votre insertion
      au sein d'une transaction, sinon, votre nouveau LOB sera inséré
      avec une longueur de zéro :
     </para>
     <programlisting role='php'>
<![CDATA[
<?php
$db = new PDO('oci:', 'scott', 'tiger');
$stmt = $db->prepare("insert into images (id, contenttype, imagedata) " .
"VALUES (?, ?, EMPTY_BLOB()) RETURNING imagedata INTO ?");
$id = get_new_id(); // fonction pour allouer un nouvel ID

// assumons que nous récupérons un fichier depuis un formulaire
// vous pouvez trouver plus de détails dans la documentation de PHP

$fp = fopen($_FILES['file']['tmp_name'], 'rb');

$stmt->bindParam(1, $id);
$stmt->bindParam(2, $_FILES['file']['type']);
$stmt->bindParam(3, $fp, PDO::PARAM_LOB);

$stmt->beginTransaction();
$stmt->execute();
$stmt->commit();
?>
]]>
     </programlisting>
    </example>
   </para>
  </section>

  <section id='pdo.classes'>
   &reftitle.classes;
   <section id='pdo.class.PDO'>
    <title><classname>PDO</classname></title>
    <para>
     Représente une connexion entre &php; et un serveur de base de données.
    </para>
    <section id='pdo.class.PDO.constructor'>
     &reftitle.constructor;
     <itemizedlist>
      <listitem>
       <para>
        <link linkend='function.PDO-construct'>PDO</link> - construit un nouvel objet PDO
       </para>
      </listitem>
     </itemizedlist>
    </section>
    <section id='pdo.class.PDO.methods'>
     &reftitle.methods;
     <itemizedlist>
      <listitem>
       <para>
        <link linkend='function.PDO-beginTransaction'>beginTransaction</link>
        - commence une transaction
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDO-commit'>commit</link>
        - valide une transaction
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDO-errorCode'>errorCode</link>
        - récupère un code erreur, s'il y en a, depuis la base de données
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDO-errorInfo'>errorInfo</link>
        - récupère un tableau contenant les informations sur l'erreur, s'il y en a, depuis la base de données
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDO-exec'>exec</link>
        - exécute une requête SQL et retourne le nombre de lignes affectées
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDO-getAttribute'>getAttribute</link>
        - récupère un attribut d'une connexion à une base de données
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDO-lastInsertId'>lastInsertId</link>
        - récupère la valeur de la dernière ligne insérée dans une table
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDO-prepare'>prepare</link>
        - prépare une requête SQL pour exécution
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDO-query'>query</link>
        - exécute une requête SQL et retourne le jeu de résultats
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDO-quote'>quote</link>
        - retourne une version quotée d'une chaîne pour utilisation dans une requête SQL
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDO-rollBack'>rollBack</link>
        - annule une transaction
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDO-setAttribute'>setAttribute</link>
        - définit un attribut d'une connexion à une base de données
       </para>
      </listitem>
     </itemizedlist>
    </section>
   </section>

   <section id='pdo.class.PDOStatement'>
    <title><classname>PDOStatement</classname></title>
    <para>
     Représente une requête préparée et, après, exécution de la requête, un jeu
     de résultat associatif.
    </para>
    <section id='pdo.class.Statement.methods'>
     &reftitle.methods;
     <itemizedlist>
      <listitem>
       <para>
        <link linkend='function.PDOStatement-bindColumn'>bindColumn</link>
        - lie une variable &php; à une colonne de sortie dans un jeu de résultats
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDOStatement-bindParam'>bindParam</link>
        - lie une variable &php; à un paramètre dans une requête préparée
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDOStatement-bindValue'>bindValue</link>
        - lie une valeur à un paramère dans une requête préparée
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDOStatement-closeCursor'>closeCursor</link>
        - ferme le curseur, autorisant la requête à être exécutée une nouvelle fois
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDOStatement-columnCount'>columnCount</link>
        - retourne le nombre de colonnes dans un jeu de résultats
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDOStatement-errorCode'>errorCode</link>
        - récupère le code erreur, s'l y en a, depuis une requête
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDOStatement-errorInfo'>errorInfo</link>
        - récupère un tableau contenant les informations sur une erreur, s'il y en a,
        depuis une requête
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDOStatement-execute'>execute</link>
        - exécute une requête préparée
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDOStatement-fetch'>fetch</link>
        - récupère une ligne depuis un jeu de résultats
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDOStatement-fetchAll'>fetchAll</link> 
        - récupère un tableau contenant touts les lignes depuis un jeu de résultats
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDOStatement-fetchColumn'>fetchColumn</link> 
        - retourne les données depuis une colonne d'un jeu de résultats
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDOStatement-getAttribute'>getAttribute</link> 
        - récupère un attribut PDOStatement
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDOStatement-getColumnMeta'>getColumnMeta</link> 
        - récupère les méta-informations pour une colonne d'un jeu de résultats
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDOStatement-nextRowset'>nextRowset</link> 
        - récupère la ligne suivante (du jeu de résultats)
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDOStatement-rowCount'>rowCount</link> 
        - retourne le nombre de lignes affectées par l'exécution d'une requête SQL
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDOStatement-setAttribute'>setAttribute</link> 
        - définit un attribut PDOStatement
       </para>
      </listitem>
      <listitem>
       <para>
        <link linkend='function.PDOStatement-setFetchMode'>setFetchMode</link> 
        - définit le mode de récupération pour une PDOStatement
       </para>
      </listitem>
     </itemizedlist>
    </section>
   </section>

   <section id='pdo.class.PDOException'>
    <title><classname>PDOException</classname></title>
    <para>
     Représente une erreur émise par PDO. Vous ne devriez pas lancerun exception
     <classname>PDOException</classname> depuis votre propre code.
     Lisez la documentation sur les <link linkend='language.exceptions'>Exceptions</link>
     pour plus de détails sur les exceptions en &php;.
    </para>
    <example>
     <title>La classe PDOException</title>
     <programlisting role='php'>
<![CDATA[
<?php
class PDOException extends Exception
{
public $errorInfo = null;    // correspond à PDO::errorInfo()
// ou PDOStatement::errorInfo()
protected $message;          // message d'erreur textuel
// utiliser Exception::getMessage() pour y accéder
protected $code;             // code erreur SQLSTATE
// utiliser Exception::getCode() pour y accéder
}
?>
]]>
     </programlisting>
    </example>
   </section>
  </section>
  &reference.pdo.constants;
 </partintro>
 &reference.pdo.functions;
</reference>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->