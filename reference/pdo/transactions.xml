<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.2 $ -->
<!-- EN-Revision: 1.3 Maintainer: yannick Status: ready -->
<!-- Reviewed: yes -->

<chapter xml:id="pdo.transactions" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Transactions et validation automatique (autocommit)</title>
 <para>
  Maintenant que vous êtes connecté via PDO, vous devez comprendre
  comment PDO gère les transactions avant d'exécuter des requêtes. Si vous n'avez
  jamais utilisé les transactions, elles offrent 4 fonctionnalités majeures :
  Atomicité, Consistance, Isolation et Durabilité (ACID). En d'autres termes,
  n'importe quel travail mené à bien dans une transaction, même s'il est effectué
  par étapes, est garanti d'être appliqué à la base de données sans risque, et sans
  interférence pour les autres connexions, quand il est validé. Le travail des transactions
  peut également être automatiquement annulé à votre demande (en supposant que
  vous n'avez encore rien validé), ce qui rend la gestion des erreurs bien plus
  simple dans vos scripts.
 </para>
 <para>
  Les transactions sont typiquement implémentées pour appliquer
  toutes vos modifications en une seule fois ; ceci a le bel effet d'éprouver
  drastiquement l'efficacité de vos mises à jour. Dans d'autres termes,
  les transactions rendent vos scripts plus rapides et potentiellement plus
  robustes (vous devez les utiliser correctement pour avoir ces bénéfices).
 </para>
 <para>
  Malheureusement, toutes les bases de données ne supportent pas les transactions,
  donc, PDO doit s'exécuter en mode "autocommit" lorsque vous ouvrez pour la première
  fois la connexion. Le mode "autocommit" signifie que toutes les requêtes que vous
  exécutez ont leurs transactions implicites, si la base de données le supporte ou
  aucune transaction si la base de données ne les supporte pas. Si vous avez besoin
  d'une transaction, vous devez utiliser la méthode <function>PDO::beginTransaction</function>
  pour l'initialiser. Si le driver utilisé ne supporte pas les transactions, une exception
  PDO sera lancée (en accord avec votre gestionnaire d'erreurs : ceci est toujours
  une erreur sérieuse). Une fois que vous êtes dans une transaction, vous devez utiliser
  la fonction <function>PDO::commit</function> ou la fonction <function>PDO::rollBack</function>
  pour la terminer, suivant le succès de votre code durant la transaction.
 </para>
 <para>
  Lorsque le script se termine ou lorsque la connexion est sur le point de se fermer,
  si vous avez une transaction en cours, PDO l'annulera automatiquement.
  Ceci est une mesure de sécurité afin de garantir la consistance de vos données
  dans le cas où le script se termine d'une façon inattendue. Si vous ne validez pas
  explicitement la transaction, alors, on présume que quelque chose s'est mal passé
  et l'annulation de la transaction intervient afin de garantir la sécurité de vos données.
 </para>
 <warning>
  <para>
   L'annulation automatique intervient si vous avez initialisé la transaction via
   <function>PDO::beginTransaction</function>. Si vous avez manuellement
   exécuté une requête qui commence une transaction, PDO n'a aucun moyen de
   le savoir et donc, n'annulera pas automatiquement cette transaction si quelque
   chose s'est mal passé.
  </para>
 </warning>
 <para>
  <example>
   <title>Exécution d'un groupe dans une transaction</title>
   <para>
    Dans l'exemple suivant, supposons que nous allons créer un jeu d'entrées
    pour un nouvel employé, dont le numéro d'ID sera 23.
    En plus des données basiques sur cette personne, nous devons également
    lui enregistrer son salaire. Il est très simple d'effectuer deux mises à jour
    séparées, mais en les enfermant dans les appels des fonctions
    <function>PDO::beginTransaction</function> et
    <function>PDO::commit</function>, nous garantissons que personne
    ne pourra voir ces modifications tant qu'elles ne seront pas complètes.
    Si quelque chose tourne mal, le bloc de capture annulera toutes les
    modifications effectuées depuis le début de la transaction et affichera
    un message d'erreur.
   </para>
   <programlisting role='php'>
<![CDATA[
<?php
try {
  $dbh = new PDO('odbc:SAMPLE', 'db2inst1', 'ibmdb2',
      array(PDO::ATTR_PERSISTENT => true));
  echo "Connecté\n";
  $dbh->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);

  $dbh->beginTransaction();
  $dbh->exec("insert into staff (id, first, last) values (23, 'Joe', 'Bloggs')");
  $dbh->exec("insert into salarychange (id, amount, changedate) 
      values (23, 50000, NOW())");
  $dbh->commit();

} catch (Exception $e) {
  $dbh->rollBack();
  echo "Failed: " . $e->getMessage();
}
?>
]]>
   </programlisting>
  </example>
 </para>
 <para>
  Vous n'êtes pas limité dans le nombre de mises à jour dans une transaction ;
  vous pouvez également y effectuer des requêtes complexes et bien sûr, utiliser
  ces informations pour construire d'autres mises à jour et requêtes ; durant l'activité
  de la transaction, vous êtes garanti que personne d'autre ne peut effectuer des
  modifications alors que vous êtes au milieu de vos modifications. En réalité,
  ceci n'est pas 100% correct, mais cela reste une très bonne introduction aux
  transactions.
 </para>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->

