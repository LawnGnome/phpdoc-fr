<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.1 $ -->
<!-- EN-Revision: 1.13 Maintainer: gui Status: partial -->
<!-- Reviewed: no -->
<chapter xml:id="phar.fileformat" xmlns="http://docbook.org/ns/docbook">
 <title>Qu'est-ce qui fait d'un phar un phar et pas un tar ou un zip?</title>
 <section xml:id="phar.fileformat.ingredients" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Les ingrédients de toutes les archives Phar, indépendemment du format de fichier</title>
  <para>
   Toute les archives Phar contiennent de trois à quatre sections:
   <orderedlist>
    <listitem>
     <para>un conteneur</para>
    </listitem>
    <listitem>
     <para>un manifest décrivant le contenu</para>
    </listitem>
    <listitem>
     <para>Le contenu du fichier</para>
    </listitem>
    <listitem>
     <para>une signature (factultative) pour vérifier l'intégrité (uniquement avec le format de fichier phar)</para>
    </listitem>
   </orderedlist>
  </para>
 </section>
<section xml:id="phar.fileformat.stub" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Le conteneur de fichier Phar</title>
 <para>
  Un conteneur Phar est un simple fichier PHP. Le conteneur minimal contient :
 </para>
 <para>
  <programlisting role="php">
   <![CDATA[<?php __HALT_COMPILER();]]>
  </programlisting>
 </para>
 <para>
  Un conteneur doit contenir au moins le jeton <literal>__HALT_COMPILER();</literal> en guise
  de conclusion. Typiquement, un conteneur comportera les fonctionnalités de chargement suivantes :
  like so:
 </para>
 <para>
  <programlisting role="php">
   <![CDATA[
<?php
Phar::mapPhar();
include 'phar://monphar.phar/index.php';
__HALT_COMPILER();
   ]]>
  </programlisting>
 </para>
 <para>
  Il n'y a aucune restriction sur le contenu d'un conteneur Phar, si ce n'est le besoin d'être conclus
  par <literal>__HALT_COMPILER();</literal>. Le tag fermant PHP <literal><![CDATA[?>]]></literal> peut être 
  inclus ou omis, mais il ne peut y avoir plus d'un espace entre le <literal>;</literal> et le tag fermant
  <literal><![CDATA[?>]]></literal> sans quoi l'extension phar ne sera pas capable de lire le
  manifeste de l'archive.
 </para>
 <para>
  Dans une archive phar basée sur tar ou zip, le conteneur est stocké dans le fichier
  <literal>.phar/stub.php</literal>.  Le conteneur par défaut des archives Phar basées sur
  phar contient approximativement 7k de code pour extraire le contenu du phar et l'exécuter.
  Regardez la fonction <function>Phar::createDefaultStub</function> pour davantage de détails.
 </para>
 <para>
  L'alias phar est stocké, dans le cas d'une archive phar basée sur tar ou zip, dans le fichier
  <literal>.phar/alias.txt</literal> en tant que texte plein.
 </para>
 </section>
 <section xml:id="phar.fileformat.comparison" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Comparaison entre Phar, Tar et Zip</title>
  <para>
   Quels sont les avantages et les inconvénients de chacun des trois formats supportés
   par l'extension phar? Ce tableau tente de répondre à cette question.
  <table>
   <title>Tableau de fonctionnalités : Phar vs. Tar vs. Zip</title>
   <tgroup cols="4">
    <thead>
     <row>
      <entry>Fonctionnalité</entry>
      <entry>Phar</entry>
      <entry>Tar</entry>
      <entry>Zip</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>Format de fichier standard</entry>
      <entry>Non</entry>
      <entry>Oui</entry>
      <entry>Oui</entry>
     </row>
     <row>
      <entry>Peut être exécuté sans l'extension Phar
       <link linkend="phar.fileformat.phartip">[1]</link>
      </entry>
      <entry>Oui</entry>
      <entry>Non</entry>
      <entry>Non</entry>
     </row>
     <row>
      <entry>Compression par fichier</entry>
      <entry>Oui</entry>
      <entry>Non</entry>
      <entry>Oui</entry>
     </row>
     <row>
      <entry>Compression pour toute l'archive</entry>
      <entry>Oui</entry>
      <entry>Oui</entry>
      <entry>Non</entry>
     </row>
     <row>
      <entry>Validation par signature de toute l'archive</entry>
      <entry>Oui</entry>
      <entry>Oui</entry>
      <entry>Non</entry>
     </row>
     <row>
      <entry>Support d'applications spécifiquement Web</entry>
      <entry>Oui</entry>
      <entry>Oui</entry>
      <entry>Oui</entry>
     </row>
     <row>
      <entry>Meta-données par fichier</entry>
      <entry>Oui</entry>
      <entry>Oui</entry>
      <entry>Oui</entry>
     </row>
     <row>
      <entry>Meta-données pour toute l'archive</entry>
      <entry>Oui</entry>
      <entry>Oui</entry>
      <entry>Oui</entry>
     </row>
     <row>
      <entry>Création/modification d'archive
       <link linkend="phar.fileformat.phartip2">[2]</link>
      </entry>
      <entry>Oui</entry>
      <entry>Oui</entry>
      <entry>Oui</entry>
     </row>
     <row>
      <entry>Support complet de toutes les fonctions de flux</entry>
      <entry>Oui</entry>
      <entry>Oui</entry>
      <entry>Oui</entry>
     </row>
     <row>
      <entry>Peut être créée/modifiée même si phar.readonly=1
       <link linkend="phar.fileformat.phartip3">[3]</link>
      </entry>
      <entry>Non</entry>
      <entry>Oui</entry>
      <entry>Oui</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  </para>
  <para xml:id="phar.fileformat.phartip">
   <tip>
    <para>
    [1] PHP ne peut accéder directement au contenu d'une archive Phar sans que l'extension
    Phar soit installée si elle utilise un <literal>conteneur</literal>
    qui extrait le contenu de l'archive phar. Le conteneur
    créé par <function>Phar::createDefaultStub</function> extrait
    l'archive phar et exécute son contenu à partir d'un répertoire temporaire si
    aucune extension phar n'est trouvée.
    </para>
   </tip>
  </para>
  <para xml:id="phar.fileformat.phartip2">
   <tip>
    <para>
    [2] Toute les accès en écriture nécessite que <literal>phar.readonly</literal> soit
    désactivé dans le php.ini ou directement via la ligne de commande.
    </para>
   </tip>
  </para>
  <para xml:id="phar.fileformat.phartip3">
   <tip>
    <para>
    [3] Seules les archives tar ou zip sans <literal>.phar</literal> dans leur
    nom et sans conteneur exécutable <literal>.phar/stub.php</literal>
    peuvent être créées si phar.readonly=1.
    </para>
   </tip>
  </para>
 </section>
 <section xml:id="phar.fileformat.tar" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Les phars basés sur Tar</title>
  <para>
   Les archives basés sur le format de fichier tar sont conforme au format moderne
   USTAR. Le design des en-têtes du fichier tar le rend plus efficace que le format de fichier zip
   et aussi efficace que le format de fichier phar quand il s'agit d'accéder aux données.
   Les noms de fichiers sont limités à 255 octets, y compris le chemin complet au sein de l'archive phar
   basée sur tar. Ces archives peuvent être intégralement compressées au format gzip ou bzip2 tout
   en restant exécutable par l'extension Phar.
  </para>
  <para>
   Pour compresser une archive entière, utilisez <function>Phar::compress</function>.
   Pour décompresser une archive entière, utilisez <function>Phar::decompress</function>.
  </para>
 </section>
 <section xml:id="phar.fileformat.zip" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Les phars basés sur Zip</title>
  <para>
   Les archives basés sur le format de fichier zip supportent de nombreuses fonctionnalités
   incluses dans le format zip. Les méta-données par fichier ou sur toute l'archive sont stockées
   dans les commentaires du fichier zip et de l'archive zip en tant que chaîne de caractères sérialisée.
   Les commentaires zip déjà existants seront lus sans problème en tant que chaîne. Les lectures/écritures
   compressées sont supportées par la compression zlib, et uniquement les lectures compressées par 
   la compression bzip2. Il n'y a pas de limite sur le nombre de fichiers au sein d'une archive phar
   basée sur zip. Les répertoires vides sont stockés dans l'archive zip comme des fichiers avec un slash final,
   comme <literal>mon/repertoire/</literal>
  </para>
 </section>
 <section xml:id="phar.fileformat.phar" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Phar File Format</title>
 <para>
  The phar file format is literally laid out as stub/manifest/contents/signature, and
  stores the crucial information of what is included in the phar archive in its
  <literal>manifest</literal>.
 </para>
 <para>
  The Phar manifest is a highly optimized format that allows per-file
  specification of file compression, file permissions, and even user-defined
  meta-data such as file user or group.  All values greater than 1 byte are stored
  in little-endian byte order, with the exception of the API version, which
  for historical reasons is stored as 3 nibbles in big-endian order.
 </para>
 <para>
  All unused flags are reserved for future use, and must not be used
  to store custom information.  Use the per-file meta-data facility
  to store customized information about particular files.
 </para>
 <para>
  The basic file format of a Phar archive manifest is as follows:
 </para>
 <para>
 <table>
  <title>Global Phar manifest format</title>
  <tgroup cols="2">
   <thead>
    <row>
     <entry>Size in bytes</entry>
     <entry>Description</entry>
    </row>
   </thead>
   <tbody>
    <row>
     <entry>4 bytes</entry>
     <entry>Length of manifest in bytes (1 MB limit)</entry>
    </row>
    <row>
     <entry>4 bytes</entry>
     <entry>Number of files in the Phar</entry>
    </row>
    <row>
     <entry>2 bytes</entry>
     <entry>API version of the Phar manifest (currently 1.0.0)</entry>
    </row>
    <row>
     <entry>4 bytes</entry>
     <entry>Global Phar bitmapped flags</entry>
    </row>
    <row>
     <entry>4 bytes</entry>
     <entry>Length of Phar alias</entry>
    </row>
    <row>
     <entry>??</entry>
     <entry>Phar alias (length based on previous)</entry>
    </row>
    <row>
     <entry>4 bytes</entry>
     <entry>Length of Phar metadata (<literal>0</literal> for none)</entry>
    </row>
    <row>
     <entry>??</entry>
     <entry>Serialized Phar Meta-data, stored in <function>serialize</function> format</entry>
    </row>
    <row>
     <entry>at least 24 * number of entries bytes</entry>
     <entry>entries for each file</entry>
    </row>
   </tbody>
  </tgroup>
 </table>
 </para>
</section>
<section xml:id="phar.fileformat.flags" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Global Phar bitmapped flags</title>
 <para>
  Here are the bitmapped flags currently recognized by the Phar extension
  for the global Phar flat bitmap:
 </para>
 <para>
  <table>
   <title>Bitmap values recognized</title>
   <tgroup cols="2">
   <thead>
    <row>
     <entry>Value</entry>
     <entry>Description</entry>
    </row>
    </thead>
    <tbody>
    <row>
     <entry><literal>0x00010000</literal></entry>
      <entry>If set, this Phar contains a verification signature</entry>
     </row>
     <row>
      <entry><literal>0x00001000</literal></entry>
      <entry>
       If set, this Phar contains at least 1 file that
       is compressed with zlib compression
      </entry>
     </row>
     <row>
      <entry><literal>0x00002000</literal></entry>
      <entry>
       If set, this Phar contains at least 1 file that
       is compressed with bzip compression
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </para>
</section>
<section xml:id="phar.fileformat.manifestfile" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Phar manifest file entry definition</title>
 <para>
  Each file in the manifest contains the following information:
 </para>
 <para>
  <table>
   <title>Phar Manifest file entry</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Size in bytes</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>4 bytes</entry>
      <entry>Filename length in bytes</entry>
     </row>
     <row>
      <entry>??</entry>
      <entry>Filename (length specified in previous)</entry>
     </row>
     <row>
      <entry>4 bytes</entry>
      <entry>Un-compressed file size in bytes</entry>
     </row>
     <row>
      <entry>4 bytes</entry>
      <entry>Unix timestamp of file</entry>
     </row>
     <row>
      <entry>4 bytes</entry>
      <entry>Compressed file size in bytes</entry>
     </row>
     <row>
      <entry>4 bytes</entry>
      <entry>CRC32 checksum of un-compressed file contents</entry>
     </row>
     <row>
      <entry>4 bytes</entry>
      <entry>Bit-mapped File-specific flags</entry>
     </row>
     <row>
      <entry>4 bytes</entry>
      <entry>Serialized File Meta-data length (<literal>0</literal> for none)</entry>
     </row>
     <row>
      <entry>??</entry>
      <entry>Serialized File Meta-data, stored in <function>serialize</function> format</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </para>
 <para>
  Note that as of API version 1.1.1, empty directories are stored as filenames
  with a trailing slash like <literal>my/directory/</literal>
 </para>
 <para>
  The File-specific bitmap values recognized are:
 </para>
 <para>
  <table>
   <title>Bitmap values recognized</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Value</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><literal>0x000001FF</literal></entry>
      <entry>
       These bits are reserved for defining specific file permissions
       of a file.  Permissions are used for <function>fstat</function>
       and can be used to recreate desired permissions upon extraction.
      </entry>
     </row>
     <row>
      <entry><literal>0x00001000</literal></entry>
      <entry>
       If set, this file is compressed with zlib compression
      </entry>
     </row>
     <row>
      <entry><literal>0x00002000</literal></entry>
      <entry>
       If set, this file is compressed with bzip compression
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </para>
</section>
<section xml:id="phar.fileformat.signature" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Phar Signature format</title>
 <para>
  Phars containing a signature always have the signature appended to the
  end of the Phar archive after the loader, manifest, and file contents.
  The two signature formats supported at this time are MD5 and SHA1.
 </para>
 <para>
  <table>
   <title>Signature format</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Length in bytes</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>16 or 20 bytes</entry>
      <entry>
       The actual signature, 20 bytes for an SHA1 signature,
       16 bytes for an MD5 signature, 32 bytes for an SHA256 signature,
       and 64 bytes for an SHA512 signature.
      </entry>
     </row>
     <row>
      <entry>4 bytes</entry>
      <entry>
       Signature flags.  <literal>0x0001</literal> is used to
       define an MD5 signature, <literal>0x0002</literal> is used
       to define an SHA1 signature, <literal>0x0004</literal> is used
       to define an SHA256 signature, and <literal>0x0008</literal> is
       used to define an SHA512 signature.  The SHA256 and SHA512 signature
       support was introduced with API version 1.1.0.
      </entry>
     </row>
     <row>
      <entry>4 bytes</entry>
      <entry>
       Magic <literal>GBMB</literal> used to define the presence of a signature.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </para>
</section>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
