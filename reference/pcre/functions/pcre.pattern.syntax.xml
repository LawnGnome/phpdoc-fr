<?xml version="1.0" encoding="iso-8859-1"?>
<!-- splitted from ./fr/functions/pcre.xml, last change in rev 1.3 -->
<!-- last change to 'pcre.pattern.syntax' in en/ tree in rev 1.2 -->
  <refentry id="pcre.pattern.syntax">
   <refnamediv>
    <refname>syntaxe des masques</refname>
    <refpurpose>
      Fonctionnement des expressions r&eacute;guli&egrave;res.
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <para>
      La biblioth&egrave;que PCRE est un ensemble de fonctions qui
      impl&eacute;mentent la recherche par expressions
      r&eacute;guli&egrave;res, en utilisant la m&ecirc;me syntaxe
      et la m&ecirc;me s&eacute;mantique que le Perl 5, avec quelques
      nuances (voir ci-dessous). L'impl&eacute;mentation actuelle
      est celle de Perl 5.005.
    </para>
   </refsect1>
   <refsect1>
    <title>Diff&eacute;rences avec Perl</title>
    <para>
     Les diff&eacute;rences avec le Perl 5.005 sont pr&eacute;sent&eacute;e ici :
    <orderedlist>
 	 <listitem>
	  <simpara>
       Par d&eacute;faut, un caract&egrave;re d'espacement correspond &agrave;
       n'importe quel caract&egrave;re que la fonction C isspace() reconna&icirc;t,
       bien qu'il soit possible de recompiler la biblioth&egrave;que PCRE avec
       d'autres tables de caract&egrave;res. Normalement, isspace() retourne
       &true; pour les espaces, les retours chariot, les
       nouvelles lignes, les formfeed, les tabulations verticales et horizontales.
       Le Perl 5 n'accepte plus la tabulation verticale comme caract&egrave;re
       d'espacement. La s&eacute;quence &#92;v qui &eacute;tait dans la documentation
       Perl depuis longtemps n'a jamais &eacute;t&eacute; reconnue. Cependant, la
       tabulation verticale elle-m&ecirc;me &eacute;tait reconnue comme un
       caract&egrave;re d'espacement jusqu'&agrave; la version 5.002. Avec les
       version 5.004 et 5.005, l'option &#92;s l'ignore.
	  </simpara>
 	 </listitem>
 	 <listitem>
	  <simpara>
       PRCE ne tol&egrave;re pas la r&eacute;p&eacute;tition de quantificateurs
       dans les expressions. Perl le permet, mais cela ne signifie pas ce que vous
       pourriez penser. Par exemple, (?!a){3} ne s'interpr&egrave;te pas : les trois
       caract&egrave;res suivants ne sont pas des "a". En fait, cela
       s'interpr&egrave;te comme : le caract&egrave;re suivant n'est pas "a" trois fois.
	  </simpara>
 	 </listitem>
 	 <listitem>
	  <simpara>
	   Les occurrences de sous-masques qui interviennent dans des assertions
       n&eacute;gatives sont compt&eacute;es, mais elles ne sont pas
       enregistr&eacute;es dans le vecteur d'occurrences. Perl modifie ses
       variables num&eacute;riques pour toutes les occurrences de sous-masque,
       avant que l'assertion ne v&eacute;rifie le masque entier, et uniquement si
       les sous-masques ne trouvent qu'une seule occurrence.
	  </simpara>
 	 </listitem>
 	 <listitem>
	  <simpara>
       Bien que les caract&egrave;res nul soient tol&eacute;r&eacute;s dans la
       cha&icirc;ne de recherche, ils ne sont pas accept&eacute;s dans le
       masque, car le masque est utilis&eacute; comme une cha&icirc;ne C
       standard, termin&eacute;e par le caract&egrave;re nul. Il faut donc
       utiliser la s&eacute;quence d'&eacute;chappement "&#92;0" dans le masque
       pour rechercher les caract&egrave;res nul.
	  </simpara>
 	 </listitem>
 	 <listitem>
	  <simpara>
       Les s&eacute;quence d'&eacute;chappement suivantes ne sont pas
       support&eacute;es par le Perl: &#92;l, &#92;u, &#92;L, &#92;U, &#92;E,
       &#92;Q. En fait, elles sont impl&eacute;ment&eacute;es par la gestion
       intrins&egrave;que de cha&icirc;nes du Perl, et ne font pas partie
       de ses caract&egrave;res sp&eacute;ciaux.
	  </simpara>
 	 </listitem>
 	 <listitem>
	  <simpara>
       L'assertion &#92;G du Perl n'est pas support&eacute;e car elle n'est pas
       pertinente pour faire des recherches avec des masques uniques.
	  </simpara>
 	 </listitem>
 	 <listitem>
	  <simpara>
       De mani&egrave;re assez &eacute;vidente, PCRE n'accepte pas la
       construction <literal>(?{code})</literal>.
	  </simpara>
 	 </listitem>
 	 <listitem>
	  <simpara>
       Au moment de l'&eacute;criture de PCRE, Perl 5.005_02 avait quelques
       comportements &eacute;tranges avec la capture des cha&icirc;nes
       lorsqu'une partie du masque est redoubl&eacute;e. Par exemple, "aba" avec
       le masque /^(a(b)?)+$/ va affecter &agrave; $2 la valeur "b", mais la
       m&ecirc;me manipulation avec "aabbaa" et /^(aa(bb)?)+$/ laissera $2 vide.
       Cependant, si le masque est remplac&eacute; par /^(aa(b(b))?)+$/ alors $2
       (et d'ailleurs $3) seront correctement affect&eacute;s. Avec le Perl
       5.004, $2 sera correctement affect&eacute; dans les deux cas, et c'est
       aussi vrai avec PCRE. Si Perl &eacute;volue vers un autre comportement
       coh&eacute;rent, PCRE s'adaptera probablement.
	  </simpara>
 	 </listitem>
 	 <listitem>
	  <simpara>
       Une autre diff&eacute;rence encore non r&eacute;solue est le fait qu'en
       Perl 5.005_02 le masque /^(a)?(?(1)a|b)+$/ accepte la cha&icirc;ne "a",
       tandis que PCRE ne l'accepte pas. Cependant, que ce soit avec Perl ou
       PCRE /^(a)?a/ et "a" laisseront $1 vide.
	  </simpara>
 	 </listitem>
 	 <listitem>
	  <para>
       PCRE propose quelques extensions aux expressions r&eacute;guli&egrave;res du Perl.
 	   <orderedlist>
 	    <listitem>
 	     <simpara>
          (a) Bien que les assertions avec retour (lookbehind) soit oblig&eacute;e
          d'apparier une cha&icirc;ne de longueur fixe, toutes les assertions avec
          retour peuvent avoir une longueur diff&eacute;rente. Perl 5.005 leur
          impose d'avoir toutes la m&ecirc;me longueur.
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          (b) Si <link linkend="pcre.pattern.modifiers">PCRE_DOLLAR_ENDONLY</link> est
          activ&eacute;, et que <link linkend="pcre.pattern.modifiers">PCRE_MULTILINE</link>
          n'est pas activ&eacute;, le m&eacute;ta caract&egrave;re
          <literal>$</literal> ne s'applique qu'&agrave; la fin
          physique de la cha&icirc;ne, et non pas avant les caract&egrave;res
          de nouvelle ligne.
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          (c) Si <link linkend="pcre.pattern.modifiers">PCRE_EXTRA</link> est
          activ&eacute;, un antislash suivi d'une lettre sans signification
	      sp&eacute;ciale est consid&eacute;r&eacute;e comme une erreur.
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          (d) SI <link linkend="pcre.pattern.modifiers">PCRE_UNGREEDY</link> est
          activ&eacute;, la "gourmandise" des quantificateurs de
          r&eacute;p&eacute;tition est invers&eacute;es, ce qui est rend non
          gourmand par d&eacute;faut, mais s'ils sont suivis de ?, il seront
          gourmands.
         </simpara>
        </listitem>
       </orderedlist>
	  </para>
 	 </listitem>
 	</orderedlist>
    </para>
   </refsect1>
   <refsect1 id="regexp.reference">
    <title>D&eacute;tails sur les expressions r&eacute;guli&egrave;res</title>
     <refsect2 id="regexp.introduction">
     <title>Introduction</title>
      <simpara>
       La syntaxe et la s&eacute;mantique des expressions r&eacute;guli&egrave;re
       support&eacute;es par PCRE sont d&eacute;crites ci-dessous.  Les expressions
       r&eacute;guli&egrave;res sont aussi d&eacute;crites dans la documentation
       Perl, et dans un grand nombre d'autres livres, avec de nombreux exemples.
       Jeffrey Friedl's "Mastering Regular Expressions", &eacute;dit&eacute;
       chez O'Reilly (ISBN 1-56592-257-3), les d&eacute;crits en profondeur.
       Cette description est organis&eacute;e comme une documentation de
       r&eacute;f&eacute;rence.
	  </simpara>
      <simpara>
       Une expression r&eacute;guli&egrave;re est un masque, appliqu&eacute; &agrave;
       une cha&icirc;ne sujet, de gauche &agrave; droite. La plupart des
       caract&egrave;res se repr&eacute;sentent eux-m&ecirc;mes. Un exemple
       trivial : un masque qui serait "<literal>Le rapide renard gris</literal>",
       pourra correspondre &agrave; une partie de la cha&icirc;ne sujet qui sera
       identique au masque, comme par exemple
       "<literal>Le rapide renard gris court dans la for&ecirc;t</literal>",
	  </simpara>
	 </refsect2>
	 <refsect2 id="regexp.reference.meta">
	  <title>M&eacute;ta-caract&egrave;res</title>
	  <para>
       La puissance des expressions r&eacute;guli&egrave;res provient de
       leur capacit&eacute; &agrave; autoriser des alternatives et des quantificateurs
       de r&eacute;p&eacute;tition dans le masque. Ils sont encod&eacute;s
       dans le masque par des m&eacute;ta-caract&egrave;res, qui ne repr&eacute;sentent
       pas ce qu'ils sont, mais sont interpr&eacute;t&eacute;s d'une certaine
       mani&egrave;re.
      </para>
      <para>
       Il y a deux sortes de m&eacute;ta-caract&egrave;res : ceux qui sont
       reconnus n'importe o&ugrave; dans un masque, hormis entre crochets,
       et ceux qui sont reconnus entre crochets.
      </para>
      <para>
       A l'ext&eacute;rieur des crochets, les m&eacute;ta caract&egrave;res sont :
       <variablelist>
        <varlistentry>
	     <term><emphasis>/</emphasis> antislash</term>
   	     <listitem>
	      <simpara>
	       Caract&egrave;re d'&eacute;chappement, avec de multiples usages
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>^</emphasis> Accent circonflexe</term>
   	     <listitem>
	      <simpara>
	       Le d&eacute;but de la cha&icirc;ne sujet (ou de ligne, en mode multiligne)
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>$</emphasis> Dollar</term>
   	     <listitem>
	      <simpara>
	       La fin de la cha&icirc;ne sujet (ou de ligne, en mode multiligne)
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>.</emphasis> Point</term>
   	     <listitem>
	      <simpara>
	       Remplace n'importe quel caract&egrave;re, hormis le caract&egrave;re
	       de nouvelle ligne (par d&eacute;faut) ;
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>[</emphasis> Crochet ouvrant</term>
   	     <listitem>
	      <simpara>
	       Caract&egrave;re de d&eacute;but de d&eacute;finition de classe
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>]</emphasis> Crochet fermant</term>
   	     <listitem>
	      <simpara>
	       Caract&egrave;re de fin de d&eacute;finition de classe
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>|</emphasis> Barre verticale</term>
   	     <listitem>
	      <simpara>
	       Caract&egrave;re de d&eacute;but d'alternative
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>(</emphasis> Parenth&egrave;se ouvrante</term>
   	     <listitem>
	      <simpara>
	       Caract&egrave;re de d&eacute;but de sous-masque
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>)</emphasis> Parenth&egrave;se fermante</term>
   	     <listitem>
	      <simpara>
	       Caract&egrave;re de fin de sous-masque
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>?</emphasis> Point d'interrogation</term>
   	     <listitem>
	      <simpara>
	       Etend le sens de (; quantificateur de 0 ou 1; quantificateur de minimisation
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>*</emphasis> Etoile</term>
   	     <listitem>
	      <simpara>
	       Quantificateur de 0 ou plus
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>+</emphasis> Plus</term>
   	     <listitem>
	      <simpara>
	       Quantificateur de 1 ou plus
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>{</emphasis> Accolade ouvrante</term>
   	     <listitem>
	      <simpara>
	       Caract&egrave;re de d&eacute;but de quantificateur minimum/maximum
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>}</emphasis> Accolade fermante</term>
   	     <listitem>
	      <simpara>
	       Caract&egrave;re de fin de quantificateur minimum/maximum
          </simpara>
	     </listitem>
        </varlistentry>
      </variablelist>
     </para>
     <para>
      La partie du masque qui est entour&eacute;e de crochet et appel&eacute;
      une classe de caract&egrave;res. Dans les classes de caract&egrave;res,
      les seuls m&eacute;ta caract&egrave;res autoris&eacute;s sont :
       <variablelist>
        <varlistentry>
	     <term><emphasis>&#92;</emphasis> Antislash</term>
   	     <listitem>
	      <simpara>
	       Caract&egrave;re d'&eacute;chappement, avec de multiples usages
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>^</emphasis> Accent circonflexe</term>
   	     <listitem>
	      <simpara>
	       N&eacute;gation de la classe, mais uniquement si plac&eacute; tout
	       au d&eacute;but de la classe
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>-</emphasis> Moins</term>
   	     <listitem>
	      <simpara>
	       Indique un intervalle de caract&egrave;res
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>]</emphasis> Crochet fermant</term>
   	     <listitem>
	      <simpara>
	       Termine la classe de caract&egrave;res
          </simpara>
	     </listitem>
        </varlistentry>
       </variablelist>
       La section suivante d&eacute;crit l'utilisation de chaque
       m&eacute;ta-caract&egrave;res.
	  </para>
	 </refsect2>
	 <refsect2 id="regexp.reference.antislash">
	  <title>Antislash</title>
	  <para>
       Le caract&egrave;re antislash a de nombreuses utilisations.
      </para>
      <para>
       En premier lieu, s'il est suivi d'un caract&egrave;re non
       alpha-num&eacute;rique, il ne prendra pas la signification
       sp&eacute;ciale qui y est rattach&eacute;e. Cette utilisation de
       l'antislash comme caract&egrave;re d'&eacute;chappement s'applique
       &agrave; l'int&eacute;rieur et &agrave; l'ext&eacute;rieur des
       classes de caract&egrave;res. Par exemple, pour recherche le
       caract&egrave;re &eacute;toile "<literal>*</literal>", il faut
       &eacute;crire dans le masque : "<literal>&#92;*</literal>". Cela
       s'applique dans tous les cas, que le caract&egrave;re qui suive
       soit un m&eacute;ta-caract&egrave;re ou non. C'est un moyen s&ucirc;r
       pour s'assurer qu'un caract&egrave;re sera recherch&eacute;
       pour sa valeur litt&eacute;rale, plut&ocirc;t que pour sa valeur
       sp&eacute;ciale. En particulier, pour rechercher les antislash,
       il faut &eacute;crire : "<literal>&#92;&#92;</literal>".
      </para>
      <para>
       Si un masque est utilis&eacute; avec l'option
       <link linkend="pcre.pattern.modifiers">PCRE_EXTENDED</link>,
       les espaces blancs du masque, mais qui ne sont pas dans une
       classe de caract&egrave;res, et les caract&egrave;res entre di&egrave;ses
       "<literal>#</literal>", ainsi que les nouvelles lignes sont ignor&eacute;es.
       L'antislash peut &ecirc;tre utilis&eacute; pour &eacute;chapper et ainsi
       rechercher un espace ou un di&egrave;se.
      </para>
      <para>
       La deuxi&egrave;me utilit&eacute; de l'antislash est de pouvoir
       coder des caract&egrave;res invisibles dans les masques. Il n'y
       a pas de restriction sur la place de ces caract&egrave;res
       invisibles, hormis pour le caract&egrave;re nul qui doit terminer
       le masque.
      </para>
      <para>
       Lors de la pr&eacute;paration du masque, il est souvent plus pratique
       d'utiliser les s&eacute;quences d'&eacute;chappement suivantes,
       plut&ocirc;t que le caract&egrave;re binaire qu'elle repr&eacute;sente :
       <variablelist>
        <varlistentry>
	     <term><emphasis>&#92;a</emphasis></term>
   	     <listitem>
	      <simpara>
	       alarme, c'est-&agrave;-dire le caract&egrave;re BEL (hex 07)
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>&#92;cx</emphasis></term>
   	     <listitem>
	      <simpara>
	       "control-x", avec x qui peut &ecirc;tre n'importe quel
	       caract&egrave;re.
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>&#92;e</emphasis></term>
   	     <listitem>
	      <simpara>
	       escape (hex 1B)
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>&#92;f</emphasis></term>
   	     <listitem>
	      <simpara>
	       formfeed (hex 0C)
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>&#92;n</emphasis></term>
   	     <listitem>
	      <simpara>
	       nouvelle ligne (hex 0A)
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>&#92;r</emphasis></term>
   	     <listitem>
	      <simpara>
	       retour chariot (hex 0D)
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>&#92;t</emphasis></term>
   	     <listitem>
	      <simpara>
	       tabulation (hex 09)
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>&#92;xhh</emphasis></term>
   	     <listitem>
	      <simpara>
	       caract&egrave;re en hexad&eacute;cimal, de code hh
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>&#92;ddd</emphasis></term>
   	     <listitem>
	      <simpara>
	       caract&egrave;re en octal, de code ddd, ou r&eacute;f&eacute;rence 
           arri&egrave;re
          </simpara>
	     </listitem>
        </varlistentry>
       </variablelist>
      </para>
      <para>
       Dans la s&eacute;quence "<literal>&#92;cx</literal>" si "<literal>x</literal>"
       est en minuscule, il est converti en majuscule. Puis, le bit 6 (hex 40)
       est invers&eacute;. Ainsi "<literal>&#92;cz</literal>" devient <literal>1A</literal>,
       mais "<literal>&#92;c{</literal>" devient hex 3B, tandis que "<literal>&#92;c;</literal>"
       devient hex 7B.
      </para>
      <para>
       Apr&egrave;s "<literal>&#92;x</literal>", deux caract&egrave;res
       hexad&eacute;cimaeux sont lus (les lettres peuvent &ecirc;tre en majuscule
       ou minuscule).
      </para>
      <para>
       Apr&egrave;s "<literal>&#92;0</literal>", deux caract&egrave;res octal sont lus.
       Dans chacun des cas, le m&eacute;ta-caract&egrave;re tente de lire autant
       de caract&egrave;re que possible. Ainsi la s&eacute;quence
       "<literal>&#92;0&#92;x&#92;07</literal>", sera comprise comme deux caract&egrave;res nuls,
       suivi d'un caract&egrave;re alarme (BEL). Assurez-vous que vous fournissez
       suffisamment de chiffres apr&egrave;s le m&eacute;ta-caract&egrave;re.
      </para>
      <para>
       La gestion de la s&eacute;quence "<literal>&#92;y</literal>", avec y &lt;&gt; 0
       est plut&ocirc;t compliqu&eacute;e. En dehors des caract&egrave;res de classes,
       PCRE va lire y et tous les caract&egrave;res qui suivent comme des chiffres
       d&eacute;cimaux. Si y est plus petit que 10, ou bien s'il y a
       d&eacute;j&agrave; eu au moins autant de parenth&egrave;ses ouvrantes
       auparavant, la s&eacute;quence est prise pour une r&eacute;f&eacute;rence
       arri&egrave;re. Le d&eacute;tail sera vu ult&eacute;rieurement, apr&egrave;s la
       section sur les sous-masques.
      </para>
      <para>
       A l'int&eacute;rieur d'un caract&egrave;re de classe, ou si y est plus
       grand que 10, et qu'il n'y a pas eu assez de parenth&egrave;ses ouvrantes
       auparavant, PCRE lis jusqu'&agrave; 3 chiffres octals &agrave; la suite
       de l'antislash, et g&eacute;n&egrave;re un octet unique, &agrave; partir
       des 8 bits de poids faible de la s&eacute;quence. Tous les chiffres qui
       suivent ne sont pas interpr&eacute;t&eacute;s, et se representent
       eux-m&ecirc;mes. Par exemple:
       <variablelist>
        <varlistentry>
	     <term><emphasis>&#92;040</emphasis></term>
   	     <listitem>
	      <simpara>
	       une autre mani&egrave;re d'&eacute;crire un espace
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>&#92;40</emphasis></term>
   	     <listitem>
	      <simpara>
	       identique, dans la mesure o&ugrave; il n'y a pas 40
	       parenth&egrave;ses ouvrantes auparavant
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>&#92;7</emphasis></term>
   	     <listitem>
	      <simpara>
	       est toujours une r&eacute;f&eacute;rence arri&egrave;re
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>&#92;11</emphasis></term>
   	     <listitem>
	      <simpara>
	       peut &ecirc;tre une r&eacute;f&eacute;rence de retour,
	       ou une tabulation
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>&#92;011</emphasis></term>
   	     <listitem>
	      <simpara>
	       toujours une tabulation
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>&#92;0113</emphasis></term>
   	     <listitem>
	      <simpara>
	       est une tabulation suivi du caract&egrave;re "3"
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>&#92;113</emphasis></term>
   	     <listitem>
	      <simpara>
	       est le caract&egrave;re 113 (&eacute;tant donn&eacute; qu'il ne
	       peut y avoir plus de 99 r&eacute;f&eacute;rences arri&egrave;res)
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>&#92;377</emphasis></term>
   	     <listitem>
	      <simpara>
	       est un octet dont tous les bits sont &agrave; 1
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>&#92;0113</emphasis></term>
   	     <listitem>
	      <simpara>
	       peut &ecirc;tre soit une r&eacute;f&eacute;rence arri&egrave;re,
	       soit le caract&egrave;re &null;, suivi des caract&egrave;res "8" et "1"
          </simpara>
	     </listitem>
        </varlistentry>
       </variablelist>
      </para>
      <para>
       Les valeurs octales sup&eacute;rieures ou &eacute;gales &agrave; 100 ne
       doivent pas &ecirc;tre introduites par un 0, car seuls les trois premiers
       octets seront lus.
      </para>
      <para>
       Toutes les s&eacute;quences qui d&eacute;finissent une valeur d'un seul
       octet peuvent &ecirc;tre utilis&eacute; dans les classes de caract&egrave;res,
       et &agrave; l'ext&eacute;rieur. De plus, dans une classe de caract&egrave;res,
       la s&eacute;quence "<literal>&#92;b</literal>" est interpr&eacute;t&eacute;e
       comme un caract&egrave;re effacer (backspace, hex 08). A l'ext&eacute;rieur
       d'une classe de caract&egrave;res, il peut avoir d'autres significations
       (voir ci-dessous).
      </para>
      <para>
       On peut encore se servir de l'antislash pour pr&eacute;ciser des types
       g&eacute;n&eacute;riques de valeurs :
       <variablelist>
        <varlistentry>
	     <term><emphasis>&#92;d</emphasis></term>
   	     <listitem>
	      <simpara>
	       tout caract&egrave;re d&eacute;cimal
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>&#92;D</emphasis></term>
   	     <listitem>
	      <simpara>
	       tout caract&egrave;re qui n'est pas un caract&egrave;re d&eacute;cimal
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>&#92;s</emphasis></term>
   	     <listitem>
	      <simpara>
	       tout caract&egrave;re blanc
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>&#92;S</emphasis></term>
   	     <listitem>
	      <simpara>
	       tout caract&egrave;re qui n'est pas un caract&egrave;re blanc
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>&#92;w</emphasis></term>
   	     <listitem>
	      <simpara>
	       tout caract&egrave;re de "mot"
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>&#92;W</emphasis></term>
   	     <listitem>
	      <simpara>
	       tout caract&egrave;re qui n'est pas un caract&egrave;re de "mot"
          </simpara>
	     </listitem>
        </varlistentry>
       </variablelist>
      </para>
      <para>
       Chaque paire pr&eacute;c&eacute;dente d&eacute;finit une partition de
       la table des caract&egrave;res : les deux ensembles sont disjoints.
       Un caract&egrave;re satisfera soit un m&eacute;ta-caract&egrave;re,
       soit l'autre.
      </para>
      <para>
       Un caract&egrave;re de "mot" sera une lettre, un chiffre ou le
       caract&egrave;re soulign&eacute;, c'est-&agrave;-dire un
       caract&egrave;re qui pourra &ecirc;tre une partie d'un mot Perl. La
       d&eacute;finition des lettres et chiffres est d&eacute;finie par les
       tables de caract&egrave;res de PCRE, et peut varier suivant la table
       locale de caract&egrave;re (voir "Tables de caract&egrave;res locales ",
       ci-dessus. Par exemple, dans la configuration fran&ccedil;ais ("fr"),
       certains caract&egrave;res ont des codes sup&eacute;rieurs &agrave;
       128, pour les caract&egrave;res accentu&eacute;s, et ils seront compris
       par le m&eacute;ta caract&egrave;re <literal>&#92;w</literal>.
      </para>
      <para>
       Ces s&eacute;quences de caract&egrave;res peuvent appara&icirc;tre &agrave;
       l'int&eacute;rieur ou &agrave; l'ext&eacute;rieur des classes de
       caract&egrave;res. Elles remplacent &agrave; chaque fois un
       caract&egrave;re du type correspondant. Si cette s&eacute;quence est
       plac&eacute;e en fin de masque, et qu'il n'y a plus de caract&egrave;re &agrave;
       comparer dans la cha&icirc;ne sujet, la recherche &eacute;choue.
      </para>
      <para>
       La quatri&egrave;me utilisation de l'antislash intervient lors d'assertions
       simples. Une assertion impose une condition &agrave; un certain point,
       sans remplacer de caract&egrave;re. L'utilisation de sous-masques pour
       r&eacute;aliser des assertions plus complexes est d&eacute;crites
       plus-bas. Les assertions avec antislash sont les suivantes :
       <variablelist>
        <varlistentry>
	     <term><emphasis>&#92;b</emphasis></term>
   	     <listitem>
	      <simpara>
	       limite de mot
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>&#92;B</emphasis></term>
   	     <listitem>
	      <simpara>
	       pas limite de mot
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>&#92;A</emphasis></term>
   	     <listitem>
	      <simpara>
	       d&eacute;but de la cha&icirc;ne sujet
	       (ind&eacute;pendant du mode multi-lignes)
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>&#92;Z</emphasis></term>
   	     <listitem>
	      <simpara>
	       fin de la cha&icirc;ne sujet ou nouvelle ligne &agrave;
	       la fin de la cha&icirc;ne sujet
	       (ind&eacute;pendant du mode multi-lignes)
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>&#92;z</emphasis></term>
   	     <listitem>
	      <simpara>
	       fin de la cha&icirc;ne sujet
	       (ind&eacute;pendant du mode multi-lignes)
          </simpara>
	     </listitem>
        </varlistentry>
       </variablelist>
      </para>
      <para>
       Ces assertions ne peuvent pas appara&icirc;tre dans une classe de
       caract&egrave;res (mais "&#92;b" a une autre signification &agrave;
       l'int&eacute;rieur d'une classe de caract&egrave;res).
      </para>
      <para>
       Une limite de mot est un emplacement dans la cha&icirc;ne sujet ou un
       caract&egrave;re et son suivant ne sont pas en m&ecirc;me temps des
       caract&egrave;res de mot, ou le contraire (on peut le voir comme
       <literal>&#92;w&#92;W</literal> ou <literal>&#92;W&#92;w</literal>), ou encore le
       premier ou le dernier caract&egrave;re est un caract&egrave;re mot.
      </para>
      <para>
       Les assertions <literal>&#92;A</literal>, <literal>&#92;Z</literal>, et
       <literal>&#92;z</literal> diff&egrave;rent des m&eacute;ta caract&egrave;res
       <literal>^</literal> et <literal>$</literal> dans la mesure o&ugrave;
       ils ne sont pas d&eacute;pendants des options, notamment
       <link linkend="pcre.pattern.modifiers">PCRE_NOTBOL</link>
       ou <link linkend="pcre.pattern.modifiers">PCRE_NOTEOL</link>.
       La diff&eacute;rence entre <literal>&#92;Z</literal> et
       <literal>&#92;z</literal> tient au fait que <literal>&#92;Z</literal> recherche
       les positions avant les nouvelles lignes et &agrave; la fin de la
       cha&icirc;ne sujet, tandis que <literal>&#92;z</literal> ne recherche
       que la fin de la cha&icirc;ne.
	  </para>
	 </refsect2>
	 <refsect2 id="regexp.reference.circudollar">
	  <title>Accent circonflexe et Dollar</title>
	  <para>
       En dehors d'une classe de caract&egrave;res, avec les options par
       d&eacute;faut, <literal>^</literal> est une assertion qui n'est
       vraie que si elle est plac&eacute;e tout au d&eacute;but de la
       cha&icirc;ne. A l'int&eacute;rieur d'une classe de caract&egrave;res,
       <literal>^</literal> a un tout autre sens (voir ci-dessous).
      </para>
      <para>
       <literal>^</literal> n'a pas besoin d'&ecirc;tre le premier
       caract&egrave;re du masque, si plusieurs alternatives sont
       propos&eacute;es, mais il doit &ecirc;tre plac&eacute; en
       premier dans chaque alternative. Si toutes les alternatives
       commencent par <literal>^</literal>, alors le masque est dit ancr&eacute;
       (il y a une autre construction qui porte cette appellation).
      </para>
      <para>
       <literal>$</literal> est une assertion qui n'est vraie que si elle
       est plac&eacute;e tout en fin de cha&icirc;ne ou juste avant un
       caract&egrave;re de nouvelle ligne qui serait le dernier
       caract&egrave;re de la cha&icirc;ne. A l'int&eacute;rieur d'une
       classe de caract&egrave;res, <literal>$</literal> a un tout autre
       sens (voir ci-dessous).
      </para>
      <para>
       <literal>$</literal> n'a pas besoin d'&ecirc;tre le dernier
       caract&egrave;re du masque, si plusieurs alternatives sont
       propos&eacute;es, mais il doit &ecirc;tre plac&eacute; en dernier
       dans chaque alternative. Si toutes les alternatives finissent par
       <literal>$</literal>, alors le masque est dit ancr&eacute; (il y
       a une autre construction qui porte cette appellation). <literal>$</literal>
       n'a pas de valeur particuli&egrave;re dans une classe de
       caract&egrave;res.
      </para>
      <para>
       La signification de <literal>$</literal> peut changer, de mani&egrave;re
       &agrave; l'amener &agrave; ce qu'il ne puisse se trouver qu'en toute
       fin de la cha&icirc;ne sujet. Cela se fait en ajoutant l'option
       <link linkend="pcre.pattern.modifiers">PCRE_DOLLAR_ENDONLY</link>
       au moment de la compilation, ou de l'ex&eacute;cution.
       Cette option est inop&eacute;rante sur <literal>&#92;Z</literal>.
      </para>
      <para>
       La signification de <literal>^</literal> peut changer, de mani&egrave;re
       &agrave; l'amener &agrave; ce qu'il puisse se trouver imm&eacute;diatement
       avant et imm&eacute;diatement apr&egrave;s un caract&egrave;re de nouvelle
       ligne "<literal>&#92;n</literal>". Cela se fait en ajoutant l'option
       <link linkend="pcre.pattern.modifiers">PCRE_MULTILINE</link> au moment de
       la compilation ou de l'ex&eacute;cution.
       Par exemple, le masque <literal>/^abc$/</literal> accepte la cha&icirc;ne
       "<literal>def&#92;nabc</literal>" uniquement en mode multi-lignes. Par
       cons&eacute;quent, toutes les parties du masques qui commencent par
       "<literal>^</literal>" ne sont pas ancr&eacute;es, en mode multi-lignes.
       L'option <link linkend="pcre.pattern.modifiers">PCRE_DOLLAR_ENDONLY</link>
       est ignor&eacute;e si l'option
       <link linkend="pcre.pattern.modifiers">PCRE_MULTILINE</link> est choisie.
      </para>
      <para>
       Notez que les m&eacute;ta caract&egrave;res <literal>&#92;A</literal>,
       <literal>&#92;Z</literal>, et <literal>&#92;z</literal> peuvent servir &agrave;
       r&eacute;p&eacute;rer le d&eacute;but et la fin du sujet, et toutes les
       parties du masque qui commenceront par <literal>&#92;A</literal> seront toujours
       ancr&eacute;es, avec l'option
       <link linkend="pcre.pattern.modifiers">PCRE_MULTILINE</link> ou non.
  	  </para>
	 </refsect2>
	 <refsect2 id="regexp.reference.dot">
	  <title>Point</title>
	  <simpara>
       En dehors d'une classe de caract&egrave;res, un point remplace n'importe
       quel caract&egrave;re, m&ecirc;me invisible et &agrave; l'exception du
       caract&egrave;re de nouvelle ligne. Avec l'option
       <link linkend="pcre.pattern.modifiers">PCRE_DOTALL</link> le point
       remplace n'importe quel caract&egrave;re, m&ecirc;me le caract&egrave;re de
       nouvelle ligne. La gestion des points et compl&egrave;tement
       ind&eacute;pendante de <literal>^</literal> et <literal>$</literal>.
       Le seul point commun est que les deux ont un comportement particulier vis
       &agrave; vis des caract&egrave;re de nouvelle ligne.
      </simpara>
      <simpara>
       Le point n'a pas de comportement particulier dans une classe de
       caract&egrave;res.
	  </simpara>
	 </refsect2>
	 <refsect2 id="regexp.reference.squarebrackets">
	  <title>Crochets</title>
	  <para>
       Un crochet ouvrant <literal>[</literal> introduit une classe de
       caract&egrave;res, et le crochet fermant <literal>]</literal>la
       conclut. Le crochet fermant n'a pas de signification en lui-m&ecirc;me.
       Si le crochet fermant est n&eacute;cessaire &agrave; l'int&eacute;rieur
       d'une classe de caract&egrave;res, il faut qu'il soit le premier
       caract&egrave;re (apr&egrave;s un <literal>^</literal> &eacute;ventuel)
       ou &eacute;chapp&eacute; avec un antislash.
      </para>
	  <para>
       Une classe de caract&egrave;res remplace un seul caract&egrave;re
       dans la cha&icirc;ne sujet, &agrave; moins que le premier
       caract&egrave;re de la classe soit un accent circonflexe
       <literal>^</literal>, qui repr&eacute;sente une n&eacute;gation :
       le caract&egrave;re ne doit pas se trouver dans la classe. Si
       <literal>^</literal> est n&eacute;cessaire dans la classe, il
       suffit qu'il ne soit pas le premier caract&egrave;re, ou bien
       qu'il soit &eacute;chapp&eacute; avec un antislash.
      </para>
      <para>
       Par exemple, le caract&egrave;re <literal>[aeiou]</literal> remplace
       n'importe quelle voyelle minuscule, tandis que <literal>[^aeiou]</literal>
       remplace n'importe quelle caract&egrave;re qui n'est pas une voyelle
       minuscule. <literal>^</literal> est une notation pratique pour
       sp&eacute;cifier des caract&egrave;res qui sont dans une classe,
       en ne citant que ceux qui n'y sont pas. Le comportement est inchang&eacute;.
      </para>
      <para>
       Avec l'option d'insensibilit&eacute; &agrave; la casse, toutes les lettres
       d'une classe de caract&egrave;res repr&eacute;sentent en m&ecirc;me temps
       la majuscule et la minuscule. Par exemple, <literal>[aeiou]</literal>
       repr&eacute;sentera "<literal>A</literal>" ou "<literal>a</literal>", et
       <literal>[^aeiou]</literal> n'acceptera pas ni "<literal>A</literal>",
       tandis que sans l'option, elle l'accepterait.
      </para>
      <para>
       Le caract&egrave;re de nouvelle ligne n'est pas trait&eacute; de
       mani&egrave;re sp&eacute;ciale dans les classes de caract&egrave;res,
       quelque soit l'option <link linkend="pcre.pattern.modifiers">PCRE_DOTALL</link>
       ou <link linkend="pcre.pattern.modifiers">PCRE_MULTILINE</link>. Une classe
       telle que <literal>[^a]</literal> acceptera toujours une nouvelle ligne.
      </para>
	  <para>
       Le signe moins (<literal>-</literal>) est utilis&eacute; pour
       sp&eacute;cifier un intervalle de caract&egrave;res, dans
       une classe. Par exemple, <literal>[d-m]</literal> remplace toutes
       les lettres entre d et m inclus. Si le caract&egrave;re moins est
       requis dans une classe, il faut l'&eacute;chapper avec un antislash,
       ou le faire appara&icirc;tre &agrave; une position ou il ne pourra
       pas &ecirc;tre interpr&eacute;t&eacute; comme une indication d'intervalle,
       c'est-&agrave;-dire au d&eacute;but ou &agrave; la fin de la classe.
      </para>
      <para>
       Il n'est pas possible d'avoir le caract&egrave;re crochet fermant
       "<literal>]</literal>" comme fin d'intervalle. Un masque tel que
       <literal>[W-]46]</literal> est compris comme la classe de caract&egrave;res
       contenant deux caract&egrave;res ("W" et "-") suivi de la cha&icirc;ne
       litt&eacute;rale "46]", ce qui fait qu'il va accepter
       "<literal>W46]</literal>" ou  "<literal>-46]</literal>". Cependant, si
       "<literal>]</literal>" est &eacute;chapp&eacute; avec un antislash, le
       masque <literal>[W-&#92;]46]</literal> est interpr&eacute;t&eacute; comme
       une classe d'un seul caract&egrave;re, contenant un intervalle de
       caract&egrave;res.
      </para>
      <para>
       La valeur octale ou hexad&eacute;cimale de  "<literal>]</literal>" peut
       aussi &ecirc;tre utilis&eacute;e pour d&eacute;terminer les limites
       de l'intervalle. Les intervalles travaillent sur des
       s&eacute;quences ASCII. Ils peuvent aussi &ecirc;tre
       pr&eacute;cis&eacute;es avec des valeurs num&eacute;riques, par exemple
       "<literal>[&#92;000-&#92;037]</literal>".
       Si cet intervalle inclut des lettres utilis&eacute;es avec une
       option d'insensibilit&eacute; de casse, les majuscules ou minuscules
       correspondantes seront aussi incluses. Par exemple,
        "<literal>[C-c]</literal>" est &eacute;quivalent &eacute;
        "<literal>[][&#92;^_`wxyzabc]</literal>", avec l'option
        d'insensibilit&eacute; de casse. Si la table locale de
        caract&egrave;res est "fr", "<literal>[&#92;xc8-&#92;xcb]</literal>"
        correspond aux caract&egrave;res accentu&eacute;s.
      </para>
      <para>
       Les types de caract&egrave;res <literal>&#92;d</literal>,
       <literal>&#92;D</literal>, <literal>&#92;S</literal>, <literal>&#92;s</literal>,
       <literal>&#92;w</literal>, <literal>&#92;W</literal> peuvent aussi intervenir
       dans les classes de caract&egrave;res. Par exemple,
       "<literal>[][&#92;^_`wxyzabc][&#92;dABCDEF]</literal>" acceptera n'importe
       quel caract&egrave;re hexad&eacute;cimal. Un accent circonflexe peut
       aussi &ecirc;tre utilis&eacute; pour sp&eacute;cifier adroitement
       des ensembles de caract&egrave;res plus restrictifs : par exemple
       <literal>[^&#92;W_]</literal> accepte toutes les lettres et les chiffres,
       mais pas les soulign&eacute;s. Tous les caract&egrave;res non alpha-
       num&eacute;riques autres que <literal>&#92;, -, ^</literal> (plac&eacute;s
       en d&eacute;but de cha&icirc;ne) et <literal>]</literal> n'ont pas de
       signification particuli&egrave;re, mais ils ne perdront rien &agrave;
       &ecirc;tre &eacute;chapp&eacute;s.
	  </para>
	 </refsect2>
	 <refsect2 id="regexp.reference.verticalbar">
	  <title>Barre verticale</title>
	  <para>
       La barre verticale <literal>|</literal> sert &agrave; s&eacute;parer des
       alternatives. Par exemple, dans le masque "<literal>/dupont|martin/</literal>"
       recherche soit "<literal>dupont</literal>", soit "<literal>martin</literal>".
       Le nombre d'alternatives n'est pas limit&eacute;, et il est m&ecirc;me possible
       d'utiliser la cha&icirc;ne vide. Lors de la recherche, toutes les alternatives
       sont essay&eacute;es, de gauche &agrave; droite, et la premi&egrave;re qui est
       accept&eacute;e est utilis&eacute;e.
      </para>
      <para>
       Si les alternatives sont dans un sous-masque, elle ne r&eacute;ussiront
       que si le masque principal r&eacute;ussi aussi.
      </para>
	 </refsect2>
	 <refsect2 id="regexp.reference.internal_options">
	  <title>Options internes</title>
	  <para>
       Les options <link linkend="pcre.pattern.modifiers">PCRE_CASELESS</link>,
       <link linkend="pcre.pattern.modifiers">PCRE_MULTILINE</link>,
       <link linkend="pcre.pattern.modifiers">PCRE_DOTALL</link> et
       <link linkend="pcre.pattern.modifiers">PCRE_EXTENDED</link> peuvent
       &ecirc;tre chang&eacute;e &agrave; l'int&eacute;rieur du masque
       lui-m&ecirc;me, avec des s&eacute;quences mises entre
       "<literal>(?</literal>" et "<literal>)</literal>".
       Les options sont :
       <variablelist>
        <varlistentry>
	     <term><emphasis>i</emphasis></term>
   	     <listitem>
	      <simpara>
	       PCRE_CASELESS
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>m</emphasis></term>
   	     <listitem>
	      <simpara>
	       PCRE_MULTILINE
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>s</emphasis></term>
   	     <listitem>
	      <simpara>
	       PCRE_DOTALL
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>x</emphasis></term>
   	     <listitem>
	      <simpara>
	       PCRE_EXTENDED
          </simpara>
	     </listitem>
        </varlistentry>
       </variablelist>
       Par exemple, <literal>(?im)</literal> rend le masque insensible &agrave;
       la casse, et multi-lignes. Il est possible d'annuler ces options en les
       faisant pr&eacute;c&eacute;der par un signe <literal>-</literal> : par
       exemple <literal>(?im-sx)</literal>, ajoutera les options
       <link linkend="pcre.pattern.modifiers">PCRE_CASELESS</link>
       et <link linkend="pcre.pattern.modifiers">PCRE_MULTILINE</link> mais
       annulera les options <link linkend="pcre.pattern.modifiers">PCRE_DOTALL</link>
       et <link linkend="pcre.pattern.modifiers">PCRE_EXTENDED</link>.
       Si une option appara&icirc;t avant et apr&egrave;s le signe moins, l'option
       sera annul&eacute;e.
      </para>
      <para>
       Le domaine d'application de ces options d&eacute;pend de la position de
       la s&eacute;quence d'option. Pour toutes les s&eacute;quences d'options
       qui sont hors des sous-masques (d&eacute;finis plus loin), l'effet est le
       m&ecirc;me que si l'option avait &eacute;t&eacute; fix&eacute;e d&egrave;s
       le d&eacute;but de la recherche. Les exemples suivants se comportent tous
       de la m&ecirc;me fa&ccedil;ons : <literal>(?i)abc</literal>,
       <literal>a(?i)bc</literal>, <literal>ab(?i)c</literal>,
       <literal>abc(?i)</literal>, et sont parfaitement &eacute;quivalents au
       masque <literal>abc</literal> avec l'option
       <link linkend="pcre.pattern.modifiers">PCRE_CASELESS</link>. En d'autres
       termes, activer des s&eacute;quences d'options dans le corps principal
       du masque revient &agrave; appliquer l'option &agrave; tout le masque, sauf
       ordre contraire dans les sous-masques. S'il y a plusieurs s&eacute;quences
       d'options qui portent sur la m&ecirc;me option, la derni&egrave;re s'appliquera.
      </para>
      <para>
       Si une option intervient dans un sous-masque, le comportement est diff&eacute;rent.
       C'est un changement de comportement apparu en Perl 5.005. Une option &agrave;
       l'int&eacute;rieur d'un sous-masque n'affecte que cette partie du masque, ce
       qui fait que <literal>(a(?i)b)c</literal> acceptera <literal>abc</literal>
       et <literal>aBc</literal> mais aucune autre cha&icirc;ne (en supposant que
       <link linkend="pcre.pattern.modifiers">PCRE_CASELESS</link> n'est pas
       utilis&eacute;). Cela signifie que les options permettent d'avoir
       diff&eacute;rente configuration de recherche pour diff&eacute;rentes
       parties du masque.
      </para>
      <para>
       Une s&eacute;quence d'options dans une alternative affecte toute
       l'alternative. Par exemple : <literal>(a(?i)b|c)</literal> accepte
       "<literal>ab</literal>", "<literal>aB</literal>", "<literal>c</literal>",
       et "<literal>C</literal>", m&ecirc;me si, comme dans le cas de
       "<literal>C</literal>", la premi&egrave;re alternative qui porte
       l'option n'est pas prise en compte. Sinon, cela risque d'introduire
       des comportements tr&egrave;s &eacute;tranges : les options
       sp&eacute;cifiques &agrave; PCRE telles que
       <link linkend="pcre.pattern.modifiers">PCRE_UNGREEDY</link> et
       <link linkend="pcre.pattern.modifiers">PCRE_EXTRA</link> peuvent
       &ecirc;tre modifi&eacute;es de la m&ecirc;me
       mani&egrave;re, en utilisant respectivement les caract&egrave;res
       U et X. L'option <literal>(?X)</literal> est particuli&egrave;re,
       car elle doit toujours intervenir avant toutes les autres options,
       m&ecirc;me au niveau du masque entier. Il vaut mieux l'activer au
       d&eacute;but du masque.
	  </para>
	 </refsect2>
	 <refsect2 id="regexp.reference.subpatterns">
	  <title>Sous-masques</title>
	  <para>
       Les sous-masques sont d&eacute;limit&eacute;s par des parenth&egrave;ses,
       et peuvent &ecirc;tre imbriqu&eacute;es. Ajouter des sous-masques a deux
       utilit&eacute;s :
      </para>
      <para>
       1. D&eacute;limiter des alternatives. Par exemple, le masque
       <literal>char(don|mant|)</literal> acceptera les mots
       "<literal>char</literal>", "<literal>charmant</literal>", ou
       "<literal>charmant</literal>". Sans les parenth&egrave;ses, il
       n'accepterait que "<literal>chardon</literal>",
       "<literal>mant</literal>" ou la cha&icirc;ne vide "".
      </para>
      <para>
       2. Le sous-masque est consid&eacute;r&eacute; comme capturant : lorsqu'une
       cha&icirc;ne sujet est accept&eacute;e par le masque complet, les
       sous-masques sont transmis &agrave; l'appelant gr&acirc;ce &agrave;
       un vecteur de sous-masques. Les parenth&egrave;ses ouvrantes sont
       compt&eacute;es de gauche &agrave; droite, (commen&ccedil;ant &agrave; 1).
       Par exemple, soit la cha&icirc;ne sujet "<literal>le roi soleil</literal>"
       qui est utilis&eacute;e avec le masque suivant :
       <literal>Le ((roi|prince) (soleil|charmant))</literal> les sous-masques
       captur&eacute; sont "<literal>roi soleil</literal>", "<literal>roi</literal>",
       et "<literal>soleil</literal>", num&eacute;rot&eacute;s respectivement 1, 2, et 3.
      </para>
      <para>
       L'ubiquit&eacute; des parenth&egrave;ses n'est pas toujours simple
       d'emploi. Il y a des moments o&ugrave; regrouper des sous-masques
       est n&eacute;cessaire, sans pour autant capturer la valeur trouv&eacute;e.
       Si une parenth&egrave;se ouvrante est suivie de "<literal>?:</literal>",
       le sous-masque ne capture pas la cha&icirc;ne assortie, et ne sera pas
       compt&eacute; lors de la num&eacute;rotation des captures. Par exemple,
       avec la cha&icirc;ne "<literal>le prince charmant</literal>", utilis&eacute;
       avec le masque <literal>Le (( ?roi|prince) (soleil|charmant))</literal>
       les cha&icirc;nes captur&eacute;es seront "<literal>prince charmant</literal>"
       et "<literal>charmant</literal>", num&eacute;rot&eacute;s respectivement 1
       et 2.
      </para>
      <para>
       Le nombre maximal de cha&icirc;ne captur&eacute;es est de 99, et le
       nombre total de sous-masque (capturant ou non) ne doit pas
       d&eacute;passer 200.
      </para>
      <para>
	   <literal>(?i:samedi|dimanche)</literal> et
	   <literal>(?:(?i) samedi | dimanche)</literal> : De plus, comme les
	   s&eacute;quences d'options sont valables sur toute une alternative,
       les masques ci-dessus accepteront aussi bien "DIMANCHE" que "Dimanche".
	  </para>
	 </refsect2>
	 <refsect2 id="regexp.reference.repetitions">
	  <title>R&eacute;p&eacute;titions</title>
	  <para>
       Les r&eacute;p&eacute;titions sont sp&eacute;cifi&eacute;es avec
       des quantificateurs, qui peuvent &ecirc;tre plac&eacute;s &agrave;
       la suite des caract&egrave;res suivants :
       <variablelist>
        <varlistentry>
	     <term><emphasis>a</emphasis></term>
   	     <listitem>
	      <simpara>
	       Un caract&egrave;re unique, m&ecirc;me s'il s'agit
	       d'un m&eacute;ta caract&egrave;re
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>[abc]</emphasis></term>
   	     <listitem>
	      <simpara>
	       Une classe de caract&egrave;res
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>&#92;2</emphasis></term>
   	     <listitem>
	      <simpara>
	       Une r&eacute;f&eacute;rence de retour (Voir section suivante)
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>(a|b|c)</emphasis></term>
   	     <listitem>
	      <simpara>
	       Un sous-masque avec parenth&egrave;ses (&agrave; moins que ce ne soit
	       une assertion, voir plus loin)
          </simpara>
	     </listitem>
        </varlistentry>
       </variablelist>
      </para>
      <para>
       Les quantificateurs g&eacute;n&eacute;raux pr&eacute;cisent un nombre
       minimum et maximum de r&eacute;p&eacute;titions possibles, donn&eacute;s
       par deux nombres entre accolades, et s&eacute;par&eacute;s par une virgule.
       Ces nombres doivent &ecirc;tre plus petits que 65536, et le premier nombre
       doit &ecirc;tre &eacute;gal ou inf&eacute;rieur au second. Par exemple
       <literal>z{2,4}</literal> accepte "<literal>zz</literal>",
       "<literal>zzz</literal>", ou "<literal>zzzz</literal>". L'accolade fermante
       n'a pas de signification par elle-m&ecirc;me.
      </para>
      <para>
       Si le second nombre est omis, mais que la virgule est l&agrave;, cela
       signifie qu'il n'y a pas de limite sup&eacute;rieure. Si le second nombre
       et la virgule sont omis, le quantificateur correspond au nombre exact de
       r&eacute;p&eacute;tition attendues. Par exemple :
       accepte n'importe quelle succession d'au moins 3 voyelles minuscules, tandis
       que <literal>&#92;d{d}</literal> n'accepte que 8 chiffres exactement.
      </para>
      <para>
       Une accolade ouvrante qui appara&icirc;t &agrave; une position o&ugrave;
       un quantificateur n'est pas accept&eacute;, ou si la syntaxe des
       quantificateurs n'est pas respect&eacute;e, sera consid&eacute;r&eacute;e
       litt&eacute;rale. Par exemple, "<literal>{,6}</literal>" n'est pas un
       quantificateur, mais une cha&icirc;ne de 4 caract&egrave;res.
      </para>
      <para>
       Le quantificateur {0} est autoris&eacute;, mais l'expression est alors
       ignor&eacute;e.
       <variablelist>
        <varlistentry>
	     <term><emphasis>*</emphasis></term>
   	     <listitem>
	      <simpara>
	       &eacute;quivalent &agrave; {0,}
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>+</emphasis></term>
   	     <listitem>
	      <simpara>
	       &eacute;quivalent &agrave; {1,}
          </simpara>
	     </listitem>
        </varlistentry>
        <varlistentry>
	     <term><emphasis>?</emphasis></term>
   	     <listitem>
	      <simpara>
	       &eacute;quivalent &agrave; {0,1}
          </simpara>
	     </listitem>
        </varlistentry>
       </variablelist>
      </para>
      <para>
       Il est possible de constituer des boucles infinies en cr&eacute;ant un sous-masque
       sans caract&egrave;res, mais pourvu d'un quantificateur sans limite
       sup&eacute;rieure. Par exemple "<literal>(a?)*</literal>.
      </para>
      <para>
       Les versions plus anciennes de Perl et PCRE g&eacute;n&eacute;raient alors
       une erreur au moment de la compilation. Cependant, &eacute;tant donn&eacute;
       qu'il existe des situations o&ugrave; ces constructions peuvent &ecirc;tre
       utiles, ces masques sont d&eacute;sormais autoris&eacute;s. Cependant, si
       la r&eacute;p&eacute;tion du sous-masque ne trouve aucun caract&egrave;re,
       la boucle est interrompue.
      </para>
      <para>
       Par d&eacute;faut, les quantificateurs sont dits "gourmands", c'est &agrave;
       dire, qu'ils cherchent d'abord &agrave; trouve le nombre maximal de
       r&eacute;p&eacute;titions qui autorise le succ&egrave;s de la recherche.
       L'exemple classique pos&eacute; par cette gourmandise est la recherche de
       commentaires d'un programme en C. Les commentaires apparaissent entre les
       s&eacute;quences <literal>/*....*/</literal> et &agrave; l'int&eacute;rieur
       de ces d&eacute;limiteurs, les <literal>*</literal> et <literal>/</literal>
       sont autoris&eacute;s. Appliquer le masque <literal>/&#92;*.*&#92;*/</literal>
       &agrave; la cha&icirc;ne
       <literal>/* first commet */  not comment  /* second comment */</literal>
       ne peut r&eacute;ussir, car le masque travaille sur toute la cha&icirc;ne,
       &agrave; cause de la gourmandise du caract&egrave;re <literal>.*</literal>.
      </para>
      <para>
       Cependant, un quantificateur suivi d'un point d'interrogation cesse
       d'&ecirc;tre gourmand, et au contraire, ne recherche que le nombre
       minimum de r&eacute;p&eacute;tition. Dans ces conditions, le masque
       <literal>/&#92;*.*?&#92;*/</literal> trouvera bien les commentaires du code
       C. La signification des autres quantificateurs n'est pas chang&eacute;e.
      </para>
      <para>
       Attention &agrave; ne pas confondre l'utilisation du point d'interrogation
       ici avec son utilisation comme quantificateur lui-m&ecirc;me.
       A cause cette ambiguit&eacute;, il peut appara&icirc;tre des situations
       o&ugrave; il faut le doubler : <literal>&#92;d??&#92;d</literal>. Ce masque va
       tenter de lire un seul chiffre, mais le cas &eacute;ch&eacute;ant,
       il acceptera 2 chiffres pour permettre &agrave; la recherche
       d'aboutir. Si l'option <link linkend="pcre.pattern.modifiers">PCRE_UNGREEDY</link>
       est activ&eacute;e, (une option qui
       n'est pas disponible avec Perl) alors les quantificateurs sont
       non gourmand par d&eacute;faut, mais peuvent &ecirc;tre
       rendu gourmand au cas par cas, en ajoutant un point d'interrogation
       apr&egrave;s. En d'autres termes, cette option inverse le comportement par
       d&eacute;faut.
      </para>
      <para>
       Lorsqu'un sous-masque est quantifi&eacute; avec un nombre minimum
       de r&eacute;p&eacute;titions, qui soit plus grand que 1, ou avec
       un maximum de r&eacute;p&eacute;titions, le masque compil&eacute; aura
       besoin de plus de place de stockage, proportionnellement au minimum
       et au maximum.
      </para>
      <para>
       Si un masque commence par <literal>..*</literal> ou <literal>.{0,}</literal>
       et que l'option <link linkend="pcre.pattern.modifiers">PCRE_DOTALL</link>
       (&eacute;quivalent en Perl &agrave; /s) est
       activ&eacute;e, c'est-&agrave;-dire en autorisant le remplacement des nouvelles
       lignes par un m&eacute;ta-caract&egrave;re, alors le masque est
       implicitement ancr&eacute;, car tout ce qui suit va &ecirc;tre
       mang&eacute; par la premi&egrave;re s&eacute;quence, et se comportera
       comme si le masque se terminait par le m&eacute;ta caract&egrave;re
       <literal>&#92;A</literal>. Dans le cas o&ugrave; on sait d'avance qu'il
       n'y aura pas de caract&egrave;re de nouvelle ligne, activer l'option
       <link linkend="pcre.pattern.modifiers">PCRE_DOTALL</link> et commencer
       le masque par <literal>.*</literal> permet d'optmiser le masque.
      </para>
      <para>
       Alternativement, on peut utiliser <literal>^</literal> pour ancrer
       explicitement le masque. Lorsqu'un sous-masque capturant est
       r&eacute;p&eacute;t&eacute;, la valeur captur&eacute;e est la
       derni&egrave;re. Par exemple, apr&egrave;s que
       "<literal>(inter[net]{3}&#92;s*)+</literal>" ai &eacute;t&eacute;
       appliqu&eacute; &agrave; "<literal>internet interne</literal>",
       la valeur de la cha&icirc;ne captur&eacute;e est "<literal>interne</literal>".
      </para>
      <para>
       Cependant, s'il y a des sous-masques imbriqu&eacute;s, la valeur
       captur&eacute;e correspondante peut l'avoir &eacute;t&eacute; lors
       des pr&eacute;c&eacute;dentes it&eacute;rations. Par exemple :
       <literal>/(a|(b))+/</literal> accepte "<literal>aba</literal>" et
       la deuxi&egrave;me valeur captur&eacute;e est "<literal>b</literal>".
      </para>
	 </refsect2>
	 <refsect2 id="regexp.reference.back_references">
	  <title>R&eacute;f&eacute;rences arri&egrave;res </title>
	  <para>
       En dehors des classes de caract&egrave;res, un antislash suivi
       d'un nombre plus grand que 0 (et possiblement plusieurs chiffres)
       est une r&eacute;f&eacute;rence arri&egrave;re (c'est &agrave;
       dire vers la gauche) dans le masque, en supposant qu'il y ait
       suffisamment de sous-masques capturants pr&eacute;c&eacute;dants.
      </para>
      <para>
       Cependant, si le nombre d&eacute;cimal suivant l'antislash est
       plus petit que 10, il sera toujours consid&eacute;r&eacute;
       comme une r&eacute;f&eacute;rence arri&egrave;re, et cela
       g&eacute;n&egrave;rera une erreur si le nombre de capture
       n'est pas suffisant. En d'autres termes, il faut qu'il existe
       suffisamment de parenth&egrave;ses ouvrantes &agrave; gauche
       de la r&eacute;f&eacute;rence, surtout si la r&eacute;f&eacute;rence
       est inf&eacute;rieure &agrave; 10.
      </para>
      <para>
       Reportez-vous &agrave; la section "antislash" pour avoir de
       plus amples d&eacute;tails &agrave; propos du nombre de
       chiffres qui suivent l'antislash.
      </para>
      <para>
       La r&eacute;f&eacute;rence arri&egrave;re remplace ce qui a
       &eacute;t&eacute; captur&eacute; par un sous-masque dans le
       masque courant, plut&ocirc;t que remplace le sous-masque
       lui-m&ecirc;me. Ainsi <literal>(calme|rapide)</literal> et
       <literal>&#92;1ment</literal> trouvera "<literal>calme et calmement</literal>"
       et "<literal>rapide et rapidement</literal>", mais pas
       "<literal>calme et rapidement</literal>". Si la recherche tient
       compte de la casse, alors la casse de la cha&icirc;ne
       captur&eacute;e sera importante. Par exemple,
       <literal>((?i)rah)&#92;s+&#92;1</literal> trouve "<literal>rah rah</literal>"
       et "<literal>RAH RAH</literal>", mais pas "<literal>RAH rah</literal>",
       m&ecirc;me si le sous-masque capturant initial ne tenait pas compte
       de la casse.
      </para>
      <para>
       Il peut y avoir plusieurs r&eacute;f&eacute;rences arri&egrave;res dans
       le m&ecirc;me sous-masque. Si un sous-masque n'a pas &eacute;t&eacute;
       utilis&eacute; dans une recherche, alors les r&eacute;f&eacute;rences
       arri&egrave;res &eacute;choueront. Par exemple "<literal>(a|(bc))&#92;2</literal>"
       ne r&eacute;ussira jamais si la cha&icirc;ne sujet commence par
       "<literal>a</literal>" plut&ocirc;t que par "<literal>bc</literal>".
      </para>
      <para>
       Etant donn&eacute; qu'il peyt y avoir jusqu'&agrave; 99 r&eacute;f&eacute;rences
       arri&egrave;res, tous les chiffres apr&egrave;s l'antislash sont
       consid&eacute;r&eacute;s comment faisant potentiellement partie de
       la r&eacute;f&eacute;rence arri&egrave;re. Si le masque recherche un
       chiffre apr&egrave;s la r&eacute;f&eacute;rence, alors il faut
       imp&eacute;rativement utiliser des d&eacute;limiteurs pour terminer
       la r&eacute;f&eacute;rence arri&egrave;re.
      </para>
      <para>>
       Si l'option <link linkend="pcre.pattern.modifiers">PCRE_EXTENDED</link>
       est activ&eacute;e, on peut utiliser un espace.
       Sinon, un commentaire vide fait l'affaire. Une r&eacute;f&eacute;rence
       arri&egrave;re qui intervient &agrave; l'int&eacute;rieur de
       parenth&egrave;ses auquel elle fait r&eacute;f&eacute;rence
       &eacute;chouera d&egrave;s que le sous-masque sera utilis&eacute;. Par exemple,
       <literal>(a&#92;1)</literal> &eacute;chouera toujours. Cependant, ces
       r&eacute;f&eacute;rences peuvent &ecirc;tre utiles dans les
       sous-masques r&eacute;p&eacute;titifs. Par exemple, le masque
       "<literal>(a|b&#92;1)+</literal>" pourra convenir pour "<literal>a</literal>",
       "<literal>aba</literal>", "<literal>ababaa</literal>", etc....
      </para>
      <para>
       A chaque it&eacute;ration du sous-masque, la r&eacute;f&eacute;rence
       arri&egrave;re utilise le r&eacute;sultat du dernier sous-masque.
       Pour que cela fonctionne, il faut que la premi&egrave;re
       it&eacute;ration n'ai pas besoin d'utiliser la r&eacute;f&eacute;rence
       arri&egrave;re. Cela arrive avec les alternatives, comme dans
       l'exemple ci-dessus, ou avec un quantificateur de minimum 0.
  	  </para>
	 </refsect2>
	 <refsect2 id="regexp.reference.assertions">
	  <title>Assertions</title>
	  <para>
       Une assertion est un test sur les caract&egrave;res suivants ou
       pr&eacute;c&eacute;dent celui qui est en cours d'&eacute;tude. Ce
       test ne consomme par de caract&egrave;re (ie, on ne d&eacute;place
       pas le pointeur de caract&egrave;res). Les assertions simples sont
       cod&eacute;es avec <literal>&#92;b</literal>, <literal>&#92;B</literal>,
       <literal>&#92;A</literal>, <literal>&#92;Z</literal>, <literal>&#92;z</literal>,
       <literal>^</literal> et <literal>$</literal>, et sont d&eacute;crites
       pr&eacute;c&eacute;demment.
      </para>
      <para>
       Il existe cependant un type d'assertions plus complexes, cod&eacute;es
       sous la forme de sous-masques. Il en existe deux types : celles qui
       travaillent au-del&agrave; de la position courante (<literal>&#92;w+(?=;)</literal>),
       et celles qui travaillent en de&ccedil;a (<literal>(?!)&#92;w+</literal>).
      </para>
      <para>
       Une assertion se comporte comme un sous-masque, hormis le fait qu'elle
       ne d&eacute;place pas le pointeur de position. Les assertions avant
       commencent par <literal>(?=</literal> pour les assertions positives, et
       par <literal>(?!</literal>, pour les assertions n&eacute;gatives. Par exemple :
       <literal>&#92;w+(?=;)</literal> s'assure qu'un mot est suivi d'un point-virgule,
       mais n'inclus pas le point virgule dans la capture. D'autre part,
       <literal>(?!foo)bar</literal> en est proche, mais ne trouve pas une
       occurrence de "<literal>bar</literal>" qui soit pr&eacute;c&eacute;d&eacute;e
       par quelque chose d'autre que "<literal>foo</literal>foo"; il trouve toutes
       les occurrences de "<literal>bar</literal>", quelque soit ce qui
       le pr&eacute;c&eacute;de, car l'assertion <literal>(?!foo)</literal>
        est toujours vraie quand les trois caract&egrave;res suivants sont
        "<literal>bar</literal>". Une assertion arri&egrave;re est ici
        n&eacute;cessaire.
       </para>
       <para>
        Les assertions arri&egrave;res commencent par <literal>(?&lt;=</literal>
        pour les assertions positives, et <literal>(?&lt;!</literal> pour les
        assertions n&eacute;gatives. Par exemple : <literal>(?&lt;!foo)bar</literal>
        trouve les occurrences de "<literal>bar</literal>" qui ne sont pas
        pr&eacute;c&eacute;d&eacute;es par "<literal>foo</literal>".
       </para>
       <para>
        Le contenu d'une r&eacute;f&eacute;rence arri&egrave;re est limit&eacute;
        de telle fa&ccedil;on que les cha&icirc;nes qu'il utilise
        soient toujours de la m&ecirc;me taille. Cependant, lorsqu'il
        y a plusieurs alternatives, elles n'ont pas besoin d'&ecirc;tre
        de la m&ecirc;me taille. Par exemple, <literal>(?&lt;=bullock|donkey)</literal>
        est autoris&eacute;, tandis que <literal>(?&lt;!dogs?|cats?)</literal>
        provoque une erreur de compilation. Les alternatives qui ont des
        longueurs diff&eacute;rentes ne sont autoris&eacute;es qu'au niveau
        sup&eacute;rieur des assertions arri&egrave;res. C'est une
        am&eacute;lioration du fonctionnement de Perl 5.005, qui impose
        aux alternatives d'avoir toutes la m&ecirc;me taille. Une
        assertion telle que <literal>(?&lt;=ab(c|de))</literal> n'est pas
        autoris&eacute;e, car l'assertion de bas niveau (la deuxi&egrave;me,
        ici) a deux alternatives de longueurs diff&eacute;rentes. Pour
        la rendre acceptable, il faut &eacute;crire <literal>(?&lt;=abc|abde)</literal>
       </para>
       <para>
        L'impl&eacute;mentation des assertions arri&egrave;res d&eacute;place
        temporairement le pointeur de position vers l'arri&egrave;re, et cherche
        &agrave; v&eacute;rifier l'assertion. Si le nombre de caract&egrave;res
        est diff&eacute;rent, la position ne sera pas correcte, et l'assertion
        &eacute;chouera. La combinaison d'assertions arri&egrave;res avec des
        sous-masques peut &ecirc;tre particuli&egrave;rement pratique &agrave;
        fin des cha&icirc;nes. Un exemple est donn&eacute; &agrave; la fin de
        cette section.
       </para>
       <para>
        Plusieurs assertions peuvent intervenir successivement. Par exemple,
        le masque <literal>(?&lt;=&#92;d{3})(?&lt;!999)foo</literal> recherche
        les cha&icirc;nes "<literal>foo</literal>" pr&eacute;c&eacute;d&eacute;es
        par trois chiffres qui ne sont pas "999". Notez que chaque assertion
        est appliqu&eacute;es ind&eacute;pendemment, au m&ecirc;me point de
        la cha&icirc;ne &agrave; traiter. Tout d'abord, il est
        v&eacute;rifi&eacute; que les trois premiers caract&egrave;res ont
        tous des chiffres, puis on s'assure que ces trois caract&egrave;res
 	    ne sont pas "<literal>999</literal>". Le masque pr&eacute;c&eacute;dant
 	    n'accepte pas "<literal>foo</literal>" pr&eacute;c&eacute;d&eacute; de
 	    6 caract&egrave;res, les trois premiers &eacute;tant des chiffres et
 	    les trois suivants &eacute;tant diff&eacute;rents de "<literal>999</literal>".
 	    Par exemple, ce masque n'acceptera pas la cha&icirc;ne
 	    "<literal>123abcfoo</literal>". Pour ce faire, il faut utiliser le masque
 	    suivant : <literal>(?&lt;=&#92;d{3}...)(?&lt;!999)foo</literal>. Dans ce
 	    masque, la premi&egrave;re assertion v&eacute;rifie les six premiers
 	    caract&egrave;res, s'assure que les trois premiers sont des entiers,
 	    et la deuxi&egrave;me assertion s'assure que les trois derniers
 	    caract&egrave;res ne sont pas "<literal>999</literal>".
 	   </para>
 	   <para>
        De plus, les assertions peuvent &ecirc;tre imbriqu&eacute;es :
        <literal>(?&lt;=(?&lt;!foo)bar)baz</literal> recherche les
        occurrences de "<literal>baz</literal>" qui sont
        pr&eacute;c&eacute;d&eacute;es par "<literal>bar</literal>", qui,
        &agrave; son tour, n'est pas pr&eacute;c&eacute;d&eacute; par
        "<literal>foo</literal>". Au contraire,
        <literal>(?&lt;=&#92;d{3}(?!999)...)foo</literal> est un autre masque,
        qui recherche les caract&egrave;res "<literal>foo</literal>",
        pr&eacute;c&eacute;d&eacute;s par trois chiffres, suivis trois
        autres caract&egrave;res qui ne forment pas "<literal>999</literal>".
        Les assertions ne sont pas capturantes, et ne peuvent pas &ecirc;tre
        r&eacute;p&eacute;t&eacute;es. Si une assertion contient des sous-masques
        capturants en son sein, ils seront compris dans le nombre de sous-masques
        capturants du masque entier. La capture est r&eacute;alis&eacute;e pour
        les assertions positives, mais cela n'a pas de sens pour les
        assertions n&eacute;gatives.
       </para>
       <para>
        200 assertions au maximum sont autoris&eacute;es.
  	  </para>
	 </refsect2>
	 <refsect2 id="regexp.reference.onlyonce">
	  <title>Sous-masques uniques</title>
	  <para>
       Avec les quantificateurs de r&eacute;p&eacute;titions, l'&eacute;chec
       d'une recherche conduit normalement &agrave; une autre recherche, avec
       un nombre diff&eacute;rent de r&eacute;p&eacute;titions, pour
       voir si le masque ne s'applique pas dans d'autres conditions.
       Parfois, il est pratique d'&eacute;viter ce comportement, soit
       pour changer la nature de la recherche, soit pour la faire abandonner
       plus t&ocirc;t, si on pense qu'il n'est pas besoin d'aller plus loin.
      </para>
      <para>
       Consid&eacute;rons par exemple, le masque <literal>&#92;d+foo</literal>
       appliqu&eacute; &agrave; la ligne <literal>123456bar</literal>.
       Apr&egrave;s avoir tent&eacute; d'utiliser les 6 chiffres suivi
       de "<literal>foo</literal>" qui font &eacute;chouer, l'action habituelle
       sera de r&eacute;essayer avec 5 chiffres, puis avec 4, et ainsi de
       suite jusqu'&agrave; l'&eacute;chec final.
      </para>
      <para>
       Un sous-masque &eacute;valu&eacute; une seule fois permettrait
       d'indiquer que lorsqu'une partie du masque est trouv&eacute;e, elle
       n'a pas besoin d'&ecirc;tre r&eacute;&eacute;valu&eacute;e &agrave;
       chaque tentative. Ceci conduirait &agrave; ce que la recherche
       &eacute;choue imm&eacute;diatement apr&egrave;s le premier test.
       Ces assertions ont leur propre notation, commen&ccedil;ant avec
       <literal>(?&gt;</literal> comme ceci : <literal>(?&gt;&#92;d+)bar</literal>.
      </para>
      <para>
       Ce type de parenth&egrave;ses verrouille le sous-masque qu'il contient
       un fois qu'il a &eacute;t&eacute; trouv&eacute;, et emp&ecirc;che un
       &eacute;chec ult&eacute;rieur d'y repasser, mais autorise &agrave;
       revenir plus loin en arri&egrave;re. Une autre description est que
       les sous-masques de ce type recherche les cha&icirc;nes de
       caract&egrave;res, et les ancre le sous-masque &agrave; l'int&eacute;rieur
       de la cha&icirc;ne.
      </para>
      <para>
       Les sous-masques uniques ne sont pas capturants. Des cas simples comme
       ceux pr&eacute;sent&eacute;s ci-dessus peuvent &ecirc;tre pris comme
       des situations maximisantes, qui r&eacute;servent le maximum de
       caract&egrave;res. En effet, alors que <literal>&#92;d+</literal> et
       <literal>&#92;d+?</literal> ajustent le nombre de chiffres trouv&eacute;s
       de mani&egrave;re &agrave; laisser la possibilit&eacute; au masque de
       r&eacute;ussir, <literal>(?&gt;&#92;d+)</literal> ne peut retenir que la
       s&eacute;quence enti&egrave;re de chiffres. Cette construction peut
       contenir un nombre arbitraire de sous-masques complexes, et ils peuvent
       &ecirc;tre imbriqu&eacute;s.
      </para>
      <para>
       Les sous-masques uniques ne peuvent &ecirc;tre utilis&eacute;s qu'avec
       les assertions arri&egrave;res, pour effectuer une recherche efficace
       en fin de cha&icirc;ne. Consid&eacute;rons un masque simple tel que
       "<literal>abcd$</literal>" appliqu&eacute; &agrave; une tr&egrave;s
       longue cha&icirc;ne qui ne lui correspond pas. A cause du syst&egrave;me
       de recherche de gauche &agrave; droite, PCRE va commencer par rechercher
       un "<literal>a</literal>" dans la cha&icirc;ne sujet, puis v&eacute;rifier
       si ce qui suit convient au reste du masque. Si le masque est
       sp&eacute;cifi&eacute; sous la forme <literal>^.*abcd$</literal>
       alors, la s&eacute;quence <literal>.*</literal> remplace en premier
       lieu la cha&icirc;ne enti&egrave;re, et &eacute;choue, repart en
       arri&egrave;re, et remplace tous les caract&egrave;res sauf le dernier,
       &eacute;choue, retourne en arri&egrave;re, prend un caract&egrave;re
       de moins, etc... et ainsi de suite. Encore une fois, la recherche du
       "<literal>a</literal>" passe en revue toute la cha&icirc;ne de gauche
       &agrave; droite, ce qui n'est pas tr&egrave;s efficace. Par contre,
       si le masque &eacute;tait &eacute;crit <literal>^(?&gt;.*)(?&lt;=abcd)</literal>
       alors il n'y aurait pas de retour en arri&egrave;re, pour satisfaire
       la s&eacute;quence <literal>.*</literal>, car elle ne peut que remplacer
       toute la cha&icirc;ne. L'assertion arri&egrave;re cons&eacute;cutive
       va alors faire un test sur les 4 derniers caract&egrave;res. Si elle
       &eacute;choue, la recherche est imm&eacute;diatement interrompue.
      </para>
      <para>
       Pour les cha&icirc;nes tr&egrave;s longues, cette approche fait la
       diff&eacute;rence en terme de performances et de temps de recherche.
	   Lorsqu'un masque contient une r&eacute;p&eacute;tition illimit&eacute;e
	   dans un sous-masque, qui contient lui-m&ecirc;me un nombre
	   illimit&eacute; de r&eacute;p&eacute;titeur, l'utilisation des
	   sous-masques &agrave; utilisation unique sont la seule fa&ccedil;on
	   d'&eacute;viter l'&eacute;chec de la recherche &agrave;  apr&egrave;s un
	   temps de calcul trop long.
	  </para>
	  <para>
   	   Le masque <literal>(&#92;D+|&lt;&#92;d+&gt;)*[!?]</literal> recherche un nombre
       illimit&eacute; de sous-cha&icirc;nes, qui contiennent soit
	   des non-chiffres, soit des chiffres inclus dans &lt;&gt;, suivi soit
	   par <literal>!</literal> ou par <literal>?</literal>. Lorsqu'il trouve
	   une solution, ce masque va tr&egrave;s vite. Mais, lorsqu'il est
	   appliqu&eacute; &agrave; une cha&icirc;ne telle que :
       <literal>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</literal>,
	   il lui faut beaucoup de temps pour annoncer un &eacute;chec. Cela est
	   d&ucirc; au fait que la chaine peut &ecirc;tre divis&eacute;e en deux
	   sous-cha&icirc;nes d'un grand nombre de fa&ccedil;ons, et qu'elles
	   ont toutes &eacute;t&eacute; essay&eacute;es. (Cet exemple utilisait
	   <literal>[!?]</literal> plut&ocirc;t qu'un caract&egrave;re simple, car
	   PCRE et PHP utilise une optimisation qui leur permettent de d&eacute;tecter
	   rapidement l'&eacute;chec lorsqu'un caract&egrave;re unique est
	   trouv&eacute;. Il se souvient du dernier caract&egrave;re qui est
	   attendu, et s'aper&ccedil;oit rapidement qu'il n'y a pas ce caract&egrave;re).
	  </para>
	  <para>
	   Si le masque utilis&eacute; est <literal>((?&gt;&#92;D+)|&lt;&#92;d+&gt;)*[!?]</literal>
       les s&eacute;quences de chiffres ne peuvent pas &ecirc;tre
       trouv&eacute;es, et l'&eacute;chec intervient rapidement.
	  </para>
	 </refsect2>
	 <refsect2 id="regexp.reference.conditional">
	  <title>Les sous-masques conditionnels</title>
	  <para>
       Il est possible de lier un sous-masque &agrave; une condition, ou de
       choisir entre deux sous-masques alternatifs, en fonction du
       r&eacute;sultat d'une assertion, ou suivant les r&eacute;sultats
       de recherche pr&eacute;c&eacute;dents.
      </para>
      <para>
       Les deux formes possibles de sous-masques conditionnels sont
       <literal>(?(condition)masque positif)</literal> et
       <literal>(?(condition) masque positif | masque n&eacute;gatif)</literal>.
      </para>
      <para>
       Si les conditions sont satisfaites, le masque positif est utilis&eacute;,
       sinon, le masque n&eacute;gatif est utilis&eacute;, si pr&eacute;sent.
       S'il y a plus de deux alternatives, une erreur est g&eacute;n&eacute;r&eacute;e
       &agrave; la compilation.
      </para>
      <para>
       Il y a deux types de conditions : si le texte entre les parenth&egrave;ses
       est une s&eacute;quence de chiffres, alors la condition est satisfaite si
       le sous-masque correspondant &agrave; ce num&eacute;ro a r&eacute;ussi.
       Consid&eacute;rons le masque suivant, qui contient des espaces non
       significatifs pour le rendre plus compr&eacute;hensible (on supposera
       l'option <link linkend="pcre.pattern.modifiers">PCRE_EXTENDED</link>
       activ&eacute;e) et qui est divis&eacute; en trois parties
       pour simplifier les explications : <literal>( &#92;( )?    [^()]+    (?(1) &#92;) )</literal>.
      </para>
      <para>
       La premi&egrave;re partie recherche une parenth&egrave;se ouvrante
       optionnelle, et si elle existe, elle est captur&eacute;e. La deuxi&egrave;me
       partie recherche un s&eacute;quence de caract&egrave;res qui ne contiennent
       pas de parenth&egrave;ses. La troisi&egrave;me partie est
       conditionn&eacute;e &agrave; la premi&egrave;re, et s'assure que s'il
       y avait une parenth&egrave;se ouvrante, il en existe une fermante.
       Si une parenth&egrave;se ouvrante a &eacute;t&eacute; trouv&eacute;e,
       elle a &eacute;t&eacute; captur&eacute;e, et donc la premi&egrave;re capture
       existe, et la condition est ex&eacute;cut&eacute;e. Sinon, elle est
       ignor&eacute;e.
      </para>
      <para>
       Ce masque recherche donc une s&eacute;quence de lettres, &eacute;ventuellement
       plac&eacute;es entre parenth&egrave;se. Si la condition n'est pas une
       s&eacute;quence de chiffres, il faut que ce soit une assertion.
       Ce peut &ecirc;tre une assertion positive ou n&eacute;gative,
       arri&egrave;re ou avant. Consid&eacute;rons le masque suivant
       (m&ecirc;me conditions que le pr&eacute;c&eacute;dent) et avec deux
       alternatives en seconde ligne :
       <literal>(?(?=[^a-z]*[a-z])&#92;d{2}[a-z]{3}-&#92;d{2} | &#92;d{2}-&#92;d{2}-&#92;d{2} )</literal>.
       La condition est une assertion avant positive, qui recherche une
       s&eacute;quence optionnelle de caract&egrave;res non-lettre. En d'autres
       termes, elle teste la presence d'au moins une lettre dans la cha&icirc;ne
       sujet. Si une lettre est trouv&eacute;e, la recherche se poursuit avec
       la premi&egrave;re alternative, et sinon, avec la seconde. Ce masque
       recherche des cha&icirc;nes de la forme <literal>dd-aaa-dd</literal> ou
       <literal>dd-dd-dd</literal>, avec "<literal>aaa</literal>" qui sont des
       lettres, et <literal>dd</literal> qui sont des chiffres.
	  </para>
	 </refsect2>
	 <refsect2 id="regexp.reference.comments">
	  <title>Commentaires</title>
	  <simpara>
       La s&eacute;quence <literal>(?#</literal> marque le d&eacute;but d'un commentaire,
       qui se termine &agrave; la prochaine parenth&egrave;se fermante. Les
       parenth&egrave;ses imbriqu&eacute;es ne sont pas autoris&eacute;es. Les
       caract&egrave;res entre ces d&eacute;limiteurs ne jouent alors aucun r&ocirc;le
       dans le masque.
	  </simpara>
	  <simpara>
       Si l'option <link linkend="pcre.pattern.modifiers">PCRE_EXTENDED</link>
        est activ&eacute;e, les caract&egrave;res di&egrave;ses
       <literal>#</literal> non &eacute;chapp&eacute;s en dehors d'une classe de
       caract&egrave;res introduisent un commentaire qui continuera jusqu'&agrave;
       la prochaine ligne dans le masque.
	  </simpara>
	 </refsect2>
	 <refsect2 id="regexp.reference.recursive">
	  <title>Masques r&eacute;cursifs</title>
 	  <para>
 	   Consid&eacute;rons le cas o&ugrave; il faut recherche dans une
 	   cha&icirc;ne, avec un niveau d'imbrications infini de
 	   parenth&egrave;ses. Sans l'aide de la r&eacute;cursivit&eacute;, le
 	   mieux que nous puissions obtenir est de cr&eacute;er un masque avec un
	   niveau fix&eacute; de profondeur d'imbrication. Il n'est pas possible
	   de traiter des masques &agrave; niveau d'imbrications variable.
	   PCRE fournit un nouvel outil exp&eacute;rimental qui permet
	   d'utiliser la r&eacute;cursivit&eacute; dans les masques (entre autre).
	   L'option <literal>(?R)</literal> est fournie pour servir la cause de
	   la r&eacute;cursivit&eacute;. Le masque suivant r&eacute;soud le
	   probl&egrave;me des parenth&egrave;ses (l'option
	   <link linkend="pcre.pattern.modifiers">PCRE_EXTENDED</link> est
	   utilis&eacute;e pour ignorer les espaces) :
       <literal>&#92;( ( (?&gt;[^()]+) | (?R) )* &#92;)</literal>
      </para>
      <para>
       Tout d'abord, le masque recherche une parenth&egrave;se ouvrante. Puis,
       il recherche n'importe quel nombre de sous-cha&icirc;nes qui sont soit
       des s&eacute;quences de caract&egrave;res non-parenth&egrave;ses, ou
       bien une recherche r&eacute;cursive avec le m&ecirc;me masque (i.e.
       une cha&icirc;ne correctement incluse entre parenth&egrave;ses).
       Finalement, il recherche une parenth&egrave;se fermante.
      </para>
      <para>
       Cet exemple particulier contient un nombre illimit&eacute; de
       r&eacute;p&eacute;titions imbriqu&eacute;es, ce qui fait que
       l'utilisation de sous-cha&icirc;nes &agrave; utilisation unique
       pour rechercher les s&eacute;quence de caract&egrave;res
       non-parenth&egrave;ses est important, lorsqu'il s'applique &agrave;
       une cha&icirc;ne qui n'est pas valide. Par exemple, si on l'applique
       &agrave; "<literal>(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa()</literal>"
       la r&eacute;ponse arrive rapidement. Sinon, si les sous-cha&icirc;nes
       &agrave; utilisation unique ne sont pas utilis&eacute;es, la
       recherche peut prendre un tr&egrave;s long temps, car il existe
       de tr&egrave;s nombreuses combinaisons de <literal>+</literal> et
       <literal>*</literal> &agrave; tester avant de conclure &agrave;
       l'&eacute;chec.
      </para>
      <para>
       Les valeurs utilis&eacute;es pour capturer les sous-masques sont celles
       utilis&eacute;es par les niveaux les plus hauts de
       r&eacute;cursivit&eacute;s, auquel la valeur est fix&eacute;e.
       Si le masque pr&eacute;c&eacute;dent est utilis&eacute; avec
       <literal>(ab(cd)ef)</literal> la valeur de la parenth&egrave;se
       capturante est "<literal>ef</literal>", qui est la derni&egrave;re
       valeur lue au niveau sup&eacute;rieur. Si de nouvelles
       parenth&egrave;ses sont ajout&eacute;es, par exemple :
       <literal>&#92;( ( ( (?&gt;[^()]+) | (?R) )* ) &#92;)</literal>
       alors la cha&icirc;ne captur&eacute;e est "<literal>ab(cd)ef</literal>",
       c'est-&agrave;-dire le contenu de la parenth&egrave;ses capturant
       de plus haut niveau. S'il y a plus de 15 parenth&egrave;ses
       capturantes dans une cha&icirc;ne, PCRE doit utiliser plus
       de m&eacute;moire pour stocker ces donn&eacute;es. S'il ne
       peut obtenir cette m&eacute;moire suppl&eacute;mentaire, il ne fait
       que sauver les 15 premi&egrave;res, car il n'y a pas moyen de
       g&eacute;n&eacute;rer une erreur de m&eacute;moire lors d'une
       r&eacute;cursion.
	  </para>
	 </refsect2>
	 <refsect2 id="regexp.reference.performances">
	  <title>Performances</title>
	  <para>
       Certaines s&eacute;quences de recherches sont plus efficaces que d'autres.
       Ainsi, il est plus efficace d'utiliser une classe de caract&egrave;res
       telle que <literal>[aeiou]</literal> plut&ocirc;t qu'une alternative
       <literal>(a|e|i|o|u)</literal>.
      </para>
      <para>
       En g&eacute;n&eacute;ral, le masque le plus simple, qui permette
       la recherche d&eacute;sir&eacute;e est le plus efficace. Le livre
       de Jeffrey Friedl's contient de nombreuses &eacute;tudes &agrave;
       propos de l'optimisation des expressions r&eacute;guli&egrave;res.
      </para>
      <para>
       Lorsqu'un masque commence par.* et que l'option
       <link linkend="pcre.pattern.modifiers">PCRE_DOTALL</link> est
       activ&eacute;e, le masque est implicitement ancr&eacute; par PCRE,
       &eacute;tant donn&eacute; qu'il ne peut que rechercher au d&eacute;but
       de la cha&icirc;ne. Cependant, si option
       <link linkend="pcre.pattern.modifiers">PCRE_DOTALL</link> n'est pas
       activ&eacute;e, PCRE ne peut faire aucune optimisation car le
       m&eacute;ta-caract&egrave;res point "<literal>.</literal>"
       ne remplace pas une nouvelle ligne, et si la cha&icirc;ne
       sujet contient des nouvelles lignes, le masque peut trouver une
       solution qui serait situ&eacute;e juste apr&egrave;s une
       de ces nouvelles lignes, et non pas seulement au d&eacute;but
       de la cha&icirc;ne sujet. Par exemple, le masque,
       <literal>(.*)second</literal> acceptera la cha&icirc;ne
       "<literal>premier &#92;net second</literal>" (avec "<literal>&#92;n</literal>"
       qui remplace la nouvelle ligne), et la premi&egrave;re cha&icirc;ne
       captur&eacute;e sera "<literal>et</literal>".
      </para>
      <para>
       Afin d'effectuer la recherche, PCRE va essayer d'appliquer le masque
       &agrave; partir de chaque d&eacute;but de ligne. Si vous utilisez un
       tel masque avec des cha&icirc;nes qui ne contiennent pas de
       caract&egrave;res de nouvelles lignes, les meilleures performances
       seront atteintes avec l'option
       <link linkend="pcre.pattern.modifiers">PCRE_DOTALL</link>, ou en ancrant le
       masque avec <literal>^.*</literal>. Cela &eacute;vite &agrave; PCRE
       de scanner toute la cha&icirc;ne pour rechercher un caract&egrave;re
       de nouvelle ligne et recommencer la recherche.
      </para>
      <para>
  	   Attention aux masques qui contiennent des quantificateurs infinis
	   imbriqu&eacute;s. Ils peuvent demander un temps de calcul tr&egrave;s
	   long, lorsqu'appliqu&eacute;s &agrave; une cha&icirc;ne qui ne
	   correspond pas &agrave; ce masque. Par exemple, <literal>(a+)*</literal>
       peut accepter "<literal>aaaa</literal>" de 33 mani&egrave;res
       diff&eacute;rentes, et ce nombre croit rapidement avec la taille
       de la cha&icirc;ne (le quantificateur <literal>*</literal> peut prendre
       les valeurs de 0, 1, 2, 3, ou 4, et pour chaque cas non nul, le
       quantificateur <literal>+</literal> peut prendre diff&eacute;rentes
       valeurs).
      </para>
      <para>
       Lorsque le reste de la cha&icirc;ne est tel que l'on s'achemine
       vers un &eacute;chec, PCRE doit en principe v&eacute;rifier
       toutes les possibilit&eacute;s, et cela prend un temps
       extr&ecirc;mement long. Un optmiseur rep&egrave;re les cas
       les plus simples, tel que <literal>(a+)*b</literal> o&ugrave;
       un caract&egrave;re simple suit les quantificateurs. Avant de partir
       dans les proc&eacute;dures standard de recherche, PCRE
       s'assure qu'il y a au moins un "<literal>b</literal>" dans la
       cha&icirc;ne, et si ce n'est pas le cas, l'&eacute;chec est
       annonc&eacute; imm&eacute;diatement. Sinon, il n'y a pas
       d'optimisation dans la recherche. Vous pouvez voir la
       diff&eacute;rence de comportement avec le masque suivant :
       <literal>(a+)*&#92;d</literal>. Le premier retourne un &eacute;chec
       quasi-imm&eacute;diatement, s'il est appliqu&eacute; &agrave;
       une ligne de "<literal>a</literal>", alors que le second masque
       prend un temps significatif pour une cha&icirc;ne de plus de
       20 caract&egrave;res.
      </para>
	 </refsect2>
   </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
