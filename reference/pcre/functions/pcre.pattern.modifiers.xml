<?xml version="1.0" encoding="iso-8859-1"?>
<!-- splitted from ./fr/functions/pcre.xml, last change in rev 1.3 -->
<!-- last change to 'pcre.pattern.modifiers' in en/ tree in rev 1.2 -->
  <refentry id="pcre.pattern.modifiers">
   <refnamediv>
    <refname>options de recherche</refname>
    <refpurpose>
      Options disponibles pour les expressions r&eacute;guli&egrave;res.
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <para>
     Les options de PCRE sont list&eacute;es ci-dessous. Les noms entre
     parenth&egrave;ses sont les noms internes &agrave; PCRE.
    </para>
    <para>
     <blockquote>
      <variablelist>
       <varlistentry>
	    <term><emphasis>i</emphasis> (PCRE_CASELESS)</term>
   	    <listitem>
	     <simpara>
 	      Effectue une recherche insensible &agrave; la casse.
         </simpara>
	    </listitem>
       </varlistentry>
       <varlistentry>
	    <term><emphasis>m</emphasis> (PCRE_MULTILINE)</term>
	<listitem>
	 <simpara>
	   Par d&eacute;faut, PCRE traite la cha&icirc;ne sujet comme une seule
	   ligne (m&ecirc;me si cette cha&icirc;ne contient des retours chariot).
	   Le m&eacute;ta-caract&egrave;re "d&eacute;but de ligne" (^) ne sera
	   valable qu'une seule fois, au d&eacute;but de la ligne, et le
	   m&eacute;ta caract&egrave;re "fin de ligne " ($) ne sera valable
	   qu'&agrave; la fin de la cha&icirc;ne, ou avant le retour chariot
	   final (&agrave; moins que l'option D ne soit activ&eacute;e). C'est le
	   m&ecirc;me fonctionnement qu'en Perl.
     </simpara>
	 <simpara>
	   Lorsque cette option est activ&eacute;e, " d&eacute;but de ligne " et
	   " fin de ligne " correspondront alors aux caract&egrave;res
	   suivant et pr&eacute;c&eacute;dent imm&eacute;diatement un
	   caract&egrave;re de nouvelle ligne, en plus du d&eacute;but
	   et de la fin de la cha&icirc;ne. C'est le m&ecirc;me
	   fonctionnement que l'option Perl /m. S'il n'y a pas de
	   caract&egrave;re de nouvelle ligne "&#92;n" dans la cha&icirc;ne sujet,
	   ou s'il n'y a aucune occurrence de ^ ou $ dans le masque, cette option
	   ne sert &agrave; rien.
     </simpara>
	</listitem>
   </varlistentry>
   <varlistentry>
	<term><emphasis>s</emphasis> (PCRE_DOTALL)</term>
	<listitem>
	 <simpara>
	   Avec cette option, le m&eacute;ta caract&egrave;re point (.)
	   remplace n'importe quel caract&egrave;re, y compris les nouvelles
	   lignes. Sans cette option, le caract&egrave;re point ne remplace
	   pas les nouvelles lignes. Cette option est &eacute;quivalente
	   &agrave; l'option Perl /s. Une classe de caract&egrave;res
	   n&eacute;gative telle que [^a] acceptera toujours les
	   caract&egrave;res de nouvelles lignes, ind&eacute;pendamment
	   de cette option.
     </simpara>
	</listitem>
   </varlistentry>
   <varlistentry>
	<term><emphasis>x</emphasis> (PCRE_EXTENDED)</term>
	<listitem>
	 <simpara>
	  Avec cette option, les caract&egrave;res d'espacement sont
	  ignor&eacute;s, sauf lorsqu'ils sont &eacute;chapp&eacute;s,
	  ou &agrave; l'int&eacute;rieur d'une classe de caract&egrave;res,
	  et tous les caract&egrave;res entre # non &eacute;chapp&eacute;s
	  et en dehors d'une classe de caract&egrave;res, et le prochain
	  caract&egrave;re de nouvelle ligne sont ignor&eacute;s. C'est
	  l'&eacute;quivalent Perl de l'option /x : elle permet l'ajout
	  de commentaires dans les masques compliqu&eacute;s. Notez bien,
	  cependant, que cela ne s'appliquent qu'aux caract&egrave;res de
	  donn&eacute;es. Les caract&egrave;res d'espacement ne doivent
	  jamais appara&icirc;tre dans les s&eacute;quences sp&eacute;ciales
	  d'un masque, comme par exemple dans la s&eacute;quence (?( qui
	  introduit une parenth&egrave;se conditionnelle.
	 </simpara>
	</listitem>
   </varlistentry>
   <varlistentry>
	<term><emphasis>E</emphasis></term>
	<listitem>
	 <simpara>
	  Avec cette option, <function>preg_replace</function> effectue la
	  substitution normale des r&eacute;f&eacute;rences arri&egrave;res dans la
	  cha&icirc;ne de remplacement, puis l'&eacute;value comme un code PHP, et
	  utilise le r&eacute;sultat pour remplacer la cha&icirc;ne de recherche.
     </simpara>
	 <simpara>
	  Seule <function>preg_replace</function> utilise cette option. Elle est
	  ignor&eacute;e par les autres.
	 </simpara>
	</listitem>
   </varlistentry>
   <varlistentry>
	<term><emphasis>A</emphasis> (PCRE_ANCHORED)</term>
	<listitem>
	 <simpara>
	   Avec cette option, le masque est ancr&eacute; de force, c'est-&agrave;-dire que le masque doit s'appliquer entre le d&eacute;but
	   et la fin de la cha&icirc;ne sujet pour &ecirc;tre
	   consid&eacute;r&eacute; comme trouv&eacute;. Il est
	   possible de r&eacute;aliser le m&ecirc;me effet en
	   ajoutant les m&eacute;ta-caract&egrave;res ad&eacute;quats,
	   ce qui est la seule mani&egrave;re de le faire en Perl.
     </simpara>
	</listitem>
   </varlistentry>
   <varlistentry>
	<term><emphasis>E</emphasis> (PCRE_DOLLAR_ENDONLY)</term>
	<listitem>
	 <simpara>
	   Avec cette option, le m&eacute;ta-caract&egrave;re $ ne sera
	   valable qu'&agrave; la fin de la cha&icirc;ne sujet. Sans
	   cette option, $ est aussi valable avant une nouvelle ligne,
	   si cette derni&egrave;re est le dernier caract&egrave;re de
	   la cha&icirc;ne. Cette option est ignor&eacute;e si l'option
	   <emphasis>m</emphasis> est activ&eacute;e. Il n'y a pas
	   d'&eacute;quivalent en Perl.
     </simpara>
	</listitem>
   </varlistentry>
   <varlistentry>
	<term><emphasis>S</emphasis></term>
	<listitem>
	 <simpara>
	   Lorsqu'un masque est utilis&eacute; plusieurs fois, cela vaut
	   la peine de passer quelques instants de plus pour l'analyser
	   et optimiser le code pour acc&eacute;l&eacute;rer les
	   traitements ult&eacute;rieurs. Cette option force cette
	   analyse plus pouss&eacute;e. Actuellement, cette analyse
	   n'est utile que pour les masques non ancr&eacute;s, qui
	   ne commencent pas par un caract&egrave;re fixe.
     </simpara>
	</listitem>
   </varlistentry>
   <varlistentry>
	<term><emphasis>U</emphasis> (PCRE_UNGREEDY)</term>
	<listitem>
	 <simpara>
	   Cette option inverse la tendance &agrave; la gourmandise des
	   expressions r&eacute;guli&egrave;res. Vous pouvez aussi inverser
	   cette tendance au coup par coup avec un ?. De m&ecirc;me, si
	   cette option est activ&eacute;e, le <literal>?</literal> rendra
	   gourmand une s&eacute;quence. Cette option n'est pas compatible
	   avec Perl. Elle peut aussi &ecirc;tre mise dans le masque avec
	   l'option <literal>?U</literal>.
     </simpara>
	</listitem>
   </varlistentry>
   <varlistentry>
	<term><emphasis>X</emphasis> (PCRE_EXTRA)</term>
	<listitem>
	 <simpara>
	  Cette option ajoute d'autres fonctionnalit&eacute;s incompatible
	  avec le PCRE de Perl. Tous les antislash suivis d'une lettre qui
	  n'aurait pas de signification particuli&egrave;re cause une erreur,
	  permettant la r&eacute;servation de ces combinaisons pour des ajouts
	  fonctionnels ult&eacute;rieurs. Par d&eacute;faut, comme en Perl, les
	   antislash suivis d'une lettre sans signification particuli&egrave;re
	   sont trait&eacute;s comme des valeurs litt&eacute;rales. Actuellement,
	   cette option ne d&eacute;clenche pas d'autres fonctions.
     </simpara>
	</listitem>
   </varlistentry>
   <varlistentry>
	<term><emphasis>u</emphasis> (PCRE_UTF8)</term>
	<listitem>
	 <simpara>
	  Cette option inactive les fonctionnalit&eacute;s additionnelles de
	  PCRE qui ne sont pas compatibles avec Perl. Les cha&icirc;nes sont
	  trait&eacute;es comme des cha&icirc;nes UTF-8. Cette option est disponible
	  en PHP 4.1.0 et plus r&eacute;cent.
	 </simpara>
	</listitem>
   </varlistentry>
  </variablelist>
 </blockquote>
 </para>
 </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
