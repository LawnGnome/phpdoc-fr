<?xml version="1.0" encoding="iso-8859-1"?>
<!-- splitted from ./fr/functions/pcre.xml, last change in rev 1.3 -->
<!-- last change to 'preg-match-all' in en/ tree in rev 1.2 -->
  <refentry id="function.preg-match-all">
   <refnamediv>
    <refname>preg_match_all</refname>
    <refpurpose>Expression r&eacute;guli&egrave;re globale.</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>int</type><methodname>preg_match_all</methodname>
      <methodparam><type>string</type><parameter>pattern</parameter></methodparam>
      <methodparam><type>string</type><parameter>subject</parameter></methodparam>
      <methodparam><type>array</type><parameter>matches</parameter></methodparam>
      <methodparam choice="opt"><type>int</type><parameter>order</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>preg_match_all</function> analyse <parameter>subject</parameter>
     pour trouver l'expression <parameter>pattern</parameter>
     et met les r&eacute;sultats dans <parameter>matches</parameter>,
     dans l'ordre sp&eacute;cifi&eacute; par <parameter>order</parameter>.
    </para>
    <para>
     Apr&egrave;s avoir trouv&eacute; un premier r&eacute;sultat,
     la recherche continue jusqu'&agrave; la fin de la cha&icirc;ne.
    </para>
    <para>
     <parameter>order</parameter> peut prendre une des deux valeurs suivantes :
     <variablelist>
      <varlistentry>
       <term>PREG_PATTERN_ORDER</term>
       <listitem>
        <para>
          L'ordre est tel que $matches[0] est un tableau qui
          contient les r&eacute;sultats qui satisfont le masque
          complet, $matches[1] est un tableau qui contient les
          r&eacute;sultats qui satisfont la premi&egrave;re
          parenth&egrave;se capturante, etc..
	 <informalexample>
	  <programlisting role="php">
 <![CDATA[
<?php
  preg_match_all("|<[^>]+>(.*)</[^>]+>|U", "<b>example: </b><div align=left>a test</div>", $out, PREG_PATTERN_ORDER);
  print $out[0][0].", ".$out[0][1]."&#92;n";
  print $out[1][0].", ".$out[1][1]."&#92;n";
?>
]]>


	  </programlisting>
	 </informalexample>
	 Cet exemple va afficher :
	 <informalexample>
          <literallayout>
	   <computeroutput>
 <![CDATA[
<b>exemple: </b>, <div align=left>ceci est un test</div>
exemple: , ceci est un test
]]>
	   </computeroutput>
      </literallayout>
	 </informalexample>
      Ainsi, $out[0] est un tableau qui contient les r&eacute;sultats qui
      satisfont le masque complet, et $out[1] est un tableau qui contient
      les balises entre &gt; et &lt;.
 	 </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>PREG_SET_ORDER</term>
     <listitem>
	  <para>
        Les r&eacute;sultats sont class&eacute;s de telle
        fa&ccedil;on que $matches[0] contient la premi&egrave;re
        s&eacute;rie de r&eacute;sultat, $matches[1] contient la
        deuxi&egrave;me s&eacute;rie de r&eacute;sultat, etc...
	    <informalexample>
   	     <programlisting role="php">
 <![CDATA[
<?php
  preg_match_all("|<[^>]+>(.*)</[^>]+>|U", 
                 "<b>exemple: </b><div align=left>un test</div>", 
                 $out, 
                 PREG_SET_ORDER);
  print $out[0][0].", ".$out[0][1]."&#92;n";
  print $out[1][0].", ".$out[1][1]."&#92;n";
?>
]]>

	     </programlisting>
	    </informalexample>
	    Cet exemple va afficher :
	    <informalexample>
             <literallayout>
	      <computeroutput>
 <![CDATA[
<b>exemple: </b>, exemple:
<div align=left>un test</div>, un test
]]>
	      </computeroutput>
         </literallayout>
	    </informalexample>
 	    Dans ce cas, $matches[0] est la premi&egrave;re s&eacute;rie de
 	    r&eacute;sultat, et $matches[0][0] contient le texte qui satisfait
 	    le masque complet, $matches[0][1] contient le texte de la
 	    premi&egrave;re parenth&egrave;se capturante, etc... De m&ecirc;me,
 	    $matches[1] contient le texte qui satisfait le masque complet, etc...
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
    <para>
      Si <parameter>order</parameter> est omis, PREG_PATTERN_ORDER est
      utilis&eacute; par d&eacute;faut.
    </para>
    <para>
     <function>preg_match_all</function> retourne le nombre de
     r&eacute;sultat qui satisfont le masque complet, ou &false;
     en cas d'&eacute;chec ou d'erreur.
    </para>
    <para>
     <example>
      <title>
        Extraction de tous les num&eacute;ros de t&eacute;l&eacute;phone d'un texte.
      </title>
      <programlisting role="php">
 <![CDATA[
<?php
  preg_match_all("/&#92;(?  (&#92;d{3})?  &#92;)?  (?(1)  [&#92;-&#92;s] ) &#92;d{3}-&#92;d{4}/x",
               "Appelez 555-1212 ou 1-800-555-1212", $phones);
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     <example>
      <title>Recherche les couples de balises HTML (gourmand)</title>
      <programlisting role="php">
 <![CDATA[
<?php
// Cet exemple utilise les r&eacute;f&eacute;rences arri&egrave;res (&#92;&#92;2).
// Elles indiquent &agrave; l'analyseur qu'il doit trouver quelquechose qu'il
// a d&eacute;j&agrave; rep&eacute;r&eacute; un peu plus t&ocirc;t
// le nombre 2 indique que c'est le deuxi&egrave;me jeu de parenth&egrave;ses
// capturante qui doit &ecirc;tre utilis&eacute; (ici, ([&#92;w]+)).
//  L'antislash est n&eacute;cessaire ici, car la cha&icirc;ne est entre guillemets doubles
  $html = "<B>Texte en gras</B><a href=salut.html>clique moi</?>
  preg_match_all ("/(<([&#92;w]+)[?>]?>)(.*)(<&#92;/&#92;&#92;?>)/", $html, $matches);
  for ($i=0; $i< count($matches[0]); $i++) {
    echo "trouv&eacute;: ".$matches[0][$i]."&#92;n";
    echo "partie 1: ".$matches[1][$i]."&#92;n";
    echo "partie 2: ".$matches[3][$i]."&#92;n";
    echo "partie 3: ".$matches[4][$i]."&#92;n&#92;n";
  }
?>
]]>
      </programlisting>
     </example>
     Cet exemple va produire :
     <computeroutput>
 <![CDATA[
trouv&eacute;: <B>bold text</B>
partie 1: <B>
partie 2: Test en gras
partie 3: </B>
trouv&eacute;: <a href=salut.html>clique moi</a>
partie 1: <a href=salut.html>
partie 2: clique moi
partie 3: </a>
]]>
     </computeroutput>
    </para>
    <simpara>
     Voir aussi
     <function>preg_match</function>,
     <function>preg_replace</function> et
     <function>preg_split</function>.
    </simpara>
   </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
