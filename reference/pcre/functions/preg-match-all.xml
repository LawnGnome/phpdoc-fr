<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.17 $ -->
<!-- EN-Revision: 1.12 Maintainer: yannick Status: ready -->
  <refentry id="function.preg-match-all">
   <refnamediv>
    <refname>preg_match_all</refname>
    <refpurpose>Expression rationnelle globale</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>int</type><methodname>preg_match_all</methodname>
      <methodparam><type>string</type><parameter>pattern</parameter></methodparam>
      <methodparam><type>string</type><parameter>subject</parameter></methodparam>
      <methodparam><type>array</type><parameter>matches</parameter></methodparam>
      <methodparam choice="opt"><type>int</type><parameter>flags</parameter></methodparam>
      <methodparam choice="opt"><type>int</type><parameter>offset</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>preg_match_all</function> analyse <parameter>subject</parameter>
     pour trouver l'expression <parameter>pattern</parameter>
     et met les résultats dans <parameter>matches</parameter>,
     dans l'ordre spécifié par <parameter>flags</parameter>.
    </para>
    <para>
     Après avoir trouvé un premier résultat,
     la recherche continue jusqu'à la fin de la chaîne.
    </para>
    <para>
     <parameter>flags</parameter> peut prendre une des deux valeurs suivantes 
     (notez bien qu'il est incohérent d'utiliser 
     <constant>PREG_PATTERN_ORDER</constant> avec 
     <constant>PREG_SET_ORDER</constant> ) :
     <variablelist>
      <varlistentry>
       <term><constant>PREG_PATTERN_ORDER</constant></term>
       <listitem>
        <para>
         L'ordre est tel que <varname>$matches[0]</varname> est un tableau qui
         contient les résultats qui satisfont le masque
         complet, <varname>$matches[1]</varname> est un tableau qui contient les
         résultats qui satisfont la première
         parenthèse capturante, etc.
         <example>
          <title>Exemple avec <function>preg_match_all</function> 
           et <constant>PREG_PATTERN_ORDER</constant>
          </title>
          <programlisting role="php">
 <![CDATA[
<?php
preg_match_all("|<[^>]+>(.*)</[^>]+>|U", 
                 "<strong>exemple : </strong><div align=\"left\">un test</div>", 
                 $out, 
                 PREG_PATTERN_ORDER);
                 
echo $out[0][0] . ', ' . $out[0][1] . "\n";
echo $out[1][0] . ', ' . $out[1][1] . "\n";
?>
]]>
          </programlisting>
          &example.outputs;
         <screen role="html">
 <![CDATA[
<strong>exemple : </strong>, <div align="left">un test</div>
exemple : , un test
]]>
         </screen>
         </example>
         Ainsi, <varname>$out[0]</varname> est un tableau qui contient les résultats qui
         satisfont le masque complet, et <varname>$out[1]</varname> est un tableau qui contient
         les balises entre &gt; et &lt;.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><constant>PREG_SET_ORDER</constant></term>
       <listitem>
        <para>
         Les résultats sont classés de telle
         façon que <varname>$matches[0]</varname> contient la première
         série de résultat, <varname>$matches[1]</varname> contient la
         deuxième série de résultat, etc.
         <example>
          <title>Exemple avec <function>preg_match_all</function> 
           et <constant>PREG_SET_ORDER</constant>
          </title>
          <programlisting role="php">
 <![CDATA[
<?php
preg_match_all("|<[^>]+>(.*)</[^>]+>|U", 
                 "<strong>exemple : </strong><div align=\"left\">un test</div>", 
                 $out, 
                 PREG_SET_ORDER);
echo $out[0][0] . ', ' . $out[0][1] . "\n";
echo $out[1][0] . ', ' . $out[1][1] . "\n";
?>
]]>
          </programlisting>
          &example.outputs;
          <screen role="html">
<![CDATA[
<strong>exemple : </strong>, exemple : 
<div align="left">un test</div>, un test
]]>
          </screen>
         </example>
          Dans ce cas, <varname>$matches[0]</varname> est la première série de
          résultat, et <varname>$matches[0][0]</varname> contient le texte qui satisfait
          le masque complet, <varname>$matches[0][1]</varname> contient le texte de la
          première parenthèse capturante, etc. De même,
          <varname>$matches[1]</varname> contient le texte qui satisfait le masque complet, etc.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><constant>PREG_OFFSET_CAPTURE</constant></term>
       <listitem>
        <simpara>
         Si cette option est activée, toutes les sous chaînes qui satisfont
         le masque seront aussi identifiées par leur offset. Notez que cela
         modifie le format de la valeur retournée , puisque chaque élément
         de réponse devient un tableau contenant la sous-chaîne résultat,
         à l'index &zero; dans la chaîne <parameter>subject</parameter> 
         constant &one;. Cette option a été ajoutée en &php; 4.3.0 .
        </simpara>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
    <para>
     Si <parameter>order</parameter> est omis, 
     <constant>PREG_PATTERN_ORDER</constant> est utilisé par défaut.
    </para>
    <para>
     Normalement, la recherche commence au début de la chaîne 
     <parameter>subject</parameter>. Le paramètre optionnel
     <parameter>offset</parameter> peut être utilisé pour spécifier
     une position pour le début de la recherche. Cela revient à passer
     la fonction <function>substr</function>(<varname>$subject</varname>, <varname>$offset</varname>)
     à <function>preg_match</function> à la place de la chaîne
     <parameter>subject</parameter>.
     Le paramètre <parameter>offset</parameter> a été introduit
     depuis la version 4.3.3 de &php;.
    </para>
    <para>
     <function>preg_match_all</function> retourne le nombre de
     résultats qui satisfont le masque complet, ou &false;
     en cas d'échec ou d'erreur.
    </para>
    <para>
     <example>
      <title>Extraction de tous les numéros de téléphone d'un texte</title>
      <programlisting role="php">
<![CDATA[
<?php
preg_match_all("/\(?  (\d{3})?  \)?  (?(1)  [\-\s] ) \d{3}-\d{4}/x",
               "Appelez 555-1212 ou 1-800-555-1212", $phones);
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     <example>
      <title>Recherche les couples de balises HTML (gourmand)</title>
      <programlisting role="php">
<![CDATA[
<?php
// Cet exemple utilise les références arrières (\\2).
// Elles indiquent à l'analyseur qu'il doit trouver quelquechose qu'il
// a déjà repéré un peu plus tôt
// le nombre 2 indique que c'est le deuxième jeu de parenthèses
// capturante qui doit être utilisé (ici, ([\w]+)).
// L'antislash est nécessaire ici, car la chaîne est entre guillemets doubles

$html = '<strong>Texte en gras</strong><a href="salut.html">clique moi</a>';

preg_match_all ("/(<([\w]+)[^>]*>)(.*)(<\/\\2>)/", $html, $matches);

for ($i=0; $i< count($matches[0]); $i++) {
  echo 'Trouvé : ' . $matches[0][$i] . "\n";
  echo 'partie 1 : ' . $matches[1][$i] . "\n";
  echo 'partie 2 : ' . $matches[3][$i] . "\n";
  echo 'partie 3 : ' . $matches[4][$i] . "\n\n";
}
?>
]]>
      </programlisting>
     &example.outputs;
     <screen role="html">
 <![CDATA[
Trouvé : <strong>Texte en gras</strong>
partie 1 : <strong>
partie 2 : Texte en gras
partie 3 : </strong>

Trouvé : <a href="salut.html">clique moi</a>
partie 1 : <a href="salut.html">
partie 2 : clique moi
partie 3 : </a>
]]>
     </screen>
     </example>
    </para>
    <simpara>
     Voir aussi
     <function>preg_match</function>,
     <function>preg_replace</function> et
     <function>preg_split</function>.
    </simpara>
   </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
