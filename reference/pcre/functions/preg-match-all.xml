<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.9 $ -->
<!-- EN-Revision: 1.1 Maintainer: nobody Status: partial -->

<!-- splitted from ./fr/functions/pcre.xml, last change in rev 1.3 -->
<!-- last change to 'preg-match-all' in en/ tree in rev 1.2 -->
  <refentry id="function.preg-match-all">
   <refnamediv>
    <refname>preg_match_all</refname>
    <refpurpose>Expression régulière globale</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>int</type><methodname>preg_match_all</methodname>
      <methodparam><type>string</type><parameter>pattern</parameter></methodparam>
      <methodparam><type>string</type><parameter>subject</parameter></methodparam>
      <methodparam><type>array</type><parameter>matches</parameter></methodparam>
      <methodparam choice="opt"><type>int</type><parameter>flags</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>preg_match_all</function> analyse <parameter>subject</parameter>
     pour trouver l'expression <parameter>pattern</parameter>
     et met les résultats dans <parameter>matches</parameter>,
     dans l'ordre spécifié par <parameter>order</parameter>.
    </para>
    <para>
     Après avoir trouvé un premier résultat,
     la recherche continue jusqu'à la fin de la chaîne.
    </para>
    <para>
     <parameter>order</parameter> peut prendre une des deux valeurs suivantes 
     (notez bien qu'il est incohérent d'utiliser 
     <constant>PREG_PATTERN_ORDER</constant> avec 
     <constant>PREG_SET_ORDER</constant> ) :
     <variablelist>
      <varlistentry>
       <term><constant>PREG_PATTERN_ORDER</constant></term>
       <listitem>
        <para>
          L'ordre est tel que $matches[0] est un tableau qui
          contient les résultats qui satisfont le masque
          complet, $matches[1] est un tableau qui contient les
          résultats qui satisfont la première
          parenthèse capturante, etc..
	 <example>
	  <title>Exemple avec <function>preg_match_all</function> 
	  et <constant>PREG_PATTERN_ORDER</constant>
	  </title>
	  <programlisting role="php">
 <![CDATA[
<?php
  preg_match_all("|<[^>]+>(.*)</[^>]+>|U", 
                 "<b>exemple : </b><div align=left>un test</div>", 
                 $out, 
                 PREG_PATTERN_ORDER);
  print $out[0][0].", ".$out[0][1]."\n";
  print $out[1][0].", ".$out[1][1]."\n";
?>
]]>


	  </programlisting>
	 </example>
	 Cet exemple va afficher :
	 <example>
      <title>Resultat avec <constant>PREG_PATTERN_ORDER</constant></title>
	   <literallayout>
	    <computeroutput>
 <![CDATA[
<b>exemple : </b>, <div align=left>un test</div>
exemple : , un test
]]>
	   </computeroutput>
      </literallayout>
	 </example>
      Ainsi, $out[0] est un tableau qui contient les résultats qui
      satisfont le masque complet, et $out[1] est un tableau qui contient
      les balises entre &gt; et &lt;.
 	 </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><constant>PREG_SET_ORDER</constant></term>
     <listitem>
	  <para>
        Les résultats sont classés de telle
        façon que $matches[0] contient la première
        série de résultat, $matches[1] contient la
        deuxième série de résultat, etc...
	    <example>
  	     <title>Exemple avec <function>preg_match_all</function>
  	     et <constant>PREG_SET_ORDER</constant></title>
   	     <programlisting role="php">
 <![CDATA[
<?php
  preg_match_all("|<[^>]+>(.*)</[^>]+>|U", 
                 "<b>exemple : </b><div align=left>un test</div>", 
                 $out, 
                 PREG_SET_ORDER);
  print $out[0][0].", ".$out[0][1]."\n";
  print $out[1][0].", ".$out[1][1]."\n";
?>
]]>
	     </programlisting>
	    </example>
	    Cet exemple va afficher :
	    <example>
    	 <title>Résultat avec <constant>PREG_SET_ORDER</constant></title>
   	     <programlisting role="php">
<![CDATA[
<b>exemple : </b>, exemple : 
<div align=left>un test</div>, un test
]]>	     
		 </programlisting>
	    </example>
 	    Dans ce cas, $matches[0] est la première série de
 	    résultat, et $matches[0][0] contient le texte qui satisfait
 	    le masque complet, $matches[0][1] contient le texte de la
 	    première parenthèse capturante, etc... De même,
 	    $matches[1] contient le texte qui satisfait le masque complet, etc...
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><constant>PREG_OFFSET_CAPTURE</constant></term>
       <listitem>
        <simpara>
         Si cette option est activée, toutes les sous chaînes qui satisfont
         le masque seront aussi identifiées par leur offset. Notez que cela
         modifie le format de la valeur retournée , puisque chaque élément
         de réponse devient un tableau contenant la sous-chaîne résultat,
         à l'index <literal>0</literal> dans la chaîne <parameter>subject</parameter> 
         constant <literal>1</literal>. Cette option a été ajoutée en &php; 4.3.0 .
        </simpara>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
    <para>
      Si <parameter>order</parameter> est omis, PREG_PATTERN_ORDER est
      utilisé par défaut.
    </para>
    <para>
     <function>preg_match_all</function> retourne le nombre de
     résultat qui satisfont le masque complet, ou &false;
     en cas d'échec ou d'erreur.
    </para>
    <para>
     <example>
      <title>
        Extraction de tous les numéros de téléphone d'un texte.
      </title>
      <programlisting role="php">
 <![CDATA[
<?php
  preg_match_all("/\(?  (\d{3})?  \)?  (?(1)  [\-\s] ) \d{3}-\d{4}/x",
               "Appelez 555-1212 ou 1-800-555-1212", $phones);
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     <example>
      <title>Recherche les couples de balises HTML (gourmand)</title>
      <programlisting role="php">
 <![CDATA[
<?php
// Cet exemple utilise les références arrières (\\2).
// Elles indiquent à l'analyseur qu'il doit trouver quelquechose qu'il
// a déjà repéré un peu plus tôt
// le nombre 2 indique que c'est le deuxième jeu de parenthèses
// capturante qui doit être utilisé (ici, ([\w]+)).
//  L'antislash est nécessaire ici, car la chaîne est entre guillemets doubles

  $html = "<B>Texte en gras</B><a href=salut.html>clique moi</a>";

preg_match_all ("/(<([\w]+)[^>]*>)(.*)(<\/\\2>)/", $html, $matches);

for ($i=0; $i< count($matches[0]); $i++) {
  echo "Trouvé : ".$matches[0][$i]."\n";
  echo "partie 1 : ".$matches[1][$i]."\n";
  echo "partie 2 : ".$matches[3][$i]."\n";
  echo "partie 3 : ".$matches[4][$i]."\n\n";
}
?>
]]>
      </programlisting>
     </example>
     Cet exemple va produire :
     <computeroutput>
 <![CDATA[
Trouvé : <B>Texte en gras</B>
partie 1 : <B>
partie 2 : Texte en gras
partie 3 : </B>

Trouvé : <a href=salut.html>clique moi</a>
partie 1 : <a href=salut.html>
partie 2 : clique moi
partie 3 : </a>
]]>
     </computeroutput>
    </para>
    <simpara>
     Voir aussi
     <function>preg_match</function>,
     <function>preg_replace</function> et
     <function>preg_split</function>.
    </simpara>
   </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
