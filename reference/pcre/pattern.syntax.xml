<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.26 $ -->
<!-- EN-Revision: 1.13 Maintainer: yannick Status: ready -->
<!-- Reviewed: no -->
  <refentry id="reference.pcre.pattern.syntax">
   <refnamediv>
    <refname>syntaxe des masques</refname>
    <refpurpose>
      Fonctionnement des expressions rationnelles
    </refpurpose>
   </refnamediv>
   <refsect1>
    &reftitle.description;
    <simpara>
      La bibliothèque PCRE est un ensemble de fonctions qui
      implémentent la recherche par expressions
      rationnelles, en utilisant la même syntaxe
      et la même sémantique que le Perl 5, avec quelques
      nuances (voir ci-dessous). L'implémentation actuelle
      est celle de Perl 5.005.
    </simpara>
   </refsect1>

   <refsect1>
    <title>Différences avec Perl</title>
    <para>
     Les différences avec le Perl 5.005 sont présentées ici :
    <orderedlist>
     <listitem>
      <simpara>
       Par défaut, un caractère d'espacement correspond à
       n'importe quel caractère que la fonction C <literal>isspace()</literal> reconnaît,
       bien qu'il soit possible de recompiler la bibliothèque PCRE avec
       d'autres tables de caractères. Normalement, <literal>isspace()</literal> retourne
       &true; pour les espaces, les retours chariot, les
       nouvelles lignes, les formfeed, les tabulations verticales et horizontales.
       Le Perl 5 n'accepte plus la tabulation verticale comme caractère
       d'espacement. La séquence \v qui était dans la documentation
       Perl depuis longtemps n'a jamais été reconnue. Cependant, la
       tabulation verticale elle-même était reconnue comme un
       caractère d'espacement jusqu'à la version 5.002. Avec les
       versions 5.004 et 5.005, l'option \s l'ignore.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       PRCE ne tolère pas la répétition de quantificateurs
       dans les expressions. Perl le permet, mais cela ne signifie pas ce que vous
       pourriez penser. Par exemple, (?!a){3} ne s'interprète pas : les trois
       caractères suivants ne sont pas des "a". En fait, cela
       s'interprète comme : le caractère suivant n'est pas "a" trois fois.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Les occurrences de sous-masques qui interviennent dans des assertions
       négatives sont comptées, mais elles ne sont pas
       enregistrées dans le vecteur d'occurrences. Perl modifie ses
       variables numériques pour toutes les occurrences de sous-masque,
       avant que l'assertion ne vérifie le masque entier, et uniquement si
       les sous-masques ne trouvent qu'une seule occurrence.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Bien que les caractères nul soient tolérés dans la
       chaîne de recherche, ils ne sont pas acceptés dans le
       masque, car le masque est utilisé comme une chaîne C
       standard, terminée par le caractère nul. Il faut donc
       utiliser la séquence d'échappement "\x00" dans le masque
       pour rechercher les caractères nul.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Les séquence d'échappement suivantes ne sont pas
       supportées par le Perl: \l, \u, \L, \U.
       En fait, elles sont implémentées par la gestion
       intrinsèque de chaînes du Perl, et ne font pas partie
       de ses caractères spéciaux.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       L'assertion \G du Perl n'est pas supportée car elle n'est pas
       pertinente pour faire des recherches avec des masques uniques.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       De manière assez évidente, PCRE n'accepte pas la
       construction <literal>(?{code})</literal>.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Au moment de l'écriture de PCRE, Perl 5.005_02 avait quelques
       comportements étranges avec la capture des chaînes
       lorsqu'une partie du masque est redoublée. Par exemple, "aba" avec
       le masque /^(a(b)?)+$/ va affecter à $2 la valeur "b", mais la
       même manipulation avec "aabbaa" et /^(aa(bb)?)+$/ laissera $2 vide.
       Cependant, si le masque est remplacé par /^(aa(b(b))?)+$/ alors $2
       (et d'ailleurs $3) seront correctement affectés. Avec le Perl
       5.004, $2 sera correctement affecté dans les deux cas, et c'est
       aussi vrai avec PCRE. Si Perl évolue vers un autre comportement
       cohérent, PCRE s'adaptera probablement.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Une autre différence encore non résolue est le fait qu'en
       Perl 5.005_02 le masque /^(a)?(?(1)a|b)+$/ accepte la chaîne "a",
       tandis que PCRE ne l'accepte pas. Cependant, que ce soit avec Perl ou
       PCRE /^(a)?a/ et "a" laisseront $1 vide.
      </simpara>
     </listitem>
     <listitem>
      <para>
       PCRE propose quelques extensions aux expressions rationnelles du Perl.
       <orderedlist>
        <listitem>
         <simpara>
          (a) Bien que les assertions arrières (<literal>lookbehind</literal>) soient obligées
          de rechercher une chaîne de longueur fixe, toutes les assertions
          arrières peuvent avoir une longueur différente. Perl 5.005 leur
          impose d'avoir toutes la même longueur.
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          (b) Si <link linkend="reference.pcre.pattern.modifiers">PCRE_DOLLAR_ENDONLY</link> est
          activé, et que <link linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link>
          ne l'est pas, le méta caractère
          <literal>$</literal> ne s'applique qu'à la fin
          physique de la chaîne, et non pas avant les caractères
          de nouvelle ligne.
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          (c) Si <link linkend="reference.pcre.pattern.modifiers">PCRE_EXTRA</link> est
          activé, un anti-slash suivi d'une lettre sans signification
          spéciale est considéré comme une erreur.
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          (d) Si <link linkend="reference.pcre.pattern.modifiers">PCRE_UNGREEDY</link> est
          activé, la "gourmandise" des quantificateurs de
          répétition est inversée, ce qui est rend non
          gourmand par défaut, mais s'ils sont suivis de ?, il seront
          gourmands.
         </simpara>
        </listitem>
       </orderedlist>
      </para>
     </listitem>
    </orderedlist>
   </para>
  </refsect1>

  <refsect1 id="regexp.reference">
    <title>Détails sur les expressions rationnelles</title>
     <refsect2 id="regexp.introduction">
     &reftitle.intro;
      <para>
       La syntaxe et la sémantique des expressions rationnelles
       supportées par PCRE sont décrites ci-dessous. Les expressions
       rationnelles sont aussi décrites dans la documentation
       Perl, et dans un grand nombre d'autres livres, avec de nombreux exemples.
       Le libre de Jeffrey Friedl "Mastering Regular Expressions", édité
       chez O'Reilly (ISBN 1-56592-257-3), les décrits en profondeur.
       Cette description est organisée comme une documentation de
       référence.
      </para>
      <para>
       Une expression rationnelle est un masque appliqué à
       une chaîne sujet, de gauche à droite. La plupart des
       caractères se représentent eux-mêmes. Un exemple
       trivial : un masque qui serait "<literal>Le rapide renard gris</literal>",
       pourra correspondre à une partie de la chaîne sujet qui sera
       identique au masque, par exemple
       "<literal>Le rapide renard gris court dans la forêt</literal>",
      </para>
     </refsect2>
     <refsect2 id="regexp.reference.meta">
      <title>Méta-caractères</title>
      <para>
       La puissance des expressions rationnelles provient de
       leur capacité à autoriser des alternatives et des quantificateurs
       de répétition dans le masque. Ils sont encodés
       dans le masque par des méta-caractères, qui ne représentent
       pas ce qu'ils sont, mais sont interprétés d'une certaine
       manière.
      </para>
      <para>
       Il y a deux sortes de méta-caractères : ceux qui sont
       reconnus n'importe où dans un masque, hormis entre crochets,
       et ceux qui sont reconnus entre crochets.
      </para>
      <para>
       À l'extérieur des crochets, les méta-caractères sont :
       <variablelist>
        <varlistentry>
         <term><emphasis>\</emphasis> anti-slash</term>
         <listitem>
          <simpara>
           Caractère d'échappement, avec de multiples usages
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><emphasis>^</emphasis> Accent circonflexe</term>
         <listitem>
          <simpara>
           Le début de la chaîne sujet (ou de ligne, en mode multi-lignes)
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><emphasis>$</emphasis> Dollar</term>
         <listitem>
          <simpara>
           La fin de la chaîne sujet (ou de ligne, en mode multi-lignes)
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><emphasis>.</emphasis> Point</term>
         <listitem>
          <simpara>
           Remplace n'importe quel caractère, hormis le caractère
           de nouvelle ligne (par défaut) ;
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><emphasis>[</emphasis> Crochet ouvrant</term>
         <listitem>
          <simpara>
           Caractère de début de définition de classe
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><emphasis>]</emphasis> Crochet fermant</term>
         <listitem>
          <simpara>
           Caractère de fin de définition de classe
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><emphasis>|</emphasis> Barre verticale</term>
         <listitem>
          <simpara>
           Caractère de début d'alternative
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><emphasis>(</emphasis> Parenthèse ouvrante</term>
         <listitem>
          <simpara>
           Caractère de début de sous-masque
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><emphasis>)</emphasis> Parenthèse fermante</term>
         <listitem>
          <simpara>
           Caractère de fin de sous-masque
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><emphasis>?</emphasis> Point d'interrogation</term>
         <listitem>
          <simpara>
           Etend le sens de (; quantificateur de 0 ou 1; quantificateur de minimisation
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><emphasis>*</emphasis> Etoile</term>
         <listitem>
          <simpara>
           Quantificateur de 0 ou plus
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><emphasis>+</emphasis> Plus</term>
         <listitem>
          <simpara>
           Quantificateur de 1 ou plus
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><emphasis>{</emphasis> Accolade ouvrante</term>
         <listitem>
          <simpara>
           Caractère de début de quantificateur minimum/maximum
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><emphasis>}</emphasis> Accolade fermante</term>
         <listitem>
          <simpara>
           Caractère de fin de quantificateur minimum/maximum
          </simpara>
         </listitem>
        </varlistentry>
      </variablelist>

      La partie du masque qui est entourée de crochets est appelée
      classe de caractères. Dans les classes de caractères,
      les seuls méta-caractères autorisés sont :
       <variablelist>
        <varlistentry>
         <term><emphasis>\</emphasis> Anti-slash</term>
         <listitem>
          <simpara>
           Caractère d'échappement, avec de multiples usages
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><emphasis>^</emphasis> Accent circonflexe</term>
         <listitem>
          <simpara>
           Négation de la classe, mais uniquement si placé tout
           au début de la classe
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><emphasis>-</emphasis> Moins</term>
         <listitem>
          <simpara>
           Indique un intervalle de caractères
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><emphasis>]</emphasis> Crochet fermant</term>
         <listitem>
          <simpara>
           Termine la classe de caractères
          </simpara>
         </listitem>
        </varlistentry>
       </variablelist>
       La section suivante décrit l'utilisation de chaque
       méta-caractère.
      </para>
    </refsect2>
    <refsect2 id="regexp.reference.backslash">
     <title>Anti-slash</title>
      <para>
       Le caractère anti-slash a de nombreuses utilisations.
       En premier lieu, s'il est suivi d'un caractère non
       alpha-numérique, il ne prendra pas la signification
       spéciale qui y est rattachée. Cette utilisation de
       l'anti-slash comme caractère d'échappement s'applique
       à l'intérieur et à l'extérieur des
       classes de caractères.
      </para>
      <para>
       Par exemple, pour rechercher le
       caractère étoile "<literal>*</literal>", il faut
       écrire dans le masque : "<literal>\*</literal>". Cela
       s'applique dans tous les cas, que le caractère qui suive
       soit un méta-caractère ou non. C'est un moyen sûr
       pour s'assurer qu'un caractère sera recherché
       pour sa valeur littérale, plutôt que pour sa valeur
       spéciale. En particulier, pour rechercher les anti-slashs,
       il faut écrire : "<literal>\\</literal>".
      </para>
      <note>
       <para>
        La <link linkend="language.types.string.syntax">chaîne de caractères</link> &php;
        simple ou double guillemet a une signification spéciale des anti-slashs. Donc,
        si \ doit être recherché avec une expression rationnelle \\, alors
        "\\\\" ou '\\\\' doit être utilisé dans le code &php;.
       </para>
      </note>
      <para>
       Si un masque est utilisé avec l'option
       <link linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link>,
       les espaces blancs du masque, mais qui ne sont pas dans une
       classe de caractères, et les caractères entre dièses
       "<literal>#</literal>", ainsi que les nouvelles lignes sont ignorées.
       L'anti-slash peut être utilisé pour échapper et ainsi
       rechercher un espace ou un dièse.
      </para>
      <para>
       La deuxième utilité de l'anti-slash est de pouvoir
       coder des caractères invisibles dans les masques. Il n'y
       a pas de restriction sur la place de ces caractères
       invisibles, hormis pour le caractère nul qui doit terminer
       le masque.
       Lors de la préparation du masque, il est souvent plus pratique
       d'utiliser les séquences d'échappement suivantes,
       plutôt que le caractère binaire qu'elles représentent :
      </para>
      <para>
       <variablelist>
        <varlistentry>
         <term><emphasis>\a</emphasis></term>
         <listitem>
           <simpara>
            alarme, c'est-à-dire le caractère BEL (hex 07)
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><emphasis>\cx</emphasis></term>
         <listitem>
          <simpara>
           "contrôle-x", avec x qui peut être n'importe quel
           caractère.
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><emphasis>\e</emphasis></term>
          <listitem>
          <simpara>
           escape (hex 1B)
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><emphasis>\f</emphasis></term>
         <listitem>
          <simpara>
           formfeed (hex 0C)
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><emphasis>\n</emphasis></term>
         <listitem>
          <simpara>
           nouvelle ligne (hex 0A)
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><emphasis>\r</emphasis></term>
         <listitem>
          <simpara>
           retour chariot (hex 0D)
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><emphasis>\t</emphasis></term>
         <listitem>
          <simpara>
           tabulation (hex 09)
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><emphasis>\xhh</emphasis></term>
         <listitem>
          <simpara>
           caractère en hexadécimal, de code hh
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><emphasis>\ddd</emphasis></term>
         <listitem>
          <simpara>
           caractère en octal, de code ddd, ou référence
           arrière
          </simpara>
         </listitem>
        </varlistentry>
       </variablelist>
      </para>
      <para>
       Dans la séquence "<literal>\cx</literal>" si "<literal>x</literal>"
       est en minuscule, il est converti en majuscule. Puis, le bit 6 (hex 40)
       est inversé. Ainsi "<literal>\cz</literal>" devient <literal>1A</literal>,
       mais "<literal>\c{</literal>" devient hex 3B, tandis que "<literal>\c;</literal>"
       devient hex 7B.
      </para>
      <para>
       Après "<literal>\x</literal>", deux caractères
       hexadécimaux sont lus (les lettres peuvent être en majuscule
       ou minuscule).
       En mode <emphasis>UTF-8</emphasis>, "<literal>\x{...}</literal>"
       est aurotisé, où le contenu des accolades est une chaîne hexadécimale.
       Il sera interprété comme un caractère UTF-8 où le numéro de code est
       le numéro hexadécimal donné. La séquence d'échappement hexadécimale
       originale, <literal>\xhh</literal>, correspond à un caractère UTF-8
       sur 2 octets si la valeur est plus grande que 127.
      </para>
      <para>
       Après "<literal>\0</literal>", deux caractères octaux sont lus.
       Dans chacun des cas, le méta-caractère tente de lire autant
       de caractères que possible. Ainsi, la séquence
       "<literal>\0\x\07</literal>" sera comprise comme deux caractères nuls,
       suivis d'un caractère alarme (BEL). Assurez-vous que vous fournissez
       suffisamment de chiffres après le méta-caractère.
      </para>
      <para>
       L'anti-slash de fin suivi par un nombre autre que 0 est compliqué.
       À l'extérieur d'une classe de caractère, PCRE le lit, et tous les nombres
       qui suivent, en tant que nombres décimaux. Si le nombre est plus petit que
       10 ou s'il y a eu au moins précédemment une parenthèse gauche capturante
       dans l'expression, la séquence entière est prise en tant que référence arrière.
       Une description sur le fonctionnement est donnée plus tard, suivez la discussion
       sur les parenthèses des sous masques.
      </para>
      <para>
       À l'intérieur d'un caractère de classe ou s'il est plus
       grand que 9, et qu'il n'y a pas eu assez de parenthèses ouvrantes
       auparavant, PCRE lit jusqu'à 3 chiffres octaux à la suite
       de l'anti-slash, et génère un octet unique, à partir
       des 8 bits de poids faible de la séquence. Tous les chiffres qui
       suivent ne sont pas interprétés, et se représentent
       eux-mêmes. Par exemple:
       <variablelist>
        <varlistentry>
        <term><emphasis>\040</emphasis></term>
         <listitem>
          <simpara>
           une autre manière d'écrire un espace
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><emphasis>\40</emphasis></term>
         <listitem>
          <simpara>
           identique, dans la mesure où il n'y a pas 40
           parenthèses ouvrantes auparavant
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><emphasis>\7</emphasis></term>
         <listitem>
          <simpara>
           est toujours une référence arrière
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><emphasis>\11</emphasis></term>
         <listitem>
          <simpara>
           peut être une référence de retour,
           ou une tabulation
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><emphasis>\011</emphasis></term>
         <listitem>
          <simpara>
           toujours une tabulation
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><emphasis>\0113</emphasis></term>
         <listitem>
          <simpara>
           est une tabulation suivie du caractère "3"
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><emphasis>\113</emphasis></term>
         <listitem>
          <simpara>
           est le caractère 113 (étant donné qu'il ne
           peut y avoir plus de 99 références arrières)
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><emphasis>\377</emphasis></term>
         <listitem>
          <simpara>
           est un octet dont tous les bits sont à 1
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><emphasis>\81</emphasis></term>
         <listitem>
          <simpara>
           peut être soit une référence arrière,
           soit un zéro binaire suivi des caractères "8" et "1"
          </simpara>
         </listitem>
        </varlistentry>
       </variablelist>
      </para>
      <para>
       Les valeurs octales supérieures ou égales à 100 ne
       doivent pas être introduites par un 0, car seuls les trois premiers
       octets seront lus.
      </para>
      <para>
       Toutes les séquences qui définissent une valeur d'un seul
       octet peuvent être utilisées dans les classes de caractères,
       et à l'extérieur. De plus, dans une classe de caractères,
       la séquence "<literal>\b</literal>" est interprétée
       comme un caractère effacer (hex 08). À l'extérieur,
       elle peut avoir d'autres significations
       (voir ci-dessous).
      </para>
      <para>
       On peut encore se servir de l'anti-slash pour préciser des types
       génériques de valeurs :
       <variablelist>
        <varlistentry>
         <term><emphasis>\d</emphasis></term>
         <listitem>
          <simpara>
           tout caractère décimal
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><emphasis>\D</emphasis></term>
         <listitem>
          <simpara>
           tout caractère qui n'est pas un caractère décimal
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><emphasis>\s</emphasis></term>
         <listitem>
          <simpara>
           tout caractère blanc
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><emphasis>\S</emphasis></term>
         <listitem>
          <simpara>
           tout caractère qui n'est pas un caractère blanc
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><emphasis>\w</emphasis></term>
         <listitem>
          <simpara>
           tout caractère de "mot"
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><emphasis>\W</emphasis></term>
         <listitem>
          <simpara>
           tout caractère qui n'est pas un caractère de "mot"
          </simpara>
         </listitem>
        </varlistentry>
       </variablelist>
      </para>
      <para>
       Chaque paire précédente définit une partition de
       la table des caractères : les deux ensembles sont disjoints.
       Un caractère satisfera soit un méta-caractère,
       soit l'autre.
      </para>
      <para>
       Un caractère de "mot" sera une lettre, un chiffre ou le
       caractère souligné, c'est-à-dire un
       caractère qui pourra être une partie d'un mot Perl. La
       définition des lettres et chiffres est définie par les
       tables de caractères de PCRE, et peut varier suivant la table
       locale de caractères. Par exemple, dans la configuration "français" ("fr"),
       certains caractères ont des codes supérieurs à
       128, pour les caractères accentués, et ils seront compris
       par le méta-caractère <literal>\w</literal>.
      </para>
      <para>
       Ces séquences de caractères peuvent apparaître à
       l'intérieur ou à l'extérieur des classes de
       caractères. Elles remplacent à chaque fois un
       caractère du type correspondant. Si cette séquence est
       placée en fin de masque, et qu'il n'y a plus de caractère à
       comparer dans la chaîne sujet, la recherche échoue.
      </para>
      <para>
       La quatrième utilisation de l'anti-slash intervient lors d'assertions
       simples. Une assertion impose une condition à un certain point,
       sans remplacer de caractère. L'utilisation de sous-masques pour
       réaliser des assertions plus complexes est décrite
       plus-bas. Les assertions avec anti-slash sont les suivantes :
       <variablelist>
        <varlistentry>
         <term><emphasis>\b</emphasis></term>
         <listitem>
          <simpara>
           limite de mot
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><emphasis>\B</emphasis></term>
         <listitem>
          <simpara>
           pas limite de mot
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><emphasis>\A</emphasis></term>
         <listitem>
          <simpara>
           début de la chaîne sujet
           (indépendant du mode multi-lignes)
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><emphasis>\Z</emphasis></term>
         <listitem>
          <simpara>
           fin de la chaîne sujet ou nouvelle ligne à
           la fin de la chaîne sujet
           (indépendant du mode multi-lignes)
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><emphasis>\G</emphasis></term>
         <listitem>
          <simpara>
           position de la première occurence trouvé dans la chaîne sujet
          </simpara>
         </listitem>
      </varlistentry>
        <varlistentry>
         <term><emphasis>\z</emphasis></term>
         <listitem>
          <simpara>
           fin de la chaîne sujet
           (indépendant du mode multi-lignes)
          </simpara>
         </listitem>
        </varlistentry>
       </variablelist>
      </para>
      <para>
       Ces assertions ne peuvent pas apparaître dans une classe de
       caractères (mais "\b" a une autre signification à
       l'intérieur d'une classe de caractères).
      </para>
      <para>
       Une limite de mot est un emplacement dans la chaîne sujet ou un
       caractère et son suivant ne sont pas en même temps des
       caractères de mot, ou le contraire (on peut le voir comme
       <literal>\w\W</literal> ou <literal>\W\w</literal>), ou encore le
       premier ou le dernier caractère est un caractère mot.
      </para>
      <para>
       Les assertions <literal>\A</literal>, <literal>\Z</literal>, et
       <literal>\z</literal> diffèrent des méta-caractères
       <literal>^</literal> et <literal>$</literal> dans la mesure où
       ils ne sont pas dépendants des options, notamment
       <link linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link>
       ou <link linkend="reference.pcre.pattern.modifiers">PCRE_DOLLAR_ENDONLY</link>.
       La différence entre <literal>\Z</literal> et
       <literal>\z</literal> tient au fait que <literal>\Z</literal> recherche
       les positions avant les nouvelles lignes et à la fin de la
       chaîne sujet, tandis que <literal>\z</literal> ne recherche
       que la fin de la chaîne.
      </para>
      <para>
       L'assertion <literal>\G</literal> est réalisée uniquement lorsque
       la position courante de l'occurence trouvée est au début de l'occurence,
       comme spécifié par l'argument <parameter>offset</parameter> de la
       fonction <function>preg_match</function>. Elle diffère de <literal>\A</literal>
       lorsque la valeur du paramètre <parameter>offset</parameter> est différente
       de zéro. Elle est disponible depuis &php; 4.3.3.
      </para>

      <para>
       <literal>\Q</literal> et <literal>\E</literal> peuvent être utilisés
       pour ignorer les méta-caractères regexp dans le masque depuis &php; 4.3.3.
       Par exemple : <literal>\w+\Q.$.\E$</literal> recherchera un ou plusieurs
       caractères suivis par la chaîne litérale <literal>.$.</literal> et ancrés à la
       fin de la chaîne.
     </para>
    </refsect2>

    <refsect2 id="regexp.reference.unicode">
     <title>Propriétés des caractères Unicode</title>
     <para>
      Depuis &php; 4.4.0 et 5.1.0, trois nouvelles séquences d'échappement
      pour trouver des types de caractères sont disponibles lorsque
      le mode <emphasis>UTF-8</emphasis> est sélectionné. Elles sont :
     </para>
     <variablelist>
      <varlistentry>
       <term><emphasis>\p{xx}</emphasis></term>
       <listitem><simpara>un caractère avec les propriétés xx</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\P{xx}</emphasis></term>
       <listitem><simpara>un caractère sans les propriétés xx</simpara></listitem>
      </varlistentry>
      <varlistentry>
       <term><emphasis>\X</emphasis></term>
       <listitem><simpara>une séquence étendue Unicode</simpara></listitem>
      </varlistentry>
     </variablelist>
     <para>
      Les noms des propriétés représentés par <literal>xx</literal> ci-dessus
      sont limités aux catégories de propriétés générales Unicode. Chaque caractère
      a exactement une seule de ces propriétés, spécifié par une abréviation sur deux caractères.
      Pour des raisons de compatibilité avec Perl, la négation peut être spécifiée
      en incluant un accent circonflexe entre l'accolade ouvrante et le nom de la
      propriété. Par exemple, <literal>\p{^Lu}</literal> équivaut à la même chose que
      <literal>\P{Lu}</literal>.
     </para>
     <para>
      Si une seule lettre est spécifiée avec <literal>\p</literal> ou <literal>\P</literal>,
      il inclut toutes les propriétés qui commencent par cette lettre. Dans ce cas,
      en l'absence de négation, les accolades dans la séquence d'échappement sont
      optionnelles ; ceci revient à la même chose :
     </para>
     <literallayout>
      \p{L}
      \pL
     </literallayout>
     <table>
      <title>Codes des propriétés supportées</title>
      <tgroup cols="2">
       <tbody>
        <row><entry><literal>C</literal></entry><entry>Autre</entry></row>
        <row><entry><literal>Cc</literal></entry><entry>Contrôle</entry></row>
        <row><entry><literal>Cf</literal></entry><entry>Format</entry></row>
        <row><entry><literal>Cn</literal></entry><entry>Non affecté</entry></row>
        <row><entry><literal>Co</literal></entry><entry>Utilisation privée</entry></row>
        <row rowsep="1"><entry><literal>Cs</literal></entry><entry>Substitut</entry></row>
        <row><entry><literal>L</literal></entry><entry>Lettre</entry></row>
        <row><entry><literal>Ll</literal></entry><entry>Lettre en minuscule</entry></row>
        <row><entry><literal>Lm</literal></entry><entry>Lettre de modification</entry></row>
        <row><entry><literal>Lo</literal></entry><entry>Autres lettres</entry></row>
        <row><entry><literal>Lt</literal></entry><entry>Lettre titrée</entry></row>
        <row rowsep="1"><entry><literal>Lu</literal></entry><entry>Lettre en majuscule</entry></row>
        <row><entry><literal>M</literal></entry><entry>Marque</entry></row>
        <row><entry><literal>Mc</literal></entry><entry>Marque d'espacement</entry></row>
        <row><entry><literal>Me</literal></entry><entry>Marque d'enfermement</entry></row>
        <row rowsep="1"><entry><literal>Mn</literal></entry><entry>Marque non espacée</entry></row>
        <row><entry><literal>N</literal></entry><entry>Nombre</entry></row>
        <row><entry><literal>Nd</literal></entry><entry>Nombre décimal</entry></row>
        <row><entry><literal>Nl</literal></entry><entry>Nombre Lettre</entry></row>
        <row rowsep="1"><entry><literal>No</literal></entry><entry>Autres nombres</entry></row>
        <row><entry><literal>P</literal></entry><entry>Pnctuation</entry></row>
        <row><entry><literal>Pc</literal></entry><entry>Ponctuation de connecteur</entry></row>
        <row><entry><literal>Pd</literal></entry><entry>Tiret de ponctuation</entry></row>
        <row><entry><literal>Pe</literal></entry><entry>Ponctuation de fermeture</entry></row>
        <row><entry><literal>Pf</literal></entry><entry>Ponctuation finale</entry></row>
        <row><entry><literal>Pi</literal></entry><entry>Ponctuation initiale</entry></row>
        <row><entry><literal>Po</literal></entry><entry>Autres ponctuations</entry></row>
        <row rowsep="1"><entry><literal>Ps</literal></entry><entry>Ponctuation ouvrante</entry></row>
        <row><entry><literal>S</literal></entry><entry>Symbole</entry></row>
        <row><entry><literal>Sc</literal></entry><entry>Symbole monétaire</entry></row>
        <row><entry><literal>Sk</literal></entry><entry>Symbole de modification</entry></row>
        <row><entry><literal>Sm</literal></entry><entry>Symbole mathématique</entry></row>
        <row rowsep="1"><entry><literal>So</literal></entry><entry>Other symbol</entry></row>
        <row><entry><literal>Z</literal></entry><entry>Séparateur</entry></row>
        <row><entry><literal>Zl</literal></entry><entry>Séparateur de ligne</entry></row>
        <row><entry><literal>Zp</literal></entry><entry>Séparateur de paragraphe</entry></row>
        <row><entry><literal>Zs</literal></entry><entry>Séparateur d'espace</entry></row>
       </tbody>
      </tgroup>
     </table>
     <para>
      Les propriétés étendues comme "Greek" ou "InMusicalSymbols" ne sont pas supportées
      par PCRE.
     </para>
     <para>
      Spécifié la casse pour la recherche n'affecte pas les séquences d'échappement.
      Par exemple, <literal>\p{Lu}</literal> cherchera toujours uniquement
      les lettres en majuscules
     </para>
     <para>
      L'échappement <literal>\X</literal> cherchera n'importe quel numéro de caractères Unicode
      qui forme une séquence étendue Unicode. <literal>\X</literal> est l'équivalent de
      <literal>(?>\PM\pM*)</literal>.
     </para>
     <para>
      C'est-à-dire qu'il cherchera un caractère sans la propriété "Marque",
      suivi par zéro ou plus caractères avec la propriété "Marque",
      et traitera la séquence en tant que groupe atomique (voir ci-dessous).
      Les caractères avec la propriété "Marque" sont typiquement des accents
      qui affectent le caractère précédent.
     </para>
     <para>
      La recherche de caractères par les propriétés Unicode n'est pas la méthode
      la plus rapide, car PCRE doit chercher une structure qui contient les données
      dans plus de quinze mille caractères. C'est pour cela que les séquences
      d'échappement traditionnelles comme <literal>\d</literal> et
      <literal>\w</literal> n'utilisent pas les propriétés Unicode dans PCRE.
     </para>
    </refsect2>

     <refsect2 id="regexp.reference.circudollar">
      <title>Accent circonflexe et Dollar</title>
      <para>
       En dehors d'une classe de caractères, avec les options par
       défaut, <literal>^</literal> est une assertion qui n'est
       vraie que si elle est placée tout au début de la
       chaîne. À l'intérieur d'une classe de caractères,
       <literal>^</literal> a un tout autre sens (voir ci-dessous).
      </para>
      <para>
       <literal>^</literal> n'a pas besoin d'être le premier
       caractère du masque, si plusieurs alternatives sont
       proposées, mais il doit être placé en
       premier dans chaque alternative. Si toutes les alternatives
       commencent par <literal>^</literal>, alors le masque est dit ancré
       (il y a une autre construction qui porte cette appellation).
      </para>
      <para>
       <literal>$</literal> est une assertion qui n'est vraie que si elle
       est placée tout en fin de chaîne ou juste avant un
       caractère de nouvelle ligne qui serait le dernier
       caractère de la chaîne. À l'intérieur d'une
       classe de caractères, <literal>$</literal> a un tout autre
       sens (voir ci-dessous).
      </para>
      <para>
       <literal>$</literal> n'a pas besoin d'être le dernier
       caractère du masque, si plusieurs alternatives sont
       proposées, mais il doit être placé en dernier
       dans chaque alternative. Si toutes les alternatives finissent par
       <literal>$</literal>, alors le masque est dit ancré (il y
       a une autre construction qui porte cette appellation). <literal>$</literal>
       n'a pas de valeur particulière dans une classe de
       caractères.
      </para>
      <para>
       La signification de <literal>$</literal> peut changer, de manière
       à l'amener à ce qu'il ne puisse se trouver qu'en toute
       fin de la chaîne sujet. Cela se fait en ajoutant l'option
       <link linkend="reference.pcre.pattern.modifiers">PCRE_DOLLAR_ENDONLY</link>
       au moment de la compilation, ou de l'exécution.
       Cette option est inopérante sur <literal>\Z</literal>.
      </para>
      <para>
       La signification de <literal>^</literal> peut changer, de manière
       à l'amener à ce qu'il puisse se trouver immédiatement
       avant et immédiatement après un caractère de nouvelle
       ligne "<literal>\n</literal>". Cela se fait en ajoutant l'option
       <link linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link> au moment de
       la compilation ou de l'exécution.
       Par exemple, le masque <literal>/^abc$/</literal> accepte la chaîne
       "<literal>def\nabc</literal>" uniquement en mode multi-lignes. Par
       conséquent, toutes les parties du masque qui commencent par
       "<literal>^</literal>" ne sont pas ancrées, en mode multi-lignes.
       L'option <link linkend="reference.pcre.pattern.modifiers">PCRE_DOLLAR_ENDONLY</link>
       est ignorée si l'option
       <link linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link> est choisie.
      </para>
      <para>
       Notez que les méta-caractères <literal>\A</literal>,
       <literal>\Z</literal>, et <literal>\z</literal> peuvent servir à
       repérer le début et la fin du sujet, et toutes les
       parties du masque qui commenceront par <literal>\A</literal> seront toujours
       ancrées, avec l'option
       <link linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link> ou non.
      </para>
     </refsect2>

     <refsect2 id="regexp.reference.dot">
      <title>Point</title>
      <para>
       En dehors d'une classe de caractères, un point remplace n'importe
       quel caractère, même invisible et à l'exception du
       caractère de nouvelle ligne. Avec l'option
       <link linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link> le point
       remplace n'importe quel caractère, même le caractère de
       nouvelle ligne. La gestion des points et complètement
       indépendante de <literal>^</literal> et <literal>$</literal>.
       Le seul point commun est que les deux ont un comportement particulier vis-à-vis
       des caractères de nouvelle ligne.
       Le point n'a pas de comportement particulier dans une classe de
       caractères.
      </para>
      <para>
       <emphasis>\C</emphasis> peut être utilisé pour chercher un seul octet.
       Il prend tout son sens en mode <emphasis>UTF-8</emphasis>
       où le point correspond à un caractère entier qui peut être constitué de plusieurs
       octets.
     </para>
     </refsect2>

     <refsect2 id="regexp.reference.squarebrackets">
      <title>Crochets</title>
      <para>
       Un crochet ouvrant <literal>[</literal> introduit une classe de
       caractères, et le crochet fermant <literal>]</literal>la
       conclut. Le crochet fermant n'a pas de signification en lui-même.
       Si le crochet fermant est nécessaire à l'intérieur
       d'une classe de caractères, il faut qu'il soit le premier
       caractère (après un <literal>^</literal> éventuel)
       ou échappé avec un anti-slash.
      </para>
      <para>
       Une classe de caractères remplace un seul caractère
       dans la chaîne sujet, à moins que le premier
       caractère de la classe soit un accent circonflexe
       <literal>^</literal>, qui représente une négation :
       le caractère ne doit pas se trouver dans la classe. Si
       <literal>^</literal> est nécessaire dans la classe, il
       suffit qu'il ne soit pas le premier caractère, ou bien
       qu'il soit échappé avec un anti-slash.
      </para>
      <para>
       Par exemple, le caractère <literal>[aeiou]</literal> remplace
       n'importe quelle voyelle minuscule, tandis que <literal>[^aeiou]</literal>
       remplace n'importe quelle caractère qui n'est pas une voyelle
       minuscule. <literal>^</literal> est une notation pratique pour
       spécifier des caractères qui sont dans une classe,
       en ne citant que ceux qui n'y sont pas. Le comportement est inchangé.
      </para>
      <para>
       Avec l'option d'insensibilité à la casse, toutes les lettres
       d'une classe de caractères représentent en même temps
       la majuscule et la minuscule. Par exemple, <literal>[aeiou]</literal>
       représentera "<literal>A</literal>" ou "<literal>a</literal>", et
       <literal>[^aeiou]</literal> n'acceptera pas ni "<literal>A</literal>",
       tandis que sans l'option, elle l'accepterait.
      </para>
      <para>
       Le caractère de nouvelle ligne n'est pas traité de
       manière spéciale dans les classes de caractères,
       quelque soit l'option <link linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link>
       ou <link linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link>. Une classe
       telle que <literal>[^a]</literal> acceptera toujours une nouvelle ligne.
      </para>
      <para>
       Le signe moins (<literal>-</literal>) est utilisé pour
       spécifier un intervalle de caractères, dans
       une classe. Par exemple, <literal>[d-m]</literal> remplace toutes
       les lettres entre d et m inclus. Si le caractère moins est
       requis dans une classe, il faut l'échapper avec un anti-slash,
       ou le faire apparaître à une position où il ne pourra
       pas être interprété comme une indication d'intervalle,
       c'est-à-dire au début ou à la fin de la classe.
      </para>
      <para>
       Il n'est pas possible d'avoir le caractère crochet fermant
       "<literal>]</literal>" comme fin d'intervalle. Un masque tel que
       <literal>[W-]46]</literal> est compris comme la classe de caractères
       contenant deux caractères ("W" et "-") suivie de la chaîne
       littérale "46]", ce qui fait qu'il va accepter
       "<literal>W46]</literal>" ou  "<literal>-46]</literal>". Cependant, si
       "<literal>]</literal>" est échappé avec un anti-slash, le
       masque <literal>[W-\]46]</literal> est interprété comme
       une classe d'un seul caractère, contenant un intervalle de
       caractères.
      </para>
      <para>
       La valeur octale ou hexadécimale de  "<literal>]</literal>" peut
       aussi être utilisée pour déterminer les limites
       de l'intervalle. Les intervalles travaillent sur des
       séquences ASCII. Ils peuvent aussi être
       précisés avec des valeurs numériques : par exemple
       "<literal>[\000-\037]</literal>".
       Si cet intervalle inclut des lettres utilisées avec une
       option d'insensibilité de casse, les majuscules ou minuscules
       correspondantes seront aussi incluses. Par exemple,
        "<literal>[C-c]</literal>" est équivalent à
        "<literal>[][\^_`wxyzabc]</literal>", avec l'option
        d'insensibilité de casse. Si la table locale de
        caractères est "fr", "<literal>[\xc8-\xcb]</literal>"
        correspond aux caractères accentués.
      </para>
      <para>
       Les types de caractères <literal>\d</literal>,
       <literal>\D</literal>, <literal>\S</literal>, <literal>\s</literal>,
       <literal>\w</literal>, <literal>\W</literal> peuvent aussi intervenir
       dans les classes de caractères. Par exemple,
       "<literal>[][\^_`wxyzabc][\dABCDEF]</literal>" acceptera n'importe
       quel caractère hexadécimal. Un accent circonflexe peut
       aussi être utilisé pour spécifier adroitement
       des ensembles de caractères plus restrictifs : par exemple
       <literal>[^\W_]</literal> accepte toutes les lettres et les chiffres,
       mais pas les soulignés. Tous les caractères non alpha-
       numériques autres que <literal>\, -, ^</literal> (placés
       en début de chaîne) et <literal>]</literal> n'ont pas de
       signification particulière, mais ils ne perdront rien à
       être échappés.
      </para>
     </refsect2>

     <refsect2 id="regexp.reference.verticalbar">
      <title>Barre verticale</title>
      <para>
       La barre verticale <literal>|</literal> sert à séparer des
       alternatives. Par exemple, dans le masque "<literal>/dupont|martin/</literal>"
       recherche soit "<literal>dupont</literal>", soit "<literal>martin</literal>".
       Le nombre d'alternatives n'est pas limité, et il est même possible
       d'utiliser la chaîne vide. Lors de la recherche, toutes les alternatives
       sont essayées, de gauche à droite, et la première qui est
       acceptée est utilisée.
       Si les alternatives sont dans un sous-masque, elle ne réussiront
       que si le masque principal réussi aussi.
      </para>
     </refsect2>

     <refsect2 id="regexp.reference.internal-options">
      <title>Options internes</title>
      <para>
       Les options <link linkend="reference.pcre.pattern.modifiers">PCRE_CASELESS</link>,
       <link linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link>,
       <link linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link>,
       <link linkend="reference.pcre.pattern.modifiers">PCRE_UNGREEDY</link>,
       <link linkend="reference.pcre.pattern.modifiers">PCRE_EXTRA</link> et
       <link linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link> peuvent
       être changées à l'intérieur du masque
       lui-même, avec des séquences mises entre
       "<literal>(?</literal>" et "<literal>)</literal>".
       Les options sont :
       <table>
        <title>Internal option letters</title>
        <tgroup cols="2">
         <tbody>
          <row>
           <entry><literal>i</literal></entry>
           <entry>pour <link linkend="reference.pcre.pattern.modifiers">PCRE_CASELESS</link></entry>
          </row>
          <row>
           <entry><literal>m</literal></entry>
           <entry>pour <link linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link></entry>
          </row>
          <row>
           <entry><literal>s</literal></entry>
           <entry>pour <link linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link></entry>
          </row>
          <row>
           <entry><literal>x</literal></entry>
           <entry>pour <link linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link></entry>
          </row>
          <row>
           <entry><literal>U</literal></entry>
           <entry>pour <link linkend="reference.pcre.pattern.modifiers">PCRE_UNGREEDY</link></entry>
          </row>
          <row>
           <entry><literal>X</literal></entry>
           <entry>Pour <link linkend="reference.pcre.pattern.modifiers">PCRE_EXTRA</link></entry>
         </row>
         </tbody>
        </tgroup>
       </table>
      </para>
      <para>
       Par exemple, <literal>(?im)</literal> rend le masque insensible à
       la casse, et multi-lignes. Il est possible d'annuler ces options en les
       faisant précéder par un signe <literal>-</literal> : par
       exemple <literal>(?im-sx)</literal>, ajoutera les options
       <link linkend="reference.pcre.pattern.modifiers">PCRE_CASELESS</link>
       et <link linkend="reference.pcre.pattern.modifiers">PCRE_MULTILINE</link> mais
       annulera les options 
       <link linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link>
       et <link linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link>.
       Si une option apparaît avant et après le signe moins, l'option
       sera annulée.
      </para>
      <para>
       Lorsqu'une modification d'option survient au degrès le plus haut (et donc, pas dans
       les parenthèses du sous-masque), les modifications sont appliquées dans le reste
       du masque qui suit. Donc, <literal>/ab(?i)c/</literal> valide uniquement
       "abc" et "abC". Ce comportement a été modifié en PCRE 4.0 et est inclus depuis
       &php; 4.3.3. Dans les versions précédentes, <literal>/ab(?i)c/</literal> fonctionne
       de la même façon que <literal>/abc/i</literal> (e.g. valide "ABC" et "aBc").
      </para>
      <para>
       Si une option intervient dans un sous-masque, le comportement est différent.
       C'est un changement de comportement apparu en Perl 5.005. Une option à
       l'intérieur d'un sous-masque n'affecte que cette partie du masque, ce
       qui fait que <literal>(a(?i)b)c</literal> acceptera <literal>abc</literal> et 
       <literal>aBc</literal> mais aucune autre chaîne (en supposant que <link
       linkend="reference.pcre.pattern.modifiers">PCRE_CASELESS</link> n'est pas
       utilisé). Cela signifie que les options permettent d'avoir
       différentes configurations de recherche pour différentes
       parties du masque.
      </para>
      <para>
       Une séquence d'options dans une alternative affecte toute
       l'alternative. Par exemple :

         <literal>(a(?i)b|c)</literal>

       accepte "<literal>ab</literal>", "<literal>aB</literal>", "<literal>c</literal>",
       et "<literal>C</literal>", même si, comme dans le cas de
       "<literal>C</literal>", la première alternative qui porte
       l'option n'est pas prise en compte. Sinon, cela risque d'introduire
       des comportements très étranges : les options
       spécifiques à PCRE telles
       <link linkend="reference.pcre.pattern.modifiers">PCRE_UNGREEDY</link> et
       <link linkend="reference.pcre.pattern.modifiers">PCRE_EXTRA</link> peuvent
       être modifiées de la même
       manière, en utilisant respectivement les caractères
       U et X. L'option <literal>(?X)</literal> est particulière,
       car elle doit toujours intervenir avant toutes les autres options,
       même au niveau du masque entier. Il vaut mieux l'activer au
       début du masque.
      </para>
     </refsect2>

     <refsect2 id="regexp.reference.subpatterns">
      <title>Sous-masques</title>
      <para>
       Les sous-masques sont délimités par des parenthèses,
       et peuvent être imbriqués. Ajouter des sous-masques a deux
       utilités :
      </para>
      <para>
       1. Délimiter des alternatives. Par exemple, le masque
       <literal>char(don|mant|)</literal> acceptera les mots
       "<literal>char</literal>", "<literal>charmant</literal>", ou
       "<literal>charmant</literal>". Sans les parenthèses, il
       n'accepterait que "<literal>chardon</literal>",
       "<literal>mant</literal>" ou la chaîne vide "".
      </para>
      <para>
       2. Le sous-masque est considéré comme capturant : lorsqu'une
       chaîne sujet est acceptée par le masque complet, les
       sous-masques sont transmis à l'appelant grâce à
       un vecteur de sous-masques. Les parenthèses ouvrantes sont
       comptées de gauche à droite, (commençant à 1).
       Par exemple, soit la chaîne sujet "<literal>le roi soleil</literal>"
       qui est utilisée avec le masque suivant :
       <literal>Le ((roi|prince) (soleil|charmant))</literal> les sous-masques
       capturés sont "<literal>roi soleil</literal>", "<literal>roi</literal>",
       et "<literal>soleil</literal>", numérotés respectivement 1, 2, et 3.
      </para>
      <para>
       L'ubiquité des parenthèses n'est pas toujours simple
       d'emploi. Il y a des moments où regrouper des sous-masques
       est nécessaire, sans pour autant capturer la valeur trouvée.
       Si une parenthèse ouvrante est suivie de "<literal>?:</literal>",
       le sous-masque ne capture pas la chaîne assortie, et ne sera pas
       compté lors de la numérotation des captures. Par exemple,
       avec la chaîne "<literal>le prince charmant</literal>", utilisé
       avec le masque <literal>Le (( ?roi|prince) (soleil|charmant))</literal>
       les chaînes capturées seront "<literal>prince charmant</literal>"
       et "<literal>charmant</literal>", numérotés respectivement 1
       et 2.
      </para>
      <para>
       Le nombre maximal de chaînes capturées est de 99, et le
       nombre total de sous-masques (capturant ou non) ne doit pas
       dépasser 200.
      </para>
      <para>
       <literal>(?i:samedi|dimanche)</literal> et
       <literal>(?:(?i) samedi | dimanche)</literal> : de plus, comme les
       séquences d'options sont valables sur toute une alternative,
       les masques ci-dessus accepteront aussi bien "DIMANCHE" que "Dimanche".
      </para>

      <para>
       Il est possible de nommer le sous-masque avec
       <literal>(?P&lt;name&gt;pattern)</literal> depuis &php; 4.3.3.
       Les tableaux avec les masques doivent contenir le masque indexé par la
       chaîne à côté le masque indexé par le numéro.
     </para>
     </refsect2>

     <refsect2 id="regexp.reference.repetition">
      <title>Répétitions</title>
      <para>
       Les répétitions sont spécifiées avec
       des quantificateurs, qui peuvent être placés à
       la suite des caractères suivants :
       <variablelist>
        <varlistentry>
         <term><emphasis>a</emphasis></term>
         <listitem>
          <simpara>
           Un caractère unique, même s'il s'agit
           d'un méta-caractère
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><emphasis>.</emphasis></term>
         <listitem>
          <simpara>
           Un méta-caractère
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><emphasis>[abc]</emphasis></term>
         <listitem>
          <simpara>
           Une classe de caractères
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><emphasis>\2</emphasis></term>
         <listitem>
          <simpara>
           Une référence de retour (voir section suivante)
          </simpara>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><emphasis>(a|b|c)</emphasis></term>
         <listitem>
          <simpara>
           Un sous-masque avec parenthèses (à moins que ce ne soit
           une assertion, voir plus loin)
          </simpara>
         </listitem>
        </varlistentry>
       </variablelist>
      </para>
      <para>
       Les quantificateurs généraux précisent un nombre
       minimum et maximum de répétitions possibles, donnés
       par deux nombres entre accolades, et séparés par une virgule.
       Ces nombres doivent être plus petits que 65536, et le premier nombre
       doit être égal ou inférieur au second. Par exemple
       <literal>z{2,4}</literal> accepte "<literal>zz</literal>",
       "<literal>zzz</literal>", ou "<literal>zzzz</literal>". L'accolade fermante
       n'a pas de signification par elle-même.
      </para>
      <para>
       Si le second nombre est omis, mais que la virgule est là, cela
       signifie qu'il n'y a pas de limite supérieure. Si le second nombre
       et la virgule sont omis, le quantificateur correspond au nombre exact de
       répétitions attendues. Par exemple :
       accepte n'importe quelle succession d'au moins 3 voyelles minuscules, tandis
       que <literal>\d{d}</literal> n'accepte que 8 chiffres exactement.
      </para>
      <para>
       Une accolade ouvrante qui apparaît à une position où
       un quantificateur n'est pas accepté, ou si la syntaxe des
       quantificateurs n'est pas respectée, sera considérée
       littérale. Par exemple, "<literal>{,6}</literal>" n'est pas un
       quantificateur, mais une chaîne de 4 caractères.
      </para>
      <para>
       Le quantificateur {0} est autorisé, mais l'expression est alors
       ignorée.
      </para>
      <para>
       Par convenance (et pour une compatibilité historique), les trois
       quantificateurs les plus communs ont une abréviation sur
       un seul caractère :
       <table>
        <title>Quantificateurs sur un seul caractère</title>
        <tgroup cols="2">
         <tbody>
          <row>
           <entry><literal>*</literal></entry>
           <entry>équivalent à <literal>{0,}</literal></entry>
          </row>
          <row>
           <entry><literal>+</literal></entry>
           <entry>équivalent à <literal>{1,}</literal></entry>
          </row>
          <row>
           <entry><literal>?</literal></entry>
           <entry>équivalent à <literal>{0,1}</literal></entry>
          </row>
         </tbody>
        </tgroup>
       </table>
      </para>
      <para>
       Il est possible de constituer des boucles infinies en créant un sous-masque
       sans caractères, mais pourvu d'un quantificateur sans limite
       supérieure. Par exemple "<literal>(a?)*</literal>.
      </para>
      <para>
       Les versions plus anciennes de Perl et PCRE généraient alors
       une erreur au moment de la compilation. Cependant, étant donné
       qu'il existe des situations où ces constructions peuvent être
       utiles, ces masques sont désormais autorisés. Toutefois, si
       la répétition du sous-masque ne trouve aucun caractère,
       la boucle est interrompue.
      </para>
      <para>
       Par défaut, les quantificateurs sont dits "gourmands", c'est à
       dire, qu'ils cherchent d'abord à trouver le nombre maximal de
       répétitions qui autorisent le succès de la recherche.
       L'exemple classique posé par cette gourmandise est la recherche de
       commentaires d'un programme en C. Les commentaires apparaissent entre les
       séquences <literal>/*....*/</literal> et à l'intérieur
       de ces délimiteurs, les <literal>*</literal> et <literal>/</literal>
       sont autorisés. Appliquer le masque <literal>/\*.*\*/</literal>
       à la chaîne
       <literal>/* premier commentaire */  aucun commentaire  /* second commentaire */</literal>
       ne peut réussir, car le masque travaille sur toute la chaîne,
       à cause de la gourmandise du caractère <literal>.*</literal>.
      </para>
      <para>
       Cependant, un quantificateur suivi d'un point d'interrogation cesse
       d'être gourmand, et au contraire, ne recherche que le nombre
       minimum de répétition. Dans ces conditions, le masque
       <literal>/\*.*?\*/</literal> trouvera bien les commentaires du code
       C. La signification des autres quantificateurs n'est pas changée.
       Attention à ne pas confondre l'utilisation du point d'interrogation
       ici avec son utilisation comme quantificateur lui-même.
       À cause de cette ambiguïté, il peut apparaître des situations
       où il faut le doubler : <literal>\d??\d</literal>. Ce masque va
       tenter de lire un seul chiffre, mais, le cas échéant,
       il acceptera 2 chiffres pour permettre à la recherche
       d'aboutir. 
      </para>
      <para>
       Si l'option <link linkend="reference.pcre.pattern.modifiers">PCRE_UNGREEDY</link>
       est activée, (une option qui
       n'est pas disponible avec Perl) alors les quantificateurs sont
       non gourmands par défaut, mais peuvent être
       rendu gourmands au cas par cas, en ajoutant un point d'interrogation
       après. En d'autres termes, cette option inverse le comportement par
       défaut.
      </para>
      <para>
       Les quantificateurs suivis par <literal>+</literal> sont "possessifs". Ils
       mangent autant de caractères que possible et ne retournent pas
       pour chercher le reste du masque. <literal>.*abc</literal> trouvera "abc"
       mais <literal>.*+abc</literal>, non, car, <literal>.*+</literal> mange
       la chaîne complètement. Les quantificateurs possessifs peuvent être utilisés
       pour accélérer le traitement depuis &php; 4.3.3
    </para>
      <para>
       Lorsqu'un sous-masque est quantifié avec un nombre minimum
       de répétitions, qui soit plus grand que 1, ou avec
       un maximum de répétitions, le masque compilé aura
       besoin de plus de place de stockage, proportionnellement au minimum
       et au maximum.
      </para>
      <para>
       Si un masque commence par <literal>..*</literal> ou <literal>.{0,}</literal>
       et que l'option <link linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link>
       (équivalent en Perl à /s) est
       activée, c'est-à-dire en autorisant le remplacement des nouvelles
       lignes par un méta-caractère, alors le masque est
       implicitement ancré, car tout ce qui suit va être
       mangé par la première séquence, et se comportera
       comme si le masque se terminait par le méta-caractère
       <literal>\A</literal>. Dans le cas où on sait d'avance qu'il
       n'y aura pas de caractère de nouvelle ligne, activer l'option
       <link linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link> et commencer
       le masque par <literal>.*</literal> permet d'optimiser le masque.
      </para>
      <para>
       Alternativement, on peut utiliser <literal>^</literal> pour ancrer
       explicitement le masque. Lorsqu'un sous-masque capturant est
       répété, la valeur capturée est la
       dernière. Par exemple, après que
       "<literal>(inter[net]{3}\s*)+</literal>" ait été
       appliqué à "<literal>internet interne</literal>",
       la valeur de la chaîne capturée est "<literal>interne</literal>".
      </para>
      <para>
       Cependant, s'il y a des sous-masques imbriqués, la valeur
       capturée correspondante peut l'avoir été lors
       des précédentes itérations. Par exemple :
       <literal>/(a|(b))+/</literal> accepte "<literal>aba</literal>" et
       la deuxième valeur capturée est "<literal>b</literal>".
      </para>
     </refsect2>

     <refsect2 id="regexp.reference.back-references">
      <title>Références arrières </title>
      <para>
       En dehors des classes de caractères, un anti-slash suivi
       d'un nombre plus grand que 0 (et possiblement plusieurs chiffres)
       est une référence arrière (c'est à
       dire vers la gauche) dans le masque, en supposant qu'il y ait
       suffisamment de sous-masques capturants précédents.
      </para>
      <para>
       Cependant, si le nombre décimal suivant l'anti-slash est
       plus petit que 10, il sera toujours considéré
       comme une référence arrière, et cela
       générera une erreur si le nombre de captures
       n'est pas suffisant. En d'autres termes, il faut qu'il existe
       suffisamment de parenthèses ouvrantes à gauche
       de la référence, surtout si la référence
       est inférieure à 10.
      </para>
      <para>
       Reportez-vous à la section "anti-slash" pour avoir de
       plus amples détails à propos du nombre de
       chiffres qui suivent l'anti-slash.
      </para>
      <para>
       La référence arrière remplace ce qui a
       été capturé par un sous-masque dans le
       masque courant, plutôt que remplace le sous-masque
       lui-même. Ainsi <literal>(calme|rapide)</literal> et
       <literal>\1ment</literal> trouvera "<literal>calme et calmement</literal>"
       et "<literal>rapide et rapidement</literal>", mais pas
       "<literal>calme et rapidement</literal>". Si la recherche tient
       compte de la casse, alors la casse de la chaîne
       capturée sera importante. Par exemple,
       <literal>((?i)rah)\s+\1</literal> trouve "<literal>rah rah</literal>"
       et "<literal>RAH RAH</literal>", mais pas "<literal>RAH rah</literal>",
       même si le sous-masque capturant initial ne tenait pas compte
       de la casse.
      </para>
      <para>
       Il peut y avoir plusieurs références arrières dans
       le même sous-masque. Si un sous-masque n'a pas été
       utilisé dans une recherche, alors les références
       arrières échoueront. Par exemple "<literal>(a|(bc))\2</literal>"
       ne réussira jamais si la chaîne sujet commence par
       "<literal>a</literal>" plutôt que par "<literal>bc</literal>".
      </para>
      <para>
       Étant donné qu'il peut y avoir jusqu'à 99 références
       arrières, tous les chiffres après l'anti-slash sont
       considérés comment faisant potentiellement partie de
       la référence arrière. Si le masque recherche un
       chiffre après la référence, alors il faut
       impérativement utiliser des délimiteurs pour terminer
       la référence arrière.
      </para>
      <para>
       Si l'option <link linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link>
       est activée, on peut utiliser un espace.
       Sinon, un commentaire vide fait l'affaire. Une référence
       arrière qui intervient à l'intérieur de
       parenthèses auxquelles elle fait référence
       échouera dès que le sous-masque sera utilisé. Par exemple,
       <literal>(a\1)</literal> échouera toujours. Cependant, ces
       références peuvent être utiles dans les
       sous-masques répétitifs. Par exemple, le masque
       "<literal>(a|b\1)+</literal>" pourra convenir pour "<literal>a</literal>",
       "<literal>aba</literal>", "<literal>ababaa</literal>", etc.
      </para>
      <para>
       À chaque itération du sous-masque, la référence
       arrière utilise le résultat du dernier sous-masque.
       Pour que cela fonctionne, il faut que la première
       itération n'ait pas besoin d'utiliser la référence
       arrière. Cela arrive avec les alternatives, comme dans
       l'exemple ci-dessus, ou avec un quantificateur de minimum 0.
      </para>
     </refsect2>

     <refsect2 id="regexp.reference.assertions">
     <title>Assertions</title>
      <para>
       Une assertion est un test sur les caractères suivants ou
       précédents celui qui est en cours d'étude. Ce
       test ne consomme par de caractère (ie, on ne déplace
       pas le pointeur de caractères). Les assertions simples sont
       codées avec <literal>\b</literal>, <literal>\B</literal>,
       <literal>\A</literal>, <literal>\Z</literal>, <literal>\z</literal>,
       <literal>^</literal> et <literal>$</literal>, et sont décrites
       précédemment.
      </para>
      <para>
       Il existe cependant des types d'assertions plus complexes, codées
       sous la forme de sous-masques. Il en existe deux types : celles qui
       travaillent au-delà de la position courante (<literal>\w+(?=;)</literal>),
       et celles qui travaillent en-deça (<literal>(?!)\w+</literal>).
      </para>
      <para>
       Une assertion se comporte comme un sous-masque, hormis le fait qu'elle
       ne déplace pas le pointeur de position. Les assertions avant
       commencent par <literal>(?=</literal> pour les assertions positives, et
       par <literal>(?!</literal>, pour les assertions négatives. Par exemple :
       <literal>\w+(?=;)</literal> s'assure qu'un mot est suivi d'un point-virgule,
       mais n'inclut pas le point virgule dans la capture. D'autre part,
       <literal>(?!foo)bar</literal> en est proche, mais ne trouve pas une
       occurrence de "<literal>bar</literal>" qui soit précédée
       par quelque chose d'autre que "<literal>foo</literal>foo"; il trouve toutes
       les occurrences de "<literal>bar</literal>", quelque soit ce qui
       le précède, car l'assertion <literal>(?!foo)</literal>
        est toujours vraie quand les trois caractères suivants sont
        "<literal>bar</literal>". Une assertion arrière est ici
        nécessaire.
       </para>
       <para>
        Les assertions arrières commencent par <literal>(?&lt;=</literal>
        pour les assertions positives, et <literal>(?&lt;!</literal> pour les
        assertions négatives. Par exemple : <literal>(?&lt;!foo)bar</literal>
        trouve les occurrences de "<literal>bar</literal>" qui ne sont pas
        précédées par "<literal>foo</literal>".
       </para>
       <para>
        Le contenu d'une référence arrière est limité
        de telle façon que les chaînes qu'il utilise
        soient toujours de la même taille. Cependant, lorsqu'il
        y a plusieurs alternatives, elles n'ont pas besoin d'être
        de la même taille. Par exemple, <literal>(?&lt;=bullock|donkey)</literal>
        est autorisé, tandis que <literal>(?&lt;!dogs?|cats?)</literal>
        provoque une erreur de compilation. Les alternatives qui ont des
        longueurs différentes ne sont autorisées qu'au niveau
        supérieur des assertions arrières. C'est une
        amélioration du fonctionnement de Perl 5.005, qui impose
        aux alternatives d'avoir toutes la même taille. Une
        assertion telle que <literal>(?&lt;=ab(c|de))</literal> n'est pas
        autorisée, car l'assertion de bas niveau (la deuxième,
        ici) a deux alternatives de longueurs différentes. Pour
        la rendre acceptable, il faut écrire <literal>(?&lt;=abc|abde)</literal>
       </para>
       <para>
        L'implémentation des assertions arrières déplace
        temporairement le pointeur de position vers l'arrière, et cherche
        à vérifier l'assertion. Si le nombre de caractères
        est différent, la position ne sera pas correcte, et l'assertion
        échouera. La combinaison d'assertions arrières avec des
        sous-masques peut être particulièrement pratique à
        fin des chaînes. Un exemple est donné à la fin de
        cette section.
       </para>
       <para>
        Plusieurs assertions peuvent intervenir successivement. Par exemple,
        le masque <literal>(?&lt;=\d{3})(?&lt;!999)foo</literal> recherche
        les chaînes "<literal>foo</literal>" précédées
        par trois chiffres qui ne sont pas "999". Notez que chaque assertion
        est appliquées indépendamment, au même point de
        la chaîne à traiter. Tout d'abord, il est
        vérifié que les trois premiers caractères ont
        tous des chiffres, puis on s'assure que ces trois caractères
        ne sont pas "<literal>999</literal>". Le masque précédant
        n'accepte pas "<literal>foo</literal>" précédé de
        6 caractères, les trois premiers étant des chiffres et
        les trois suivants étant différents de "<literal>999</literal>".
        Par exemple, ce masque n'acceptera pas la chaîne
        "<literal>123abcfoo</literal>". Pour ce faire, il faut utiliser le masque
        suivant : <literal>(?&lt;=\d{3}...)(?&lt;!999)foo</literal>. Dans ce
         masque, la première assertion vérifie les six premiers
        caractères, s'assure que les trois premiers sont des entiers,
        et la deuxième assertion s'assure que les trois derniers
        caractères ne sont pas "<literal>999</literal>".
       </para>
       <para>
        De plus, les assertions peuvent être imbriquées :
        <literal>(?&lt;=(?&lt;!foo)bar)baz</literal> recherche les
        occurrences de "<literal>baz</literal>" qui sont
        précédées par "<literal>bar</literal>", qui,
        à son tour, n'est pas précédé par
        "<literal>foo</literal>". Au contraire,
        <literal>(?&lt;=\d{3}...(?&lt;!999))foo</literal> est un autre masque,
        qui recherche les caractères "<literal>foo</literal>",
        précédés par trois chiffres, suivis de trois
        autres caractères qui ne forment pas "<literal>999</literal>".
        Les assertions ne sont pas capturantes, et ne peuvent pas être
        répétées. Si une assertion contient des sous-masques
        capturants en son sein, ils seront compris dans le nombre de sous-masques
        capturants du masque entier. La capture est réalisée pour
        les assertions positives, mais cela n'a pas de sens pour les
        assertions négatives.
       </para>
       <para>
        200 assertions au maximum sont autorisées.
       </para>
      </refsect2>

      <refsect2 id="regexp.reference.onlyonce">
       <title>Sous-masques uniques</title>
       <para>
        Avec les quantificateurs de répétitions, l'échec
        d'une recherche conduit normalement à une autre recherche, avec
        un nombre différent de répétitions, pour
        voir si le masque ne s'applique pas dans d'autres conditions.
        Parfois, il est pratique d'éviter ce comportement, soit
        pour changer la nature de la recherche, soit pour la faire abandonner
        plus tôt, si on pense qu'il n'est pas besoin d'aller plus loin.
       </para>
       <para>
        Considérons, par exemple, le masque <literal>\d+foo</literal>
        appliqué à la ligne <literal>123456bar</literal>.
        Après avoir tenté d'utiliser les 6 chiffres suivis
        de "<literal>foo</literal>" qui font échouer, l'action habituelle
        sera de réessayer avec 5 chiffres, puis avec 4, et ainsi de
        suite jusqu'à l'échec final.
       </para>
       <para>
        Un sous-masque évalué une seule fois permettrait
        d'indiquer que lorsqu'une partie du masque est trouvée, elle
        n'a pas besoin d'être réévaluée à
        chaque tentative. Ceci conduirait à ce que la recherche
        échoue immédiatement après le premier test.
        Ces assertions ont leur propre notation, commençant avec
        <literal>(?&gt;</literal> comme ceci : <literal>(?&gt;\d+)bar</literal>.
       </para>
       <para>
        Ce type de parenthèses verrouille le sous-masque qu'il contient
        une fois qu'il a été trouvé, et empêche un
        échec ultérieur d'y repasser, mais autorise à
        revenir plus loin en arrière. Une autre description est que
        les sous-masques de ce type recherchent les chaînes de
        caractères, et ancre le sous-masque à l'intérieur
        de la chaîne.
       </para>
       <para>
        Les sous-masques uniques ne sont pas capturants. Des cas simples comme
        ceux présentés ci-dessus peuvent être pris comme
        des situations maximales, qui réservent le maximum de
        caractères. En effet, alors que <literal>\d+</literal> et
        <literal>\d+?</literal> ajustent le nombre de chiffres trouvés
        de manière à laisser la possibilité au masque de
        réussir, <literal>(?&gt;\d+)</literal> ne peut retenir que la
        séquence entière de chiffres. Cette construction peut
        contenir un nombre arbitraire de sous-masques complexes, et ils peuvent
        être imbriqués.
       </para>
       <para>
        Les sous-masques uniques ne peuvent être utilisés qu'avec
        les assertions arrières, pour effectuer une recherche efficace
        en fin de chaîne. Considérons un masque simple tel
        "<literal>abcd$</literal>" appliqué à une très
        longue chaîne qui ne lui correspond pas. À cause du système
        de recherche de gauche à droite, PCRE va commencer par rechercher
        un "<literal>a</literal>" dans la chaîne sujet, puis vérifier
        si ce qui suit convient au reste du masque. Si le masque est
        spécifié sous la forme <literal>^.*abcd$</literal>
        alors, la séquence <literal>.*</literal> remplace en premier
        lieu la chaîne entière, et échoue, repart en
        arrière, et remplace tous les caractères sauf le dernier,
        échoue, retourne en arrière, prend un caractère
        de moins, etc. et ainsi de suite. Encore une fois, la recherche du
        "<literal>a</literal>" passe en revue toute la chaîne de gauche
        à droite, ce qui n'est pas très efficace. Par contre,
        si le masque était écrit <literal>^(?&gt;.*)(?&lt;=abcd)</literal>
        alors il n'y aurait pas de retour en arrière, pour satisfaire
        la séquence <literal>.*</literal>, car elle ne peut que remplacer
        toute la chaîne. L'assertion arrière consécutive
        va alors faire un test sur les 4 derniers caractères. Si elle
        échoue, la recherche est immédiatement interrompue.
       </para>
       <para>
        Pour les chaînes très longues, cette approche fait la
        différence en termes de performances et de temps de recherche.
        Lorsqu'un masque contient une répétition illimitée
        dans un sous-masque, qui contient lui-même un nombre
        illimité de répétiteurs, l'utilisation des
        sous-masques à utilisation unique est la seule façon
        d'éviter l'échec de la recherche après un
        temps de calcul trop long.
       </para>
       <para>
        Le masque <literal>(\D+|&lt;\d+&gt;)*[!?]</literal> recherche un nombre
        illimité de sous-chaînes, qui contiennent soit
        des non chiffres, soit des chiffres inclus dans &lt;&gt;, suivi soit
        par <literal>!</literal> ou par <literal>?</literal>. Lorsqu'il trouve
        une solution, ce masque va très vite. Mais, lorsqu'il est
        appliqué à une chaîne telle :
        <literal>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</literal>,
        il lui faut beaucoup de temps pour annoncer un échec. Cela est
        dû au fait que la chaîne peut être divisée en deux
        sous-chaînes d'un grand nombre de façons, et qu'elles
        ont toutes été essayées. (Cet exemple utilisait
        <literal>[!?]</literal> plutôt qu'un caractère simple, car
        PCRE et &php; utilise une optimisation qui leur permettent de détecter
        rapidement l'échec lorsqu'un caractère unique est
        trouvé. Il se souvient du dernier caractère qui est
        attendu, et s'aperçoit rapidement qu'il n'y a pas ce caractère).
       </para>
       <para>
        Si le masque utilisé est <literal>((?&gt;\D+)|&lt;\d+&gt;)*[!?]</literal>
        les séquences de chiffres ne peuvent pas être
        trouvées, et l'échec intervient rapidement.
       </para>
      </refsect2>

      <refsect2 id="regexp.reference.conditional">
       <title>Les sous-masques conditionnels</title>
       <para>
        Il est possible de lier un sous-masque à une condition, ou de
        choisir entre deux sous-masques alternatifs, en fonction du
        résultat d'une assertion, ou suivant les résultats
        de recherche précédents.
       </para>
       <para>
        Les deux formes possibles de sous-masques conditionnels sont
        <literal>(?(condition)masque positif)</literal> et
        <literal>(?(condition) masque positif | masque négatif)</literal>.
       </para>
       <para>
        Si les conditions sont satisfaites, le masque positif est utilisé,
        sinon, le masque négatif est utilisé, si présent.
        S'il y a plus de deux alternatives, une erreur est générée
        à la compilation.
       </para>
       <para>
        Il y a deux types de conditions : si le texte entre les parenthèses
        est une séquence de chiffres, alors la condition est satisfaite si
        le sous-masque correspondant à ce numéro a réussi.
        Considérons le masque suivant, qui contient des espaces non
        significatifs pour le rendre plus compréhensible (on supposera
        l'option <link linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link>
        activée) et qui est divisée en trois parties
        pour simplifier les explications : <literal>( \( )?    [^()]+    (?(1) \) )</literal>.
       </para>
       <para>
        La première partie recherche une parenthèse ouvrante
        optionnelle et, si elle existe, elle est capturée. La deuxième
        partie recherche un séquence de caractères qui ne contiennent
        pas de parenthèses. La troisième partie est
        conditionnée à la première, et s'assure que s'il
        y a une parenthèse ouvrante, il en existe une fermante.
        Si une parenthèse ouvrante a été trouvée,
        elle a été capturée, et donc la première capture
        existe, et la condition est exécutée. Sinon, elle est
        ignorée. Ce masque recherche donc une séquence de lettres, 
        éventuellement placées entre parenthèse.
       </para>
       <para>
        Si la condition est la chaîne <literal>(R)</literal>, elle sera
        satisfaite si un appel récursif au masque ou au sous-masque
        a été fait. Au premier appel, la condition n'est pas vérifiée.
    </para>
       <para>
         Si la condition n'est pas une séquence de chiffres, il faut que ce soit 
         une assertion. Ce peut être une assertion positive ou négative,
        arrière ou avant. Considérons le masque suivant
        (même conditions que le précédent) et avec deux
        alternatives en seconde ligne :
        <literal>(?(?=[^a-z]*[a-z])\d{2}[a-z]{3}-\d{2} | \d{2}-\d{2}-\d{2} )</literal>.
        La condition est une assertion avant positive, qui recherche une
        séquence optionnelle de caractères non-lettre. En d'autres
        termes, elle teste la présence d'au moins une lettre dans la chaîne
        sujet. Si une lettre est trouvée, la recherche se poursuit avec
        la première alternative, et sinon, avec la seconde. Ce masque
        recherche des chaînes de la forme <literal>dd-aaa-dd</literal> ou
        <literal>dd-dd-dd</literal>, avec "<literal>aaa</literal>" qui sont des
        lettres, et <literal>dd</literal> qui sont des chiffres.
       </para>
      </refsect2>

      <refsect2 id="regexp.reference.comments">
       <title>Commentaires</title>
       <para>
        La séquence <literal>(?#</literal> marque le début d'un commentaire,
        qui se termine à la prochaine parenthèse fermante. Les
        parenthèses imbriquées ne sont pas autorisées. Les
        caractères entre ces délimiteurs ne jouent alors aucun rôle
        dans le masque.
       </para>
       <para>
        Si l'option <link linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link>
        est activée, les caractères dièses
        <literal>#</literal> non échappés en dehors d'une classe de
        caractères introduisent un commentaire qui continuera jusqu'à
        la prochaine ligne dans le masque.
       </para>
      </refsect2>

      <refsect2 id="regexp.reference.recursive">
       <title>Masques récursifs</title>
       <para>
        Considérons le cas où il faut rechercher dans une
        chaîne avec un niveau d'imbrications infini de
        parenthèses. Sans l'aide de la récursivité, le
        mieux que nous puissions obtenir est de créer un masque avec un
        niveau fixé de profondeur d'imbrication. Il n'est pas possible
        de traiter des masques à niveau d'imbrication variable.
        PCRE fournit un nouvel outil expérimental qui permet
        d'utiliser la récursivité dans les masques (entre autres).
        L'option <literal>(?R)</literal> est fournie pour servir la cause de
        la récursivité. Le masque suivant résout le
        problème des parenthèses (l'option
        <link linkend="reference.pcre.pattern.modifiers">PCRE_EXTENDED</link> est
        utilisée pour ignorer les espaces) :
        <literal>\( ( (?&gt;[^()]+) | (?R) )* \)</literal>
       </para>
       <para>
        Tout d'abord, le masque recherche une parenthèse ouvrante. Puis,
        il recherche n'importe quel nombre de sous-chaînes qui sont soit
        des séquences de caractères non-parenthèses, ou
        bien une recherche récursive avec le même masque (i.e.
        une chaîne correctement incluse entre parenthèses).
        Finalement, il recherche une parenthèse fermante.
       </para>
       <para>
        Cet exemple particulier contient un nombre illimité de
        répétitions imbriquées, ce qui fait que
        l'utilisation de sous-chaînes à utilisation unique
        pour rechercher les séquences de caractères
        non parenthèses est important, lorsqu'il s'applique à
        une chaîne qui n'est pas valide. Par exemple, si on l'applique
        à "<literal>(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa()</literal>"
        la réponse arrive rapidement. Sinon, si les sous-chaînes
        à utilisation unique ne sont pas utilisées, la
        recherche peut prendre un temps très long, car il existe
        de très nombreuses combinaisons de <literal>+</literal> et
        <literal>*</literal> à tester avant de conclure à
        l'échec.
       </para>
       <para>
        Les valeurs utilisées pour capturer les sous-masques sont celles
        utilisées par les niveaux les plus hauts de
        récursivité, auxquels la valeur est fixée.
        Si le masque précédent est utilisé avec
        <literal>(ab(cd)ef)</literal> la valeur de la parenthèse
        capturante est "<literal>ef</literal>", qui est la dernière
        valeur lue au niveau supérieur. Si de nouvelles
        parenthèses sont ajoutées, par exemple :
        <literal>\( ( ( (?&gt;[^()]+) | (?R) )* ) \)</literal>
        alors la chaîne capturée est "<literal>ab(cd)ef</literal>",
        c'est-à-dire le contenu de la parenthèse capturante
        de plus haut niveau. S'il y a plus de 15 parenthèses
        capturantes dans une chaîne, PCRE doit utiliser plus
        de mémoire pour stocker ces données. S'il ne
        peut obtenir cette mémoire supplémentaire, il ne fait
        que sauver les 15 premières, car il n'y a pas moyen de
        générer une erreur de mémoire lors d'une
        récursion.
       </para>

       <para>
        Depuis &php; 4.3.3, <literal>(?1)</literal>, <literal>(?2)</literal> et suivant 
        peuvent être également utilisés pour les sous masques récursifs. Il est également
        possible d'utiliser les sous masques nommés : <literal>(?P>foo)</literal>.
       </para>
       <para>
        Si la syntaxe pour une référence de sous masque récursif (soit par un
        nombre ou par un nom) est utilisée en dehors des parenthèses à laquelle
        elle fait référence, il opère comme un sous routine dans un langage de programmation.
        Un exemple ci-dessus a montré que le masque
        <literal>(sens|respons)e and \1ibility</literal>
        trouvera "sense and sensibility" et "response and responsibility", mais pas
        "sense and responsibility". Si on utilise plutôt le masque
        <literal>(sens|respons)e and (?1)ibility</literal>
        alors, il trouvera "sense and responsibility" tout comme les deux autres chaînes.
        De telles références doivent, dependant, suivre le sous masque auquel
        elles se réfèrent.
     </para>
      </refsect2>

      <refsect2 id="regexp.reference.performances">
       <title>Performances</title>
       <para>
        Certaines séquences de recherches sont plus efficaces que d'autres.
        Ainsi, il est plus efficace d'utiliser une classe de caractères
        telle que <literal>[aeiou]</literal> plutôt qu'une alternative
        <literal>(a|e|i|o|u)</literal>.
       </para>
       <para>
        En général, le masque le plus simple, qui permette
        la recherche désirée est le plus efficace. Le livre
        de Jeffrey Friedl's contient de nombreuses études à
        propos de l'optimisation des expressions rationnelles.
       </para>
       <para>
        Lorsqu'un masque commence par.* et que l'option
        <link linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link> est
        activée, le masque est implicitement ancré par PCRE,
        étant donné qu'il ne peut que rechercher au début
        de la chaîne. Cependant, si l'option
        <link linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link> n'est pas
        activée, PCRE ne peut faire aucune optimisation car le
        méta-caractères point "<literal>.</literal>"
        ne remplace pas une nouvelle ligne, et si la chaîne
        sujet contient des nouvelles lignes, le masque peut trouver une
        solution qui serait située juste après une
        de ces nouvelles lignes, et non pas seulement au début
        de la chaîne sujet. Par exemple, le masque,
        <literal>(.*)second</literal> acceptera la chaîne
        "<literal>premier \net second</literal>" (avec "<literal>\n</literal>"
        qui remplace la nouvelle ligne), et la première chaîne
        capturée sera "<literal>et</literal>".
       </para>
       <para>
        Afin d'effectuer la recherche, PCRE va essayer d'appliquer le masque
        à partir de chaque début de ligne. Si vous utilisez un
        tel masque avec des chaînes qui ne contiennent pas de
        caractères de nouvelle ligne, les meilleures performances
        seront atteintes avec l'option
        <link linkend="reference.pcre.pattern.modifiers">PCRE_DOTALL</link>, ou en ancrant le
        masque avec <literal>^.*</literal>. Cela évite à PCRE
        de scanner toute la chaîne pour rechercher un caractère
        de nouvelle ligne et recommencer la recherche.
       </para>
       <para>
        Attention aux masques qui contiennent des quantificateurs infinis
        imbriqués. Ils peuvent demander un temps de calcul très
        long, lorsque appliqués à une chaîne qui ne
        correspond pas à ce masque. Par exemple, <literal>(a+)*</literal>
        peut accepter "<literal>aaaa</literal>" de 33 manières
        différentes, et ce nombre croit rapidement avec la taille
        de la chaîne (le quantificateur <literal>*</literal> peut prendre
        les valeurs de 0, 1, 2, 3, ou 4, et pour chaque cas non nul, le
        quantificateur <literal>+</literal> peut prendre différentes
        valeurs).
       </para>
       <para>
        Lorsque le reste de la chaîne est tel que l'on s'achemine
        vers un échec, PCRE doit en principe vérifier
        toutes les possibilités, et cela prend un temps
        extrêmement long. Un optimiseur repère les cas
        les plus simples, tel que <literal>(a+)*b</literal> où
        un caractère simple suit les quantificateurs. Avant de partir
        dans les procédures standards de recherche, PCRE
        s'assure qu'il y a au moins un "<literal>b</literal>" dans la
        chaîne, et si ce n'est pas le cas, l'échec est
        annoncé immédiatement. Sinon, il n'y a pas
        d'optimisation dans la recherche. Vous pouvez voir la
        différence de comportement avec le masque suivant :
        <literal>(a+)*\d</literal>. Le premier retourne un échec
        quasi-immédiatement, s'il est appliqué à
        une ligne de "<literal>a</literal>", alors que le second masque
        prend un temps significatif pour une chaîne de plus de
        20 caractères.
       </para>
      </refsect2>
   </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
