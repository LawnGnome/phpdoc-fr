<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.11 $ -->
<!-- EN-Revision: 1.10 Maintainer: yannick Status: ready -->
  <refentry id="function.session-set-save-handler">
   <refnamediv>
    <refname>session_set_save_handler</refname>
    <refpurpose>
     Configure les fonctions de stockage de sessions
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>bool</type><methodname>session_set_save_handler</methodname>
      <methodparam><type>string</type><parameter>open</parameter></methodparam>
      <methodparam><type>string</type><parameter>close</parameter></methodparam>
      <methodparam><type>string</type><parameter>read</parameter></methodparam>
      <methodparam><type>string</type><parameter>write</parameter></methodparam>
      <methodparam><type>string</type><parameter>destroy</parameter></methodparam>
      <methodparam><type>string</type><parameter>gc</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>session_set_save_handler</function> configure les fonctions
     de stockage de session, et permet de choisir des fonctions utilisateurs
     pour sauver et relire toutes les sessions. Cette fonction est
     très pratique lorsqu'il faut sauver les données de sessions
     en utilisant une autre technique que le système par fichier fourni
     par défaut : notamment, stockage en base de données, ou dans des
     démons tels que le <productname>SRM</productname>. 
     &return.success;
    </para>
    <note>
     <para>
      Le gestionnaire d'écriture n'est pas exécuté tant que le
      flot de sortie est ouvert. Par conséquent, l'affichage
      de messages de debogage durant le gestionnaire d'écriture
      ne sera donc jamais visible depuis le navigateur. Si vous
      avez besoin de débogage, nous vous suggérons d'écrire 
      vos messages dans un fichier.
     </para>
    </note>
    <note>
     <para>
      Le gestionnaire d'écriture n'est pas appelé s'il n'y a pas de données
      dans la session. Cela s'applique aussi si des variables de sessions
      vides sont enregistrées. Cela diffère du comportement du système
      de gestion des sessions par fichier, qui crée un fichier vide dans
      ce cas.
      </para>
    </note>
    <para>
     L'exemple suivant fournit un exemple de stockage des sessions
     semblable au système par défaut (par fichiers).
     Cet exemple peut facilement être adapté pour réaliser des
     sauvegardes en base de données, avec votre serveur préféré.
    </para>
    <para>
     La fonction de lecture doit toujours retourner une chaîne,
     pour que le gestionnaire fonctionne comme prévu. Vous devez
     retourner une chaîne vide s'il n'y a pas de données à lire.
     Les valeurs retournées par les autres gestionnaires sont 
     converties en booléen avant d'être retournées au script.
     &true; pour la réussite, &false; pour l'échec.
    </para>
    <para>
     <example>
      <title>
       Exemple avec <function>session_set_save_handler</function>
      </title>
      <programlisting role="php">
<![CDATA[
<?php
function open ($save_path, $session_name) {
  global $sess_save_path, $sess_session_name;
       
  $sess_save_path = $save_path;
  $sess_session_name = $session_name;
  return(true);
}

function close() {
  return(true);
}

function read ($id) {
  global $sess_save_path, $sess_session_name;

  $sess_file = "$sess_save_path/sess_$id";
  if ($fp = @fopen($sess_file, "r")) {
    $sess_data = fread($fp, filesize($sess_file));
    return($sess_data);
  } else {
    return(""); // Doit retourner "" ici.
  }

}

function write ($id, $sess_data) {
  global $sess_save_path, $sess_session_name;

  $sess_file = "$sess_save_path/sess_$id";
  if ($fp = @fopen($sess_file, "w")) {
    return(fwrite($fp, $sess_data));
  } else {
    return(false);
  }

}

function destroy ($id) {
  global $sess_save_path, $sess_session_name;
       
  $sess_file = "$sess_save_path/sess_$id";
  return(@unlink($sess_file));
}

/*******************************************************
 * ATTENTION - Vous devrez implémenter un       *
 * collecteur de données obosolètes ici. *
 *******************************************************/
function gc ($maxlifetime) {
  return true;
}

session_set_save_handler ("open", "close", "read", "write", "destroy", "gc");

session_start();

// Utilisez vos sessions comme d'habitude
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Voir aussi la directive de configuration 
     <link linkend="ini.session.save-handler">session.save_handler</link>.
    </para>
   </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
