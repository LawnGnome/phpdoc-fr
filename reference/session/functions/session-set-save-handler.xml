<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.2 $ -->
<!-- splitted from ./en/functions/session.xml, last change in rev 1.23 -->
  <refentry id="function.session-set-save-handler">
   <refnamediv>
    <refname>session_set_save_handler</refname>
    <refpurpose>
     Configure les fonctions de stockage de sessions
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>bool</type><methodname>session_set_save_handler</methodname>
      <methodparam><type>string</type><parameter>open</parameter></methodparam><methodparam><type>string</type><parameter>close</parameter></methodparam><methodparam><type>string</type><parameter>read</parameter></methodparam><methodparam><type>string</type><parameter>write</parameter></methodparam><methodparam><type>string</type><parameter>destroy</parameter></methodparam><methodparam><type>string</type><parameter>gc</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function><function>session_set_save_handler</function><\/function> configure les fonctions
     de stockage de session, et permet de choisir des fonctions utilisateurs
     pour sauver et relire toutes les sessions. Cette fonction est
     tr&egrave;s pratique lorsqu'il faut sauver les donn&eacute;es de sessions
     en utilisant une autre technique que le syst&egrave;me par fichier fourni
     par d&eacute;faut : notamment, stockage en base de donn&eacute;es, ou dans des
     d&eacute;mons tels que le SRM. &return.success;
    </para>
    <note>
     <para>
      Vous devez configurer l'option <parameter>session.save_handler</parameter> 
      &agrave; <parameter>user</parameter> dans votre fichier &php.ini; pour que
      <function><function>session_set_save_handler</function><\/function> soit actif.
     </para>
    </note>
    <note>
     <para>
      Le gestionnaire d'&eacute;criture n'est pas ex&eacute;cut&eacute; tant que le
      flot de sortie est ouvert. Par cons&eacute;quent, l'affichage
      de messages de debogage durant le gestionnaire d'&eacute;criture
      ne sera donc jamais visible depuis le navigateur. Si vous
      avez besoin de d&eacute;bogage, nous vous sugg&eacute;rons d'&eacute;crire 
      vos messages dans un fichier.
     </para>
    </note>
    <note>
     <para>
      Le gestionnaire d'&eacute;criture n'est pas appel&eacute; s'il n'y a pas de donn&eacute;es
      dans la session. Cela s'applique aussi si des variables de sessions
      vides sont enregistr&eacute;es. Cela diff&egrave;re du comportement du syst&egrave;me
      de gestion des sessions par fichier, qui cr&eacute;e un fichier vide dans
      ce cas.
      </para>
    </note>
    <para>
     L'exemple suivant fournit un exemple de stockage des sessions
     semblable au syst&egrave;me par d&eacute;faut : par fichier.
     Cet exemple peut facilement &ecirc;tre adapt&eacute; pour r&eacute;aliser des
     sauvegardes en bases de donn&eacute;es, avec votre serveur pr&eacute;f&eacute;r&eacute;.
    </para>
    <para>
     La fonction de lecture doit toujours retourner une chaîne,
     pour que le gestionnaire fonctionne comme pr&eacute;vu. Vous devez
     retourner une chaîne vide s'il n'y a pas de donn&eacute;es &agrave; lire.
     Les valeurs retourn&eacute;es par les autres gestionnaires sont 
     converties en bool&eacute;en avant d'&ecirc;tre retourn&eacute;es au script.
     &true; pour la r&eacute;ussite, &false pour l'&eacute;chec.
    </para>
    <para>
     <example>
      <title>
       Exemple avec <function><function>session_set_save_handler</function><\/function>
      </title>
      <programlisting role="php">
<![CDATA[
<?php
function open ($save_path, $session_name) {
  global $sess_save_path, $sess_session_name;
       
  $sess_save_path = $save_path;
  $sess_session_name = $session_name;
  return(true);
}

function close() {
  return(true);
}

function read ($id) {
  global $sess_save_path, $sess_session_name;

  $sess_file = "$sess_save_path/sess_$id";
  if ($fp = @fopen($sess_file, "r")) {
    $sess_data = fread($fp, filesize($sess_file));
    return($sess_data);
  } else {
    return(""); // Doit retourner "" ici.
  }

}

function write ($id, $sess_data) {
  global $sess_save_path, $sess_session_name;

  $sess_file = "$sess_save_path/sess_$id";
  if ($fp = @fopen($sess_file, "w")) {
    return(fwrite($fp, $sess_data));
  } else {
    return(false);
  }

}

function destroy ($id) {
  global $sess_save_path, $sess_session_name;
       
  $sess_file = "$sess_save_path/sess_$id";
  return(@unlink($sess_file));
}

/*********************************************
 * ATTENTION - Vous devrez impl&eacute;menter un    *
 * collecteur de donn&eacute;es obosol&egrave;tes ici.     *
 *********************************************/
function gc ($maxlifetime) {
  return true;
}

session_set_save_handler ("open", "close", "read", "write", "destroy", "gc");

session_start();

// Utilisez vos sessions comme d'habitude
?>
]]>
      </programlisting>
     </example>
    </para>
   </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
