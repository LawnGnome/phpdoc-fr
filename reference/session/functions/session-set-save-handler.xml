<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.18 $ -->
<!-- EN-Revision: 1.12 Maintainer: yannick Status: ready -->
<!-- Reviewed: no -->

  <refentry id="function.session-set-save-handler">
   <refnamediv>
    <refname>session_set_save_handler</refname>
    <refpurpose>
     Configure les fonctions de stockage de sessions
    </refpurpose>
   </refnamediv>
   <refsect1>
    &reftitle.description;
     <methodsynopsis>
      <type>bool</type><methodname>session_set_save_handler</methodname>
      <methodparam><type>string</type><parameter>open</parameter></methodparam>
      <methodparam><type>string</type><parameter>close</parameter></methodparam>
      <methodparam><type>string</type><parameter>read</parameter></methodparam>
      <methodparam><type>string</type><parameter>write</parameter></methodparam>
      <methodparam><type>string</type><parameter>destroy</parameter></methodparam>
      <methodparam><type>string</type><parameter>gc</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>session_set_save_handler</function> configure les fonctions
     de stockage de sessions, et permet de choisir des fonctions utilisateurs
     pour sauver et relire toutes les sessions. Cette fonction est
     très pratique lorsqu'il faut sauver les données de sessions
     en utilisant une autre technique que le système par fichier fourni
     par défaut : notamment, stockage en base de données ou dans des
     démons tels <productname>SRM</productname>.
     &return.success;
    </para>
    <note>
     <para>
      Le gestionnaire d'écriture n'est pas exécuté tant que le
      flot de sortie est ouvert. Par conséquent, l'affichage
      de messages de débogage durant le gestionnaire d'écriture
      ne sera donc jamais visible depuis le navigateur. Si vous
      avez besoin de débogage, nous vous suggérons d'écrire
      vos messages dans un fichier.
     </para>
    </note>
    <para>
     L'exemple suivant fournit un exemple de stockage des sessions
     semblable au système par défaut (par fichiers).
     Cet exemple peut facilement être adapté pour réaliser des
     sauvegardes en base de données, avec votre serveur préféré.
    </para>
    <para>
     La fonction de lecture doit toujours retourner une chaîne,
     pour que le gestionnaire fonctionne comme prévu. Vous devez
     retourner une chaîne vide s'il n'y a pas de données à lire.
     Les valeurs retournées par les autres gestionnaires sont
     converties en booléen avant d'être retournées au script.
     &true; pour la réussite, &false; pour l'échec.
    </para>
    <warning>
     <para>
      Les gestionnaires d'écriture et de fermeture sont appelés après la destruction
      des objets depuis &php; 5.0.5. Ces destructeurs peuvent utiliser les sessions
      mais le gestionnaire de session ne peut pas utiliser les objets. Dans les versions
      antérieures, ils étaient appelés dans l'ordre inverse. Il est possible d'appeler
      <function>session_write_close</function> depuis le destructeur pour résoudre
      ce problème.
     </para>
    </warning>
    <para>
     <example>
      <title>
       Exemple avec <function>session_set_save_handler</function>
      </title>
      <programlisting role="php">
<![CDATA[
<?php
function open ($save_path, $session_name) {
  global $sess_save_path, $sess_session_name;

  $sess_save_path = $save_path;
  $sess_session_name = $session_name;
  return(true);
}

function close() {
  return(true);
}

function read ($id) {
  global $sess_save_path, $sess_session_name;

  $sess_file = "$sess_save_path/sess_$id";
  if ($fp = @fopen($sess_file, "r")) {
    $sess_data = fread($fp, filesize($sess_file));
    return($sess_data);
  } else {
    return(""); // Doit retourner "" ici.
  }

}

function write ($id, $sess_data) {
  global $sess_save_path, $sess_session_name;

  $sess_file = "$sess_save_path/sess_$id";
  if ($fp = @fopen($sess_file, "w")) {
    return(fwrite($fp, $sess_data));
  } else {
    return(false);
  }

}

function destroy ($id) {
  global $sess_save_path, $sess_session_name;

  $sess_file = "$sess_save_path/sess_$id";
  return(@unlink($sess_file));
}

/*******************************************************
 * ATTENTION - Vous devrez implémenter un       *
 * collecteur de données obosolètes ici. *
 *******************************************************/
function gc ($maxlifetime) {
  return true;
}

session_set_save_handler ("open", "close", "read", "write", "destroy", "gc");

session_start();

// Utilisez vos sessions comme d'habitude
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Voir aussi la directive de configuration
     <link linkend="ini.session.save-handler"><option>session.save_handler</option></link>.
    </para>
   </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
