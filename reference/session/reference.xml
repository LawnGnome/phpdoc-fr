<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.35 $ -->
<!-- EN-Revision: 1.57 Maintainer: yannick Status: ready -->
<!-- Purpose: basic.session -->
<!-- Membership: core -->
<!-- Reviewed: no -->

 <reference id="ref.session">
  <title>Sessions</title>
  <titleabbrev>Sessions</titleabbrev>

  <partintro>

   <section id="session.intro">
    &reftitle.intro;
    <para>
     Le support des sessions de &php; est un moyen de préserver
     des données entre plusieurs accès. Cela vous permet de
     créer des applications personnalisées, et d'augmenter
     l'attrait de votre site.
    </para>
    <para>
     Chaque visiteur accédant à votre page web se voit assigner un
     identifiant unique, appelé "identifiant de session". Il peut
     être stocké soit dans un cookie, soit propagé dans l'URL.
    </para>
    <para>
     Le support des sessions vous permet d'enregistrer un
     nombre illimité de variables qui doivent être préservées
     entre les requêtes. Lorsqu'un visiteur accède à votre site,
     &php; va vérifier automatiquement (si 
     <link linkend="ini.session.auto-start"><option>session.auto_start
     </option></link> est activé)  ou sur demande (explicitement avec
     <function>session_start</function> ou  implicitement avec
     <function>session_register</function>) s'il existe une
     session du même nom. Si c'est le cas, l'environnement
     précédemment sauvé sera recréé.
    </para>
    <caution>
     <para>
      Si vous activez <link
      linkend="ini.session.auto-start"><option>session.auto_start
      </option></link>, alors vous ne pourrez pas enregistrer
      d'objets dans votre session tant que la définition de la classe
      ne sera pas chargée avant le début de la session, pour recréer les objets
      de votre session.
     </para>
    </caution>
    <para>
     Toutes les variables sont sérialisées après l'exécution du
     script &php;. Les variables qui sont indéfinies sont marquées
     comme telles. Lors des accès ultérieurs, elles ne seront pas
     définies, jusqu'à ce que l'utilisateur le fasse.
    </para>
    <warning>
     <para>
      Quelques types de données ne peuvent pas être linéarisés pour être stockés
      dans les sessions. Cela inclut les variables de type <type>resource</type>
      ou les objets avec des références circulaires (i.e. objet qui passe une
      référence à lui-même à un autre objet).
     </para>
    </warning>
    <note>
     <para>
      La gestion des sessions a été ajoutée en &php; 4.0.
     </para>
    </note>
    <note>
     <para>
      Notez que lorsque vous travaillez avec les sessions, un enregistrement
      dans la session ne sera pas créé tant que la variable ne sera pas 
      enregistrée en utilisant la fonction <function>session_register</function>
      ou en ajoutant une clé à la variable super-globale
      <varname>$_SESSION</varname>. Cela n'est vrai que si vous avez débuté une
      session en appelant la fonction <function>session_start</function>.
     </para>
    </note>
   </section>

   <section id="session.security">
    <title>Sessions et sécurité</title>
    <para>
     Lien externe : <ulink url="&url.session-fixation;">Session fixation</ulink>
    </para>
    <para>
     Utiliser les sessions ne signifie pas que les données de session ne
     pourront être vues que par un seul utilisateur. Il est important de
     garder cela en tête lorsque vous stockez et affichez des données
     importantes. Lorsque vous stockez des données dans une session,
     il faut se demander quels seront les problèmes posés si quelqu'un
     d'autre accède à cette information, ou comment votre application
     est affectée si la session est en fait celle d'un autre.
    </para>
    <para>
     Par exemple, si quelqu'un usurpe une session, il peut alors poster
     un message dans un forum sous une fausse identité. Quelle est la
     gravité de ce problème ? Ou bien, il peut accéder aux commandes
     d'un client, et même, modifier son panier d'achat. À priori, c'est
     moins problématique pour un fleuriste que pour un pharmacien.
     Si vous voulez résoudre ce souci de façon simple, il peut être utile
     d'activer <literal>session.use_only_cookies</literal>. Dans ce cas,
     les cookies devront être activés par le client, sinon, les sessions ne 
     fonctionneront pas.
    </para>
    <para>
     Par conséquent, lorsque vous manipulez des données importantes,
     il faut exploiter d'autres méthodes pour décider si une session
     est valide ou pas. Les sessions ne fournissent pas une méthode
     fiable d'identification.
    </para>
    <para>
     Les sessions reposent sur un identifiant de session, ce qui signifie
     que quelqu'un peut voler cet identifiant, rien qu'en volant l'ID. Ce vol
     peut être rendu très difficile, comme en utilisant les
     cookies, mais en aucun cas cela sera impossible. Les sessions dépendent
     aussi de la discipline de l'utilisateur qui referme son navigateur
     à la fin de la session pour tout clore proprement.
     De plus, même les cookies de session peuvent être
     surveillés sur un réseau, ou bien notés par un proxy car ils transitent en 
     clair sur le réseau. Pour remédier à cela, vous devriez implémenter un
     chiffrage SSL sur votre plate-forme.
    </para>
   </section>

   <section id="session.requirements">
    &reftitle.required;
    &no.requirement;
    <note>
     <para>
      Optionnellement, vous pouvez utiliser l'allocation de mémoire partagée 
      (mm), développé par Ralf S.Engelschall, pour stocker votre session.
      Vous devez télécharger <ulink url="&url.mm;">mm</ulink> et l'installer.
      Cette option n'est pas disponible pour les environnements Windows.
      Notez que le module de stockage de session mm ne garantit pas
      les verrous de sessions en cas d'accès multiples à la même session.
      Il peut être plus approprié d'utiliser un système de fichiers
      basé en mémoire partagée
      (comme tmpfs sur Solaris/Linux ou <filename>/dev/md</filename> sur BSD)
      pour stocker les sessions dans des fichiers, car ils seront proprement verrouillés.
      Les données de session sont stockées en mémoire ainsi, elles seront effacées
      lors du redémarrage du serveur web.
     </para>
    </note>
   </section>

   &reference.session.configure;

   &reference.session.ini;

   <section id="session.resources">
    &reftitle.resources;
    &no.resource;
   </section>

   &reference.session.constants;

   <section id="session.examples">
    &reftitle.examples;
    <note>
     <para>
      Depuis &php; 4.1.0, <varname>$_SESSION</varname> est disponible comme
      variable globale, au même titre que <varname>$_POST</varname>,
      <varname>$_GET</varname>, <varname>$_REQUEST</varname>, etc.
      Contrairement à <varname>$HTTP_SESSION_VARS</varname>,
      <varname>$_SESSION</varname> est toujours globale. Par conséquent, vous
      n'avez pas besoin d'utiliser le mot réservé
      <link linkend="language.variables.scope"><command>global</command></link>
      avec <varname>$_SESSION</varname>. Notez que cette documentation
      a été modifiée pour utiliser <varname>$_SESSION</varname>.
      Vous pouvez toujours le remplacer par 
      <varname>$HTTP_SESSION_VARS</varname> si vous préférez l'ancienne version.
      Notez également que vous devez démarrer votre session en utilisant la fonction
      <function>session_start</function> avant d'utiliser
      la variable super-globale <varname>$_SESSION</varname>.
     </para>
     <para>
      Les clés du tableau <varname>$_SESSION</varname> sont sujettes
      aux mêmes limitations que les variables &php; habituelles, c'est-à-dire
      qu'elles ne peuvent pas commencer par un nombre, mais commencer par
      une lettre ou un souligné '_'. Pour plus de détails, reportez-vous à
      la section sur les <link linkend="language.variables">variables</link>.
     </para>
    </note>

    <para>
     Si <link linkend="ini.track-vars"><literal>track_vars</literal></link> est
     activé et <link linkend="ini.register-globals"><literal>register_globals</literal></link>
     est désactivé, seuls les éléments du tableau global
     <varname>$_SESSION</varname> contiendront les variables
     enregistrées dans la session. Les variables de sessions relues seront
     uniquement disponibles dans <varname>$_SESSION</varname>.
    </para>
    <para>
     L'utilisation de <varname>$_SESSION</varname> (ou
     <varname>$HTTP_SESSION_VARS</varname> avec &php; 4.0.6 et plus ancien) est
     recommandé pour une meilleure sécurité et un code plus facilement
     entretenu. Avec <varname>$_SESSION</varname>, il n'y a pas besoin
     d'utiliser les fonctions <function>session_register</function>,
     <function>session_unregister</function> et
     <function>session_is_registered</function>. Les variables de sessions
     sont accessibles comme toute autre variable.
     <example>
      <title>
       Enregistrer une variable avec <varname>$_SESSION</varname>.
      </title>
      <programlisting role="php">
<![CDATA[
<?php
session_start();
// Utilisez $HTTP_SESSION_VARS avec PHP 4.0.6 ou plus ancien
if (!isset($_SESSION['compteur'])) {
    $_SESSION['compteur'] = 0;
} else {
    $_SESSION['compteur']++;
}
?>
]]>
      </programlisting>
     </example>
     <example>
      <title>
       Retirer une variable de session avec <varname>$_SESSION</varname> et <link
       linkend="ini.register-globals"><option>register_globals</option></link> inactif.
      </title>
      <programlisting role="php">
<![CDATA[
<?php
session_start();
// Utilisez $HTTP_SESSION_VARS avec PHP 4.0.6 ou plus ancien
unset($_SESSION['compteur']);
?>
]]>
      </programlisting>
     </example>
     </para>
    <para>
     <caution>
      <para>
       N'utilisez PAS la fonction <function>unset</function>
       avec <varname>$_SESSION</varname> sous la forme
       <literal>unset($_SESSION)</literal> sinon, cela rendra impossible 
       l'enregistrement de données dans la session en utilisant la super-globale
       <varname>$_SESSION</varname>.
      </para>
     </caution>
    </para>
    <warning>
     <para>
      Vous ne pouvez pas utiliser les références sur des variables de session
      car il n'y a aucune manière faisable de restaurer une référence vers une
      autre variable.
     </para>
    </warning>
    <para>
     Si <link linkend="ini.register-globals"><literal>register_globals</literal></link>
     est activé, alors toutes les variables globales peuvent être
     enregistrées comme variables de session, et toutes les variables de
     sessions seront reconstituées comme variables globales. Comme &php; doit
     savoir quels variables globales sont enregistrées comme variables
     de sessions, l'utilisateur doit enregistrer les variables avec
     <function>session_register</function> tandis que
     <varname>$HTTP_SESSION_VARS</varname> et <varname>$_SESSION</varname>
     ne nécessitent pas <function>session_register</function>.
     <caution>
      <para>
       Avant &php; 4.3, si vous utilisez <varname>$_SESSION</varname> et que
       vous avez désactivé <link
       linkend="ini.register-globals"><option>register_globals</option></link>,
       n'utilisez pas <function>session_register</function>,
       <function>session_is_registered</function> ou
       <function>session_unregister</function>.
      </para>
      <para>
       Désactiver
       <link linkend="ini.register-globals"><literal>register_globals</literal></link>
       est recommandé pour des raisons de sécurité et de performances.
      </para>
     </caution>
    </para>
    <para>
     Si <link
     linkend="ini.register-globals"><literal>register_globals</literal></link>
     est activé, alors les variables globales et les entrées dans le tableau
     <varname>$_SESSION</varname> seront des références sur la même valeur pour
     les valeurs qui auront été enregistrées avant le démarrage de la session
     (donc, dans les page précédentes). Cependant, si la variable a été enregistrée
     avec <varname>$_SESSION</varname>, alors, la variable globale est disponible
     jusqu'à la prochaine requête.
    </para>
    <para>
     De plus, si vous enregistrez une nouvelle variable avec la fonction
     <function>session_register</function>, l'entrée dans l'environnement
     global et <varname>$_SESSION</varname> ne fera pas de référence vers la
     même valeur jusqu'à la prochaine utilisation de
     <function>session_start</function> (ceci s'applique à &php; 4.2 et
     avant seulement). C'est à dire qu'une modification dans les variables
     globales ne sera pas répercutée dans les entrées de 
     <varname>$_SESSION</varname>. Il est peu probable que cela ait un impact en
     pratique et, de plus, cela a été corrigé en &php; 4.3.
    </para>
   </section>

   <section id="session.idpassing">
    <title>Passer l'identifiant de session (session ID)</title>
    <para>
     Il y a deux méthodes de propagation de l'identifiant de session :
     <itemizedlist>
      <listitem>
       <simpara>
        Cookies
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        Par URL
       </simpara>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     Le module de session supporte les deux méthodes. Les cookies sont
     optimaux, mais comme ils ne sont pas sûrs (tous les internautes
     ne les acceptent pas), ils ne sont pas fiables. La seconde
     méthode place l'identifiant de session directement dans les URL.
    </para>
    <para>
     &php; est capable de faire cela de manière transparente, lorsqu'il est 
     compilé avec l'option <link linkend="ini.session.use-trans-sid">
     <literal>--enable-trans-sid</literal></link>. Si vous activez
     cette option, les URL relatives seront modifiées pour contenir
     l'identifiant de session automatiquement. Alternativement,
     vous pouvez utiliser la constante <constant>SID</constant>, qui est
     définie, si le client n'a pas envoyé le cookie approprié.
     <constant>SID</constant> est soit de la forme
     <literal>session_name=session_id</literal> ou une chaîne vide.
     <note>
      <para>
       L'option <link linkend="ini.arg-separator.output">arg_separator.output</link>
       de &php.ini; vous permet de personnaliser le séparateur d'arguments.
       Pour être complètement en accord avec les spécifications XHTML, spécifiez
       &amp;amp; ici.
      </para>
     </note>
    </para>
    <para>
     Alternativement, vous pouvez utiliser la constante <constant>SID</constant>
     qui est définie si la session a commencé. Si le client n'envoie pas un cookie de session
     approprié, il aura la forme <literal>session_name=session_id</literal>.
     Sinon, il vaudra une chaîne vide. Ainsi, vous pouvez dans tous les cas
     l'inclure dans l'URL.
    </para>
    <para>
     L'exemple suivant vous montre comment enregistrer une variable et comment
     réaliser un lien correct avec une autre page, avec
     <constant>SID</constant>.
     <example>
      <title>Compter le nombre de passages d'un utilisateur sur une page</title>
      <programlisting role="php">
<![CDATA[
<?php
if (!session_is_registered('compteur')) {
    session_register('compteur');
    $compteur = 1;
} else {
    $compteur++;
}
?>

<p>
Bonjour visiteur, vous avez vu cette page <?php echo $compteur; ?> fois.
</p>

<p>
Pour continuer, <a href="nextpage.php?<?php echo strip_tags(SID); ?>">cliquez ici</a>.
</p>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     La fonction <function>strip_tags</function> est utilisée lors de l'affichage 
     du <constant>SID</constant> dans le but de contrer les attaques XSS.
    </para>
    <para>
     L'affichage du <constant>SID</constant>, comme montré dans l'exemple
     ci-dessus, n'est pas nécessaire si <link
     linkend="install.configure.enable-trans-sid">
     <option>--enable-trans-sid</option></link> a été utilisé pour compiler
     &php;.
    </para>
    <note>
     <para>
      Les URL non-relatives sont considérées comme externes au site, et ne
      recevront pas le <constant>SID</constant>, car c'est une fuite
      d'informations vers un autre site (envoi d'informations importantes).
     </para>
    </note>
   </section>

   <section id="session.customhandler">
    <title>Gestion personnalisée des sessions</title>
    <para>
     Pour implémenter un stockage en base de données, ou toute autre méthode,
     vous aurez besoin de la fonction 
     <function>session_set_save_handler</function> pour
     paramétrer vos propres fonctions de stockage.
    </para>
   </section>
  </partintro>

&reference.session.functions;

 </reference>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->

