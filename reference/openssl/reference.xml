<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.1 $ -->
 <reference id="ref.openssl">
  <title>OpenSSL</title>
  <titleabbrev>OpenSSL</titleabbrev>
  <partintro>
   &warn.experimental;
  <section id="openssl.intro">
  <title>Introduction</title>
   <para>
    Cette extension utilise les fonctions de
    <ulink url="&url.openssl;">OpenSSL</ulink> pour g&eacute;n&eacute;rer
    et v&eacute;rifier les signatures, ainsi que pour sceller (chiffrer)
    et ouvrir (d&eacute;chiffrer) les donn&eacute;es. Vous avez besoin de
    OpenSSL >= 0.9.5 pour utiliser ce module.
   </para>
   <para>
    Cette extension supporte aussi la signature et le cryptage des
    courrier &eacute;l&eacute;ctroniques. Il est aussi possible de
    sp&eacute;cifier des couples cl&eacute;s/certificats d'un grand nombre de
    cas, qui rendent le code PHP plus facile &agrave; lire. Ces
    fonctionnalit&eacute;s sont disponibles en d&eacute;veloppement sur CVS, et
    probablement avec PHP 4.0.6.
    <emphasis>ATTENTION : cette extension est encore 
    exp&eacute;rimentale!</emphasis>
   </para>
   <para>
    OpenSSL offre de nombreuses fonctionnalit&eacute;s qui ne sont pas
    encore support&eacute;es par ce module. Elle seront ajout&eacute;es
    ult&eacute;rieurement.
   </para>
  </section>
  <section id="openssl.certparams">
  <title>Param&egrave;tres cl&eacute;s/certificats</title>
   <para>
    Un bon nombre de fonctions OpenSSL demandent une cl&eacute; et un certificat
    comme param&egrave;tres. PHP 4.0.5 et plus r&eacute;cent utilisait
    des cl&eacute;s ou certificats sous forme de ressource, retourn&eacute;e
    par l'une des fonctions openssl_get_xxx(). Les versions ult&eacute;rieures
    utilisent l'une des m&eacute;thodes suivantes :
    <itemizedlist>
     <listitem>
      <para>
       Certificats
       <orderedlist>
        <listitem>
         <simpara>
          Une ressource X.509 retourn&eacute;e par 
          <function>openssl_x509_read</function>
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          Une cha&icirc;ne au format
          <filename>file://path/to/cert.pem</filename>;
          Le fichier ainsi rep&eacute;r&eacute; doit contenir un certificat,
          encod&eacute; au format PEM
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          Une cha&icirc;ne contenant le contenu d'un certificat, encod&eacute;
          au format PEM.
         </simpara>
        </listitem>
       </orderedlist>
      </para>
     </listitem>
     <listitem>
      <para>
       Cl&eacute;s publiques/priv&eacute;e
       <orderedlist>
        <listitem>
         <simpara>
          Une ressource cl&eacute;, retourn&eacute;e par la fonction
          <function>openssl_get_publickey</function> ou
          <function>openssl_get_privatekey</function>
         </simpara>
        </listitem>
        <listitem>
         <simpara>
         Pour les cl&eacute;s publiques seulement : une ressource
         X.509
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          Une cha&icirc;ne avec le format : 
          <filename>file://path/to/file.pem</filename>.
          Le fichier doit contenir une cl&eacute; priv&eacute; ou un certificat,
          encod&eacute; au format PEM (il peut contenir les deux).
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          Une cha&icirc;ne contenant une cl&eacute; ou un certificat
          encod&eacute; au format PEM
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          Pour les cl&eacute;s priv&eacute;es, vous pouvez aussi utiliser la
          syntaxe <emphasis>array($key, $passphrase)</emphasis>, o&ugrave; $key
          repr&eacute;sente une cl&eacute; sp&eacute;cifi&eacute;e par un
          fichier ou une repr&eacute;sentation textuelle comme 
          cit&eacute; ci-dessus, et $passphrase repr&eacute;sente une
          cha&icirc;ne contenant la passe-phrase de cette cl&eacute;
          priv&eacute;e.
         </simpara>
        </listitem>
       </orderedlist>
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </section>
  <section id="openssl.cert.verification">
  <title>V&eacute;rification de certificats</title>
   <para>
    Lorsque vous appelez une fonction qui va v&eacute;rifier une signature ou
    un certificat, le param&egrave;tre <emphasis>cainfo</emphasis> doit &ecirc;tre un
    tableau contenant les noms d'un dossier et d'un fichier contenant les
    tiers de confiance. Si un dossier est sp&eacute;cifi&eacute;, il doit &ecirc;tre correct,
    car <command>openssl</command> va l'utiliser.
   </para>
   </section>
   <section id="openssl.pkcs7.flags">
    <title>Constantes/flags PKCS7</title>
    <para>
     Les fonctions S/MIME utilisent des flags qui sont sp&eacute;cifi&eacute;s
     par un champs de bits. Les valeurs valides sont :
     <table>
      <title>Constantes PKCS7</title>
       <tgroup cols="2">
        <thead>
         <row>
          <entry>Constante</entry>
          <entry>Description</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry>PKCS7_TEXT</entry>
          <entry>
           Ajoute le texte plein en clair dans les en-t&ecirc;tes du message
           sign&eacute;/chiffr&eacute;. Lors du d&eacute;chiffrement ou la v&eacute;rification,
           il supprime purement et simplement ces donn&eacute;es. Si le
           message chiffr&eacute; ou sign&eacute; n'est pas du type MIME, une erreur
           surviendra.
          </entry>
         </row>
         <row>
          <entry>PKCS7_BINARY</entry>
          <entry>
           Normalement, le message est converti au format canonique
           qui utilise effectivement des CR et LF comme fin de ligne,
           comme demand&eacute; dans les sp&eacute;cification de S/MIME.
           Lorsque cette option est activ&eacute;e, le message ne sera
           pas converti. Cela sert lorsque vous manipulez des donn&eacute;es
           binaires qui ne sont pas au format MIME.
          </entry>
         </row>
         <row>
          <entry>PKCS7_NOINTERN</entry>
          <entry>
           Lors de la v&eacute;rification d'un message, les certificats
           (s'il y en a) inclus dans le message sont normalement
           utilis&eacute; pour rechercher le certificat de signature. Avec
           cette option, seul le certificat sp&eacute;cifi&eacute; par le
           param&egrave;tre <parameter>extracerts</parameter> de la fonction
           <function>openssl_pkcs7_verify</function> est utilis&eacute;.
           Les certificats fournis peuvent toujours &ecirc;tre utilis&eacute;,
           avec un niveau de confiance r&eacute;duit.
          </entry>
         </row>
         <row>
          <entry>PKCS7_NOVERIFY</entry>
          <entry>
           Ne v&eacute;rifie pas les certificats des signataires d'un message
           sign&eacute;.
          </entry>
         </row>
         <row>
          <entry>PKCS7_NOCHAIN</entry>
          <entry>
           N'enchaine pas les v&eacute;rifications des signataires de
           certificats. C'est-&agrave;-dire, n'utilise pas les certificats
           contenu dans le message.
          </entry>
         </row>
         <row>
          <entry>PKCS7_NOCERTS</entry>
          <entry>
           Lors de la signature d'un message, le certificat du signataire
           est normalement inclus. Avec cette option, c'est
           d&eacute;sactiv&eacute;. Cela va r&eacute;duire la taille du message,
           mais le v&eacute;rificateur devra avoir une copie local du certificat
           du signataire (pass&eacute;e au param&egrave;tre
           <parameter>extracerts</parameter>, avec la fonction
           <function>openssl_pkcs7_verify</function>).
          </entry>
         </row>
         <row>
          <entry>PKCS7_NOATTR</entry>
          <entry>
           Normalement, lorsqu'un message est sign&eacute;, un jeu d'attributs
           contenant l'heure de signature et l'algorithme sym&eacute;trique
           support&eacute;, est inclus dans le message. Avec cette option,
           il n'est pas inclus.
          </entry>
         </row>
         <row>
          <entry>PKCS7_DETACHED</entry>
          <entry>
           Lors de la signature d'un message, utilise la signature
           en texte claire, avec le type MIME "multipart/signed".
           C'est la valeur par d&eacute;faut du param&egrave;tre
           <parameter>flags</parameter>
           pour la fonction <function>openssl_pkcs7_sign</function>.
           Si vous annulez cette optoin, le message sera sign&eacute; de
           mani&egrave;re opaque, ce qui resiste mieux &agrave; la traduction
           des relais mails (certains serveur mail anciens corrompent les
           messages), mais emp&ecirc;che la lecture par les client mails qui ne
           connaissent pas S/MIME.
          </entry>
         </row>
         <row>
          <entry>PKCS7_NOSIGS</entry>
          <entry>
           Ne v&eacute;rifie pas les signatures d'une message
          </entry>
         </row>
        </tbody>
       </tgroup>
      </table>
    </para>
    <note>
     <para>
      Ces constantes ont &eacute;t&eacute; ajout&eacute;es en PHP 4.0.6.
     </para>
    </note>
   </section>
  </partintro>
&reference.openssl.functions;

 </reference>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->

