<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.19 $ -->
<!-- EN-Revision: 1.20 Maintainer: yannick Status: ready -->
<!-- Reviewed: yes -->
 <reference id="ref.sockets">
  <title>Sockets</title>
  <titleabbrev>Sockets</titleabbrev>

  <partintro>

   <section id="sockets.intro">
    &reftitle.intro;
   <para>
    L'extension socket implémente une interface bas niveau avec les fonctions
    de communication par socket, basées sur les sockets BSD si populaires,
    et fournit la possibilité de fonctionner aussi bien sous forme de client
    que de serveur.
   </para>
   <para>
     Pour une interface socket cliente plus générique, voyez
     <function>stream_socket_client</function>,
     <function>stream_socket_server</function>,
     <function>fsockopen</function> et
     <function>pfsockopen</function>.
   </para>
   <para>
    Lorsque vous utilisez ces fonctions, il est important de vous
    rappeler que si de nombreuses fonctions ont le même nom que leur
    équivalent en langage C, elles ont souvent des déclarations différentes.
    Lisez attentivement les descriptions pour éviter des confusions.
   </para>
   <para>
    Cela dit, ceux qui ne sont pas familiers avec la programmation par socket
    peuvent toujours trouver beaucoup de documentation dans les pages de
    manuel Unix appropriées, et il y a une grande quantité d'introductions
    en langage C sur le web, qui peuvent être facilement réutilisées, avec
    des adaptations mineures.
    <ulink url="&url.socket.faq;">UNIX Socket FAQ</ulink> est un bon début.
   </para>
   </section>

   <section id="sockets.requirements">
    &reftitle.required;
    &no.requirement;
   </section>

   &reference.sockets.configure;

   <section id="sockets.configuration">
    &reftitle.runtime;
    &no.config;
   </section>

   <section id="sockets.resources">
    &reftitle.resources;
    &no.resource;
   </section>

   &reference.sockets.constants;

   <section id="sockets.errors">
    <title>Erreurs de socket</title>
    <para>
     L'extension socket a été écrite pour fournir une interface utilisable
     avec les puissantes sockets fournies par BSD. Un soin particulier a été
     apporté pour que les fonctions soient aussi efficaces sous Unix que sous
     Windows. Presque toutes les fonctions de sockets peuvent échouer
     dans certaines circonstances, et émettent ainsi un message d'alerte
     <constant>E_WARNING</constant> décrivant l'erreur. Parfois, cela ne
     se fait pas selon les souhaits du développeur. Par exemple, la fonction
     <function>socket_read</function> peut tout à coup émettre un
     message <constant>E_WARNING</constant> car la connexion a été
     inopinément interrompue. Il est commun de supprimer les erreurs avec
     l'opérateur <literal>@</literal> et de traiter les erreurs avec la
     fonction <function>socket_last_error</function>, au niveau de l'application.
     Vous pouvez appeler <function>socket_strerror</function> avec le code
     d'erreur pour connaître le message d'erreur, humainement lisible.
     Reportez-vous à leur description pour plus de détails.
    </para>
    <note>
     <para>
      Les messages <constant>E_WARNING</constant> générés par l'extension
      socket sont en anglais, mais ils s'afficheront en fonction
      de la configuration locale (<constant>LC_MESSAGES</constant>):
      <programlisting role="php">
<![CDATA[
Warning - socket_bind() unable to bind address [98]: Die Adresse wird bereits verwendet
]]>
      </programlisting>
     </para>
    </note>
   </section>

   <section id="sockets.examples">
    &reftitle.examples;
    <para>
     <example>
      <title>Exemple de socket : serveur TCP/IP simple</title>
      <para>
       Cet exemple montre comment créer un serveur simple.
       Changez les variables <varname>address</varname> et
       <varname>port</varname> pour vous adapter à votre configuration,
       et exécutez-le. Vous pourrez alors vous connecter au serveur
       avec une commande comme ceci : <command>telnet 192.168.1.53
       10000</command> (en supposant que l'adresse et le port correspondent
       à votre configuration). Tout ce que vous saisissez après cela sera
       envoyé au serveur, et affiché en retour. Pour vous déconnecter,
       tapez 'quit'.
      </para>
      <programlisting role="php">
<![CDATA[
#!/usr/local/bin/php -q
<?php
error_reporting(E_ALL);

/* Autorise l'exécution infinie du script, en attente de connexion. */
set_time_limit(0);

/* Active le vidage implicite des buffers de sortie, pour que nous
 * puissions voir ce que nous lisons au fur et à mesure. */
ob_implicit_flush();

$address = '192.168.1.53';
$port = 10000;

if (($sock = socket_create(AF_INET, SOCK_STREAM, SOL_TCP)) < 0) {
    echo "socket_create() a échoué : raison : " . socket_strerror($sock) . "\n";
}

if (($ret = socket_bind($sock, $address, $port)) < 0) {
    echo "socket_bind() a échoué : raison : " . socket_strerror ($ret) . "\n";
}

if (($ret = socket_listen($sock, 5)) < 0) {
    echo "socket_listen() a échoué : raison : " . socket_strerror ($ret) . "\n";
}

do {
    if (($msgsock = socket_accept($sock)) < 0) {
        echo "socket_accept() a échoué : raison : " . socket_strerror ($msgsock) . "\n";
        break;
    }
    /* Send instructions. */
    $msg = "\Bienvenue sur le serveur de test PHP.\n" .
        "Pour quitter, tapez 'quit'. Pour éteindre le serveur, tapez 'shutdown'.\n";
    socket_write($msgsock, $msg, strlen($msg));

    do {
        if (false === ($buf = socket_read($msgsock, 2048))) {
            echo "socket_read() a échoué : raison : " . socket_strerror ($ret) . "\n";
            break 2;
        }
        if (!$buf = trim($buf)) {
            continue;
        }
        if ($buf == 'quit') {
            break;
        }
        if ($buf == 'shutdown') {
            socket_close($msgsock);
            break 2;
        }
        $talkback = "PHP: You said '$buf'.\n";
        socket_write($msgsock, $talkback, strlen($talkback));
        echo "$buf\n";
    } while (true);
    socket_close($msgsock);
} while (true);

socket_close($sock);
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     <example>
      <title>Exemple avec les sockets : client TCP/IP simple</title>
      <para>
       Cet exemple implémente un client HTTP simple. Il se connecte simplement
       à une page, envoie une requête <literal>HEAD</literal>, affiche le
       résultat et se termine.
      </para>
     <programlisting role="php">
<![CDATA[
<?php
error_reporting(E_ALL);

echo "<h2>Connexion TCP/IP</h2>\n";

/* Lit le port du service WWW. */
$service_port = getservbyname('www', 'tcp');

/* Lit l'adresse IP du serveur de destination */
$address = gethostbyname('www.example.com');

/* Cree une socket TCP/IP. */
$socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);
if ($socket < 0) {
    echo "socket_create() a échoué : raison :  " . socket_strerror ($socket) . "\n";
} else {
    echo "OK.\n";
}

echo "Essai de connexion à '$address' sur le port '$service_port'...";
$result = socket_connect($socket, $address, $service_port);
if ($result < 0) {
    echo "socket_connect() a échoué : raison : ($result) " . socket_strerror($result) . "\n";
} else {
    echo "OK.\n";
}

$in = "HEAD / HTTP/1.0\r\n\r\n";
$in .= "Host: www.example.com\r\n";
$in .= "Connection: Close\r\n\r\n";
$out = '';

echo "Envoi de la requête HTTP HEAD...";
socket_write($socket, $in, strlen($in));
echo "OK.\n";

echo "Lire la réponse : \n\n";
while ($out = socket_read($socket, 2048)) {
    echo $out;
}

echo "Fermeture de la socket...";
socket_close($socket);
echo "OK.\n\n";
?>
]]>
      </programlisting>
     </example>
    </para>
   </section>
  </partintro>

&reference.sockets.functions;

 </reference>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->

