<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.7 $ -->
<!-- splitted from ./en/functions/sockets.xml, last change in rev 1.27 -->
  <refentry id="function.socket-select">
   <refnamediv>
    <refname>socket_select</refname>
    <refpurpose>
     Ex&eacute;cute l'appel syst&egrave;me select() un tableau de sockets 
     avec une dur&eacute;e d'expiration
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>int</type><methodname>socket_select</methodname>
      <methodparam><type>array</type><parameter>&amp;read</parameter></methodparam>
      <methodparam><type>array</type><parameter>&amp;write</parameter></methodparam>
      <methodparam><type>array</type><parameter>&amp;except</parameter></methodparam>
      <methodparam><type>int</type><parameter>tv_sec</parameter></methodparam>
      <methodparam choice="opt"><type>int</type><parameter>tv_usec</parameter></methodparam>
     </methodsynopsis>
     &warn.experimental.func;
    <para>
     <function>socket_select</function> accepte un tableau de sockets et
     attend qu'elles changent de statut. Ceux qui sont familiers avec les
     sockets de BSD reconnaitront dans ces tableaux de sockets les
     sets de file descriptor. Trois tableaux ind&eacute;pendants de ressources
     de sockets sont surveill&eacute;s.
    </para>
    <para>
     Les sockets list&eacute;es dans le param&egrave;tre <parameter>read</parameter> 
     seront surveill&eacute;es en lecture : pour savoir quand elles sont 
     disponibles en lecture (plus pr&eacute;cis&eacute;ment, si une lecture 
     ne va pas bloquer, en particulier, une ressource de socket a d&eacute;j&agrave; 
     atteint une fin de fichier, auquel cas <function>socket_read</function> 
     retournera une cha&icirc;ne de taille z&eacute;ro).
    </para>
    <para>
     Les sockets list&eacute;es dans <parameter>write</parameter> seront surveill&eacute;es 
     en &eacute;criture : pour voir si une &eacute;criture ne va pas bloquer.
    </para>
    <para>
     Les sockets list&eacute;es dans <parameter>except</parameter> seront surveill&eacute;es pour
     leurs exceptions.
    </para>
    <warning>
     <para>
      En sortie de fonction, les tableaux sont modifi&eacute;es pour indiquer
      quelles sockets ont chang&eacute;s d'&eacute;tats.
     </para>
    </warning>
    <para>
     Vous n'avez pas besoin de passer tous les tableaux &agrave; 
     <function>socket_select</function>. Vous pouvez les omettre, ou
     utiliser un tableau vide, ou encore &null; &agrave; la place. N'oubliez pas
     que ces tableaux sont pass&eacute;s par <emphasis>r&eacute;f&eacute;rence</emphasis> et 
     seront modifi&eacute;s par <function>socket_select</function>.
    </para>
    <para>
     <example>
      <title>Exemple avec <function>socket_select</function></title>
      <programlisting role="php">
<![CDATA[
<?php
  /* Pr&eacute;pare le tableau read (socket surveill&eacute;es en lecture) */
  $read = array($socket1, $socket2);

  if (false === ($num_changed_sockets = socket_select($read, $write = NULL, $except = NULL, 0))) {
    /* Gestion des erreurs */
  else if ($num_changed_sockets > 0) {
    /* Au moins une des sockets a &eacute;t&eacute; modifi&eacute; */
  }
?>
]]>
      </programlisting>
     </example>
    </para>
    <note>
     <para>
      A cause d'une limitation du Zend Engine actuel, il n'est pas possible
      de passer une constante comme &null; directement comme param&egrave;tre &agrave; cette
      focntion, qui attend une valeur par r&eacute;f&eacute;rence. A la place, utiliser
      un tableau temporaireou une expression dont le membre de gauche
      est une variable temporaire : 
      <example>
       <title>Passer &null; &agrave; <function>socket_select</function></title>
       <programlisting role="php">
<![CDATA[
<?php
  socket_select($r, $w, $e = NULL, 0);
?>
]]>
       </programlisting>
      </example>
     </para>
    </note>
    <para>
     Les param&egrave;tres <parameter>tv_sec</parameter> and <parameter>tv_usec</parameter>
     ensemble forment le param&egrave;tre <emphasis>timeout</emphasis> (dur&eacute;e de vie). 
     Le <emphasis>timeout</emphasis> est la dur&eacute;e maximale de temps avant que
     <function>socket_select</function> ne se termine. 
     <parameter>tv_sec</parameter> peut &ecirc;tre z&eacute;ro , ce qui fera que 
     <function>socket_select</function> retournera imm&eacute;diatement. C'est tr&egrave;s 
     pratique opur faire du polling (sondage). Si <parameter>tv_sec</parameter> est &null; 
     (pas de timeout), <function>socket_select</function> peut se bloquer ind&eacute;finiment.
    </para>
    <para>
     En cas de succ&egrave;s, <function>socket_select</function> retourne le nombre de
     sockets contenus dans les tableaux modifi&eacute;es. Ce nombre peut &ecirc;tre z&eacute;ro si
     la dur&eacute;e maximale d'attente a &eacute;t&eacute; atteinte. En cas d'erreur, &false;
     est retourn&eacute;. Le code
     d'erreur g&eacute;n&eacute;r&eacute; peut &ecirc;tre obtenu en appelant la fonction
     <function>socket_last_error</function>. Ce code d'erreur
     peut &ecirc;tre pass&eacute; &agrave; la fonction <function>socket_strerror</function> 
     pour obtenir un message d'erreur, humainement lisible.
    </para>
    <note>
     <para>
     Assurez vous bien d'utiliser l'op&eacute;rateur <literal>===</literal> 
     lorsque vous v&eacute;rifiez les erreurs. Etant donn&eacute;e que 
     <function>socket_select</function> peut retourner 0, la comparaison
     avec &false via <literal>==</literal> donnerait &true; :
     <example>
      <title>Analyser le r&eacute;sultat de <function>socket_select</function></title>
      <programlisting role="php">
<![CDATA[
<?php
  if (false === socket_select($r, $w, $e = NULL, 0)) {
    echo "socket_select() a &eacute;chou&eacute;. Raison : " .
          socket_strerror(socket_last_error()) . "\n";
  }
?>
]]>
       </programlisting>
      </example>
     </para>
    </note>
    <note>
     <para>
      M&eacute;fiez vous des impl&eacute;mentations de sockets, qui doivent &ecirc;tre manipul&eacute;es avec
      d&eacute;licatesse. Quelques r&egrave;gles de base : 
      <itemizedlist>
       <listitem>
        <simpara>
         Vous devez toujours essayer d'utiliser <function>socket_select</function>
         sans timeout. Votre programme ne devrait avoir rien &agrave; faire si
         il n'y a pas de donn&eacute;es disponibles. Le code qui d&eacute;pends d'un
         timeout est g&eacute;n&eacute;ralement peut portable, et difficile &agrave; d&eacute;boguer.
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         Une socket ne doit pas &ecirc;tre ajout&eacute;e &agrave; l'un des tableaux en param&egrave;tre,
         si vous ne souhaitez pas v&eacute;rifier le r&eacute;sultat apr&egrave;s l'appel &agrave; 
         <function>socket_select</function>. Apr&egrave;s le retour de 
         <function>socket_select</function>, toutes les sockets dans tous les
         tableaux doivent &ecirc;tre v&eacute;rifi&eacute;es. Toute socket qui est disponible en
         &eacute;criture ou en lecture doit &ecirc;tre utilis&eacute;e pour &eacute;crire ou lire.
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         Si vous &eacute;crivez ou lisez avec une socket retourn&eacute;e dans un tableau,
         soyez conscient qu'elles ne pourront pas &eacute;crire ou lire toutes les donn&eacute;es
         que vous demandez. Soyez pr&ecirc;ts &agrave; ne pouvoir lire qu'un seul octet. 
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         Il est commun &agrave; la plupart des impl&eacute;mentations de socket que la seule 
         exception intercept&eacute;e par les sockets dans le tableau 
         <parameter>except</parameter> est le cas des donn&eacute;es hors limites,
         re&ccedil;ues par une socket.
        </simpara>
       </listitem>
      </itemizedlist>
     </para>
    </note>
    <para>
     Voir aussi
     <function>socket_read</function>,
     <function>socket_write</function>,
     <function>socket_last_error</function> et 
     <function>socket_strerror</function>.
    </para>
   </refsect1>
  </refentry>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
