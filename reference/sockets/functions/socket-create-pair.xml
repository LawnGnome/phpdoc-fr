<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.9 $ -->
<!-- EN-Revision: 1.7 Maintainer: yannick Status: ready -->
  <refentry id="function.socket-create-pair">
   <refnamediv>
    <refname>socket_create_pair</refname>
    <refpurpose>Crée une paire de sockets identiques</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>bool</type><methodname>socket_create_pair</methodname>
      <methodparam><type>int</type><parameter>domain</parameter></methodparam>
      <methodparam><type>int</type><parameter>type</parameter></methodparam>
      <methodparam><type>int</type><parameter>protocol</parameter></methodparam>
      <methodparam><type>array</type><parameter>&amp;fd</parameter></methodparam>
     </methodsynopsis>
     &warn.experimental.func;
    <para>
     <function>socket_create_pair</function> crée une paire de sockets identiques et les stockent
     dans <parameter>&amp;fd</parameter>. Cette fonction est utilisée couramment dans
     IPC (<literal>InterProcess Communication</literal>).
    </para>
    <para>
     Le paramètre <parameter>domain</parameter> spécifie la famille du protocole à utiliser par 
     le socket.
    </para>
    <table>
    <title>Famille d'adresses / protocoles valides</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Domaine</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><literal>AF_INET</literal></entry>
       <entry>
        Protocole IPv4. TCP et UDP sont les protocoles communs de cette famille. 
        Supporté uniquement Windows.
       </entry>
      </row>
      <row>
       <entry><literal>AF_INET6</literal></entry>
       <entry>
        Protocole IPv6. TCP et UDP sont les protocoles communs de cette famille. 
        Le support a été ajouté en &php; 5.0.0.
        Supporté uniquement sous Windows.
       </entry>
      </row>
      <row>
       <entry><literal>AF_UNIX</literal></entry>
       <entry>
        Protocole de communication locale. Le rendement élevé et des moindres coûts supplémentaires lui font une grande
        force d'IPC (<literal>Interprocess Communication</literal>).
       </entry>
      </row>
     </tbody>
    </tgroup>
    </table>
    <para>
     Le paramètre <parameter>type</parameter> spécifie le type de 
     communication à utiliser par la socket.
    </para>
    <table>
    <title>Types de sockets disponibles</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Type</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><literal>SOCK_STREAM</literal></entry>
       <entry>
        Fournit des flux d'octets ordonnancés, fiables, full-duplex, raccordés sur la base.
        Un mécanisme de transmission des données "<literal>out-of-band</literal>" peut être supporté.
        Le protocole TCP est basé sur ce type de socket.
       </entry>
      </row>
      <row>
       <entry><literal>SOCK_DGRAM</literal></entry>
       <entry>
         Support des datagrammes (moins de connexion, message non garantie d'une longueur maximum fixe).
         Le protocole UDP est basé sur ce type de socket.
       </entry>
      </row>
        <row>
       <entry><literal>SOCK_SEQPACKET</literal></entry>
       <entry>
        Fournis un chemin de transmission de données séquentiel, fiable, connexion à la basé par deux chemins pour
        les datagrammes de longueur maximal fixe ; un consommateur est requit pour lire la totalité d'un paquet
        avec chaque appel à la lecture.
       </entry>
      </row>
      <row>
       <entry><literal>SOCK_RAW</literal></entry>
       <entry>
         Fournit l'accès brut de protocole de réseau. Ce type spécial de socket peut être utilisé 
         pour construire manuellement tout type de protocole. Une utilisation commune de ce type de socket
         est le traitement des requêtes ICMP (comme le ping, traceroute, etc.).
       </entry>
      </row>
      <row>
       <entry><literal>SOCK_RDM</literal></entry>
       <entry>
        Fournit une couche fiable de datagramme qui ne garantie pas l'ordre des données.
        Ce type de socket est le plus susceptible de ne pas être implémenté sur votre système d'exploitation.
       </entry>
      </row>
     </tbody>
    </tgroup>
    </table>
    <para>
     Le paramètre <parameter>protocol</parameter> définie un protocole spécifique
     dans le domaine spécifié <parameter>domain</parameter> pour être utilisé lors d'une 
     communication sur une socket retournée. La valeur appropriée peut être retrouvée par son nom
     en utilisant la fonction <function>getprotobyname</function>. Si le protocole désiré est TCP ou UDP, 
     les constantes correspondantes <constant>SOL_TCP</constant> et <constant>SOL_UDP</constant>
     peuvent être utilisées.
    </para>
    <table>
    <title>Protocoles communs</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Nom</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><literal>icmp</literal></entry>
       <entry>
        Le protocole ICMP (<literal>Internet Control Message Protocol</literal>) est utilisé tout d'abord par les
        passerelles et les hôtes pour reporter les erreurs dans des communications de datagramme.
        La commande "<literal>ping</literal>" (présente dans les systèmes de production modernes) est un
        exemple d'application utilisant le protocole ICMP.
       </entry>
      </row>
      <row>
       <entry><literal>udp</literal></entry>
       <entry>
        Le protocole UDP (<literal>User Datagramm Protocol</literal>) est un protocole 
        sans connexion, incertaine avec les longueurs d'enregistrement fixes. De ce fait,
        <literal>UDP</literal> requiert une quantité minimum de protocole.
       </entry>
      </row>
        <row>
       <entry><literal>tcp</literal></entry>
       <entry>
        Le protocole TCP (<literal>Transmission Control Protocol</literal>) est un protocole fiable, connecté sur la base, 
        orienté flux et full-duplex. <literal>TCP</literal> garantie que chaque paquet est reçu
        dans l'ordre dans lequel il a été envoyé. Si quelques paquets sont perdus pendant la communication,
        <literal>TCP</literal> retransmettra ces paquets tant que l'hôte destinataire ne les aura pas
        reçu entièrement. Pour des raisons de fiabilité et de performance, l'implémentation <literal>TCP</literal>
        lui-même décide des frontières appropriées d'octets de la couche fondamentale 
        de communication du datagramme. Par conséquent, les applications <literal>TCP</literal>
        doivent autoriser la possibilité de transmission partiel d'enregistrement.
       </entry>
      </row>
     </tbody>
    </tgroup>
    </table>
    <para>
    <example>
    <title>Exemple avec <function>socket_create_pair</function></title>
    <programlisting role="php">
<![CDATA[
<?php
$sockets = array();
$uniqid = uniqid('');
if (file_exists("/tmp/$uniqid.sock")) {
    die('La socket temporaire existe déjà.');
}
/* Création de la paire de sockets */
if (!socket_create_pair(AF_UNIX, SOCK_STREAM, 0, $sockets)) {
    echo socket_strerror(socket_last_error());
}
/* Envoi et réception de données */
if (!socket_write($sockets[0], "ABCdef123\n", strlen("ABCdef123\n"))) {
    echo socket_strerror(socket_last_error());
}
if (!$data = socket_read($sockets[1], strlen("ABCdef123\n"), PHP_BINARY_READ)) {
    echo socket_strerror(socket_last_error());
}
var_dump($data);

/* Fermeture des sockets */
socket_close($sockets[0]);
socket_close($sockets[1]);
?>
]]>
    </programlisting>
    </example>
    </para>
    <para>
    <example>
    <title>Exemple IPC avec <function>socket_create_pair</function></title>
    <programlisting role="php">
<![CDATA[
<?php
$ary = array();
$strone = 'Message From Parent.';
$strtwo = 'Message From Child.';
if (!socket_create_pair(AF_UNIX, SOCK_STREAM, 0, $ary)) {
    echo socket_strerror(socket_last_error());
}
$pid = pcntl_fork();
if ($pid == -1) {
    echo 'Impossible de dupliquer le processus.';
} elseif ($pid) {
    /* parent */
    socket_close($ary[0]);
    if (!socket_write($ary[1], $strone, strlen($strone))) {
        echo socket_strerror(socket_last_error());
    }
    if (socket_read($ary[1], strlen($strtwo), PHP_BINARY_READ) == $strtwo) {
       echo "Réception de $strtwo\n";
    }
    socket_close($ary[1]);
} else {
    /* fils */
    socket_close($ary[1]);
    if (!socket_write($ary[0], $strtwo, strlen($strtwo))) {
       echo socket_strerror(socket_last_error());
    }
    if (socket_read($ary[0], strlen($strone), PHP_BINARY_READ) == $strone) {
       echo "Réception de $strone\n";
    }
    socket_close($ary[0]);
}
?>
]]>
    </programlisting>
    </example>
    </para>
   </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
