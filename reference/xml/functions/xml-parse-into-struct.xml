<?xml version="1.0" encoding="iso-8859-1"?>
<!-- splitted from ./fr/functions/xml.xml, last change in rev 1.2 -->
<!-- last change to 'xml-parse-into-struct' in en/ tree in rev 1.11 -->
 <refentry id="function.xml-parse-into-struct">
   <refnamediv>
    <refname>xml_parse_into_struct</refname>
    <refpurpose>Analyse une structure XML</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>int</type><methodname>xml_parse_into_struct</methodname>
      <methodparam><type>resource</type><parameter>parser</parameter></methodparam>
      <methodparam><type>string</type><parameter>data</parameter></methodparam>
      <methodparam><type>array</type><parameter>&amp;values</parameter></methodparam>
      <methodparam><type>array</type><parameter>&amp;index</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>xml_parse_into_struct</function> analyse le fichier
     XML <parameter>data</parameter>, et le place dans deux tableaux :
	 le premier <parameter>index</parameter> contient des pointeurs
	 sur la position des valeurs correspondantes dans le tableau
	 <parameter>values</parameter> array. Ces deux param&egrave;tres sont
	 pass&eacute;s par r&eacute;f&eacute;rences.
    </para>
    <para>
     Ci-dessous, vous trouverez un exemple qui illustre la structure
     des deux tableaux g&eacute;n&eacute;r&eacute;s par la fonction. On utilise une balise
     simple <literal>note</literal>, plac&eacute;e dans une autre balise
     <literal>para</literal>. On analyse le tout, et on
      affiche la structure g&eacute;n&eacute;r&eacute;e :
     <informalexample>
      <programlisting role="php">
&lt;?php
$simple = &quot;&lt;para&gt;&lt;note&gt;simple note&lt;/note&gt;&lt;/para&gt;&quot;;
$p = xml_parser_create();
xml_parse_into_struct($p,$simple,$vals,$index);
xml_parser_free($p);
echo "Tableau d'index\n";
print_r($index);
echo "\nTableau de valeurs\n";
print_r($vals);
?&gt;
      </programlisting>
     </informalexample>
     Lors de l'&eacute;x&eacute;cution du code, l'affichage sera :
     <informalexample>
      <literallayout>
       <computeroutput>
Tableau d'index
Array
(
    [PARA] =&gt; Array
        (
            [0] =&gt; 0
            [1] =&gt; 2
        )
    [NOTE] =&gt; Array
        (
            [0] =&gt; 1
        )
)
Tableau de valeurs
Array
(
    [0] =&gt; Array
        (
            [tag] =&gt; PARA
            [type] =&gt; open
            [level] =&gt; 1
        )
    [1] =&gt; Array
        (
            [tag] =&gt; NOTE
            [type] =&gt; complete
            [level] =&gt; 2
            [value] =&gt; simple note
        )
    [2] =&gt; Array
        (
            [tag] =&gt; PARA
            [type] =&gt; close
            [level] =&gt; 1
        )
)
       </computeroutput>
      </literallayout>
     </informalexample>
    </para>
    <para>
     L'analyse &eacute;v&eacute;nementielle (comme celle de expat), peut se
     r&eacute;v&eacute;ler complexe lorsque le document XML est complexe.
     <function>xml_parse_into_struct</function> ne g&eacute;n&egrave;re pas
     d'objet de type DOM, mais il g&eacute;n&egrave;re plut&ocirc;t des
     structures qui peuvent &ecirc;tre parcourues &agrave; la fa&ccedil;on d'un arbre.
     Consid&eacute;rons le fichier suivant, qui repr&eacute;sente une petite base
     de donn&eacute;es XML :
     <example>
      <title>moldb.xml - Petite base de donn&eacute;es mol&eacute;culaire</title>
      <programlisting role="xml">
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;moldb&gt;
    &lt;molecule&gt;
        &lt;name&gt;Alanine&lt;/name&gt;
        &lt;symbol&gt;ala&lt;/symbol&gt;
        &lt;code&gt;A&lt;/code&gt;
        &lt;type&gt;hydrophobic&lt;/type&gt;
    &lt;/molecule&gt;
    &lt;molecule&gt;
        &lt;name&gt;Lysine&lt;/name&gt;
        &lt;symbol&gt;lys&lt;/symbol&gt;
        &lt;code&gt;K&lt;/code&gt;
        &lt;type&gt;charged&lt;/type&gt;
    &lt;/molecule&gt;
&lt;/moldb&gt;
      </programlisting>
     </example>
      Et maitenant, un code qui analyse le document, et g&eacute;n&egrave;re les
      objet ad hoc :
      <example>
      <title>
       parsemoldb.php - analyse moldb.xml et cr&eacute;e un tableau
       d'objet mol&eacute;culaires
      </title>
      <programlisting role="php">
&lt;?php
class AminoAcid {
    var $name;  // nom de l'amino acide
    var $symbol;    // symbole en trois lettres
    var $code;  // code en une lettre
    var $type;  // hydrophobe, charg&eacute; ou neutre
    function AminoAcid ($aa) {
        foreach ($aa as $k-&gt;$v)
            $this-&gt;$k = $aa[$k];
    }
}
function readDatabase($filename) {
    // read the xml database of aminoacids
    $data = implode(&quot;&quot;,file($filename));
    $parser = xml_parser_create();
    xml_parser_set_option($parser,XML_OPTION_CASE_FOLDING,0);
    xml_parser_set_option($parser,XML_OPTION_SKIP_WHITE,1);
    xml_parse_into_struct($parser,$data,&amp;$values,&amp;$tags);
    xml_parser_free($parser);
    // parcourt les structures
    foreach ($tags as $key-&gt;$val) {
        if ($key == &quot;molecule&quot;) {
            $molranges = $val;
            // chaque paire contigue sont les d&eacute;finitions sup&eacute;rieures
            // et inf&eacute;rieures de la mol&eacute;cule
            for ($i=0; $i &lt; count($molranges); $i+=2) {
                    $offset = $molranges[$i] + 1;
                $len = $molranges[$i + 1] - $offset;
                $tdb[] = parseMol(array_slice($values, $offset, $len));
            }
        } else {
            continue;
        }
    }
    return $tdb;
}
function parseMol($mvalues) {
    for ($i=0; $i &lt; count($mvalues); $i++)
        $mol[$mvalues[$i][&quot;tag&quot;]] = $mvalues[$i][&quot;value&quot;];
    return new AminoAcid($mol);
}
$db = readDatabase(&quot;moldb.xml&quot;);
echo "** Database of AminoAcid objects:\n";
print_r($db);
?&gt;
      </programlisting>
      </example>
      Apr&egrave;s ex&eacute;cution de <filename>parsemoldb.php</filename>, la variable
      <varname>$db</varname> contient un tableau d'objets
      <classname>AminoAcid</classname>, et l'affichage le confirme :
      <informalexample>
       <literallayout>
        <computeroutput>
** Database of AminoAcid objects:
Array
(
    [0] =&gt; aminoacid Object
        (
            [name] =&gt; Alanine
            [symbol] =&gt; ala
            [code] =&gt; A
            [type] =&gt; hydrophobic
        )
    [1] =&gt; aminoacid Object
        (
            [name] =&gt; Lysine
            [symbol] =&gt; lys
            [code] =&gt; K
            [type] =&gt; charged
        )
)
        </computeroutput>
       </literallayout>
      </informalexample>
    </para>
   </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
