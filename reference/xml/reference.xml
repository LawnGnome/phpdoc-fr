<?xml version="1.0" encoding="iso-8859-1"?>
 <reference id="ref.xml">
  <title>Analyseur syntaxique XML</title>
  <titleabbrev>XML</titleabbrev>
  <partintro>
    <section id="xml.intro">
    &reftitle.intro;
     <para>
      Le langage XML (eXtensible Markup Language (Langage &agrave; Balises
      Etendu)) est un format structur&eacute; de donn&eacute;es pour les
      &eacute;changes sur le web. C'est un standard d&eacute;fini par le
      consortium World Wide Web (W3C). Plus d'informations &agrave; propos
      du XML et des technologies aff&eacute;rentes sont accessibles (en anglais)
      <ulink url="&url.xml;">&url.xml;</ulink>.
     </para>
     <para>
       Cette extension PHP supporte la librairie <productname>expat</productname>
       de James Clark sous PHP. Cela vous permettra d'analyser mais
       pas de valider les documents XML. Il supporte trois types de
       codage diff&eacute;rents, disponibles aussi sous PHP:
      <literal>US-ASCII</literal>, <literal>ISO-8859-1</literal> et
      <literal>UTF-8</literal>. <literal>UTF-16</literal> n'est pas support&eacute;.
     </para>
     <para>
       Cette extension vous permet de cr&eacute;er des
       <link linkend="function.xml-parser-create">analyseurs XML</link>
       puis de d&eacute;finir des <emphasis>points d'entr&eacute;e</emphasis>
       pour chaque &eacute;v&eacute;nement XML. Les analyseurs XML disposent
       de quelques
       <link linkend="function.xml-parser-set-option">param&eacute;trages</link>.
     </para>
    </section>
   <section id="xml.requirements">
    &reftitle.required;
    <para>
      Cette extension de PHP utilise <productname>expat</productname>,
      disponible &agrave; <ulink url="&url.expat;">&url.expat;</ulink>.
      Le fichier Makefile livr&eacute; avec <productname>expat</productname>
      ne construit pas par d&eacute;faut de librairie : il faut utiliser
      la ligne suivante :
      <programlisting role="makefile">
<![CDATA[
libexpat.a: $(OBJS)
	ar -rc $@ $(OBJS)
	ranlib $@
]]>
      </programlisting>
      Les sources RPM de expat sont disponibles &agrave;
      <ulink url="&url.expat.rpm;">&url.expat.rpm;</ulink>.
     </para>
   </section>

   &reference.xml.configure;

   <section id="xml.configuration">
    &reftitle.runtime;
    &no.config;
   </section>

   <section id="xml.resources">
    &reftitle.resources;
    <section id="xml.resources.xml">
     <title><literal>xml</literal></title>
     <para>
      La ressource <literal>xml</literal> est retourn&eacute;e par 
      <function>xml_parser_create</function> et
      <function>xml_parser_create_ns</function>, et repr&eacute;sente
      un analysueur XML &agrave; utiliser avec les autres fonctions de l'extension.
     </para>
    </section>
   </section>

   &reference.xml.constants;


    <section id="xml.eventhandlers">
     <title>gestionnaires d'&eacute;v&egrave;nements</title>
     <para>
       Les gestionnaires d'&eacute;v&egrave;nements XML sont:
      <table>
       <title>Les gestionnaires d'&eacute;v&egrave;nements XML</title>
       <tgroup cols="2">
	<thead>
	 <row>
	  <entry>Fonction PHP de configuration du gestionnaire</entry>
	  <entry>Description de l'&eacute;v&eacute;nement</entry>
	 </row>
	</thead>
	<tbody>
	 <row>
	  <entry><function>xml_set_element_handler</function></entry>
	  <entry>
		Un &eacute;v&eacute;nement est g&eacute;n&eacute;r&eacute;
		&agrave; chaque fois que l'analyseur XML rencontre une balise de
		d&eacute;but ou de fin. Deux gestionnaires sont disponibles : un
		pour le d&eacute;but, et un pour la fin.
	  </entry>
	 </row>
	 <row>
	  <entry>
	   <function>xml_set_character_data_handler</function>
	  </entry>
	  <entry>
		 "Character data" correspond grosso modo &agrave; tout ce qui n'est
		 pas une balise XML, y compris les espaces entre les balises. Notez
		 bien que l'analyseur XML n'ajoute ou n'efface aucun espace, et que
		 c'est &agrave; l'application (c'est-&agrave;-dire vous) de
		 d&eacute;cider de la signification de ces espaces.
      </entry>
	 </row>
	 <row>
	  <entry>
	   <function>xml_set_processing_instruction_handler</function>
	  </entry>
	  <entry>
        Les programmeurs PHP sont habitu&eacute;s aux instructions
        ex&eacute;cutables (processing instructions ou PIs).
        <literal>&lt;?php ?&gt;</literal> est une instruction ex&eacute;cutable o&ugrave;
        php est appel&eacute; programme cible. Ces instructions sont
		g&eacute;r&eacute;es de mani&egrave;re sp&eacute;cifiques,
		(sauf le programme cible, qui est r&eacute;serv&eacute; &agrave; XML).
	  </entry>
	 </row>
	 <row>
	  <entry><function>xml_set_default_handler</function></entry>
	  <entry>
		Tout ce qui n'a pas trouv&eacute; de gestionnaire est transmis
		au gestionnaire par d&eacute;faut. Vous retrouverez par exemple,
		les d&eacute;clarations de type de document dans ce gestionnaire.
	  </entry>
	 </row>
	 <row>
	  <entry>
	   <function>xml_set_unparsed_entity_decl_handler</function>
	  </entry>
	  <entry>
		Ce gestionnaire est appel&eacute; pour g&eacute;rer les
		d&eacute;claration des entit&eacute;s non analys&eacute;s.
	  </entry>
	 </row>
	 <row>
	  <entry>
	   <function>xml_set_notation_decl_handler</function>
	  </entry>
	  <entry>
	   Ce gestionnaire est appel&eacute; pour g&eacute;rer les notations.
	  </entry>
	 </row>
	 <row>
	  <entry>
	   <function>xml_set_external_entity_ref_handler</function>
	  </entry>
	  <entry>
		Ce gestionnaire est appel&eacute; lorsque l'analyseur XML trouve une
		r&eacute;f&eacute;rence &agrave; un fichier externe. Cela peut
		&ecirc;tre un fichier, ou une URL. Reportez-vous &agrave;
		<link linkend="example.xml-external-entity">entit&eacute; externe</link>
		pour un exemple.
	  </entry>
	 </row>
	</tbody>
       </tgroup>
      </table>
     </para>
    </section>
    <section id="xml.case-folding">
     <title>Probl&egrave;mes de casse</title>
     <para>
        Les fonctions de gestion des balises peuvent rencontrer des balises en
        minuscule, majuscule ou encore dans un m&eacute;lange des deux. En XML,
        la proc&eacute;dure standard est d' "identifier les s&eacute;quences de
        caract&egrave;re qui ne sont pas reconnues comme majuscule, et de les
        remplacer par leur &eacute;quivalent majuscule". En d'autres termes,
        XML met toutes lettres en majuscules.
     </para>
     <para>
        Par d&eacute;faut, tous les noms des &eacute;l&eacute;ments qui sont
        transmis aux fonctions de gestion sont mises en majuscule. Ce
        comportement est contr&ocirc;l&eacute; par l'analyseur XML, et
        peut &ecirc;tre lu et modifi&eacute; avec les fonctions respectives
        <function>xml_parser_get_option</function> et
        <function>xml_parser_set_option</function>, respectivement.
     </para>
    </section>
    <section id="xml.error-codes">
     <title>Codes d'erreurs</title>
     <para>
      Les constantes suivantes sont d&eacute;finies comme des codes
      d'erreurs XML : (retourn&eacute;e par <function>xml_parse</function>)
      <simplelist>
       <member><constant>XML_ERROR_NONE</constant></member>
       <member><constant>XML_ERROR_NO_MEMORY</constant></member>
       <member><constant>XML_ERROR_SYNTAX</constant></member>
       <member><constant>XML_ERROR_NO_ELEMENTS</constant></member>
       <member><constant>XML_ERROR_INVALID_TOKEN</constant></member>
       <member><constant>XML_ERROR_UNCLOSED_TOKEN</constant></member>
       <member><constant>XML_ERROR_PARTIAL_CHAR</constant></member>
       <member><constant>XML_ERROR_TAG_MISMATCH</constant></member>
       <member><constant>XML_ERROR_DUPLICATE_ATTRIBUTE</constant></member>
       <member><constant>XML_ERROR_JUNK_AFTER_DOC_ELEMENT</constant></member>
       <member><constant>XML_ERROR_PARAM_ENTITY_REF</constant></member>
       <member><constant>XML_ERROR_UNDEFINED_ENTITY</constant></member>
       <member><constant>XML_ERROR_RECURSIVE_ENTITY_REF</constant></member>
       <member><constant>XML_ERROR_ASYNC_ENTITY</constant></member>
       <member><constant>XML_ERROR_BAD_CHAR_REF</constant></member>
       <member><constant>XML_ERROR_BINARY_ENTITY_REF</constant></member>
       <member><constant>XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF</constant></member>
       <member><constant>XML_ERROR_MISPLACED_XML_PI</constant></member>
       <member><constant>XML_ERROR_UNKNOWN_ENCODING</constant></member>
       <member><constant>XML_ERROR_INCORRECT_ENCODING</constant></member>
       <member><constant>XML_ERROR_UNCLOSED_CDATA_SECTION</constant></member>
       <member><constant>XML_ERROR_EXTERNAL_ENTITY_HANDLING</constant></member>
      </simplelist>
     </para>
    </section>
    <section id="xml.encoding">
     <title>Codage des caract&egrave;res</title>
     <para>
      L'extension XML de PHP supporte les caract&egrave;res
      <ulink url="&url.unicode;">Unicode</ulink> gr&acirc;ce &agrave;
      diff&eacute;rents codages. Il y a deux types de codages de
      caract&egrave;res : le codage &agrave; la source et le codage &agrave;
      la cible. PHP utilise le <literal>UTF-8</literal> comme
      repr&eacute;sentation interne.
     </para>
     <para>
      L'encodage &agrave; la source est effectu&eacute; lors de
     <link linkend="function.xml-parse">l'analyse</link> du fichier par XML.
      Lors de la <link linkend="function.xml-parser-create"> cr&eacute;ation
      d'un analyseur XML</link>), un type de codage &agrave; la
      source doit &ecirc;tre sp&eacute;cifi&eacute; (et il ne pourra plus
      &ecirc;tre modifi&eacute; jusqu'&agrave; la destruction de
      l'analyseur). Les codages support&eacute;s sont :
      <literal>ISO-8859-1</literal>, <literal>US-ASCII</literal> et
      <literal>UTF-8</literal>. Les deux derniers sont des codages
      &agrave; un seul octet, c'est-&agrave;-dire que les caract&egrave;res
      sont repr&eacute;sent&eacute;s sur un seul octet. <literal>UTF-8</literal>
      peut repr&eacute;senter des caract&egrave;res compos&eacute;s par un
      nombre variable de bits (jusqu'&agrave; 21), allant de 1 &agrave;
      quatre octets. Le codage par d&eacute;faut utilis&eacute; par PHP
      <literal>ISO-8859-1</literal>.
     </para>
     <para>
      Le codage &agrave; la cible est effectu&eacute; lorsque PHP transfert
      les donn&eacute;es aux gestionnaires XML. Lorsqu'un analyseur est
      cr&eacute;&eacute;, le codage &agrave; la cible est sp&eacute;cifi&eacute;
      de la m&ecirc;me fa&ccedil;on que le codage &agrave; la source, mais
      il peut &ecirc;tre modifi&eacute; &agrave; tout moment. Le codage
      &agrave; la cible affectera les balises, tout comme les
      donn&eacute;es brutes, et les noms des instructions ex&eacute;cutables.
     </para>
     <para>
      Si l'analyseur XML rencontre un caract&egrave;re qu'il ne
      conna&icirc;t pas (hors limite, par exemple), il retournera une erreur.
     </para>
     <para>
      Si PHP rencontre un caract&egrave;re dans le document XML analys&eacute;,
      qu'il ne peut pas repr&eacute;senter dans le codage &agrave; la cible
      choisi, le caract&egrave;re sera remplac&eacute; par un point
      d'interrogation (cette attitude est susceptible de changer
      ult&eacute;rieurement).
     </para>
    </section>
   <section id="xml.examples">
    &reftitle.examples;
    <para>
     Voici une liste d'exemple de code PHP qui analyse un document XML.
    </para>
    <section id="example.xml-structure">
     <title>Exemple de structure XML</title>
     <para>
      Ce premier exemple affiche la structure de l'&eacute;l&eacute;ment
      de d&eacute;but dans un document avec indentation.
      <example>
       <title>Afficher une structure XML</title>
       <programlisting role="php">
<![CDATA[
<?php
$file = "donnees.xml";
$depth = array();

function debutElement($parser, $name, $attrs) {
    global $depth;
    for ($i = 0; $i < $depth[$parser]; $i++) {
        print "  ";
    }
    print "$name\n";
    $depth[$parser]++;
}

function finElement($parser, $name) {
    global $depth;
    $depth[$parser]--;
}

$xml_parser = xml_parser_create();
xml_set_element_handler($xml_parser, "debutElement", "finElement");
if (!($fp = fopen($file, "r"))) {
    die("Impossible d'ouvrir le fichier XML");
}

while ($data = fread($fp, 4096)) {
    if (!xml_parse($xml_parser, $data, feof($fp))) {
        die(sprintf("erreur XML : %s &agrave; la ligne %d",
                    xml_error_string(xml_get_error_code($xml_parser)),
                    xml_get_current_line_number($xml_parser)));
    }
}
xml_parser_free($xml_parser);
?>
]]>
       </programlisting>
      </example>
     </para>
    </section>
    <section id="example.xml-map-tags">
     <title>Transtypage XML -> HTML</title>
     <para>
      <example>
       <title>Transtypage XML -> HTML</title>
       <para>
        Cet exemple remplace les balises XML d'un document par des balises
        HTML. Les &eacute;l&eacute;ments inconnus seront ignor&eacute;s.
        Bien entendu, cet exemple sera appliqu&eacute; &agrave; un type
        pr&eacute;cis de fichiers XML.
	<programlisting role="php">
<![CDATA[
<?php
$file = "data.xml";
$map_array = array(
    "BOLD"     => "B",
    "EMPHASIS" => "I",
    "LITERAL"  => "TT"
);

function startElement($parser, $name, $attrs) {
    global $map_array;
    if ($htmltag = $map_array[$name]) {
        print "<$htmltag>";
    }
}

function endElement($parser, $name) {
    global $map_array;
    if ($htmltag = $map_array[$name]) {
        print "</$htmltag>";
    }
}

function characterData($parser, $data) {
    print $data;
}

$xml_parser = xml_parser_create();
// Utilison la gestion de casse, de mani&egrave;re &agrave; &ecirc;tre sur de trouver la balise dans $map_array
xml_parser_set_option($xml_parser, XML_OPTION_CASE_FOLDING, true);
xml_set_element_handler($xml_parser, "startElement", "endElement");
xml_set_character_data_handler($xml_parser, "characterData");
if (!($fp = fopen($file, "r"))) {
    die("Impossible de trouver le fichier XML");
}

while ($data = fread($fp, 4096)) {
    if (!xml_parse($xml_parser, $data, feof($fp))) {
        die(sprintf("erreur XML : %s &agrave; la ligne %d",
                    xml_error_string(xml_get_error_code($xml_parser)),
                    xml_get_current_line_number($xml_parser)));
    }
}
xml_parser_free($xml_parser);
?>
]]>
	</programlisting>
       </para>
      </example>
     </para>
    </section>
    <section id="example.xml-external-entity">
     <title>Entit&eacute; externe</title>
     <para>
      Cet exemple exploite les r&eacute;f&eacute;rences externes de XML :
      il est possible d'utiliser un gestionnaire d'entit&eacute; externe
      pour inclure et analyser les documents, tous comme les instructions
      ex&eacute;cutables peuvent servir &agrave; inclure et analyser
      d'autres documents, et aussi fournir une indication de confiance
      (voir plus bas).
     </para>
     <para>
      Le document XML qui est utilis&eacute; dans cet exemple est fourni plus
      loin dans l'exemple (<filename>xmltest.xml</filename> et
      <filename>xmltest2.xml</filename>).
     </para>
     <para>
      <example>
       <title>Entit&eacute; externe</title>
       <programlisting role="php">
<![CDATA[
<?php
$file = "xmltest.xml";

function trustedFile($file) {
    // only trust local files owned by ourselves
    if (!eregi("^([a-z]+)://", $file) 
        && fileowner($file) == getmyuid()) {
            return true;
    }
    return false;
}

function startElement($parser, $name, $attribs) {
    print "<<font color=\"#0000cc\">$name</font>";
    if (sizeof($attribs)) {
        while (list($k, $v) = each($attribs)) {
            print " <font color=\"#009900\">$k</font>=\"<font 
                   color=\"#990000\">$v</font>\"";
        }
    }
    print ">";
}

function endElement($parser, $name) {
    print "</<font color=\"#0000cc\">$name</font>>";
}

function characterData($parser, $data) {
    print "<b>$data</b>";
}

function PIHandler($parser, $target, $data) {
    switch (strtolower($target)) {
        case "php":
            global $parser_file;
            // If the parsed document is "trusted", we say it is safe
            // to execute PHP code inside it.  If not, display the code
            // instead.
            if (trustedFile($parser_file[$parser])) {
                eval($data);
            } else {
                printf("Untrusted PHP code: <i>%s</i>", 
                        htmlspecialchars($data));
            }
            break;
    }
}

function defaultHandler($parser, $data) {
    if (substr($data, 0, 1) == "&" && substr($data, -1, 1) == ";") {
        printf('<font color="#aa00aa">%s</font>', 
                htmlspecialchars($data));
    } else {
        printf('<font size="-1">%s</font>', 
                htmlspecialchars($data));
    }
}

function externalEntityRefHandler($parser, $openEntityNames, $base, $systemId,
                                  $publicId) {
    if ($systemId) {
        if (!list($parser, $fp) = new_xml_parser($systemId)) {
            printf("Could not open entity %s at %s\n", $openEntityNames,
                   $systemId);
            return false;
        }
        while ($data = fread($fp, 4096)) {
            if (!xml_parse($parser, $data, feof($fp))) {
                printf("erreur XML : %s &agrave; la ligne %d lors de l'analyse de l'entit&eacute; %s\n",
                       xml_error_string(xml_get_error_code($parser)),
                       xml_get_current_line_number($parser), $openEntityNames);
                xml_parser_free($parser);
                return false;
            }
        }
        xml_parser_free($parser);
        return true;
    }
    return false;
}

function new_xml_parser($file) {
    global $parser_file;

    $xml_parser = xml_parser_create();
    xml_parser_set_option($xml_parser, XML_OPTION_CASE_FOLDING, 1);
    xml_set_element_handler($xml_parser, "startElement", "endElement");
    xml_set_character_data_handler($xml_parser, "characterData");
    xml_set_processing_instruction_handler($xml_parser, "PIHandler");
    xml_set_default_handler($xml_parser, "defaultHandler");
    xml_set_external_entity_ref_handler($xml_parser, "externalEntityRefHandler");
    
    if (!($fp = @fopen($file, "r"))) {
        return false;
    }
    if (!is_array($parser_file)) {
        settype($parser_file, "array");
    }
    $parser_file[$xml_parser] = $file;
    return array($xml_parser, $fp);
}

if (!(list($xml_parser, $fp) = new_xml_parser($file))) {
    die("Impossible d'ouvrir le fichier XML");
}

print "<pre>";
while ($data = fread($fp, 4096)) {
    if (!xml_parse($xml_parser, $data, feof($fp))) {
        die(sprintf("Erreur XML : %s &agrave; la ligne %d\n",
                    xml_error_string(xml_get_error_code($xml_parser)),
                    xml_get_current_line_number($xml_parser)));
    }
}
print "</pre>";
print "parse complete\n";
xml_parser_free($xml_parser);

?>
]]>
       </programlisting>
      </example>
     </para>
     <para>
      <example>
       <title>xmltest.xml</title>
       <programlisting role="xml">
<![CDATA[
<?xml version='1.0'?>
<!DOCTYPE chapter SYSTEM "/just/a/test.dtd" [
<!ENTITY plainEntity "FOO entity">
<!ENTITY systemEntity SYSTEM "xmltest2.xml">
]>
<chapter>
 <TITLE>Title &plainEntity;</TITLE>
 <para>
  <informaltable>
   <tgroup cols="3">
    <tbody>
     <row><entry>a1</entry><entry morerows="1">b1</entry><entry>c1</entry></row>
     <row><entry>a2</entry><entry>c2</entry></row>
     <row><entry>a3</entry><entry>b3</entry><entry>c3</entry></row>
    </tbody>
   </tgroup>
  </informaltable>
 </para>
 &systemEntity;
 <section id="about">
  <title>About this Document</title>
  <para>
   <!-- Ceci est un commentaire -->
   <?php print 'Salut! Ceci est PHP version '.phpversion(); ?>
  </para>
 </section>
</chapter>
]]>
       </programlisting>
      </example>
     </para>
     <para>
      Ce fichier est inclus depuis <filename>xmltest.xml</filename>:
      <example>
       <title>xmltest2.xml</title>
       <programlisting role="xml">
<![CDATA[
<?xml version="1.0"?>
<!DOCTYPE foo [
<!ENTITY testEnt "test entity">
]>
<foo>
   <element attrib="value"/>
   &testEnt;
   <?php print "Ceci est du code PHP qui est ex&eacute;cut&eacute;."; ?>
</foo>
]]>
       </programlisting>
      </example>
     </para>
    </section>
   </section>
  </partintro>

&reference.xml.functions;

 </reference>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->

