<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.3 $ -->
<!-- EN-Revision: 1.2 Maintainer: yannick Status: ready -->
<!-- Reviewed: yes -->

<chapter xml:id="hw.apache" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Intégration avec Apache</title>
 <para>
  L'extension Hyperwave est utilisée de manière optimale lorsque
  PHP est compilé comme module Apache. Dans ce cas, le serveur Hyperwave
  sous-jacent peut être caché quasiment totalement aux utilisateurs,
  si Apache utilise son moteur d'écriture. Les explications suivantes vous
  éclaireront :
 </para>
 <para>
  Étant donné que PHP avec l'extension Hyperwave et Apache tend à
  remplacer la solution native basée sur Wavemaster, je vais supposer que
  le serveur Apache servira seulement d'interface Hyperwave. Ce n'est pas
  nécessaire, mais cela simplifie grandement la configuration. Le
  concept est très simple. Premièrement, vous avez besoin d'un
  script PHP qui évalue la variable <envar>$_ENV['PATH_INFO']</envar> et
  considère que cette valeur est un objet Hyperwave. Appelons ce script
  <literal>"Hyperwave"</literal>. L'URL
  <systemitem role="url">http://votre.hote/Hyperwave/nom_objet</systemitem>
  retourne l'objet Hyperwave dont le nom est <literal>"nom_objet"</literal>. Le script doit
  alors réagir suivant le type de l'objet. Si c'est un groupe, il devra
  probablement retourner une liste de fils. Si c'est un document, il pourra
  retourner son type MIME et son contenu. Une amélioration peut
  être obtenue en utilisant le moteur de réécriture d'Apache.
  D'un point de vue utilisateur, il est plus direct si l'URL
  <systemitem role="url">http://votre.hote/nom_objet</systemitem>
  retourne l'objet. La règle de réécriture est simple :
  <example>
   <title>Configuration d'Apache pour HyperWave</title>
   <programlisting role="apache-conf">
<![CDATA[
RewriteRule ^/(.*) /usr/local/apache/htdocs/HyperWave/$1 [L]
]]>
   </programlisting>
  </example>
  Maintenant, toutes les URL pointent sur un objet Hyperwave. Cela conduit à
  un problème simple. Il n'y a pas d'autre façon d'exécuter,
  c'est-à-dire rechercher, un autre script que ce script <literal>"Hyperwave"</literal>.
  Cela pourra être corrigé avec une autre règle telle que :
  <example>
   <title>Configuration d'Apache pour HyperWave (2)</title>
   <programlisting role="apache-conf">
<![CDATA[
RewriteRule ^/hw/(.*) /usr/local/apache/htdocs/hw/$1 [L]
]]>
   </programlisting>
  </example>
  Le dossier <filename class="directory">/usr/local/apache/htdocs/hw</filename>
  sera ainsi réservé pour d'autres scripts et fichiers. Assurez-vous que
  cette règle est évaluée avant la première
  règle que nous avons défini. Il y a juste un léger
  inconvénient : tous les objets Hyperwave qui commencent par <literal>"hw/"</literal> seront
  cachés. Alors, assurez-vous que vous n'utilisez pas de tels noms. Si vous
  avez besoin d'autres dossiers, par exemple, un dossier d'images, ajoutez
  simplement d'autres règles. N'oubliez pas de lancer le moteur de
  réécriture avec.
  <example>
   <title>Démarrer les règles de réécriture d'Apache pour HyperWave</title>
   <programlisting role="apache-conf">
<![CDATA[
RewriteEngine on
]]>
   </programlisting>
  </example>
  Mon expérience m'a montré que vous aurez besoin
  des scripts suivants :
  <itemizedlist>
   <listitem>
    <simpara>
     Retourne l'objet lui-même
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     Pour autoriser la recherche
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     S'identifier
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     Choisir une configuration
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     Un script pour chaque fonction supplémentaire, comme afficher
     un objet, afficher des informations sur les utilisateurs, afficher
     le statut du serveur, etc.
    </simpara>
   </listitem>
  </itemizedlist>
 </para>
 <para>
  Une alternative pour le moteur de réécriture est l'utilisation de
  la directive Apache <literal>ErrorDocument</literal>, mais sachez alors
  que <literal>ErrorDocument</literal> n'effectue pas les redirections de
  méthodes POST.
 </para>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->

