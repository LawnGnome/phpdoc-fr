<?xml version='1.0' encoding='iso-8859-1'?>
<!-- $Revision: 1.3 $ -->
<!-- EN-Revision: 1.4 Maintainer: jsgoupil Status: ready -->
<!-- Reviewed: no -->

<refentry id="function.PDO-sqliteCreateFunction">
 <refnamediv>
  <refname>PDO::sqliteCreateFunction</refname>
  <refpurpose>
   Référence une fonction définie par l'utilisateur pour une utilisation dans les requêtes SQL
  </refpurpose>
 </refnamediv>

 <refsect1 role="description">
  &reftitle.description;
  <methodsynopsis>
   <type>bool</type><methodname>PDO::sqliteCreateFunction</methodname>
   <methodparam><type>string</type><parameter>function_name</parameter></methodparam>
   <methodparam><type>callback</type><parameter>callback</parameter></methodparam>
   <methodparam choice="opt"><type>int</type><parameter>num_args</parameter></methodparam>
  </methodsynopsis>
  &warn.experimental.func;

  <para>
   <function>PDO::sqliteCreateFunction</function> vous permet de référencer
   une fonction &php; avec SQLite comme étant un <acronym>UDF</acronym> (User
   Defined Function), alors elle peut être appelée à l'intérieure de vos
   requêtes SQL.
  </para>
  <para>
   Un UDF peut être utilisé dans n'importe quelle requête SQL qui peut appeler
   des fonctions, par exemple les requêtes SELECT et UPDATE mais aussi dans les
   marqueurs.
  </para>
 </refsect1>

 <refsect1 role="parameters">
  &reftitle.parameters;
  <para>
   <variablelist>
    <varlistentry>
     <term><parameter>function_name</parameter></term>
     <listitem>
      <para>
       Le nom de la fonction utilisé dans les requêtes SQL.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>callback</parameter></term>
     <listitem>
      <para>
       Fonction de rappel pour manipuler la fonction SQL définie.
      </para>
      <note>
       <simpara>
        Les fonctions de rappel devraient retourner un type connu par SQLite
        (c'est-à-dire <link linkend="language.types.intro">type scalaire</link>).
       </simpara>
      </note>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>num_args</parameter></term>
     <listitem>
      <para>
       Conseil à l'analyseur SQLite si la fonction de rappel accepte un nombre
       prédéterminé d'arguments.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
  &sqlite.param-compat;
 </refsect1>

 <refsect1 role="examples">
  &reftitle.examples;
  <para>
   <example>
    <title>Exemple avec <function>PDO::sqliteCreateFunction</function></title>
    <programlisting role="php">
<![CDATA[
<?php
function md5_et_renverse($string) 
{
    return strrev(md5($string));
}

$db = new PDO('sqlite:sqlitedb');
$db->sqliteCreateFunction('md5rev', 'md5_et_renverse', 1);
$rows = $db->query('SELECT md5rev(filename) FROM files')->fetchAll();
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Dans cet exemple, nous avons une fonction qui calcule la somme md5 de la
   chaîne de caractères et la renverse ensuite. Lorsque la requête SQL
   s'exécute, elle retourne la valeur du nom du fichier transformée par notre
   fonction. Les données retournées dans <parameter>$rows</parameter>
   contiennent le résultat traité.
  </para>
  <para>
   La beauté de cette technique est que vous n'avez pas à traiter le résultat
   en utilisant une boucle foreach() après que vous ayez récupéré les données.
  </para>
  <tip>
   <para>
    Vous pouvez utiliser <function>PDO::sqliteCreateFunction</function> 
    <function>PDO::sqliteCreateAggregate</function> pour surcharger les
    fonctions natives de SQL.
   </para>
  </tip>
  <note>
   <para>
    Cette méthode n'est pas disponible avec les pilotes de SQLite2.
    Utilisez l'ancien style de l'API sqlite à la place.
   </para>
  </note>
 </refsect1>

 <refsect1 role="seealso">
  &reftitle.seealso;
  <para>
   <simplelist>
    <member><function>PDO::sqliteCreateAggregate</function></member>
    <member><function>sqlite_create_function</function></member>
    <member><function>sqlite_create_aggregate</function></member>
   </simplelist>
  </para>
 </refsect1>

</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
