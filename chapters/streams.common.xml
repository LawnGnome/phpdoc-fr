<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.12 $ -->
<!-- Author: Wez Furlong <wez@thebrainroom.com>
  Please contact me before making any major amendments to the
  content of this section.  Splitting/Merging are fine if they are
  required for php-doc restructuring purposes - just drop me a line
  if you make a change (so I can update my local copy).
-->
 <sect1 id="stream.common-api">
    <title>R&eacute;f&eacute;rence des API communes de flux</title>
  
  <refentry id="streams.php-stream-stat-path">
   <refnamediv>
    <refname>php_stream_stat_path</refname>
    <refpurpose>Lit l'&eacute;tat du fichier ou de l'URL</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>int</type><methodname>php_stream_stat_path</methodname>
      <methodparam><type>char *</type><parameter>path</parameter></methodparam>
      <methodparam><type>php_stream_statbuf *</type><parameter>ssb</parameter></methodparam>
     </methodsynopsis>
     <para>
      <function>php_stream_stat_path</function> examine le fichier ou l'URL 
      sp&eacute;cifi&eacute; par <parameter>path</parameter> et retourne des informations telles
      que la taille, les droits d'acc&egrave;s, la date de cr&eacute;ation, etc...
      La valeur retourn&eacute;e est 0 en cas de succ&egrave;s, et -1 en cas d'&eacute;chec.
      Pour plus d'informations, voyez 
      <link linkend="streams.struct-php-stream-statbuf">php_stream_statbuf</link>.
     </para>
    </refsect1>
  </refentry>
  
  <refentry id="streams.php-stream-stat">
   <refnamediv>
    <refname>php_stream_stat</refname>
    <refpurpose>Lit le statut du cache associ&eacute; au flux</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>int</type><methodname>php_stream_stat</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
      <methodparam><type>php_stream_statbuf *</type><parameter>ssb</parameter></methodparam>
     </methodsynopsis>
     <para>
      <function>php_stream_stat</function> examine le syst&egrave;me de stocker du flux 
      <parameter>stream</parameter>, et retourne des informations telles que 
      la taille de fichier, les droits d'acc&egrave;s, la date de cr&eacute;ation, etc...
      La valeur retourn&eacute;e est 0 en cas de succ&egrave;s, et -1 en cas d'&eacute;chec.
      Pour plus d'informations sur les informations retourn&eacute;es, voyez 
      <link linkend="streams.struct-php-stream-statbuf">php_stream_statbuf</link>.
     </para>
    </refsect1>
  </refentry>
  
  
  <refentry id="streams.php-stream-open-wrapper">
   <refnamediv>
    <refname>php_stream_open_wrapper</refname>
    <refpurpose>Ouvre un flux sur un fichier ou une URL</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>php_stream *</type><methodname>php_stream_open_wrapper</methodname>
      <methodparam><type>char *</type><parameter>path</parameter></methodparam>
      <methodparam><type>char *</type><parameter>mode</parameter></methodparam>
      <methodparam><type>int</type><parameter>options</parameter></methodparam>
      <methodparam><type>char **</type><parameter>opened</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_open_wrapper</function> ouvre un fichier, une URL ou 
     n'importe quelle ressource g&eacute;r&eacute;, sp&eacute;cifi&eacute;e par 
     <parameter>path</parameter>.  
     Suivant la valeur de <parameter>mode</parameter>, le flux peut &ecirc;tre ouvert
     en lecture, &eacute;criture, ajout ou une combinaison des trois. Voyez la table
     ci-dessous pour conna&icirc;tres les modes utilis&eacute;es. De plus vous pouvez
     aussi int&eacute;grer le caract&egrave;re 'b' comme deuxi&egrave;me ou derni&egrave;re option. 
     Sa pr&eacute;sence indiquera que le flux fonctionnera en mode binaire.
    </para>
    <para>
     L'option 'b' est ignor&eacute;e sur les syst&egrave;mes POSIX, qui traitent les
     fichiers textes et binaires de la m&ecirc;me fa&ccedil;on. C'est une bonne id&eacute;e
     que de sp&eacute;cifier 'b' &agrave; chaque fois que votre flux acc&egrave;de &agrave; des
     donn&eacute;es binaires, pour que votre code fonctionne lorsqu'il est 
     compil&eacute; sur un syst&egrave;me o&ugrave; 'b' serait important.
    </para>
    <para>
     Tous les fichiers locaux cr&eacute;&eacute;s par l'API des flux recevront les
     droits par d&eacute;faut du syst&egrave;me : sous Unix, cela signifie que le masque
     utilisateur du processus sera utilis&eacute;. Sous Windows, le fichier sera
     donn&eacute; au propri&eacute;taire du processus. Tous les fichiers distants seront
     cr&eacute;&eacute; suivant le protocole utilis&eacute;, et les droits utilis&eacute;s seront
     ceux du serveur distant.
    </para>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <constant>r</constant> 
       </term>
       <listitem>
        <simpara>
         Ouvre le fichier texte en mode lecture. Le pointeur du flux est
         plac&eacute; au d&eacute;but du fichier.
        </simpara>
       </listitem>
      </varlistentry>
      
      <varlistentry>
       <term>
        <constant>r+</constant> 
       </term>
       <listitem>
        <simpara>
         Ouvre le fichier texte en lecture et &eacute;criture. Le pointeur du flux est
         plac&eacute; au d&eacute;but du fichier.
        </simpara>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
        <constant>w</constant> 
       </term>
       <listitem>
        <simpara>
         Tronque le fichier &agrave; une taille de 0 ou bien cr&eacute;e le fichier,
         puis l'ouvre en mode &eacute;criture. Le pointeur du flux est
         plac&eacute; au d&eacute;but du fichier.
        </simpara>
       </listitem>
      </varlistentry>
      
      <varlistentry>
       <term>
        <constant>w+</constant> 
       </term>
       <listitem>
        <simpara>
         Tronque le fichier &agrave; une taille de 0 ou bien cr&eacute;e le fichier,
         puis l'ouvre en mode &eacute;criture et lecture. Le pointeur du flux est
         plac&eacute; au d&eacute;but du fichier. 
        </simpara>
       </listitem>
      </varlistentry>
      
      <varlistentry>
       <term>
        <constant>a</constant> 
       </term>
       <listitem>
        <simpara>
         Ouvre le fichier en mode d'&eacute;criture. Le fichier est cr&eacute;&eacute; si il n'existe
         pas. Le pointeur de flux est positionn&eacute; &agrave; la fin du fichier.
        </simpara>
       </listitem>
      </varlistentry>
      
      <varlistentry>
       <term>
        <constant>a+</constant> 
       </term>
       <listitem>
        <simpara>
         Ouvre le fichier en mode d'&eacute;criture et lecture. Le fichier est cr&eacute;&eacute; 
         si il n'existe pas. Le pointeur de flux est positionn&eacute; &agrave; la fin du 
         fichier.
         </simpara>
       </listitem>
      </varlistentry>
      
     </variablelist>    
    </para>    
    <para>
     <parameter>options</parameter> affecte l'interpr&eacute;tation du path ou de l'URL, les
     v&eacute;rifications du safe_mode et les actions &agrave; prendre lorsqu'il y a une erreur. Voyez
     <link linkend="streams.options">Stream open options</link> pour plus de d&eacute;tails sur
     ces options.
    </para>
    <para>
     Si <parameter>opened</parameter> est non NULL, il sera assign&eacute; avec le nom
     du fichier ou de la ressource qui aura &eacute;t&eacute; r&eacute;ellement ouverte. 
     C'est important lorsque l'option inclus <constant>USE_PATH</constant>, qui permet de fouiller 
     l'include_path pour rechercher le fichier. Vous, l'appelant, &ecirc;tes responsable de 
     l'appel de <function>efree</function> sur le nom de fichier retourn&eacute; par ce 
     param&egrave;tre.
    </para>
    <note>
     <simpara>
      Si vous avez sp&eacute;cifi&eacute; l'option <constant>STREAM_MUST_SEEK</constant> dans 
      <parameter>options</parameter>, le chemin retourn&eacute; dans <parameter>opened</parameter> 
      peut ne pas &ecirc;tre le m&ecirc;me que celui qui vous a &eacute;t&eacute; 
      r&eacute;ellemetn retourn&eacute;. Toutefois, ce sera le nom de la ressource originale 
      &agrave; partir de laquelle un flux &agrave; pointeur variable a &eacute;t&eacute; 
      cr&eacute;&eacute;.
     </simpara>
    </note>
   </refsect1>
  </refentry>
  
  
  <refentry id="streams.php-stream-read">
   <refnamediv>
    <refname>php_stream_read</refname>
    <refpurpose>Lit des octets depuis un flux dans un buffer</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>size_t</type><methodname>php_stream_read</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
      <methodparam><type>char *</type><parameter>buf</parameter></methodparam>
      <methodparam><type>size_t</type><parameter>count</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_read</function> lit jusqu'&agrave; <parameter>count</parameter>
     octets dans le flux <parameter>stream</parameter> puis les copie dans le buffer
     <parameter>buf</parameter>.
    </para>
    <para>
     <function>php_stream_read</function> retourne le nombre d'octets lus. Il n'y a 
     pas de disctinction entre une lecture qui &eacute;choue et la fin du fichier : utilisez
     <function>php_stream_eof</function> pour tester la fin du fichier avec <constant>EOF</constant>.
    </para>
    <para>
     Le pointeur de position dans le flux est avanc&eacute; d'autant d'octets que le nombre
     qui en a &eacute;t&eacute; lu. Par cons&eacute;quent, la prochaine lecture reprendra l&agrave; 
     ou la lecture pr&eacute;c&eacute;dente s'est arr&ecirc;t&eacute;e.
    </para>
    <para>
     Si moins de <parameter>count</parameter> octets ont &eacute;t&eacute; lus, cet appel bloquera
     l'application jusqu'&agrave; ce que le nombre d'octets n&eacute;cessaire soit atteint, en fonction
     de la configuration du flux (bloquant, non bloquant). Par d&eacute;faut, un flux est 
     ouvert en mode bloquant. Lorsque vous lisez dans des fichiers classiques, le mode bloquant
     ne vous g&egrave;nera pas. Lors que le flux atteint <constant>EOF</constant>
     <function>php_stream_read</function> retournera un nombre d'octets lus inf&eacute;rieur
     &agrave; <parameter>count</parameter>, puis il retournera 0 aux prochaines lectures.
    </para>
   </refsect1>
  </refentry>

  <refentry id="streams.php-stream-write">
   <refnamediv>
    <refname>php_stream_write</refname>
    <refpurpose>&eacute;crit des octets depuis un buffer vers un flux</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>size_t</type><methodname>php_stream_write</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
      <methodparam><type>const char *</type><parameter>buf</parameter></methodparam>
      <methodparam><type>size_t</type><parameter>count</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_write</function> &eacute;crit <parameter>count</parameter>
     octets du buffer <parameter>buf</parameter> dans le flux <parameter>stream</parameter>.
    </para>
    <para>
     <function>php_stream_write</function> retourne le nombre d'octets qui ont
     &eacute;t&eacute; &eacute;crit. Si il y a eu une erreur, le nombre d'octets &eacute;crit sera 
     inf&eacute;rieur au param&egrave;tre <parameter>count</parameter>.
    </para>
    <para>
     Le pointeur de position dans le flux est avanc&eacute; d'autant d'octets que le nombre
     qui en a &eacute;t&eacute; &eacute;crit. Par cons&eacute;quent, la prochaine &eacute;criture 
     reprendra l&agrave; ou la lecture pr&eacute;c&eacute;dente s'est arr&eacute;t&eacute;.
    </para>
   </refsect1>
  </refentry>

  <refentry id="streams.php-stream-eof">
   <refnamediv>
    <refname>php_stream_eof</refname>
    <refpurpose>V&eacute;rifie que le pointeur n'est pas au bout du flux</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>int</type><methodname>php_stream_eof</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_eof</function> v&eacute;rifie que le pointeur n'est pas au bout du 
     flux <parameter>stream</parameter>.
    </para>
    <para>
     <function>php_stream_read</function> retourne 1 pour indiquer la fin du flux 
     (<constant>EOF</constant>), 0 si il n'y a pas de fin de flux, et -1 pour indiquer une 
     erreur.
    </para>
   </refsect1>
  </refentry>

  <refentry id="streams.php-stream-getc">
   <refnamediv>
    <refname>php_stream_getc</refname>
    <refpurpose>Lit un octet dans un flux</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>int</type><methodname>php_stream_getc</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_getc</function> lit un octet dans le flux
     <parameter>stream</parameter> puis le retourne de type unsigned char transtyp&eacute; en
     int, ou <constant>EOF</constant> si la fin du flux est atteinte, ou bien
     si une erreur est survenue.
    </para>
    <para>
     <function>php_stream_getc</function> peut bloquer l'application de la m&ecirc;me fa&ccedil;on
     que <function>php_stream_read</function> bloque.
    </para>
    <para>
     Le pointeur de position est avanc&eacute; d'une position si la lecture r&eacute;ussit.
    </para>
   </refsect1>
  </refentry>

  <refentry id="streams.php-stream-gets">
   <refnamediv>
    <refname>php_stream_gets</refname>
    <refpurpose>Lit une ligne de donn&eacute;es d'un flux dans un buffer</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>char *</type><methodname>php_stream_gets</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
      <methodparam><type>char *</type><parameter>buf</parameter></methodparam>
      <methodparam><type>size_t</type><parameter>maxlen</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_gets</function> lit jusqu'&agrave; <parameter>count</parameter>-1
     octets de donn&eacute;es dans le flux <parameter>stream</parameter> puis les copies dans 
     le buffer <parameter>buf</parameter>. La lecture s'arr&ecirc;te apr&egrave;s la rencontre de 
     la fin du fichier (<constant>EOF</constant>) ou une nouvelle ligne. Si la nouvelle
     ligne est lue, elle est stock&eacute;e dans <parameter>buf</parameter> dans les 
     donn&eacute;es retourn&eacute;es. Un caract&egrave;re NUL de fin de cha&icirc;ne est 
     stock&eacute; comme dernier caract&egrave;re dans le buffer.
    </para>
    <para>
     <function>php_stream_read</function> retourne <parameter>buf</parameter>
     lorsque cela fonctionne, et NULL sinon.
    </para>
    <para>
     Le pointeur de position est avanc&eacute; d'une position si la lecture r&eacute;ussit.
    </para>
    <para>
     <function>php_stream_gets</function> peut bloquer l'application de la m&ecirc;me fa&ccedil;on
     que <function>php_stream_read</function> bloque.   
    </para>
   </refsect1>
  </refentry>

  <refentry id="streams.php-stream-close">
   <refnamediv>
    <refname>php_stream_close</refname>
    <refpurpose>Ferme un flux</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>int</type><methodname>php_stream_close</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_close</function> ferme correctement le flux 
     <parameter>stream</parameter> et lib&egrave;re les ressources qui lui sont associ&eacute;es. 
     Apr&agrave;s la fermeture de <parameter>stream</parameter>, il prend une valeur 
     ind&eacute;finie, et ne devrait plus &ecirc;tre utilis&eacute;.
    </para>
    <para>
     <function>php_stream_close</function> retourne 0 si le flux a &eacute;t&eacute; 
     ferm&eacute;, ou bien <constant>EOF</constant> pour indiquer une erreur. 
     Ind&eacute;pendamment du succ&egrave;s de l'op&eacute;ration, <parameter>stream</parameter> 
     prend une valeur ind&eacute;finie, et ne devrait plus &ecirc;tre utilis&eacute;.
    </para>
   </refsect1>
  </refentry>

  <refentry id="streams.php-stream-flush">
   <refnamediv>
    <refname>php_stream_flush</refname>
    <refpurpose>Vide les buffers dans le flux</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>int</type><methodname>php_stream_flush</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_flush</function> vide toutes les donn&eacute;es contenues dans
     les buffers d'&eacute;criture du flux <parameter>stream</parameter> et force leur stockage.
    </para>
    <para>
     <function>php_stream_flush</function> retourne 0 si les buffers ont &eacute;t&eacute; 
     vid&eacute;s, ou si les buffers n'ont pas besoin d'&ecirc;tre vid&eacute;, mais retourne 
     <constant>EOF</constant> pour indiquer une erreur.
    </para>
   </refsect1>
  </refentry>

  <refentry id="streams.php-stream-seek">
   <refnamediv>
    <refname>php_stream_seek</refname>
    <refpurpose>Modifie la position du pointeur de flux</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>int</type><methodname>php_stream_seek</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
      <methodparam><type>off_t</type><parameter>offset</parameter></methodparam>
      <methodparam><type>int</type><parameter>whence</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_seek</function> modifie la position du pointeur de
     position du flux <parameter>stream</parameter>. La nouvelle position
     est d&eacute;termin&eacute;e en ajoutant <parameter>offset</parameter>
     &agrave; la position indiqu&eacute;e par <parameter>whence</parameter>.
     Si <parameter>whence</parameter> vaut <constant>SEEK_SET</constant>,
     <constant>SEEK_CUR</constant> ou <constant>SEEK_END</constant> l'offset sera 
     relativ au d&eacute;but du flux, &agrave; la position courante ou &agrave; la fin du 
     flux, respectivement.
    </para>
    <para>
     <function>php_stream_seek</function> retourne 0 en cas de succ&egrave;s, et -1 en cas d'erreur.
    </para>
    <note>
     <para>
     Tous les flux ne supportent pas la modification de la position du pointeur,
     m&ecirc;me si l'API va &eacute;muler un tel pointeur si <parameter>whence</parameter> vaut
     <constant>SEEK_CUR</constant> et <parameter>offset</parameter> est positif, en 
     appelant <function>php_stream_read</function> pour lire (et ignorer) 
     <parameter>offset</parameter> octets.
      </para>
      <para>
      L'&eacute;mulation est uniquement appliqu&eacute;e si l'impl&eacute;mentation du gestionnaire 
      de flux suporte le pointeur de position. Si le flux est (par exemple) 
      bas&eacute; sur des fichiers qui travaille avec des flux de pipes, l'API de flux 
      ne pourra pas appliquer une telle &eacute;mulation. Le positionnement du pointeur de 
      flux &eacute;chouera et une erreur sera retourn&eacute;e.
      </para>
    </note>
   </refsect1>
  </refentry>

  <refentry id="streams.php-stream-tell">
   <refnamediv>
    <refname>php_stream_tell</refname>
    <refpurpose>D&eacute;termine la position du pointeur dans un flux</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>off_t</type><methodname>php_stream_tell</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_tell</function> retourne la position du pointeur
     du flux <parameter>stream</parameter>, relativement au d&eacute;but du
     flux. 
     Si une erreur survient, retourne -1.
     </para>
   </refsect1>
  </refentry>

 <refentry id="streams.php-stream-copy-to-stream">
   <refnamediv>
    <refname>php_stream_copy_to_stream</refname>
    <refpurpose>Copie des donn&eacute;es d'un flux &agrave; l'autre</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>size_t</type><methodname>php_stream_copy_to_stream</methodname>
      <methodparam><type>php_stream *</type><parameter>src</parameter></methodparam>
      <methodparam><type>php_stream *</type><parameter>dest</parameter></methodparam>
      <methodparam><type>size_t</type><parameter>maxlen</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_copy_to_stream</function> essaie de lire un maximum de 
     <parameter>maxlen</parameter> octets dans le flux <parameter>src</parameter>
     puis de les &eacute;crire dans le flux <parameter>dest</parameter>. La fonction
     retourne le nombre d'octets copi&eacute;s.
    </para>
    <para>
     Si vous souhaitez copier tous les octets restants dans le flux
     <parameter>src</parameter>, passez la constante 
     <constant>PHP_STREAM_COPY_ALL</constant> comme valeur de <parameter>maxlen</parameter>.
    </para>
    <note>
     <simpara>
      Cette fonction va essayer d'effectuer la copie de la mani&egrave;re la plus efficace,
      en utilise dans buffer m&eacute;moire lorsque c'est possible.
     </simpara>
    </note>
   </refsect1>
  </refentry>

 <refentry id="streams.php-stream-copy-to-mem">
   <refnamediv>
    <refname>php_stream_copy_to_mem</refname>
    <refpurpose>Copie des donn&eacute;es depuis un flux dans un buffer</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>size_t</type><methodname>php_stream_copy_to_mem</methodname>
      <methodparam><type>php_stream *</type><parameter>src</parameter></methodparam>
      <methodparam><type>char **</type><parameter>buf</parameter></methodparam>
      <methodparam><type>size_t</type><parameter>maxlen</parameter></methodparam>
      <methodparam><type>int</type><parameter>persistent</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_copy_to_mem</function> alloue un buffer de taille 
     <parameter>maxlen</parameter>+1 en utilisant la fonction <function>pemalloc</function> (en 
     passant <parameter>persistent</parameter>). Puis, elle lit <parameter>maxlen</parameter> 
     octets depuis le flux  from <parameter>src</parameter> and stores them in the allocated 
     buffer.
    </para>
    <para>
     The allocated buffer is returned in <parameter>buf</parameter>, and the number of bytes 
     successfully read.  You, the caller, are responsible for freeing the buffer by passing it and 
     <parameter>persistent</parameter> to <function>pefree</function>.
    </para>
    <para>
     If you want to copy all remaining data from the <parameter>src</parameter> stream, pass the
     constant <constant>PHP_STREAM_COPY_ALL</constant> as the value of <parameter>maxlen</parameter>.
    </para>
    <note>
     <simpara>
      Cette fonction va essayer d'effectuer la copie de la mani&egrave;re la plus efficace,
      en utilise dans buffer m&eacute;moire lorsque c'est possible.
     </simpara>
    </note>
   </refsect1>
  </refentry>

 <refentry id="streams.php-stream-make-seekable">
   <refnamediv>
    <refname>php_stream_make_seekable</refname>
    <refpurpose>Convertit un flux en flux avec un pointeur de position</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>int</type><methodname>php_stream_make_seekable</methodname>
      <methodparam><type>php_stream *</type><parameter>origstream</parameter></methodparam>
      <methodparam><type>php_stream **</type><parameter>newstream</parameter></methodparam>
      <methodparam><type>int</type><parameter>flags</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_make_seekable</function> v&eacute;rifie si <parameter>origstream</parameter>
     dispose d'un pointeur de potision. Si ce n'est pas le cas, il va copier les donn&eacute;es
     du flux dans un autre flux temporaire, et disposant d'un pointeur de position.
     Si cela fonctionne, <parameter>newstream</parameter> sera un flux valide
     m&ecirc;me si le flux original avait d&eacute;j&agrave; un pointeur de position.
    </para>
    <para>
     <parameter>flags</parameter> vous permet de sp&eacute;cifier votre pr&eacute;f&eacute;rence
     pour le flux retourn&eacute; : utilisez la constante <constant>PHP_STREAM_NO_PREFERENCE</constant> 
     pour utiliser le flux &agrave; pointeur de position par d&eacute;faut (qui utilise la
     m&eacute;moire, mais passe automatiquement sur un fichier si le fichier devient trop grand),
     ou bien utilisez <constant>PHP_STREAM_PREFER_STDIO</constant> pour utiliser 
     un fichier temporaire classique.
    </para>
    <para>
     <table>
      <title>Valeurs retourn&eacute;es par <function>php_stream_make_seekable</function></title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>Valeur</entry>
         <entry>Signification</entry>
        </row>
       </thead>
       <tbody>

        <row>
         <entry>PHP_STREAM_UNCHANGED</entry>
         <entry>Le flux original avait d&eacute;j&agrave; son pointeur de position. 
         <parameter>newstream</parameter> vaut <parameter>origstream</parameter>.
         </entry>
        </row>

        <row>
         <entry>PHP_STREAM_RELEASED</entry>
         <entry>Le flux originl n'avait pas pointeur de position, et il a &eacute;t&eacute; 
         d&eacute;truit. Vous n'avez plus acc&egrave;s &agrave; <parameter>origstream</parameter>.
         </entry>
        </row>

        <row>
         <entry>PHP_STREAM_FAILED</entry>
         <entry>Une erreur est survenue lors de la conversion. 
         <parameter>newstream</parameter> vaut NULL;
          <parameter>origstream</parameter> est toujours valide.
         </entry>
        </row>

        <row>
         <entry>PHP_STREAM_CRITICAL</entry>
         <entry>Une erreur est survenue lors de la conversion de <parameter>origstream</parameter>,
         qui est maintenant dans un &eacute;tat ind&eacute;termin&eacute;. 
         <parameter>newstream</parameter> vaut NULL et il est tr&egrave;s recommand&eacute; que 
         vous vous fermiez <parameter>origstream</parameter>.
         </entry>
        </row>
         
       </tbody>
      </tgroup>
     </table>
    </para>
    <note>
     <simpara>
      Si vous devez d&eacute;placer le pointeur et &eacute;crire dans le flux, n'utilisez 
      pas cette fonction, car le flux retourn&eacute; est un flux mis en cache. Il 
      n'est pas garantit qu'il soit li&eacute; &agrave; la ressource originale.
     </simpara>
    </note>
    <note>
     <simpara>
      Si vous avez uniquement de d&eacute;placer le pointeur de position vers l'avant,
      il n'y a pas besoin d'appeler cette fonction, car l'API va automatiquement
      &eacute;muler ce fonctionnement avec le param&egrave;tre whence &agrave; la valeur 
      <constant>SEEK_CUR</constant>.
     </simpara>
    </note>
    <note>
     <simpara>
      Si <parameter>origstream</parameter> repose sur le r&eacute;seau, cette fonction
      va se bloquer jusqu'&agrave; ce que tout le contenu soit t&eacute;l&eacute;charg&eacute;.
      </simpara>
    </note>
    <note>
     <simpara>
      Ne JAMAIS appeler cette fonction avec un flux <parameter>origstream</parameter> qui
      est une r&eacute;f&eacute;rence &agrave; un pointeur de fichier dans un script PHP. Cette 
      fonction pourrait alors fermer le fichier, ce qui conduira &agrave; un crash au prochain 
      acc&egrave;s au pointeur.
     </simpara>
    </note>
    <note>
     <simpara>
     Dans de nombreux cas, cette fonction ne peut r&eacute;ussir que si 
     <parameter>origstream</parameter> vient d'&ecirc;tre tout juste ouvert, et qu'aucune 
     donn&eacute;es n'ont &eacute;t&eacute; mises dans les caches de la couche de flux. Pour 
     cette raison, et parceque cette fonction est compliqu&eacute;e &agrave; utiliser 
     correctement, il est recommand&eacute; que vous utilisiez la fonction 
     <function>php_stream_open_wrapper</function> en lui passant la constante 
     <constant>PHP_STREAM_MUST_SEEK</constant> dans vos options, au lieu d'appeler
     cette fonction directement.
     </simpara>
    </note>
    </refsect1>
  </refentry>


<refentry id="streams.php-stream-cast">
   <refnamediv>
    <refname>php_stream_cast</refname>
    <refpurpose>Convertit un flux en une autre forme, comme un FILE* ou une socket</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>int</type><methodname>php_stream_cast</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
      <methodparam><type>int</type><parameter>castas</parameter></methodparam>
      <methodparam><type>void **</type><parameter>ret</parameter></methodparam>
      <methodparam><type>int</type><parameter>flags</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_cast</function> tente de convertir le flux <parameter>stream</parameter>
     en un autre ressource indiqu&eacute; par <parameter>castas</parameter>.
     Si <parameter>ret</parameter> est NULL, le flux est interrog&eacute; pour savoir une telle
     conversoin est posible, sans effectuer r&eacute;ellemnt la conversion (mais
     certains &eacute;tat interne pourrait &ecirc;tre chang&eacute;s dans ce cas). Si 
     <parameter>flags</parameter> vaut <constant>REPORT_ERRORS</constant>, un message
     d'erreur appara&icirc;tra si une erreur survient durant la conversion.
    </para>
    <note>
        <para>
         Cette fonction retourne <constant>SUCCESS</constant> en cas de r&eacute;ussite et 
         <constant>FAILURE</constant> en cas d'&eacute;chec. Soyez pr&eacute;venu que vous devez
         faire une comparaison explicite avec <constant>SUCCESS</constant>
         ou <constant>FAILURE</constant> &agrave; cause des valeurs sous jacentes de ces
         constantes. Une simple comparaison d'expression bool&eacute;enne ne sera pas 
         interpr&eacute;t&eacute;e comme vous le souhaitez.
        </para>
    </note>
    <para>
     <table>
      <title>Types de ressources de <parameter>castas</parameter></title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>Valeur</entry>
         <entry>Signification</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>PHP_STREAM_AS_STDIO</entry>
         <entry>Un pointeur ANSI FILE* qui repr&eacute;sente le flux</entry>
        </row>
        <row>
         <entry>PHP_STREAM_AS_FD</entry>
         <entry>Un pointeur de fichier de type POSIX qui repr&eacute;sente le flux</entry>
        </row>
        <row>
         <entry>PHP_STREAM_AS_SOCKETD</entry>
         <entry>Un pointeur de socket r&eacute;seau  qui repr&eacute;sente le flux</entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </para>
    <para>
     En plus des types de ressources basiques ci-dessus, le processus de conversion
     peut &ecirc;tre modifi&eacute; en utilisant les param&egrave;tres ci-dessous, ou bien en utilisant
     l'op&eacute;rateur OR pour combiner le type de ressource avec une ou plusieurs des valeurs
     suivantes : 
     <table>
      <title>Types de ressources pour <parameter>castas</parameter></title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>Valeur</entry>
         <entry>Signification</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>PHP_STREAM_CAST_TRY_HARD</entry>
         <entry>Essaie aussi fort que possible, m&ecirc;me si c'est au prix de quelques
         ressources suppl&eacute;mentaires,  que la conversion r&eacute;ussisse</entry>
        </row>
        <row>
         <entry>PHP_STREAM_CAST_RELEASE</entry>
         <entry>Informque l'API de flux que d'autre code (possible une librairie tierce
         partie) sera responsable de la gestion des ressources de bas niveau. Cela fait que
         le flux <parameter>stream</parameter> sera ferm&eacute; de telle fa&ccedil;on &agrave; 
         ce que le gestionnaire soit pr&eacute;serv&eacute; et retourn&eacute; dans le 
         param&egrave;tre <parameter>ret</parameter>.
         Si la fonction r&eacute;ussit, le param&egrave;tre <parameter>stream</parameter>
         doit &ecirc;tre consid&eacute;r&eacute; comme ferm&eacute;, et inutilisable en l'&eacute;tat.
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </para>
    <note>
     <simpara>
      Si votre syst&egrave;me supporte la fonction <function>fopencookie</function> (les syst&egrave;mes
      utilisant la librairie glibc 2 ou plus r&eacute;cent), l'API de flux sera toujours
      capable de cr&eacute;er des pointeurs de fichiers de type ANSI FILE* pour tous les flux.
      M&ecirc;me si c'est extr&ecirc;mement utile pour passer des flux PHP &agrave; des 
      librairie tierce partie, un tel syst&egrave;me n'est pas portable. Il est demand&eacute; que 
      vous consid&eacute;riez la portabilit&eacute; e vos fonctions avant de diffuser votre 
      extension. Si l'utilisation de fopencookie() n'est pas d&eacute;sirable, il est 
      recommand&eacute; d'interroger le flux pour voir si il supporte naturellement la 
      conversion en FILE* en utilisant la fonction <function>php_stream_is</function>
     </simpara>
    </note>
    <note>
     <simpara>
      Si vous demandez une socket r&eacute;seau &agrave; la place d'un FILE*, l'API de flux
      va utiliser la fonction <function>fdopen</function> pour la cr&eacute;er pour vous.
      Soyez pr&eacute;venu que faire cela risque de perdre les donn&eacute;es qui ont 
      &eacute;t&eacute; mises en buffer dans le flux, si vous m&eacute;langer des appels de 
      l'API de flux et les appels standards ANSI.
     </simpara>
    </note>
    <para>
     Voir aussi 
     <function>php_stream_is</function> et 
     <function>php_stream_can_cast</function>.
    </para>
   </refsect1>
  </refentry>
 
<refentry id="streams.php-stream-can-cast">
   <refnamediv>
    <refname>php_stream_can_cast</refname>
    <refpurpose>D&eacute;termine si un flux peut &ecirc;tre converti en une autre forme, comme FILE* ou socket</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>int</type><methodname>php_stream_can_cast</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
      <methodparam><type>int</type><parameter>castas</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_can_cast</function> est l'&eacute;quivalent de la fonction 
     <function>php_stream_cast</function> avec le param&egrave;tre <parameter>ret</parameter>
     mis &agrave; NULL, et le param&egrave;tre <parameter>flags</parameter> mis &agrave; 0.
     Elle retourne <constant>SUCCESS</constant> si le flux peut &ecirc;tre converti dans
     la forme demand&eacute;e, ou bien <constant>FAILURE</constant> si la conversion ne peut
     se faire.
    </para>
    <note>
     <simpara>
      Bien que cette fonction n'effectue aucune conversion, il est possible que certains
      &eacute;tat interne du flux soient modifi&eacute;s.
     </simpara>
    </note>
    <note>
     <simpara>
      Vous devez explicitement comparer la valeur de retour avec une des constantes, comme
      d&eacute;crit dans <function>php_stream_cast</function>.
      </simpara>
    </note>
    <para>
     Voir aussi
     <function>php_stream_cast</function> et 
     <function>php_stream_is</function>.
    </para>
   </refsect1>
  </refentry>

<refentry id="streams.php-stream-is-persistent">
   <refnamediv>
    <refname>php_stream_is_persistent</refname>
    <refpurpose>D&eacute;termine si un flux est un flux persistant</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>int</type><methodname>php_stream_is_persistent</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_is_persistent</function> retourne  1 si le flux 
     <parameter>stream</parameter> est un flux persistant, et 0 sinon.
    </para>
 </refsect1>
</refentry>

<refentry id="streams.php-stream-is">
   <refnamediv>
    <refname>php_stream_is</refname>
    <refpurpose>D&eacute;termine si un flux est d'un type particulier</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>int</type><methodname>php_stream_is</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
      <methodparam><type>int</type><parameter>istype</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_is</function> retourne 1 si <parameter>stream</parameter> 
     est du type sp&eacute;cifi&eacute; par <parameter>istype</parameter>, et 0 sinon.
    <table>
      <title>Valeurs possibles pour <parameter>istype</parameter></title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>Valeur</entry>
         <entry>Signification</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>PHP_STREAM_IS_STDIO</entry>
         <entry>Le flux est impl&eacute;ment&eacute; en utilisant l'impl&eacute;mentation standard</entry>
        </row>
        <row>
         <entry>PHP_STREAM_IS_SOCKET</entry>
         <entry>Le flux est impl&eacute;ment&eacute; en utilisant l'impl&eacute;mentation des sockets r&eacute;seau</entry>
        </row>
        <row>
         <entry>PHP_STREAM_IS_USERSPACE</entry>
         <entry>Le flux est impl&eacute;ment&eacute; en utilisant l'impl&eacute;mentation de l'objet utilisateur</entry>
        </row>
        <row>
         <entry>PHP_STREAM_IS_MEMORY</entry>
         <entry>Le flux est impl&eacute;ment&eacute; en utilisant l'impl&eacute;mentation m&eacute;moire &agrave; taille automatique</entry>
        </row>
       </tbody>
      </tgroup>
     </table>

    </para>
    <note>
     <simpara>
      Les constantes PHP_STREAM_IS_XXX sont en fait d&eacute;finies comme des  pointeurs
      sur la structure des op&eacute;rations de base. Si vous extension (ou une autre extension
      d&eacute;finit des flux additionnels), il faut qu'elle d&eacute;clare aussi les constantes
      PHP_STREAM_IS_XXX dans ses en-t&ecirc;tes, pour que vous puissiez les utiliser comme
      base de comparaison.
      </simpara>
    </note>
    <note>
     <simpara>
      Cette fonction est impl&eacute;ment&eacute;e comme une comparaison de pointeurs simple
      (et rapide), et ne modifie pas l'&eacute;tat du flux.
     </simpara>
    </note>
    <para>
     Voir aussi 
     <function>php_stream_cast</function> et 
     <function>php_stream_can_cast</function>.
    </para>
   </refsect1>
  </refentry>
  
  <refentry id="streams.php-stream-passthru">
   <refnamediv>
    <refname>php_stream_passthru</refname>
    <refpurpose>Affiche toutes les donn&eacute;es restantes d'un flux</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>size_t</type><methodname>php_stream_passthru</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
     </methodsynopsis>
     <para>
      <function>php_stream_passthru</function> affiche tous les octets restant dans le
      flux <parameter>stream</parameter> vers le buffer de sortie. Les donn&eacute;es sont
      &eacute;crites directement dans le buffer de sortie, qui sera le navigateur dans le cas
      de PHP sur un serveur web, ou la sortie standard dans le cas de PHP en mode 
      de ligne de commande. Cette fonction essaie d'utiliser des fichiers en m&eacute;moire
      pour acc&eacute;l&eacute;rer l'ex&eacute;cution.
     </para>
    </refsect1>
  </refentry>

  <refentry id="streams.php-register-url-stream-wrapper">
   <refnamediv>
    <refname>php_register_url_stream_wrapper</refname>
    <refpurpose>Enregistre un gestionnaire pour l'API de flux</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>int</type><methodname>php_register_url_stream_wrapper</methodname>
      <methodparam><type>char *</type><parameter>protocol</parameter></methodparam>
      <methodparam><type>php_stream_wrapper *</type><parameter>wrapper</parameter></methodparam>
      <methodparam><type>TSRMLS_DC</type><parameter></parameter></methodparam>
     </methodsynopsis>
     <para>
      <function>php_register_url_stream_wrapper</function> enregistre le gestionnaire
      <parameter>wrapper</parameter> pour le protocole <parameter>protocol</parameter>.
     </para>
     <note>
      <simpara>
       Si vous appelez cette fonction dans un module dynamiquement charg&eacute;, vous DEVEZ
       appeler la fonction <function>php_unregister_url_stream_wrapper</function>
       dans la fonction de terminaison de votre module, sinon PHP 
       va crasher.
      </simpara>
     </note>
    </refsect1>
  </refentry>

  <refentry id="streams.php-unregister-url-stream-wrapper">
   <refnamediv>
    <refname>php_unregister_url_stream_wrapper</refname>
    <refpurpose>D&eacute;senregistre un gestionnaire pour l'API de flux</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>int</type><methodname>php_unregister_url_stream_wrapper</methodname>
      <methodparam><type>char *</type><parameter>protocol</parameter></methodparam>
      <methodparam><type>TSRMLS_DC</type><parameter></parameter></methodparam>
     </methodsynopsis>
     <para>
      <function>php_unregister_url_stream_wrapper</function> d&eacute;senregistre le gestionnaire
      associ&eacute; avec le protocole <parameter>protocol</parameter>.
     </para>
    </refsect1>
  </refentry>

  <refentry id="streams.php-stream-open-wrapper-ex">
   <refnamediv>
    <refname>php_stream_open_wrapper_ex</refname>
    <refpurpose>Ouvre un flux avec un fichier ou une URL, en sp&eacute;cifiant le contexte</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>php_stream *</type><methodname>php_stream_open_wrapper_ex</methodname>
      <methodparam><type>char *</type><parameter>path</parameter></methodparam>
      <methodparam><type>char *</type><parameter>mode</parameter></methodparam>
      <methodparam><type>int</type><parameter>options</parameter></methodparam>
      <methodparam><type>char **</type><parameter>opened</parameter></methodparam>
      <methodparam><type>php_stream_context *</type><parameter>context</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_open_wrapper_ex</function> est exactement comme 
     <function>php_stream_open_wrapper</function>, mais vous permet de sp&eacute;cifier un
     objet de type php_stream_context avec le param&egrave;tre <parameter>context</parameter>.
     Pour en savoir plus sur les contextes, voyez ... une section qui viendra plus
     tard.
    </para>
    </refsect1>
    </refentry>

  <refentry id="streams.php-stream-open-wrapper-as-file">
   <refnamediv>
    <refname>php_stream_open_wrapper_as_file</refname>
    <refpurpose>Ouvre un flux avec un fichier ou une URL, et le convertit en pointeur FILE*</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>FILE *</type><methodname>php_stream_open_wrapper_as_file</methodname>
      <methodparam><type>char *</type><parameter>path</parameter></methodparam>
      <methodparam><type>char *</type><parameter>mode</parameter></methodparam>
      <methodparam><type>int</type><parameter>options</parameter></methodparam>
      <methodparam><type>char **</type><parameter>opened</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_open_wrapper_as_file</function> est exactement identique
     &agrave; la fonction <function>php_stream_open_wrapper</function>, mais convertit le
     flux en un pointeur ANSI FILE* puis le retourne &agrave; la place du flux. C'est un
     raccourci commode pour les extensions qui passent des pointeurs FILE* aux 
     librairies tierce partie.
    </para>
    </refsect1>
    </refentry>

    <refentry id="streams.php-stream-filter-register-factory">
   <refnamediv>
    <refname>php_stream_filter_register_factory</refname>
    <refpurpose>Enregistre une usine &agrave; filtres avec l'API des flux</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <methodsynopsis>
     <type>int</type><methodname>php_stream_filter_register_factory</methodname>
     <methodparam><type>const char *</type><parameter>filterpattern</parameter></methodparam>
     <methodparam><type>php_stream_filter_factory *</type><parameter>factory</parameter></methodparam>
    </methodsynopsis>
    <para>
     Utilisez cette fonction pour enregistrer une usine &agrave; filtres, dont le nom
     est donn&eacute; par <parameter>filterpattern</parameter>. <parameter>filterpattern</parameter>
     peut &ecirc;tre un nom classique, sous forme de cha&icirc;ne, (i.e. <literal>myfilter</literal>) ou
     un mod&egrave;le g&eacute;n&eacute;ral (i.e. <literal>myfilterclass.*</literal>) pour permettre &agrave; un filtre
     d'effectuer diff&eacute;rentes op&eacute;rations en fonction du nom du filtre
     invoqu&eacute; (i.e. <literal>myfilterclass.foo</literal>, <literal>myfilterclass.bar</literal>,
     etc...)
    </para>
    <note>
     <simpara>
      Les filtres enregistr&eacute;s par une extension dynamiquement charg&eacute;e doivent
      s'assurer d'appeler php_stream_filter_unregister_factory() durant MSHUTDOWN.
     </simpara>
    </note>
   </refsect1>
  </refentry>
  <refentry id="streams.php-stream-filter-unregister-factory">
   <refnamediv>
    <refname>php_stream_filter_unregister_factory</refname>
    <refpurpose>Supprime une usine &agrave; filtres des API de flux</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <methodsynopsis>
     <type>int</type><methodname>php_stream_filter_unregister_factory</methodname>
     <methodparam><type>const char *</type><parameter>filterpattern</parameter></methodparam>
    </methodsynopsis>
    <para>
     Supprime l'usine &agrave; filtres <parameter>filterfactory</parameter> sp&eacute;cifi&eacute; par le
     param&egrave;tre <parameter>filterpattern</parameter>, la rendant inutilisable.
    </para>
    <note>
     <simpara>
      Les filtres enregistr&eacute;s par une extension dynamiquement charg&eacute;e doivent
      s'assurer d'appeler php_stream_filter_unregister_factory() durant MSHUTDOWN.
     </simpara>
    </note>
   </refsect1>
  </refentry>

</sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->

