<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.21 $ -->
<!-- EN-Revision: 1.12 Maintainer: dams Status: ready -->
 <sect1 id="stream.common-api">
  <title>Référence des API communes de flux</title>
  
  <refentry id="streams.php-stream-stat-path">
   <refnamediv>
    <refname>php_stream_stat_path</refname>
    <refpurpose>Lit l'état du fichier ou de l'URL</refpurpose>
   </refnamediv>
   <refsect1>
    &reftitle.description;
    <methodsynopsis>
     <type>int</type><methodname>php_stream_stat_path</methodname>
     <methodparam><type>char *</type><parameter>path</parameter></methodparam>
     <methodparam><type>php_stream_statbuf *</type><parameter>ssb</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_stat_path</function> examine le fichier ou l'URL 
     spécifié par <parameter>path</parameter> et retourne des informations telles
     que la taille, les droits d'accès, la date de création, etc.
     La valeur retournée est 0 en cas de succès, et -1 en cas d'échec.
     Pour plus d'informations, voyez 
     <link linkend="streams.struct-php-stream-statbuf">php_stream_statbuf</link>.
    </para>
   </refsect1>
  </refentry>
  
  <refentry id="streams.php-stream-stat">
   <refnamediv>
    <refname>php_stream_stat</refname>
    <refpurpose>Lit le statut du cache associé au flux</refpurpose>
   </refnamediv>
   <refsect1>
    &reftitle.description;
    <methodsynopsis>
     <type>int</type><methodname>php_stream_stat</methodname>
     <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
     <methodparam><type>php_stream_statbuf *</type><parameter>ssb</parameter></methodparam>
    </methodsynopsis>
    <para>
     <function>php_stream_stat</function> examine le système de stocker du flux 
     <parameter>stream</parameter>, et retourne des informations telles que 
     la taille de fichier, les droits d'accès, la date de création, etc.
     La valeur retournée est 0 en cas de succès, et -1 en cas d'échec.
     Pour plus d'informations sur les informations retournées, voyez 
     <link linkend="streams.struct-php-stream-statbuf">php_stream_statbuf</link>.
    </para>
   </refsect1>
  </refentry>
  
  
  <refentry id="streams.php-stream-open-wrapper">
   <refnamediv>
    <refname>php_stream_open_wrapper</refname>
    <refpurpose>Ouvre un flux sur un fichier ou une URL</refpurpose>
   </refnamediv>
   <refsect1>
    &reftitle.description;
     <methodsynopsis>
      <type>php_stream *</type><methodname>php_stream_open_wrapper</methodname>
      <methodparam><type>char *</type><parameter>path</parameter></methodparam>
      <methodparam><type>char *</type><parameter>mode</parameter></methodparam>
      <methodparam><type>int</type><parameter>options</parameter></methodparam>
      <methodparam><type>char **</type><parameter>opened</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_open_wrapper</function> ouvre un fichier, une URL ou 
     n'importe quelle ressource géré, spécifiée par 
     <parameter>path</parameter>.  
     Suivant la valeur de <parameter>mode</parameter>, le flux peut être ouvert
     en lecture, écriture, ajout ou une combinaison des trois. Voyez la table
     ci-dessous pour connaîtres les modes utilisées. De plus vous pouvez
     aussi intégrer le caractère 'b' comme deuxième ou dernière option. 
     Sa présence indiquera que le flux fonctionnera en mode binaire.
    </para>
    <para>
     L'option 'b' est ignorée sur les systèmes POSIX, qui traitent les
     fichiers textes et binaires de la même façon. C'est une bonne idée
     que de spécifier 'b' à chaque fois que votre flux accède à des
     données binaires, pour que votre code fonctionne lorsqu'il est 
     compilé sur un système où 'b' serait important.
    </para>
    <para>
     Tous les fichiers locaux créés par l'API des flux recevront les
     droits par défaut du système : sous Unix, cela signifie que le masque
     utilisateur du processus sera utilisé. Sous Windows, le fichier sera
     donné au propriétaire du processus. Tous les fichiers distants seront
     créé suivant le protocole utilisé, et les droits utilisés seront
     ceux du serveur distant.
    </para>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <constant>r</constant> 
       </term>
       <listitem>
        <simpara>
         Ouvre le fichier texte en mode lecture. Le pointeur du flux est
         placé au début du fichier.
        </simpara>
       </listitem>
      </varlistentry>
      
      <varlistentry>
       <term>
        <constant>r+</constant> 
       </term>
       <listitem>
        <simpara>
         Ouvre le fichier texte en lecture et écriture. Le pointeur du flux est
         placé au début du fichier.
        </simpara>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
        <constant>w</constant> 
       </term>
       <listitem>
        <simpara>
         Tronque le fichier à une taille de 0 ou bien crée le fichier,
         puis l'ouvre en mode écriture. Le pointeur du flux est
         placé au début du fichier.
        </simpara>
       </listitem>
      </varlistentry>
      
      <varlistentry>
       <term>
        <constant>w+</constant> 
       </term>
       <listitem>
        <simpara>
         Tronque le fichier à une taille de 0 ou bien crée le fichier,
         puis l'ouvre en mode écriture et lecture. Le pointeur du flux est
         placé au début du fichier. 
        </simpara>
       </listitem>
      </varlistentry>
      
      <varlistentry>
       <term>
        <constant>a</constant> 
       </term>
       <listitem>
        <simpara>
         Ouvre le fichier en mode d'écriture. Le fichier est créé s'il n'existe
         pas. Le pointeur de flux est positionné à la fin du fichier.
        </simpara>
       </listitem>
      </varlistentry>
      
      <varlistentry>
       <term>
        <constant>a+</constant> 
       </term>
       <listitem>
        <simpara>
         Ouvre le fichier en mode d'écriture et lecture. Le fichier est créé 
         s'il n'existe pas. Le pointeur de flux est positionné à la fin du 
         fichier.
         </simpara>
       </listitem>
      </varlistentry>
      
     </variablelist>    
    </para>    
    <para>
     <parameter>options</parameter> affecte l'interprétation du path ou de l'URL, les
     vérifications du safe_mode et les actions à prendre lorsqu'il y a une erreur. Voyez
     <link linkend="streams.options">Stream open options</link> pour plus de détails sur
     ces options.
    </para>
    <para>
     Si <parameter>opened</parameter> est non NULL, il sera assigné avec le nom
     du fichier ou de la ressource qui aura été réellement ouverte. 
     C'est important lorsque l'option inclus <constant>USE_PATH</constant>, qui permet de fouiller 
     l'include_path pour rechercher le fichier. Vous, l'appelant, êtes responsable de 
     l'appel de <function>efree</function> sur le nom de fichier retourné par ce 
     paramètre.
    </para>
    <note>
     <simpara>
      Si vous avez spécifié l'option <constant>STREAM_MUST_SEEK</constant> dans 
      <parameter>options</parameter>, le chemin retourné dans <parameter>opened</parameter> 
      peut ne pas être le même que celui qui vous a été 
      réellemetn retourné. Toutefois, ce sera le nom de la ressource originale 
      à partir de laquelle un flux à pointeur variable a été 
      créé.
     </simpara>
    </note>
   </refsect1>
  </refentry>
  
  
  <refentry id="streams.php-stream-read">
   <refnamediv>
    <refname>php_stream_read</refname>
    <refpurpose>Lit des octets depuis un flux dans un buffer</refpurpose>
   </refnamediv>
   <refsect1>
    &reftitle.description;
     <methodsynopsis>
      <type>size_t</type><methodname>php_stream_read</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
      <methodparam><type>char *</type><parameter>buf</parameter></methodparam>
      <methodparam><type>size_t</type><parameter>count</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_read</function> lit jusqu'à <parameter>count</parameter>
     octets dans le flux <parameter>stream</parameter> puis les copie dans le buffer
     <parameter>buf</parameter>.
    </para>
    <para>
     <function>php_stream_read</function> retourne le nombre d'octets lus. Il n'y a 
     pas de disctinction entre une lecture qui échoue et la fin du fichier : utilisez
     <function>php_stream_eof</function> pour tester la fin du fichier avec <constant>EOF</constant>.
    </para>
    <para>
     Le pointeur de position dans le flux est avancé d'autant d'octets que le nombre
     qui en a été lu. Par conséquent, la prochaine lecture reprendra là 
     ou la lecture précédente s'est arrêtée.
    </para>
    <para>
     Si moins de <parameter>count</parameter> octets ont été lus, cet appel bloquera
     l'application jusqu'à ce que le nombre d'octets nécessaire soit atteint, en fonction
     de la configuration du flux (bloquant, non bloquant). Par défaut, un flux est 
     ouvert en mode bloquant. Lorsque vous lisez dans des fichiers classiques, le mode bloquant
     ne vous gènera pas. Lors que le flux atteint <constant>EOF</constant>
     <function>php_stream_read</function> retournera un nombre d'octets lus inférieur
     à <parameter>count</parameter>, puis il retournera 0 aux prochaines lectures.
    </para>
   </refsect1>
  </refentry>

  <refentry id="streams.php-stream-write">
   <refnamediv>
    <refname>php_stream_write</refname>
    <refpurpose>écrit des octets depuis un buffer vers un flux</refpurpose>
   </refnamediv>
   <refsect1>
    &reftitle.description;
     <methodsynopsis>
      <type>size_t</type><methodname>php_stream_write</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
      <methodparam><type>const char *</type><parameter>buf</parameter></methodparam>
      <methodparam><type>size_t</type><parameter>count</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_write</function> écrit <parameter>count</parameter>
     octets du buffer <parameter>buf</parameter> dans le flux <parameter>stream</parameter>.
    </para>
    <para>
     <function>php_stream_write</function> retourne le nombre d'octets qui ont
     été écrit. S'il y a eu une erreur, le nombre d'octets écrit sera 
     inférieur au paramètre <parameter>count</parameter>.
    </para>
    <para>
     Le pointeur de position dans le flux est avancé d'autant d'octets que le nombre
     qui en a été écrit. Par conséquent, la prochaine écriture 
     reprendra là ou la lecture précédente s'est arrété.
    </para>
   </refsect1>
  </refentry>

  <refentry id="streams.php-stream-eof">
   <refnamediv>
    <refname>php_stream_eof</refname>
    <refpurpose>Vérifie que le pointeur n'est pas au bout du flux</refpurpose>
   </refnamediv>
   <refsect1>
    &reftitle.description;
     <methodsynopsis>
      <type>int</type><methodname>php_stream_eof</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_eof</function> vérifie que le pointeur n'est pas au bout du 
     flux <parameter>stream</parameter>.
    </para>
    <para>
     <function>php_stream_read</function> retourne 1 pour indiquer la fin du flux 
     (<constant>EOF</constant>), 0 s'il n'y a pas de fin de flux, et -1 pour indiquer une 
     erreur.
    </para>
   </refsect1>
  </refentry>

  <refentry id="streams.php-stream-getc">
   <refnamediv>
    <refname>php_stream_getc</refname>
    <refpurpose>Lit un octet dans un flux</refpurpose>
   </refnamediv>
   <refsect1>
    &reftitle.description;
     <methodsynopsis>
      <type>int</type><methodname>php_stream_getc</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_getc</function> lit un octet dans le flux
     <parameter>stream</parameter> puis le retourne de type unsigned char transtypé en
     int, ou <constant>EOF</constant> si la fin du flux est atteinte, ou bien
     si une erreur est survenue.
    </para>
    <para>
     <function>php_stream_getc</function> peut bloquer l'application de la même façon
     que <function>php_stream_read</function> bloque.
    </para>
    <para>
     Le pointeur de position est avancé d'une position si la lecture réussit.
    </para>
   </refsect1>
  </refentry>

  <refentry id="streams.php-stream-gets">
   <refnamediv>
    <refname>php_stream_gets</refname>
    <refpurpose>Lit une ligne de données d'un flux dans un buffer</refpurpose>
   </refnamediv>
   <refsect1>
    &reftitle.description;
     <methodsynopsis>
      <type>char *</type><methodname>php_stream_gets</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
      <methodparam><type>char *</type><parameter>buf</parameter></methodparam>
      <methodparam><type>size_t</type><parameter>maxlen</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_gets</function> lit jusqu'à <parameter>count</parameter>-1
     octets de données dans le flux <parameter>stream</parameter> puis les copies dans 
     le buffer <parameter>buf</parameter>. La lecture s'arrête après la rencontre de 
     la fin du fichier (<constant>EOF</constant>) ou une nouvelle ligne. Si la nouvelle
     ligne est lue, elle est stockée dans <parameter>buf</parameter> dans les 
     données retournées. Un caractère NUL de fin de chaîne est 
     stocké comme dernier caractère dans le buffer.
    </para>
    <para>
     <function>php_stream_read</function> retourne <parameter>buf</parameter>
     lorsque cela fonctionne, et NULL sinon.
    </para>
    <para>
     Le pointeur de position est avancé d'une position si la lecture réussit.
    </para>
    <para>
     <function>php_stream_gets</function> peut bloquer l'application de la même façon
     que <function>php_stream_read</function> bloque.   
    </para>
   </refsect1>
  </refentry>

  <refentry id="streams.php-stream-close">
   <refnamediv>
    <refname>php_stream_close</refname>
    <refpurpose>Ferme un flux</refpurpose>
   </refnamediv>
   <refsect1>
    &reftitle.description;
     <methodsynopsis>
      <type>int</type><methodname>php_stream_close</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_close</function> ferme correctement le flux 
     <parameter>stream</parameter> et libère les ressources qui lui sont associées. 
     Apràs la fermeture de <parameter>stream</parameter>, il prend une valeur 
     indéfinie, et ne devrait plus être utilisé.
    </para>
    <para>
     <function>php_stream_close</function> retourne 0 si le flux a été 
     fermé, ou bien <constant>EOF</constant> pour indiquer une erreur. 
     Indépendamment du succès de l'opération, <parameter>stream</parameter> 
     prend une valeur indéfinie, et ne devrait plus être utilisé.
    </para>
   </refsect1>
  </refentry>

  <refentry id="streams.php-stream-flush">
   <refnamediv>
    <refname>php_stream_flush</refname>
    <refpurpose>Vide les buffers dans le flux</refpurpose>
   </refnamediv>
   <refsect1>
    &reftitle.description;
     <methodsynopsis>
      <type>int</type><methodname>php_stream_flush</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_flush</function> vide toutes les données contenues dans
     les buffers d'écriture du flux <parameter>stream</parameter> et force leur stockage.
    </para>
    <para>
     <function>php_stream_flush</function> retourne 0 si les buffers ont été 
     vidés, ou si les buffers n'ont pas besoin d'être vidé, mais retourne 
     <constant>EOF</constant> pour indiquer une erreur.
    </para>
   </refsect1>
  </refentry>

  <refentry id="streams.php-stream-seek">
   <refnamediv>
    <refname>php_stream_seek</refname>
    <refpurpose>Modifie la position du pointeur de flux</refpurpose>
   </refnamediv>
   <refsect1>
    &reftitle.description;
     <methodsynopsis>
      <type>int</type><methodname>php_stream_seek</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
      <methodparam><type>off_t</type><parameter>offset</parameter></methodparam>
      <methodparam><type>int</type><parameter>whence</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_seek</function> modifie la position du pointeur de
     position du flux <parameter>stream</parameter>. La nouvelle position
     est déterminée en ajoutant <parameter>offset</parameter>
     à la position indiquée par <parameter>whence</parameter>.
     Si <parameter>whence</parameter> vaut <constant>SEEK_SET</constant>,
     <constant>SEEK_CUR</constant> ou <constant>SEEK_END</constant> l'offset sera 
     relativ au début du flux, à la position courante ou à la fin du 
     flux, respectivement.
    </para>
    <para>
     <function>php_stream_seek</function> retourne 0 en cas de succès, et -1 en cas d'erreur.
    </para>
    <note>
     <para>
     Tous les flux ne supportent pas la modification de la position du pointeur,
     même si l'API va émuler un tel pointeur si <parameter>whence</parameter> vaut
     <constant>SEEK_CUR</constant> et <parameter>offset</parameter> est positif, en 
     appelant <function>php_stream_read</function> pour lire (et ignorer) 
     <parameter>offset</parameter> octets.
      </para>
      <para>
      L'émulation est uniquement appliquée si l'implémentation du gestionnaire 
      de flux suporte le pointeur de position. Si le flux est (par exemple) 
      basé sur des fichiers qui travaille avec des flux de pipes, l'API de flux 
      ne pourra pas appliquer une telle émulation. Le positionnement du pointeur de 
      flux échouera et une erreur sera retournée.
      </para>
    </note>
   </refsect1>
  </refentry>

  <refentry id="streams.php-stream-tell">
   <refnamediv>
    <refname>php_stream_tell</refname>
    <refpurpose>Détermine la position du pointeur dans un flux</refpurpose>
   </refnamediv>
   <refsect1>
    &reftitle.description;
     <methodsynopsis>
      <type>off_t</type><methodname>php_stream_tell</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_tell</function> retourne la position du pointeur
     du flux <parameter>stream</parameter>, relativement au début du
     flux. 
     Si une erreur survient, retourne -1.
     </para>
   </refsect1>
  </refentry>

 <refentry id="streams.php-stream-copy-to-stream">
   <refnamediv>
    <refname>php_stream_copy_to_stream</refname>
    <refpurpose>Copie des données d'un flux à l'autre</refpurpose>
   </refnamediv>
   <refsect1>
    &reftitle.description;
     <methodsynopsis>
      <type>size_t</type><methodname>php_stream_copy_to_stream</methodname>
      <methodparam><type>php_stream *</type><parameter>src</parameter></methodparam>
      <methodparam><type>php_stream *</type><parameter>dest</parameter></methodparam>
      <methodparam><type>size_t</type><parameter>maxlen</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_copy_to_stream</function> essaie de lire un maximum de 
     <parameter>maxlen</parameter> octets dans le flux <parameter>src</parameter>
     puis de les écrire dans le flux <parameter>dest</parameter>. La fonction
     retourne le nombre d'octets copiés.
    </para>
    <para>
     Si vous souhaitez copier tous les octets restants dans le flux
     <parameter>src</parameter>, passez la constante 
     <constant>PHP_STREAM_COPY_ALL</constant> comme valeur de <parameter>maxlen</parameter>.
    </para>
    <note>
     <simpara>
      Cette fonction va essayer d'effectuer la copie de la manière la plus efficace,
      en utilise dans buffer mémoire lorsque c'est possible.
     </simpara>
    </note>
   </refsect1>
  </refentry>

 <refentry id="streams.php-stream-copy-to-mem">
  <refnamediv>
   <refname>php_stream_copy_to_mem</refname>
   <refpurpose>Copie des données depuis un flux dans un buffer</refpurpose>
   </refnamediv>
   <refsect1>
    &reftitle.description;
    <methodsynopsis>
     <type>size_t</type><methodname>php_stream_copy_to_mem</methodname>
     <methodparam><type>php_stream *</type><parameter>src</parameter></methodparam>
     <methodparam><type>char **</type><parameter>buf</parameter></methodparam>
     <methodparam><type>size_t</type><parameter>maxlen</parameter></methodparam>
     <methodparam><type>int</type><parameter>persistent</parameter></methodparam>
    </methodsynopsis>
    <para>
     <function>php_stream_copy_to_mem</function> alloue un buffer de taille 
     <parameter>maxlen</parameter>+1 en utilisant la fonction 
     <function>pemalloc</function> (en 
     passant <parameter>persistent</parameter>). 
     Puis, elle lit <parameter>maxlen</parameter> 
     octets depuis le flux <parameter>src</parameter> et stocke le résultat
     dans le buffer alloué.
    </para>
    <para>
     Le buffer alloué est retourné dans le paramètre <parameter>buf</parameter> ainsi
     que le nombre d'octets lus avec succès. Vous, l'appelant, êtes responsable
     de la libération du buffer en le passant de <parameter>persistent</parameter> à 
     <function>pefree</function>.
    </para>
    <para>
     Si vous voulez copier toutes les données du flux <parameter>src</parameter>,
     passez à la constante <constant>PHP_STREAM_COPY_ALL</constant>  la valeur
     du paramètre <parameter>maxlen</parameter>.
    </para>
    <note>
     <simpara>
      Cette fonction va essayer d'effectuer la copie de la manière la plus efficace,
      en utilise dans buffer mémoire lorsque c'est possible.
     </simpara>
    </note>
   </refsect1>
  </refentry>

 <refentry id="streams.php-stream-make-seekable">
   <refnamediv>
    <refname>php_stream_make_seekable</refname>
    <refpurpose>Convertit un flux en flux avec un pointeur de position</refpurpose>
   </refnamediv>
   <refsect1>
    &reftitle.description;
     <methodsynopsis>
      <type>int</type><methodname>php_stream_make_seekable</methodname>
      <methodparam><type>php_stream *</type><parameter>origstream</parameter></methodparam>
      <methodparam><type>php_stream **</type><parameter>newstream</parameter></methodparam>
      <methodparam><type>int</type><parameter>flags</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_make_seekable</function> vérifie si <parameter>origstream</parameter>
     dispose d'un pointeur de potision. Si ce n'est pas le cas, il va copier les données
     du flux dans un autre flux temporaire, et disposant d'un pointeur de position.
     Si cela fonctionne, <parameter>newstream</parameter> sera un flux valide
     même si le flux original avait déjà un pointeur de position.
    </para>
    <para>
     <parameter>flags</parameter> vous permet de spécifier votre préférence
     pour le flux retourné : utilisez la constante <constant>PHP_STREAM_NO_PREFERENCE</constant> 
     pour utiliser le flux à pointeur de position par défaut (qui utilise la
     mémoire, mais passe automatiquement sur un fichier si le fichier devient trop grand),
     ou bien utilisez <constant>PHP_STREAM_PREFER_STDIO</constant> pour utiliser 
     un fichier temporaire classique.
    </para>
    <para>
     <table>
      <title>Valeurs retournées par <function>php_stream_make_seekable</function></title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>Valeur</entry>
         <entry>Signification</entry>
        </row>
       </thead>
       <tbody>

        <row>
         <entry>PHP_STREAM_UNCHANGED</entry>
         <entry>Le flux original avait déjà son pointeur de position. 
         <parameter>newstream</parameter> vaut <parameter>origstream</parameter>.
         </entry>
        </row>

        <row>
         <entry>PHP_STREAM_RELEASED</entry>
         <entry>Le flux originl n'avait pas pointeur de position, et il a été 
         détruit. Vous n'avez plus accès à <parameter>origstream</parameter>.
         </entry>
        </row>

        <row>
         <entry>PHP_STREAM_FAILED</entry>
         <entry>Une erreur est survenue lors de la conversion. 
         <parameter>newstream</parameter> vaut NULL;
          <parameter>origstream</parameter> est toujours valide.
         </entry>
        </row>

        <row>
         <entry>PHP_STREAM_CRITICAL</entry>
         <entry>Une erreur est survenue lors de la conversion de <parameter>origstream</parameter>,
         qui est maintenant dans un état indéterminé. 
         <parameter>newstream</parameter> vaut NULL et il est très recommandé que 
         vous vous fermiez <parameter>origstream</parameter>.
         </entry>
        </row>
         
       </tbody>
      </tgroup>
     </table>
    </para>
    <note>
     <simpara>
      Si vous devez déplacer le pointeur et écrire dans le flux, n'utilisez 
      pas cette fonction, car le flux retourné est un flux mis en cache. Il 
      n'est pas garantit qu'il soit lié à la ressource originale.
     </simpara>
    </note>
    <note>
     <simpara>
      Si vous avez uniquement de déplacer le pointeur de position vers l'avant,
      il n'y a pas besoin d'appeler cette fonction, car l'API va automatiquement
      émuler ce fonctionnement avec le paramètre whence à la valeur 
      <constant>SEEK_CUR</constant>.
     </simpara>
    </note>
    <note>
     <simpara>
      Si <parameter>origstream</parameter> repose sur le réseau, cette fonction
      va se bloquer jusqu'à ce que tout le contenu soit téléchargé.
      </simpara>
    </note>
    <note>
     <simpara>
      Ne JAMAIS appeler cette fonction avec un flux <parameter>origstream</parameter> qui
      est une référence à un pointeur de fichier dans un script &php;. Cette 
      fonction pourrait alors fermer le fichier, ce qui conduira à un crash au prochain 
      accès au pointeur.
     </simpara>
    </note>
    <note>
     <simpara>
     Dans de nombreux cas, cette fonction ne peut réussir que si 
     <parameter>origstream</parameter> vient d'être tout juste ouvert, et qu'aucune 
     données n'ont été mises dans les caches de la couche de flux. Pour 
     cette raison, et parce que cette fonction est compliquée à utiliser 
     correctement, il est recommandé que vous utilisiez la fonction 
     <function>php_stream_open_wrapper</function> en lui passant la constante 
     <constant>PHP_STREAM_MUST_SEEK</constant> dans vos options, au lieu d'appeler
     cette fonction directement.
     </simpara>
    </note>
    </refsect1>
  </refentry>


<refentry id="streams.php-stream-cast">
   <refnamediv>
    <refname>php_stream_cast</refname>
    <refpurpose>Convertit un flux en une autre forme, comme un FILE* ou une socket</refpurpose>
   </refnamediv>
   <refsect1>
    &reftitle.description;
     <methodsynopsis>
      <type>int</type><methodname>php_stream_cast</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
      <methodparam><type>int</type><parameter>castas</parameter></methodparam>
      <methodparam><type>void **</type><parameter>ret</parameter></methodparam>
      <methodparam><type>int</type><parameter>flags</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_cast</function> tente de convertir le flux <parameter>stream</parameter>
     en un autre ressource indiqué par <parameter>castas</parameter>.
     Si <parameter>ret</parameter> est NULL, le flux est interrogé pour savoir une telle
     conversoin est posible, sans effectuer réellemnt la conversion (mais
     certains état interne pourrait être changés dans ce cas). Si 
     <parameter>flags</parameter> vaut <constant>REPORT_ERRORS</constant>, un message
     d'erreur apparaîtra si une erreur survient durant la conversion.
    </para>
    <note>
        <para>
         Cette fonction retourne <constant>SUCCESS</constant> en cas de réussite et 
         <constant>FAILURE</constant> en cas d'échec. Soyez prévenu que vous devez
         faire une comparaison explicite avec <constant>SUCCESS</constant>
         ou <constant>FAILURE</constant> à cause des valeurs sous jacentes de ces
         constantes. Une simple comparaison d'expression booléenne ne sera pas 
         interprétée comme vous le souhaitez.
        </para>
    </note>
    <para>
     <table>
      <title>Types de ressources de <parameter>castas</parameter></title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>Valeur</entry>
         <entry>Signification</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>PHP_STREAM_AS_STDIO</entry>
         <entry>Un pointeur ANSI FILE* qui représente le flux</entry>
        </row>
        <row>
         <entry>PHP_STREAM_AS_FD</entry>
         <entry>Un pointeur de fichier de type POSIX qui représente le flux</entry>
        </row>
        <row>
         <entry>PHP_STREAM_AS_SOCKETD</entry>
         <entry>Un pointeur de socket réseau  qui représente le flux</entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </para>
    <para>
     En plus des types de ressources basiques ci-dessus, le processus de conversion
     peut être modifié en utilisant les paramètres ci-dessous, ou bien en utilisant
     l'opérateur OR pour combiner le type de ressource avec une ou plusieurs des valeurs
     suivantes : 
     <table>
      <title>Types de ressources pour <parameter>castas</parameter></title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>Valeur</entry>
         <entry>Signification</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>PHP_STREAM_CAST_TRY_HARD</entry>
         <entry>Essaie aussi fort que possible, même si c'est au prix de quelques
         ressources supplémentaires,  que la conversion réussisse</entry>
        </row>
        <row>
         <entry>PHP_STREAM_CAST_RELEASE</entry>
         <entry>Informque l'API de flux que d'autre code (possible une bibliothèque tierce
         partie) sera responsable de la gestion des ressources de bas niveau. Cela fait que
         le flux <parameter>stream</parameter> sera fermé de telle façon à 
         ce que le gestionnaire soit préservé et retourné dans le 
         paramètre <parameter>ret</parameter>.
         Si la fonction réussit, le paramètre <parameter>stream</parameter>
         doit être considéré comme fermé, et inutilisable en l'état.
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </para>
    <note>
     <simpara>
      Si votre système supporte la fonction <function>fopencookie</function> (les systèmes
      utilisant la bibliothèque glibc 2 ou plus récent), l'API de flux sera toujours
      capable de créer des pointeurs de fichiers de type ANSI FILE* pour tous les flux.
      Même si c'est extrêmement utile pour passer des flux &php; à des 
      bibliothèque tierce partie, un tel système n'est pas portable. Il est demandé que 
      vous considériez la portabilité e vos fonctions avant de diffuser votre 
      extension. Si l'utilisation de fopencookie() n'est pas désirable, il est 
      recommandé d'interroger le flux pour voir s'il supporte naturellement la 
      conversion en FILE* en utilisant la fonction <function>php_stream_is</function>
     </simpara>
    </note>
    <note>
     <simpara>
      Si vous demandez une socket réseau à la place d'un FILE*, l'API de flux
      va utiliser la fonction <function>fdopen</function> pour la créer pour vous.
      Soyez prévenu que faire cela risque de perdre les données qui ont 
      été mises en buffer dans le flux, si vous mélanger des appels de 
      l'API de flux et les appels standards ANSI.
     </simpara>
    </note>
    <para>
     Voir aussi 
     <function>php_stream_is</function> et 
     <function>php_stream_can_cast</function>.
    </para>
   </refsect1>
  </refentry>
 
<refentry id="streams.php-stream-can-cast">
   <refnamediv>
    <refname>php_stream_can_cast</refname>
    <refpurpose>Détermine si un flux peut être converti en une autre forme, comme FILE* ou socket</refpurpose>
   </refnamediv>
   <refsect1>
    &reftitle.description;
     <methodsynopsis>
      <type>int</type><methodname>php_stream_can_cast</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
      <methodparam><type>int</type><parameter>castas</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_can_cast</function> est l'équivalent de la fonction 
     <function>php_stream_cast</function> avec le paramètre <parameter>ret</parameter>
     mis à NULL, et le paramètre <parameter>flags</parameter> mis à 0.
     Elle retourne <constant>SUCCESS</constant> si le flux peut être converti dans
     la forme demandée, ou bien <constant>FAILURE</constant> si la conversion ne peut
     se faire.
    </para>
    <note>
     <simpara>
      Bien que cette fonction n'effectue aucune conversion, il est possible que certains
      état interne du flux soient modifiés.
     </simpara>
    </note>
    <note>
     <simpara>
      Vous devez explicitement comparer la valeur de retour avec une des constantes, comme
      décrit dans <function>php_stream_cast</function>.
      </simpara>
    </note>
    <para>
     Voir aussi
     <function>php_stream_cast</function> et 
     <function>php_stream_is</function>.
    </para>
   </refsect1>
  </refentry>

<refentry id="streams.php-stream-is-persistent">
   <refnamediv>
    <refname>php_stream_is_persistent</refname>
    <refpurpose>Détermine si un flux est un flux persistant</refpurpose>
   </refnamediv>
   <refsect1>
    &reftitle.description;
     <methodsynopsis>
      <type>int</type><methodname>php_stream_is_persistent</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_is_persistent</function> retourne  1 si le flux 
     <parameter>stream</parameter> est un flux persistant, et 0 sinon.
    </para>
 </refsect1>
</refentry>

<refentry id="streams.php-stream-is">
   <refnamediv>
    <refname>php_stream_is</refname>
    <refpurpose>Détermine si un flux est d'un type particulier</refpurpose>
   </refnamediv>
   <refsect1>
    &reftitle.description;
     <methodsynopsis>
      <type>int</type><methodname>php_stream_is</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
      <methodparam><type>int</type><parameter>istype</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_is</function> retourne 1 si <parameter>stream</parameter> 
     est du type spécifié par <parameter>istype</parameter>, et 0 sinon.
    <table>
      <title>Valeurs possibles pour <parameter>istype</parameter></title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>Valeur</entry>
         <entry>Signification</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>PHP_STREAM_IS_STDIO</entry>
         <entry>Le flux est implémenté en utilisant l'implémentation standard</entry>
        </row>
        <row>
         <entry>PHP_STREAM_IS_SOCKET</entry>
         <entry>Le flux est implémenté en utilisant l'implémentation des sockets réseau</entry>
        </row>
        <row>
         <entry>PHP_STREAM_IS_USERSPACE</entry>
         <entry>Le flux est implémenté en utilisant l'implémentation de l'objet utilisateur</entry>
        </row>
        <row>
         <entry>PHP_STREAM_IS_MEMORY</entry>
         <entry>Le flux est implémenté en utilisant l'implémentation mémoire à taille automatique</entry>
        </row>
       </tbody>
      </tgroup>
     </table>

    </para>
    <note>
     <simpara>
      Les constantes PHP_STREAM_IS_XXX sont en fait définies comme des  pointeurs
      sur la structure des opérations de base. Si vous extension (ou une autre extension
      définit des flux additionnels), il faut qu'elle déclare aussi les constantes
      PHP_STREAM_IS_XXX dans ses en-têtes, pour que vous puissiez les utiliser comme
      base de comparaison.
      </simpara>
    </note>
    <note>
     <simpara>
      Cette fonction est implémentée comme une comparaison de pointeurs simple
      (et rapide), et ne modifie pas l'état du flux.
     </simpara>
    </note>
    <para>
     Voir aussi 
     <function>php_stream_cast</function> et 
     <function>php_stream_can_cast</function>.
    </para>
   </refsect1>
  </refentry>
  
  <refentry id="streams.php-stream-passthru">
   <refnamediv>
    <refname>php_stream_passthru</refname>
    <refpurpose>Affiche toutes les données restantes d'un flux</refpurpose>
   </refnamediv>
   <refsect1>
    &reftitle.description;
     <methodsynopsis>
      <type>size_t</type><methodname>php_stream_passthru</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
     </methodsynopsis>
     <para>
      <function>php_stream_passthru</function> affiche tous les octets restant dans le
      flux <parameter>stream</parameter> vers le buffer de sortie. Les données sont
      écrites directement dans le buffer de sortie, qui sera le navigateur dans le cas
      de &php; sur un serveur web, ou la sortie standard dans le cas de &php; en mode 
      de ligne de commande. Cette fonction essaie d'utiliser des fichiers en mémoire
      pour accélérer l'exécution.
     </para>
    </refsect1>
  </refentry>

  <refentry id="streams.php-register-url-stream-wrapper">
   <refnamediv>
    <refname>php_register_url_stream_wrapper</refname>
    <refpurpose>Enregistre un gestionnaire pour l'API de flux</refpurpose>
   </refnamediv>
   <refsect1>
    &reftitle.description;
     <methodsynopsis>
      <type>int</type><methodname>php_register_url_stream_wrapper</methodname>
      <methodparam><type>char *</type><parameter>protocol</parameter></methodparam>
      <methodparam><type>php_stream_wrapper *</type><parameter>wrapper</parameter></methodparam>
      <methodparam><type>TSRMLS_DC</type><parameter></parameter></methodparam>
     </methodsynopsis>
     <para>
      <function>php_register_url_stream_wrapper</function> enregistre le gestionnaire
      <parameter>wrapper</parameter> pour le protocole <parameter>protocol</parameter>.
     </para>
     <note>
      <simpara>
       Si vous appelez cette fonction dans un module dynamiquement chargé, vous DEVEZ
       appeler la fonction <function>php_unregister_url_stream_wrapper</function>
       dans la fonction de terminaison de votre module, sinon &php; 
       va crasher.
      </simpara>
     </note>
    </refsect1>
  </refentry>

  <refentry id="streams.php-unregister-url-stream-wrapper">
   <refnamediv>
    <refname>php_unregister_url_stream_wrapper</refname>
    <refpurpose>Désenregistre un gestionnaire pour l'API de flux</refpurpose>
   </refnamediv>
   <refsect1>
    &reftitle.description;
     <methodsynopsis>
      <type>int</type><methodname>php_unregister_url_stream_wrapper</methodname>
      <methodparam><type>char *</type><parameter>protocol</parameter></methodparam>
      <methodparam><type>TSRMLS_DC</type><parameter></parameter></methodparam>
     </methodsynopsis>
     <para>
      <function>php_unregister_url_stream_wrapper</function> désenregistre le gestionnaire
      associé avec le protocole <parameter>protocol</parameter>.
     </para>
    </refsect1>
  </refentry>

  <refentry id="streams.php-stream-open-wrapper-ex">
   <refnamediv>
    <refname>php_stream_open_wrapper_ex</refname>
    <refpurpose>Ouvre un flux avec un fichier ou une URL, en spécifiant le contexte</refpurpose>
   </refnamediv>
   <refsect1>
    &reftitle.description;
     <methodsynopsis>
      <type>php_stream *</type><methodname>php_stream_open_wrapper_ex</methodname>
      <methodparam><type>char *</type><parameter>path</parameter></methodparam>
      <methodparam><type>char *</type><parameter>mode</parameter></methodparam>
      <methodparam><type>int</type><parameter>options</parameter></methodparam>
      <methodparam><type>char **</type><parameter>opened</parameter></methodparam>
      <methodparam><type>php_stream_context *</type><parameter>context</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_open_wrapper_ex</function> est exactement comme 
     <function>php_stream_open_wrapper</function>, mais vous permet de spécifier un
     objet de type php_stream_context avec le paramètre <parameter>context</parameter>.
     Pour en savoir plus sur les contextes, voyez le <link linkend="stream.contexts">contexte Stream</link>.
    </para>
    </refsect1>
    </refentry>

  <refentry id="streams.php-stream-open-wrapper-as-file">
   <refnamediv>
    <refname>php_stream_open_wrapper_as_file</refname>
    <refpurpose>Ouvre un flux avec un fichier ou une URL, et le convertit en pointeur FILE*</refpurpose>
   </refnamediv>
   <refsect1>
    &reftitle.description;
     <methodsynopsis>
      <type>FILE *</type><methodname>php_stream_open_wrapper_as_file</methodname>
      <methodparam><type>char *</type><parameter>path</parameter></methodparam>
      <methodparam><type>char *</type><parameter>mode</parameter></methodparam>
      <methodparam><type>int</type><parameter>options</parameter></methodparam>
      <methodparam><type>char **</type><parameter>opened</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_open_wrapper_as_file</function> est exactement identique
     à la fonction <function>php_stream_open_wrapper</function>, mais convertit le
     flux en un pointeur ANSI FILE* puis le retourne à la place du flux. C'est un
     raccourci commode pour les extensions qui passent des pointeurs FILE* aux 
     bibliothèques tierce partie.
    </para>
    </refsect1>
    </refentry>

    <refentry id="streams.php-stream-filter-register-factory">
   <refnamediv>
    <refname>php_stream_filter_register_factory</refname>
    <refpurpose>Enregistre une usine à filtres avec l'API des flux</refpurpose>
   </refnamediv>
   <refsect1>
    &reftitle.description;
    <methodsynopsis>
     <type>int</type><methodname>php_stream_filter_register_factory</methodname>
     <methodparam><type>const char *</type><parameter>filterpattern</parameter></methodparam>
     <methodparam><type>php_stream_filter_factory *</type><parameter>factory</parameter></methodparam>
    </methodsynopsis>
    <para>
     Utilisez cette fonction pour enregistrer une usine à filtres, dont le nom
     est donné par <parameter>filterpattern</parameter>. <parameter>filterpattern</parameter>
     peut être un nom classique, sous forme de chaîne, (i.e. <literal>myfilter</literal>) ou
     un modèle général (i.e. <literal>myfilterclass.*</literal>) pour permettre à un filtre
     d'effectuer différentes opérations en fonction du nom du filtre
     invoqué (i.e. <literal>myfilterclass.foo</literal>, <literal>myfilterclass.bar</literal>,
     etc.)
    </para>
    <note>
     <simpara>
      Les filtres enregistrés par une extension dynamiquement chargée doivent
      s'assurer d'appeler php_stream_filter_unregister_factory() durant MSHUTDOWN.
     </simpara>
    </note>
   </refsect1>
  </refentry>
  <refentry id="streams.php-stream-filter-unregister-factory">
   <refnamediv>
    <refname>php_stream_filter_unregister_factory</refname>
    <refpurpose>Supprime une usine à filtres des API de flux</refpurpose>
   </refnamediv>
   <refsect1>
    &reftitle.description;
    <methodsynopsis>
     <type>int</type><methodname>php_stream_filter_unregister_factory</methodname>
     <methodparam><type>const char *</type><parameter>filterpattern</parameter></methodparam>
    </methodsynopsis>
    <para>
     Supprime l'usine à filtres <parameter>filterfactory</parameter> spécifié par le
     paramètre <parameter>filterpattern</parameter>, la rendant inutilisable.
    </para>
    <note>
     <simpara>
      Les filtres enregistrés par une extension dynamiquement chargée doivent
      s'assurer d'appeler php_stream_filter_unregister_factory() durant MSHUTDOWN.
     </simpara>
    </note>
   </refsect1>
  </refentry>

</sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->

