<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.3 $ -->
<!-- Author: Wez Furlong <wez@thebrainroom.com>
  Please contact me before making any major amendments to the
  content of this section.  Splitting/Merging are fine if they are
  required for php-doc restructuring purposes - just drop me a line
  if you make a change (so I can update my local copy).
-->
 <sect1 id="stream.common-api">
    <title>R&eacute;f&eacute;rence des API communes de fl&ocirc;ts</title>
  
  <refentry id="streams.php-stream-stat-path">
   <refnamediv>
    <refname>php_stream_stat_path</refname>
    <refpurpose>Lit l'&eacute;tat du fichier ou de l'URL</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>int</type><methodname>php_stream_stat_path</methodname>
      <methodparam><type>char *</type><parameter>path</parameter></methodparam>
      <methodparam><type>php_stream_statbuf *</type><parameter>ssb</parameter></methodparam>
     </methodsynopsis>
     <para>
      <function>php_stream_stat_path</function> &eacute;xamine le fichier ou l'URL 
      sp&eacute;cifi&eacute; par <parameter>path</parameter> et retourne des informations telles
      que la taille, les droits d'acc&egrave;s, la date de cr&eacute;ation, etc...
      La valeur retourn&eacute;e est 0 en cas de succ&egrave;s, et -1 en cas d'&eacute;chec.
      Pour plus d'informations, voyez 
      <link linkend="streams.struct-php-stream-statbuf">php_stream_statbuf</link>.
     </para>
    </refsect1>
  </refentry>
  
  <refentry id="streams.php-stream-stat">
   <refnamediv>
    <refname>php_stream_stat</refname>
    <refpurpose>Lit le statut du cache associ&eacute; au fl&ocirc;t</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>int</type><methodname>php_stream_stat</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
      <methodparam><type>php_stream_statbuf *</type><parameter>ssb</parameter></methodparam>
     </methodsynopsis>
     <para>
      <function>php_stream_stat</function> examine le syst&egrave;me de stocker du fl&ocirc;t 
      <parameter>stream</parameter>, et retourne des informations telles que 
      la taille de fichier, les droits d'acc&egrave;s, la date de cr&eacute;ation, etc...
      La valeur retourn&eacute;e est 0 en cas de succ&egrave;s, et -1 en cas d'&eacute;chec.
      Pour plus d'informations sur les informations retourn&eacute;es, voyez 
      <link linkend="streams.struct-php-stream-statbuf">php_stream_statbuf</link>.
     </para>
    </refsect1>
  </refentry>
  
  
  <refentry id="streams.php-stream-open-wrapper">
   <refnamediv>
    <refname>php_stream_open_wrapper</refname>
    <refpurpose>Ouvre un fl&ocirc;t sur un fichier ou une URL</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>php_stream *</type><methodname>php_stream_open_wrapper</methodname>
      <methodparam><type>char *</type><parameter>path</parameter></methodparam>
      <methodparam><type>char *</type><parameter>mode</parameter></methodparam>
      <methodparam><type>int</type><parameter>options</parameter></methodparam>
      <methodparam><type>char **</type><parameter>opened</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_open_wrapper</function> ouvre un fichier, une URL ou 
     n'importe quelle ressource g&eacute;r&eacute;, sp&eacute;cifi&eacute;e par 
     <parameter>path</parameter>.  
     Suivant la valeur de <parameter>mode</parameter>, le fl&ocirc;t peut &ecirc;tre ouvert
     en lecture, &eacute;criture, ajout ou une combinaison des trois. Voyez la table
     ci-dessous pour conna&icirc;tres les modes utilis&eacute;es. De plus vous pouvez
     aussi int&eacute;grer le caract&egrave;re 'b' comme deuxi&egrave;me ou derni&egrave;re option. 
     Sa pr&eacute;sence indiquera que le fl&ocirc;t fonctionnera en mode binaire.
    </para>
    <para>
     L'option 'b' est ignor&eacute;e sur les syst&egrave;mes POSIX, qui traitent les
     fichiers textes et binaires de la m&ecirc;me fa&ccedil;on. C'est une bonne id&eacute;e
     que de sp&eacute;cifier 'b' &agrave; chaque fois que votre fl&ocirc;t acc&egrave;de &agrave; des
     donn&eacute;es binaires, pour que votre code fonctionne lorsqu'il est 
     compil&eacute; sur un syst&egrave;me où 'b' serait important.
    </para>
    <para>
     Tous les fichiers locaux cr&eacute;&eacute;s par l'API des fl&ocirc;ts recevront les
     droits par d&eacute;faut du syst&egrave;me : sous Unix, cela signifie que le masque
     utilisateur du processus sera utilis&eacute;. Sous Windows, le fichier sera
     donn&eacute; au propri&eacute;taire du processus. Tous les fichiers distants seront
     cr&eacute;&eacute; suivant le protocole utilis&eacute;, et les droits utilis&eacute;s seront
     ceux du serveur distant.
    </para>
    <para>
     <variablelist>
      <varlistentry>
       <term>
        <constant>r</constant> 
       </term>
       <listitem>
        <simpara>
         Ouvre le fichier texte en mode lecture. Le pointeur du fl&ocirc;t est
         plac&eacute; au d&eacute;but du fichier.
        </simpara>
       </listitem>
      </varlistentry>
      
      <varlistentry>
       <term>
        <constant>r+</constant> 
       </term>
       <listitem>
        <simpara>
         Ouvre le fichier texte en lecture et &eacute;criture. Le pointeur du fl&ocirc;t est
         plac&eacute; au d&eacute;but du fichier.
        </simpara>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
        <constant>w</constant> 
       </term>
       <listitem>
        <simpara>
         Tronque le fichier &agrave; une taille de 0 ou bien cr&eacute;e le fichier,
         puis l'ouvre en mode &eacute;criture. Le pointeur du fl&ocirc;t est
         plac&eacute; au d&eacute;but du fichier.
        </simpara>
       </listitem>
      </varlistentry>
      
      <varlistentry>
       <term>
        <constant>w+</constant> 
       </term>
       <listitem>
        <simpara>
         Tronque le fichier &agrave; une taille de 0 ou bien cr&eacute;e le fichier,
         puis l'ouvre en mode &eacute;criture et lecture. Le pointeur du fl&ocirc;t est
         plac&eacute; au d&eacute;but du fichier. 
        </simpara>
       </listitem>
      </varlistentry>
      
      <varlistentry>
       <term>
        <constant>a</constant> 
       </term>
       <listitem>
        <simpara>
         Ouvre le fichier en mode d'&eacute;criture. Le fichier est cr&eacute;&eacute; si il n'existe
         pas. Le pointeur de fl&ocirc;t est positionn&eacute; &agrave; la fin du fichier.
        </simpara>
       </listitem>
      </varlistentry>
      
      <varlistentry>
       <term>
        <constant>a+</constant> 
       </term>
       <listitem>
        <simpara>
         Ouvre le fichier en mode d'&eacute;criture et lecture. Le fichier est cr&eacute;&eacute; 
         si il n'existe pas. Le pointeur de fl&ocirc;t est positionn&eacute; &agrave; la fin du 
         fichier.
         </simpara>
       </listitem>
      </varlistentry>
      
     </variablelist>    
    </para>    
    <para>
     <parameter>options</parameter> affecte l'interpr&eacute;tation du path ou de l'URL, les
     v&eacute;rifications du safe_mode et les actions &agrave; prendre lorsqu'il y a une erreur. Voyez
     <link linkend="streams.options">Stream open options</link> pour plus de d&eacute;tails sur
     ces options.
    </para>
    <para>
     Si <parameter>opened</parameter> est non NULL, il sera assign&eacute; avec le nom
     du fichier ou de la ressource qui aura &eacute;t&eacute; r&eacute;ellement ouverte. 
     C'est important lorsque l'option inclus <constant>USE_PATH</constant>, qui permet de fouiller 
     l'include_path pour rechercher le fichier. Vous, l'appelant, &ecirc;tes responsable de 
     l'appel de <function>efree</function> sur le nom de fichier retourn&eacute; par ce 
     param&egrave;tre.
    </para>
    <note>
     <simpara>
      Si vous avez sp&eacute;cifi&eacute; l'option <constant>STREAM_MUST_SEEK</constant> dans 
      <parameter>options</parameter>, le chemin retourn&eacute; dans <parameter>opened</parameter> 
      peut ne pas &ecirc;tre le m&ecirc;me que celui qui vous a &eacute;t&eacute; 
      r&eacute;ellemetn retourn&eacute;. Toutes fois, ce sera le nom de la ressource originale 
      &agrave; partir de laquelle un fl&ocirc;t &agrave; pointeur variable a &eacute;t&eacute; 
      cr&eacute;&eacute;.
     </simpara>
    </note>
   </refsect1>
  </refentry>
  
  
  <refentry id="streams.php-stream-read">
   <refnamediv>
    <refname>php_stream_read</refname>
    <refpurpose>Lit des octets depuis un fl&ocirc;t dans un buffer</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>size_t</type><methodname>php_stream_read</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
      <methodparam><type>char *</type><parameter>buf</parameter></methodparam>
      <methodparam><type>size_t</type><parameter>count</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_read</function> lit jusqu'&agrave; <parameter>count</parameter>
     octets dans le fl&ocirc;t <parameter>stream</parameter> puis les copie dans le buffer
     <parameter>buf</parameter>.
    </para>
    <para>
     <function>php_stream_read</function> retourne le nombre d'octets lus. Il n'y a 
     pas de disctinction entre une lecture qui &eacute;choue et la fin du fichier : utilisez
     <function>php_stream_eof</function> pour tester la fin du fichier avec <constant>EOF</constant>.
    </para>
    <para>
     Le pointeur de position dans le fl&ocirc;t est avanc&eacute; d'autant d'octets que le nombre
     qui en a &eacute;t&eacute; lu. Par cons&eacute;quent, la prochaine lecture reprendra l&agrave; 
     ou la lecture pr&eacute;c&eacute;dente s'est arr&ecirc;t&eacute;e.
    </para>
    <para>
     Si moins de <parameter>count</parameter> octets ont &eacute;t&eacute; lus, cet appel bloquera
     l'application jusqu'&agrave; ce que le nombre d'octets n&eacute;cessaire soit atteint, en fonction
     de la configuration du fl&ocirc;t (bloquant, non bloquant). Par d&eacute;faut, un fl&ocirc;t est 
     ouvert en mode bloquant. Lorsque vous lisez dans des fichiers classiques, le mode bloquant
     ne vous g&egrave;nera pas. Lors que le fl&ocirc;t atteint <constant>EOF</constant>
     <function>php_stream_read</function> retournera un nombre d'octets lus inf&eacute;rieur
     &agrave; <parameter>count</parameter>, puis il retournera 0 aux prochaines lectures.
    </para>
   </refsect1>
  </refentry>

  <refentry id="streams.php-stream-write">
   <refnamediv>
    <refname>php_stream_write</refname>
    <refpurpose>&eacute;crit des octets depuis un buffer vers un fl&ocirc;t</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>size_t</type><methodname>php_stream_write</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
      <methodparam><type>const char *</type><parameter>buf</parameter></methodparam>
      <methodparam><type>size_t</type><parameter>count</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_write</function> &eacute;crit <parameter>count</parameter>
     octets du buffer <parameter>buf</parameter> dans le flot <parameter>stream</parameter>.
    </para>
    <para>
     <function>php_stream_write</function> retourne le nombre d'octets qui ont
     &eacute;t&eacute; &eacute;crit. Si il y a eu une erreur, le nombre d'octets &eacute;crit sera 
     inf&eacute;rieur au param&egrave;tre <parameter>count</parameter>.
    </para>
    <para>
     Le pointeur de position dans le fl&ocirc;t est avanc&eacute; d'autant d'octets que le nombre
     qui en a &eacute;t&eacute; &eacute;crit. Par cons&eacute;quent, la prochaine &eacute;criture 
     reprendra l&agrave; ou la lecture pr&eacute;c&eacute;dente s'est arr&eacute;t&eacute;.
    </para>
   </refsect1>
  </refentry>

  <refentry id="streams.php-stream-eof">
   <refnamediv>
    <refname>php_stream_eof</refname>
    <refpurpose>V&eacute;rifie que le pointeur n'est pas au bout du fl&ocirc;t</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>int</type><methodname>php_stream_eof</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_eof</function> v&eacute;rifie que le pointeur n'est pas au bout du 
     fl&ocirc;t <parameter>stream</parameter>.
    </para>
    <para>
     <function>php_stream_read</function> retourne 1 pour indiquer la fin du fl&ocirc;t 
     (<constant>EOF</constant>), 0 si il n'y a pas de fin de fl&ocirc;t, et -1 pour indiquer une 
     erreur.
    </para>
   </refsect1>
  </refentry>

  <refentry id="streams.php-stream-getc">
   <refnamediv>
    <refname>php_stream_getc</refname>
    <refpurpose>Lit un octet dans un fl&ocirc;t</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>int</type><methodname>php_stream_getc</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_getc</function> lit un octet dans le fl&ocirc;t
     <parameter>stream</parameter> puis le retourne de type unsigned char transtyp&eacute; en
     int, ou <constant>EOF</constant> si la fin du fl&ocirc;t est atteinte, ou bien
     si une erreur est survenue.
    </para>
    <para>
     <function>php_stream_getc</function> peut bloquer l'application de la m&ecirc;me fa&ccedil;on
     que <function>php_stream_read</function> bloque.
    </para>
    <para>
     Le pointeur de position est avanc&eacute; d'une position si la lecture r&eacute;ussit.
    </para>
   </refsect1>
  </refentry>

  <refentry id="streams.php-stream-gets">
   <refnamediv>
    <refname>php_stream_gets</refname>
    <refpurpose>Lit une ligne de donn&eacute;es d'un fl&ocirc;t dans un buffer</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>char *</type><methodname>php_stream_gets</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
      <methodparam><type>char *</type><parameter>buf</parameter></methodparam>
      <methodparam><type>size_t</type><parameter>maxlen</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_gets</function> lit jusqu'&agrave; <parameter>count</parameter>-1
     octets de donn&eacute;es dans le fl&ocirc;t <parameter>stream</parameter> puis les copies dans 
     le buffer <parameter>buf</parameter>. La lecture s'arr&ecirc;te apr&egrave;s la rencontre de 
     la fin du fichier (<constant>EOF</constant>) ou une nouvelle ligne. Si la nouvelle
     ligne est lue, elle est stock&eacute;e dans <parameter>buf</parameter> dans les 
     donn&eacute;es retourn&eacute;es. Un caract&egrave;re NUL de fin de cha&icirc;ne est 
     stock&eacute; comme dernier caract&egrave;re dans le buffer.
    </para>
    <para>
     <function>php_stream_read</function> retourne <parameter>buf</parameter>
     lorsque cela focntionn, et NULL sinon.
    </para>
    <para>
     Le pointeur de position est avanc&eacute; d'une position si la lecture r&eacute;ussit.
    </para>
    <para>
     <function>php_stream_gets</function> peut bloquer l'application de la m&ecirc;me fa&ccedil;on
     que <function>php_stream_read</function> bloque.   
    </para>
   </refsect1>
  </refentry>

  <refentry id="streams.php-stream-close">
   <refnamediv>
    <refname>php_stream_close</refname>
    <refpurpose>Ferme un fl&ocirc;t</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>int</type><methodname>php_stream_close</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_close</function> ferme correctement le fl&ocirc;t 
     <parameter>stream</parameter> et lib&egrave;re les ressources qui lui sont associ&eacute;es. 
     Apr&agrave;s la fermeture de <parameter>stream</parameter>, il prend une valeur 
     ind&eacute;finie, et ne devrait plus &ecirc;tre utilis&eacute;.
    </para>
    <para>
     <function>php_stream_close</function> retourne 0 si le fl&ocirc;t a &eacute;t&eacute; 
     ferm&eacute;, ou bien <constant>EOF</constant> pour indiquer une erreur. 
     Ind&eacute;pendamment du succ&egrave;s de l'op&eacute;ration, <parameter>stream</parameter> 
     prend une valeur ind&eacute;finie, et ne devrait plus &ecirc;tre utilis&eacute;.
    </para>
   </refsect1>
  </refentry>

  <refentry id="streams.php-stream-flush">
   <refnamediv>
    <refname>php_stream_flush</refname>
    <refpurpose>Vide les buffers dans le fl&ocirc;t</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>int</type><methodname>php_stream_flush</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_flush</function> vide toutes les donn&eacute;es contenues dans
     les buffers d'&eacute;criture du fl&ocirc;t <parameter>stream</parameter> et force leur stockage.
    </para>
    <para>
     <function>php_stream_flush</function> retourne 0 si les buffers ont &eacute;t&eacute; 
     vid&eacute;s, ou si les buffers n'ont pas besoin d'&ecirc;tre vid&eacute;, mais retourne 
     <constant>EOF</constant> pour indiquer une erreur.
    </para>
   </refsect1>
  </refentry>

  <refentry id="streams.php-stream-seek">
   <refnamediv>
    <refname>php_stream_seek</refname>
    <refpurpose>Modifie la position du pointeur de fl&ocirc;t</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>int</type><methodname>php_stream_seek</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
      <methodparam><type>off_t</type><parameter>offset</parameter></methodparam>
      <methodparam><type>int</type><parameter>whence</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_seek</function> modifie la position du pointeur de
     position du fl&ocirc;t <parameter>stream</parameter>. La nouvelle position
     est d&eacute;termin&eacute;e en ajoutant <parameter>offset</parameter>
     &agrave; la position indiqu&eacute;e par <parameter>whence</parameter>.
     Si <parameter>whence</parameter> vaut <constant>SEEK_SET</constant>,
     <constant>SEEK_CUR</constant> ou <constant>SEEK_END</constant> l'offset sera 
     relativ au d&eacute;but du fl&ocirc;t, &agrave; la position courante ou &agrave; la fin du 
     fl&ocirc;t, respectivement.
    </para>
    <para>
     <function>php_stream_seek</function> retourne 0 en cas de succ&egrave;s, et -1 en cas d'erreur.
    </para>
    <note>
     <para>
     Tous les fl&ocirc;ts ne supportent pas la modification de la position du pointeur,
     m&ecirc;me si l'API va &eacute;muler un tel pointeur si <parameter>whence</parameter> vaut
     <constant>SEEK_CUR</constant> et <parameter>offset</parameter> est positif, en 
     appelant <function>php_stream_read</function> pour lire (et ignorer) 
     <parameter>offset</parameter> octets.
      </para>
      <para>
      L'&eacute;mulation est uniquement appliqu&eacute;e si l'impl&eacute;mentation du gestionnaire 
      de fl&ocirc;t suporte le pointeur de position. Si le fl&ocirc;t est (par exemple) 
      bas&eacute; sur des fichiers qui travaille avec des fl&ocirc;t de pipes, l'API de fl&ocirc;t 
      ne pourra pas appliquer une telle &eacute;mulation. Le positionnement du pointeur de 
      fl&ocirc;t &eacute;chouera et une erreur sera retourn&eacute;e.
      </para>
    </note>
   </refsect1>
  </refentry>

  <refentry id="streams.php-stream-tell">
   <refnamediv>
    <refname>php_stream_tell</refname>
    <refpurpose>D&eacute;termine la position du pointeur dans un fl&ocirc;t</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>off_t</type><methodname>php_stream_tell</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_tell</function> retourne la position du pointeur
     du fl&ocirc;t <parameter>stream</parameter>, relativement au d&eacute;but du
     fl&ocirc;t. 
     Si une erreur survient, retourne -1.
     </para>
   </refsect1>
  </refentry>

 <refentry id="streams.php-stream-copy-to-stream">
   <refnamediv>
    <refname>php_stream_copy_to_stream</refname>
    <refpurpose>Copie des donn&eacute;es d'un fl&ocirc;t &agrave; l'autre</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>size_t</type><methodname>php_stream_copy_to_stream</methodname>
      <methodparam><type>php_stream *</type><parameter>src</parameter></methodparam>
      <methodparam><type>php_stream *</type><parameter>dest</parameter></methodparam>
      <methodparam><type>size_t</type><parameter>maxlen</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_copy_to_stream</function> essaie de lire un maximum de 
     <parameter>maxlen</parameter> octets dans le fl&ocirc;t <parameter>src</parameter>
     puis de les &eacute;crire dans le fl&ocirc;t <parameter>dest</parameter>. La fonction
     retourne le nombre d'octets copi&eacute;s.
    </para>
    <para>
     Si vous souhaitez copier tous les octets restants dans le fl&ocirc;t
     <parameter>src</parameter>, passez la constante 
     <constant>PHP_STREAM_COPY_ALL</constant> comme valeur de <parameter>maxlen</parameter>.
    </para>
    <note>
     <simpara>
      Cette fonction va essayer d'effectuer la copie de la mani&egrave;re la plus efficace,
      en utilise dans buffer m&eacute;moire lorsque c'est possible.
     </simpara>
    </note>
   </refsect1>
  </refentry>

 <refentry id="streams.php-stream-copy-to-mem">
   <refnamediv>
    <refname>php_stream_copy_to_mem</refname>
    <refpurpose>Copie des donn&eacute;es depuis un fl&ocirc;t dans un buffer</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>size_t</type><methodname>php_stream_copy_to_mem</methodname>
      <methodparam><type>php_stream *</type><parameter>src</parameter></methodparam>
      <methodparam><type>char **</type><parameter>buf</parameter></methodparam>
      <methodparam><type>size_t</type><parameter>maxlen</parameter></methodparam>
      <methodparam><type>int</type><parameter>persistent</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_copy_to_mem</function> alloue un buffer de taille 
     <parameter>maxlen</parameter>+1 en utilisant la fonction <function>pemalloc</function> (en 
     passant <parameter>persistent</parameter>). Puis, elle lit <parameter>maxlen</parameter> 
     octets depuis le fl&ocirc;t  from <parameter>src</parameter> and stores them in the allocated 
     buffer.
    </para>
    <para>
     The allocated buffer is returned in <parameter>buf</parameter>, and the number of bytes 
     successfully read.  You, the caller, are responsible for freeing the buffer by passing it and 
     <parameter>persistent</parameter> to <function>pefree</function>.
    </para>
    <para>
     If you want to copy all remaining data from the <parameter>src</parameter> stream, pass the
     constant <constant>PHP_STREAM_COPY_ALL</constant> as the value of <parameter>maxlen</parameter>.
    </para>
    <note>
     <simpara>
      Cette fonction va essayer d'effectuer la copie de la mani&egrave;re la plus efficace,
      en utilise dans buffer m&eacute;moire lorsque c'est possible.
     </simpara>
    </note>
   </refsect1>
  </refentry>

 <refentry id="streams.php-stream-make-seekable">
   <refnamediv>
    <refname>php_stream_make_seekable</refname>
    <refpurpose>Convertit un fl&ocirc;t en fl&ocirc;t avec un pointeur de position</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>int</type><methodname>php_stream_make_seekable</methodname>
      <methodparam><type>php_stream *</type><parameter>origstream</parameter></methodparam>
      <methodparam><type>php_stream **</type><parameter>newstream</parameter></methodparam>
      <methodparam><type>int</type><parameter>flags</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_make_seekable</function> v&eacute;rifie si <parameter>origstream</parameter>
     dispose d'un pointeur de potision. Si ce n'est pas le cas, il va copier les donn&eacute;es
     du fl&ocirc;t dans un autre fl&ocirc;t temporaire, et disposant d'un pointeur de position.
     Si cela fonctionne, <parameter>newstream</parameter> sera un fl&ocirc;t valide
     m&ecirc;me si le fl&ocirc;t original avait d&eacute;j&agrave; un pointeur de position.
    </para>
    <para>
     <parameter>flags</parameter> vous permet de sp&eacute;cifier votre pr&eacute;f&eacute;rence
     pour le fl&ocirc;t retourn&eacute; : utilisez la constante <constant>PHP_STREAM_NO_PREFERENCE</constant> 
     pour utiliser le fl&ocirc;t &agrave; pointeur de position par d&eacute;faut (qui utilise la
     m&eacute;moire, mais passe automatiquement sur un fichier si le fichier devient trop grand),
     ou bien utilisez <constant>PHP_STREAM_PREFER_STDIO</constant> pour utiliser 
     un fichier temporaire classique.
    </para>
    <para>
     <table>
      <title>Valeurs retourn&eacute;es par <function>php_stream_make_seekable</function></title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>Valeur</entry>
         <entry>Signification</entry>
        </row>
       </thead>
       <tbody>

        <row>
         <entry>PHP_STREAM_UNCHANGED</entry>
         <entry>Le fl&ocirc;t original avait d&eacute;j&agrave; son pointeur de position. 
         <parameter>newstream</parameter> vaut <parameter>origstream</parameter>.
         </entry>
        </row>

        <row>
         <entry>PHP_STREAM_RELEASED</entry>
         <entry>Le fl&ocirc;t originl n'avait pas pointeur de position, et il a &eacute;t&eacute; 
         d&eacute;truit. Vous n'avez plus acc&egrave;s &agrave; <parameter>origstream</parameter>.
         </entry>
        </row>

        <row>
         <entry>PHP_STREAM_FAILED</entry>
         <entry>Une erreur est survenue lors de la conversion. 
         <parameter>newstream</parameter> vaut NULL;
          <parameter>origstream</parameter> est toujours valide.
         </entry>
        </row>

        <row>
         <entry>PHP_STREAM_CRITICAL</entry>
         <entry>Une erreur est survenue lors de la conversion de <parameter>origstream</parameter>,
         qui est maintenant dans un &eacute;tat ind&eacute;termin&eacute;. 
         <parameter>newstream</parameter> vaut NULL et il est tr&egrave;s recommand&eacute; que 
         vous vous fermiez <parameter>origstream</parameter>.
         </entry>
        </row>
         
       </tbody>
      </tgroup>
     </table>
    </para>
    <note>
     <simpara>
      Si vous devez d&eacute;placer le pointeur et &eacute;crire dans le fl&ocirc;t, n'utilisez 
      pas cette fonction, car le fl&ocirc;t retourn&eacute; est un fl&ocirc;t mis en cache. Il 
      n'est pas garantit qu'il soit li&eacute; &agrave; la ressource originale.
     </simpara>
    </note>
    <note>
     <simpara>
      Si vous avez uniquement de d&eacute;placer le pointeur de position vers l'avant,
      il n'y a pas besoin d'appeler cette fonction, car l'API va automatiquement
      &eacute;muler ce fonctionnement avec le param&egrave;tre whence &agrave; la valeur 
      <constant>SEEK_CUR</constant>.
     </simpara>
    </note>
    <note>
     <simpara>
      Si <parameter>origstream</parameter> repose sur le r&eacute;seau, cette fonction
      va se bloquer jusqu'&agrave; ce que tout le contenu soit t&eacute;l&eacute;charg&eacute;.
      </simpara>
    </note>
    <note>
     <simpara>
      Ne JAMAIS appeler cette fonction avec un fl&ocirc;t <parameter>origstream</parameter> qui
      est une r&eacute;f&eacute;rence &agrave; un pointeur de fichier dans un script PHP. Cette 
      fonction pourrait alors fermer le fichier, ce qui conduira &agrave; un crash au prochain 
      acc&egrave;s au pointeur.
     </simpara>
    </note>
    <note>
     <simpara>
     Dans de nombreux cas, cette fontion ne peut r&eacute;ussir que si 
     <parameter>origstream</parameter> vient d'&ecirc;tre tout juste ouvert, et qu'aucune 
     donn&eacute;es n'ont &eacute;t&eacute; mises dans les caches de la couche de fl&ocirc;t. Pour 
     cette raison, et parceque cette fonction est compliqu&eacute;e &agrave; utiliser 
     correctement, il est recommand&eacute; que vous utilisiez la fonction 
     <function>php_stream_open_wrapper</function> en lui passant la constante 
     <constant>PHP_STREAM_MUST_SEEK</constant> dans vos options, au lieu d'appeler
     cette fonction directement.
     </simpara>
    </note>
    </refsect1>
  </refentry>


<refentry id="streams.php-stream-cast">
   <refnamediv>
    <refname>php_stream_cast</refname>
    <refpurpose>Convertit un fl&ocirc;t en une autre forme, comme un FILE* ou une socket</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>int</type><methodname>php_stream_cast</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
      <methodparam><type>int</type><parameter>castas</parameter></methodparam>
      <methodparam><type>void **</type><parameter>ret</parameter></methodparam>
      <methodparam><type>int</type><parameter>flags</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_cast</function> tente de convertir le fl&ocirc;t <parameter>stream</parameter>
     en un autre ressource indiqu&eacute; par <parameter>castas</parameter>.
     Si <parameter>ret</parameter> est NULL, le fl&ocirc;t est interrog&eacute; pour savoir une telle
     conversoin est posible, sans effectuer r&eacute;ellemnt la conversion (mais
     certains &eacute;tat interne pourrait &ecirc;tre chang&eacute;s dans ce cas). Si 
     <parameter>flags</parameter> vaut <constant>REPORT_ERRORS</constant>, un message
     d'erreur appara&icirc;tra si une erreur survient durant la conversion.
    </para>
    <note>
        <para>
         Cette fonction retourne <constant>SUCCESS</constant> en cas de r&eacute;ussite et 
         <constant>FAILURE</constant> en cas d'&eacute;chec. Soyez pr&eacute;venu que vous devez
         faire une comparaison explicite avec <constant>SUCCESS</constant>
         ou <constant>FAILURE</constant> &agrave; cause des valeurs sous jacentes de ces
         constantes. Une simple comparaison d'expression bool&eacute;enne ne sera pas 
         interpr&eacute;t&eacute;e comme vous le souhaitez.
        </para>
    </note>
    <para>
     <table>
      <title>Types de ressources de <parameter>castas</parameter></title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>Valeur</entry>
         <entry>Signification</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>PHP_STREAM_AS_STDIO</entry>
         <entry>Un pointeur ANSI FILE* qui repr&eacute;sente le fl&ocirc;t</entry>
        </row>
        <row>
         <entry>PHP_STREAM_AS_FD</entry>
         <entry>Un pointeur de fichier de type POSIX qui repr&eacute;sente le fl&ocirc;t</entry>
        </row>
        <row>
         <entry>PHP_STREAM_AS_SOCKETD</entry>
         <entry>Un pointeur de socket r&eacute;seau  qui repr&eacute;sente le fl&ocirc;t</entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </para>
    <para>
     En plus des types de ressources basiques ci-dessus, le processus de conversion
     peut &ecirc;tre modifi&eacute; en utilisant les param&egrave;tres ci-dessous, ou bien en utilisant
     l'op&eacute;rateur OR pour combiner le type de ressource avec une ou plusieurs des valeurs
     suivantes : 
     <table>
      <title>Types de ressources pour <parameter>castas</parameter></title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>Valeur</entry>
         <entry>Signification</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>PHP_STREAM_CAST_TRY_HARD</entry>
         <entry>Essaie aussi fort que possible, m&ecirc;me si c'est au prix de quelques
         ressources suppl&eacute;mentaires,  que la conversion r&eacute;ussisse</entry>
        </row>
        <row>
         <entry>PHP_STREAM_CAST_RELEASE</entry>
         <entry>Informque l'API de fl&ocirc;t que d'autre code (possible une librairie tierce
         partie) sera responsable de la gestion des ressources de bas niveau. Cela fait que
         le fl&ocirc;t <parameter>stream</parameter> sera ferm&eacute; de telle fa&ccedil;on &agrave; 
         ce que le gestionnaire soit pr&eacute;serv&eacute; et retourn&eacute; dans le 
         param&egrave;tre <parameter>ret</parameter>.
         Si la fonction r&eacute;ussit, le param&egrave;tre <parameter>stream</parameter>
         doit &ecirc;tre consid&eacute;r&eacute; comme ferm&eacute;, et inutilisable en l'&eacute;tat.
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </para>
    <note>
     <simpara>
      Si votre syst&egrave;me supporte la fonction <function>fopencookie</function> (les syst&egrave;mes
      utilisant la librairie glibc 2 ou plus r&eacute;cent), l'API de fl&ocirc;t sera toujours
      capable de cr&eacute;er des pointeurs de fichiers de type ANSI FILE* pour tous les fl&ocirc;ts.
      M&ecirc;me si c'est extr&ecirc;mement utile pour passer des fl&ocirc;ts PHP &agrave; des 
      librairie tierce partie, un tel syst&egrave;me n'est pas portable. Il est demand&eacute; que 
      vous consid&eacute;riez la portabilit&eacute; e vos fonctions avant de diffuser votre 
      extension. Si l'utilisation de fopencookie() n'est pas d&eacute;sirable, il est 
      recommand&eacute; d'interroger le fl&ocirc;t pour voir si il supporte naturellement la 
      conversion en FILE* en utilisant la fonction <function>php_stream_is</function>
     </simpara>
    </note>
    <note>
     <simpara>
      Si vous demandez une socket r&eacute;seau &agrave; la place d'un FILE*, l'API de fl&ocirc;ts
      va utiliser la fonction <function>fdopen</function> pour la cr&eacute;er pour vous.
      Soyez pr&eacute;venu que faire cela risque de perdre les donn&eacute;es qui ont 
      &eacute;t&eacute; mises en buffer dans le fl&ocirc;t, si vous m&eacute;langer des appels de 
      l'API de fl&ocirc;t et les appels standards ANSI.
     </simpara>
    </note>
    <para>
     Voir aussi 
     <function>php_stream_is</function> et 
     <function>php_stream_can_cast</function>.
    </para>
   </refsect1>
  </refentry>
 
<refentry id="streams.php-stream-can-cast">
   <refnamediv>
    <refname>php_stream_can_cast</refname>
    <refpurpose>D&eacute;termine si un fl&ocirc;t peut &ecirc;tre converti en une autre forme, comme FILE* ou socket</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>int</type><methodname>php_stream_can_cast</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
      <methodparam><type>int</type><parameter>castas</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_can_cast</function> est l'&eacute;quivalent de la fonction 
     <function>php_stream_cast</function> avec le param&egrave;tre <parameter>ret</parameter>
     mis &agrave; NULL, et le param&egrave;tre <parameter>flags</parameter> mis &agrave; 0.
     Elle retourne <constant>SUCCESS</constant> si le fl&ocirc;t peut &ecirc;tre converti dans
     la forme demand&eacute;e, ou bien <constant>FAILURE</constant> si la conversion ne peut
     se faire.
    </para>
    <note>
     <simpara>
      Bien que cette fonction n'effectue aucune conversion, il est possible que certains
      &eacute;tat interne du fl&ocirc;t soient modifi&eacute;s.
     </simpara>
    </note>
    <note>
     <simpara>
      Vous devez explicitement comparer la valeur de retour avec une des constantes, comme
      d&eacute;crit dans <function>php_stream_cast</function>.
      </simpara>
    </note>
    <para>
     Voir aussi
     <function>php_stream_cast</function> et 
     <function>php_stream_is</function>.
    </para>
   </refsect1>
  </refentry>

<refentry id="streams.php-stream-is-persistent">
   <refnamediv>
    <refname>php_stream_is_persistent</refname>
    <refpurpose>D&eacute;termine si un fl&ocirc;t est un fl&ocirc;t persistant</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>int</type><methodname>php_stream_is_persistent</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_is_persistent</function> retourne  1 si le fl&ocirc;t 
     <parameter>stream</parameter> est un fl&ocirc;t persistant, et 0 sinon.
    </para>
 </refsect1>
</refentry>

<refentry id="streams.php-stream-is">
   <refnamediv>
    <refname>php_stream_is</refname>
    <refpurpose>D&eacute;termine si un fl&ocirc;t est d'un type particulier</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>int</type><methodname>php_stream_is</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
      <methodparam><type>int</type><parameter>istype</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_is</function> retourne 1 si <parameter>stream</parameter> 
     est du type sp&eacute;cifi&eacute; par <parameter>istype</parameter>, et 0 sinon.
    <table>
      <title>Valeurs possibles pour <parameter>istype</parameter></title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>Valeur</entry>
         <entry>Signification</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>PHP_STREAM_IS_STDIO</entry>
         <entry>Le fl&ocirc;t est impl&eacute;ment&eacute; en utilisant l'impl&eacute;mentation standard</entry>
        </row>
        <row>
         <entry>PHP_STREAM_IS_SOCKET</entry>
         <entry>Le fl&ocirc;t est impl&eacute;ment&eacute; en utilisant l'impl&eacute;mentation des sockets r&eacute;seau</entry>
        </row>
        <row>
         <entry>PHP_STREAM_IS_USERSPACE</entry>
         <entry>Le fl&ocirc;t est impl&eacute;ment&eacute; en utilisant l'impl&eacute;mentation de l'objet utilisateur</entry>
        </row>
        <row>
         <entry>PHP_STREAM_IS_MEMORY</entry>
         <entry>Le fl&ocirc;t est impl&eacute;ment&eacute; en utilisant l'impl&eacute;mentation m&eacute;moire &agrave; taille automatique</entry>
        </row>
       </tbody>
      </tgroup>
     </table>

    </para>
    <note>
     <simpara>
      Les constantes PHP_STREAM_IS_XXX sont en fait d&eacute;finies comme des  pointeurs
      sur la structure des op&eacute;rations de base. Si vous extension (ou une autre extension
      d&eacute;finit des fl&ocirc;ts additionnels), il faut qu'elle d&eacute;clare aussi les constantes
      PHP_STREAM_IS_XXX dans ses ent&ecirc;tes, pour que vous puissiez les utiliser comme
      base de comparaison.
      </simpara>
    </note>
    <note>
     <simpara>
      Cette fonction est impl&eacute;ment&eacute;e comme une comparaison de pointeurs simple
      (et rapide), et ne modifie pas l'&eacute;tat du fl&ocirc;t.
     </simpara>
    </note>
    <para>
     Voir aussi 
     <function>php_stream_cast</function> et 
     <function>php_stream_can_cast</function>.
    </para>
   </refsect1>
  </refentry>
  
  <refentry id="streams.php-stream-passthru">
   <refnamediv>
    <refname>php_stream_passthru</refname>
    <refpurpose>Affiche toutes les donn&eacute;es restantes d'un fl&ocirc;t</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>size_t</type><methodname>php_stream_passthru</methodname>
      <methodparam><type>php_stream *</type><parameter>stream</parameter></methodparam>
     </methodsynopsis>
     <para>
      <function>php_stream_passthru</function> affiche tous les octets restant dans le
      fl&ocirc;t <parameter>stream</parameter> vers le buffer de sortie. Les donn&eacute;es sont
      &eacute;crites directement dans le buffer de sortie, qui sera le navigateur dans le cas
      de PHP sur un serveur web, ou la sortie standard dans le cas de PHP en mode 
      de ligne de commande. Cette fonction essaie d'utiliser des fichiers en m&eacute;moire
      pour acc&eacute;l&eacute;rer l'ex&eacute;cution.
     </para>
    </refsect1>
  </refentry>

  <refentry id="streams.php-register-url-stream-wrapper">
   <refnamediv>
    <refname>php_register_url_stream_wrapper</refname>
    <refpurpose>Enregistre un gestionnaire pour l'API de fl&ocirc;ts</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>int</type><methodname>php_register_url_stream_wrapper</methodname>
      <methodparam><type>char *</type><parameter>protocol</parameter></methodparam>
      <methodparam><type>php_stream_wrapper *</type><parameter>wrapper</parameter></methodparam>
      <methodparam><type>TSRMLS_DC</type><parameter></parameter></methodparam>
     </methodsynopsis>
     <para>
      <function>php_register_url_stream_wrapper</function> enregistre le gestionnaire
      <parameter>wrapper</parameter> pour le protocole <parameter>protocol</parameter>.
     </para>
     <note>
      <simpara>
       Si vous appelez cette fonction dans un module dynamiquement charg&eacute;, vous DEVEZ
       appeler la fonction <function>php_unregister_url_stream_wrapper</function>
       dans la fonction de terminaison de votre module, sinon PHP 
       va crasher.
      </simpara>
     </note>
    </refsect1>
  </refentry>

  <refentry id="streams.php-unregister-url-stream-wrapper">
   <refnamediv>
    <refname>php_unregister_url_stream_wrapper</refname>
    <refpurpose>D&eacute;senregistre un gestionnaire pour l'API de fl&ocirc;ts</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>int</type><methodname>php_unregister_url_stream_wrapper</methodname>
      <methodparam><type>char *</type><parameter>protocol</parameter></methodparam>
      <methodparam><type>TSRMLS_DC</type><parameter></parameter></methodparam>
     </methodsynopsis>
     <para>
      <function>php_unregister_url_stream_wrapper</function> d&eacute;senregistre le gestionnaire
      associ&eacute; avec le protocole <parameter>protocol</parameter>.
     </para>
    </refsect1>
  </refentry>

  <refentry id="streams.php-stream-open-wrapper-ex">
   <refnamediv>
    <refname>php_stream_open_wrapper_ex</refname>
    <refpurpose>Ouvre un fl&ocirc;t avec un fichier ou une URL, en sp&eacute;cifiant le contexte</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>php_stream *</type><methodname>php_stream_open_wrapper_ex</methodname>
      <methodparam><type>char *</type><parameter>path</parameter></methodparam>
      <methodparam><type>char *</type><parameter>mode</parameter></methodparam>
      <methodparam><type>int</type><parameter>options</parameter></methodparam>
      <methodparam><type>char **</type><parameter>opened</parameter></methodparam>
      <methodparam><type>php_stream_context *</type><parameter>context</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_open_wrapper_ex</function> est exactement comme 
     <function>php_stream_open_wrapper</function>, mais vous permet de sp&eacute;cifier un
     objet de type php_stream_context avec le param&egrave;tre <parameter>context</parameter>.
     Pour en savoir plus sur les contextes, voyez ... une section qui viendra plus
     tard.
    </para>
    </refsect1>
    </refentry>

  <refentry id="streams.php-stream-open-wrapper-as-file">
   <refnamediv>
    <refname>php_stream_open_wrapper_as_file</refname>
    <refpurpose>Ouvre un fl&ocirc;t avec un fichier ou une URL, et le convertit en pointeur FILE*</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
     <methodsynopsis>
      <type>FILE *</type><methodname>php_stream_open_wrapper_as_file</methodname>
      <methodparam><type>char *</type><parameter>path</parameter></methodparam>
      <methodparam><type>char *</type><parameter>mode</parameter></methodparam>
      <methodparam><type>int</type><parameter>options</parameter></methodparam>
      <methodparam><type>char **</type><parameter>opened</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>php_stream_open_wrapper_as_file</function> est exactement identique
     &agrave; la fonction <function>php_stream_open_wrapper</function>, mais convertit le
     fl&ocirc;t en un pointeur ANSI FILE* puis le retourne &agrave; la place du fl&ocirc;t. C'est un
     raccourci commode pour les extensions qui passent des pointeurs FILE* aux 
     librairies tierce partie.
    </para>
    </refsect1>
    </refentry>

  
</sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->

