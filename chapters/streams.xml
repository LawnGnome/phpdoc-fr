<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.6 $ -->
<!-- EN-Revision: 1.1 Maintainer: nobody Status: partial -->
<!-- Author: Wez Furlong <wez@thebrainroom.com>
  Please contact me before making any major amendments to the
  content of this section.  Splitting/Merging are fine if they are
  required for php-doc restructuring purposes - just drop me a line
  if you make a change (so I can update my local copy).
-->

<chapter id="streams">
 <title>API de flux les auteurs d'extensions</title>

 <sect1 id="streams.overview">
  <title>Présentation</title>
  <para>
   Les flux de PHP proposent une approche unifiée à la gestion des
   fichiers et sockets, depuis une extension PHP. En utilisant l'API
   standard, les flux vous permettent d'accéder à des fichiers, des 
   sockets, des URL, de la mémoire ou encore des objets définis dans des
   scripts. Les flux (streams en anglais), sont une API flexible et
   dynamique, dynamiquement chargée dans les modules (et les scripts!).
  </para>
  <para>
   Le but des flux est de proposer une API confortables pour les programmeurs,
   lors des manipulations de fichiers, URL et autres sources de données linéaires.
   L'API unifiée est très simple à comprendre : elle est plus ou moins basée sur
   la famille de fonction classiques C d'entrée/sortie (avec les mêmes concepts
   pour la plupart des fonctions) : les programmeurs C ne seront pas dépaysés.
  </para>
  <para>
    L'API des flux intervient à différents niveaux : à la base, elle définit un
    objet php_stream, qui représente les sources de données. A un niveau au dessus,
    l'API défini un objet php_stream_wrapper qui s'interface avec l'API de bas
    niveau, pour lire et écrire les données et méta données, dans les sources.
  </para>
  <para>
   Les flux peuvent être converti en pilotes pour fichiers, de manière à être
   utilisé par des librairies tierce-partie avec beaucoup de facilité. Cela 
   autorise ces librairies à accéder aux données directement depuis des sources
   représentées par des URL. Si votre système supporte la fonction
   <function>fopencookie</function>, vous pouvez même passer n'importe quel
   flux PHP à une autre librairie qui utilise les entrée/sortie standard ANSI!
  </para>
 </sect1>

 <sect1 id="streams.basics">
  <title>Eléments de bases</title>
  <para>
   Utiliser les flux ressemble énormément à l'utilisation des fonctions 
   d'entrée/sortie standard ANSI streams. La principale différence est que
   vous devez créer le pointeur de flux d'abord. Dans la plupart des
   cas, vous utiliserez la fonction <function>php_stream_open_wrapper</function>
   pour l'obtenir. Cette fonction ressemble à fopen(),
   comme le montre l'exemple ci-dessous : 
  </para>
  <para>
     <example>
      <title>Exemple de flux qui affiche la page de PHP.net</title>
      <programlisting role="c">
<![CDATA[
php_stream * stream = php_stream_open_wrapper("http://www.php.net", "rb", REPORT_ERRORS, NULL);
if (stream) {
    while(!php_stream_eof(stream)) {
        char buf[1024];
        
        if (php_stream_gets(stream, buf, sizeof(buf))) {
            printf(buf);
        } else {
            break;
        }
    }
    php_stream_close(stream);
}
]]>
      </programlisting>
     </example>
  </para>
  <para>
   La table ci-dessous montre les fonctions de flux équivalentes aux fonctions
   ANSI. Sauf indication contraire, les fonctionnalités sont les mêmes.
     <table>
      <title>ANSI stdio equivalent functions in the Streams API</title>
      <tgroup cols="3">
       <thead>
        <row>
         <entry>Fonction ANSI</entry>
         <entry>Fonction Flux PHP</entry>
         <entry>Notes</entry>
        </row>
       </thead>
       <tbody>

        <row>
         <entry>fopen</entry>
         <entry>php_stream_open_wrapper</entry>
         <entry>Les flux incluent des paramètres supplémentaires</entry>
        </row>

        <row>
         <entry>fclose</entry>
         <entry>php_stream_close</entry>
         <entry></entry>
        </row>

        <row>
         <entry>fgets</entry>
         <entry>php_stream_gets</entry>
         <entry></entry>
        </row>

        <row>
         <entry>fread</entry>
         <entry>php_stream_read</entry>
         <entry>Le paramètre nmemb est suppos avoir la valeur 1 : le prototype ressemble plutôt à read(2)</entry>
        </row>

        <row>
         <entry>fwrite</entry>
         <entry>php_stream_write</entry>
         <entry>Le paramètre nmemb est suppos avoir la valeur 1 : le prototype ressemble plutôt à write(2)</entry>
        </row>

        <row>
         <entry>fseek</entry>
         <entry>php_stream_seek</entry>
         <entry></entry>
        </row>

        <row>
         <entry>ftell</entry>
         <entry>php_stream_tell</entry>
         <entry></entry>
        </row>

        <row>
         <entry>rewind</entry>
         <entry>php_stream_rewind</entry>
         <entry></entry>
        </row>

        <row>
         <entry>feof</entry>
         <entry>php_stream_eof</entry>
         <entry></entry>
        </row>

        <row>
         <entry>fgetc</entry>
         <entry>php_stream_getc</entry>
         <entry></entry>
        </row>

        <row>
         <entry>fputc</entry>
         <entry>php_stream_putc</entry>
         <entry></entry>
        </row>

        <row>
         <entry>fflush</entry>
         <entry>php_stream_flush</entry>
         <entry></entry>
        </row>

        <row>
         <entry>puts</entry>
         <entry>php_stream_puts</entry>
         <entry>Identique à puts, et non pas à fputs</entry>
        </row>

        <row>
         <entry>fstat</entry>
         <entry>php_stream_stat</entry>
         <entry>Les informations des flux sont plus riches</entry>
        </row>
         
       </tbody>
      </tgroup>
     </table>
   
  </para>
 </sect1>
 <sect1 id="streams.resources">
  <title>Les flux qui sont des ressources</title>
  <para>
   Tous les flux sont enregitrés comme des ressources lorsqu'il sont créés.
   Cela garantit qu'ils seront convenablement déblayés de la mémoire, même
   en cas d'erreur fatale. Toutes les fonctions du sytème de fichier de &php;
   opère sur des ressources : cela signifie que vos extensions peuvent accepter
   des pointeurs de fichiers comme paramètre, et retourner des flux. L'API des
   flux rend ce processus très convivial.
  </para>
  <para>
     <example>
      <title>Comment accepter un flux comme paramètre d'entrée</title>
      <programlisting role="c">
<![CDATA[
PHP_FUNCTION(example_write_hello)
{
    zval *zstream;
    php_stream *stream;
    
    if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "r", &zstream))
        return;
    
    php_stream_from_zval(stream, &zstream);

    /* Vous pouvez maintenant utiliser votre flux. Cependant, vous ne 
       "possédez" pas le flux, mais le script le possède. Cela signifie
       que vous de DEVEZ PAS fermer le flux, car sinon, PHP va crasher! */

    php_stream_write(stream, "hello\n");
        
    RETURN_TRUE();
}
]]>
      </programlisting>
     </example>
  </para>
  <para>
     <example>
      <title>Comment retourner un flux depuis une fonction</title>
      <programlisting role="c">
<![CDATA[
PHP_FUNCTION(example_open_php_home_page)
{
    php_stream *stream;
    
    stream = php_stream_open_wrapper("http://www.php.net", "rb", REPORT_ERRORS, NULL);
    
    php_stream_to_zval(stream, return_value);

    /* A partir de ce moment, le flux appartient au script.
      Si vous le fermer ici, vous allez faire crasher PHP! */
}
]]>
      </programlisting>
     </example>
  </para>
  <para>
   Comme les flux sont automatiquement déblayés de la mémoire, il est tentant de
   penser que vous pouvez être des programmeurs paresseux et ne pas vous préoccuper
   de la fermeture du flux lorsque vous en avez terminé avec lui. Même si une telle
   approche fonctionnera probablement, ce n'est pas une bonne idée pour un bon
   nombre de raisons : les flux conservent des verrous sur les ressources
   systèmes durant un temps plus long, ce qui fait que laisser le verrous empêche
   d'autres processus d'accéder à cette ressource. Si le script gère un grand
   nombre de fichier, l'accumulation de ressources, en terme de mémoire et de
   nombre de fichiers ouverts, causer l'échec des requêtes du serveur web. Cela n'est
   plus aussi séduisant, n'est-ce pas? L'API de flux inclut un peu de magie pour
   que vous puissiez garder votre code propre : si un flux n'est pas fermé par 
   votre code alors qu'il devrait l'être, vous trouverez des informations de
   débogage dans le fichier d'historique d'erreur de votre serveur web.
  </para>
  <note>
   <simpara>
    Utilisez toujours une version de débogagge de &php; lorsque vous développez
    (<option>--enable-debug</option> lors de la configuration de la compilation)
    car de nombreux efforts ont été fait pour vous aider à traquer les fuites
    de mémoire.
   </simpara>
  </note>
  <para>
   Dans certains cas, il est pratique de garder un flux ouvert pour toute la
   durée de la requête, afin de l'utiliser comme fichier d'historique. Ecrire le
   code nécessaire au nettoyage propre d'un tel fichier n'est pas difficile, mais
   ce sont plusieurs lignes e code qui ne sont pas strictement nécessaire. Pour 
   vous éviter l'écriture de ce code, vous pouvez marquer le flux pour qu'il soit
   automatiquement libéré lorsque viendra le temps de libérer les ressources.
   Pour cela, vous pouvez utiliser la fonction <function>php_stream_auto_cleanup</function>.
  </para>
 </sect1>
 
&chapters.streams.common;
&chapters.streams.dir;
&chapters.streams.file;
&chapters.streams.socket;
&chapters.streams.structs;
&chapters.streams.constants;
 
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->

