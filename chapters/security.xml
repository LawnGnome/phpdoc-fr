<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.26 $ -->
 <chapter id="security.index">
  <title>Sécurité</title>
  <simpara>
    PHP est un langage puissant et l'interpréteur, qu'il soit inclus dans le
    serveur web ou bien compilé en version CGI, est capable d'accéder
    aux fichiers, d'exécuter des commandes et d'ouvrir des connexions
    réseaux.  Toutes ces propriétés rendent fragile la
    sécurité d'un serveur web. Le langage PHP a été
    pensé afin d'être un langage beaucoup plus sécurisé
    pour écrire des <acronym>CGI</acronym> que le Perl ou le langage C. De
    plus, une sélection rigoureuse des options de compilation et
    d'exécution vous permettra d'obtenir un équilibre
    parfait entre liberté et sécurité.
  </simpara>
  <simpara>
    Etant donné qu'il y a de nombreux moyens d'utiliser le langage PHP,
    il y a de nombreuses directives de configuration afin d'en contrôler
    le comportement. Un grand nombre d'options permettent d'utiliser le PHP
    dans de nombreuses situations, mais cela signifie aussi qu'il y a certaines
    combinaisons d'options de compilation et d'exécution qui fragilisent
    la sécurité du serveur. Ce chapitre explique comme les
    différentes options de configuration peuvent être
    combinées, tout en conservant une sécurité maximum.
  </simpara>
  <simpara>
   La flexibilité de configuration de PHP est épaulée par
   la flexibilité du code. PHP peut être compilé pour
   constituer une application serveur complète, avec toutes
   les fonctionnalités d'un shell, ou il peut encore
   être utilisé comme simple SSI (server side include)
   avec peu de risque, dans un environnement à sécurité
   renforcée. Comment créer cet environnement et le
   sécuriser est largement à la charge du
   développeur PHP.
  </simpara>
  <simpara>
   Ce chapitre commence par expliquer les différentes options de configuration
   et les situations dans lesquelles elles peuvent être utilisées en
   toute sécurité. Puis, viennent les considérations de
   niveaux de sécurité, et les conseils généraux.
  </simpara>
  <sect1 id="security.general">
   <title>Considérations générales</title>
   <simpara>
    Un système complètement sûr est une impossiblité virtuelle. 
    L'approche souvent utilisée par les professionnels de la
    sécurité est d'équilibrer les risques et l'ergonomie.
    Si chaque variable fournie par l'utilisateur demandait deux
    formes de validation biométrique (un scan de la rétine et
    une empreinte digitale), on obtiendrait un système avec
    un niveau de sécurité d'un bon niveau. Il faudrait aussi une
    bonne heure pour remplir un formulaire simple, ce qui encouragerait
    les utilisateurs à trouver un moyen de contourner cette sécurité.
   </simpara>
   <simpara>
    La meilleure sécurité est suffisamment discrète pour assurer
    un maximum de sécurité sans ajouter de contraintes insurmontables
    pour l'utilisateur ou de systèmes complexes de programmation.
    Souvent, les attaques sur un script sont des exploitations 
    des systèmes de sécurité trop complexes, qui s'érodent au cour
    du temps.
   </simpara>
   <simpara>
    Un principe qu'il est bon de retenir : Un système est aussi sur
    que son maillon le plus faible. Si toutes les transactions sont
    bien notées dans une base, avec confirmation mais que l'utilisateur
    n'est authentifié que par un cookie, la robustesse de votre
    système est sévèrement réduite.
   </simpara>
   <simpara>
    Lorsque vous testez votre site, gardez en tête que vous ne pourrez
    jamais tester toutes les situations, même pour les pages les plus
    simples. Les valeurs que vous attendez seront toujours complétement
    différentes des valeurs entrées par un employé négligent, un hacker qui a toute
    la nuit devant lui ou encore le chat de la maison qui marche sur le clavier.
    C'est pourquoi il est préférable de regarder le code d'un point de vue
    logique, pour repérer les points d'entrée des données inattendues,
    puis de voir comment elles pourront être modifiées, 
    amplifiées ou réduites.
   </simpara>
   <simpara>
    L'Internet est rempli d'individus qui tentent de se faire une renommée
    en piratant vos programmes, en bloquant votre site, en envoyant des contenus
    inappropriés, qui rendent vos journées si &quot;spéciales&quot;.
    Peu importe que vous ayez un grand portail ou un petit web, vous pouvez
    être la cible pour tout quidam avec une connexion. Vous êtes une
    cible potentielle dès que vous êtes connecté vous-même.
    Certains programmes de piratage ne font pas dans la demi-mesure, et
    testent systématiquement des millions d'IP, à la recherche
    de victimes : ne soyez pas la prochaine.
   </simpara>
  </sect1>
  <sect1 id="security.cgi-bin">
   <title>Binaires CGI</title>
   <sect2 id="security.cgi-bin.attacks">
    <title>Faiblesses connues</title>
    <simpara>
         Utiliser le PHP comme un <acronym>CGI</acronym> exécutable vient
      la majorité du temps du fait que l'on ne veut pas l'utiliser comme un module
      du serveur web, (comme Apache), ou bien que l'on souhaite l'utiliser en
      combinaison d'un <acronym>CGI</acronym> complémentaire, afin de
      créer un environnement de script sécurisé (en utilisant
      des techniques de chroot ou setuid). Une telle décision signifie
      habituellement que vous installez votre exécutable dans le
      répertoire cgi-bin de votre serveur web.
    <ulink url="&url.cert;">CERT CA-96.11</ulink> recommande effectivement de
    placer l'interpréteur à l'intérieur du répertoire
    cgi-bin. Même si le binaire PHP peut être utilisé comme
    interpréteur indépendant, PHP a été
    pensé afin de rendre impossible les attaques que ce type
    d'installation induit.
    </simpara>
    <itemizedlist>
     <listitem>
      <simpara>
       Accès au système de fichier:
       <filename role="url">http://ma.machine/cgi-bin/php?/etc/passwd</filename>
      </simpara>
      <simpara>
       Lorsque la requête est passée dans une url, après le point
       d'interrogation (?), elle est envoyée à l'interpréteur
       comme une ligne de commande par l'interface CGI. Habituellement,
       l'interpréteur ouvre le fichier spécifié et
       l'exécute.
      </simpara>
      <simpara>
       Lorsqu'il est invoqué comme exécutable CGI, le PHP refuse
          d'interpréter les arguments de la ligne de commande.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Accès d'un document web sur le serveur :
       <filename role="url">http://my.host/cgi-bin/php/secret/doc.html</filename>
      </simpara>
      <simpara>
           Le "path information" dans l'url, situé juste après le nom
           de l'exécutable PHP, <filename role="uri">/secret/doc.html</filename> est
           utilisé par convention pour spécifier le nom du fichier
           qui doit être ouvert et interprété par le programe
           <acronym>CGI</acronym>. Habituellement, des directives de configuration
           du serveur web (pour le serveur Apache: Action) sont utilisées pour
           rediriger les requêtes afin d'obtenir un document
           <filename role="url">http://my.host/secret/script.php</filename> par
           l'interpréteur PHP. Dans une telle configuration, le serveur web
           vérifie d'abord s'il a accès au répertoire
           <filename role="uri">/secret</filename>, et après cette
           vérification redirige la requête vers
           <filename role="url">http://my.host/cgi-bin/php/secret/script.php</filename>.
           Malheureusement, si la requête est faite directement sous cette forme,
           aucune vérification d'accès n'est faite par le serveur web
           pour le fichier <filename role="uri">/secret/script.php</filename>,
           mais uniquement pour le fichier <filename role="uri">/cgi-bin/php</filename>.
           De cette manière, n'importe quel utilisateur qui peut accéder
           au fichier <filename role="uri">/cgi-bin/php</filename> peut aussi
           accéder aux documents protégés sur le serveur web.
      </simpara>
      <simpara>
       Avec le PHP, l'option de compilation
       <link linkend="install.configure.enable-force-cgi-redirect">--enable-force-cgi-redirect</link>
       et les options d'exécution <link linkend="ini.doc-root">doc_root</link>
       et <link linkend="ini.user-dir">user_dir</link> peuvent être
       utilisées pour prévenir ce genre d'attaques, si des restrictions
       d'accès sont appliquées sur les documents du serveur. Voir
       ci-dessous pour des explications plus complètes sur les
       différentes combinaisons.
      </simpara>
     </listitem>
    </itemizedlist>
   </sect2>
   <sect2 id="security.cgi-bin.default">
    <title>Cas 1: Tous les fichiers sont publics</title>
    <simpara>
      Si votre serveur n'a aucun document dont l'accès est restreint
      par un mot de passe ou un système de vérification de l'adresse
      IP, vous n'avez aucun besoin de ce type de configuration. Si votre serveur web
      ne permet pas les redirections, ou si votre serveur web n'a aucun besoin de
      communiquer avec le binaire PHP de manière sécurisée,
      vous pouvez utiliser l'option de compilation
      <link linkend="install.configure.enable-force-cgi-redirect">--disable-force-cgi-redirect</link>.
      Vous devez quand même vérifier qu'aucun script ne fait appel
      au PHP, de manière directe,
      <filename role="php">http://my.host/cgi-bin/php/dir/script.php</filename>
      ou bien de manière indirecte, par redirection,
      <filename role="php">http://my.host/dir/script.php</filename>.
    </simpara>
    <simpara>
      Les redirections peuvent être configurées dans les fichiers
      de configuration d'Apache en utilisant les directives "AddHandler" et
      "Action" (voir ci-dessous).
    </simpara>
   </sect2>
   <sect2 id="security.cgi-bin.force-redirect">
    <title>
      Cas 2: Utilisation de la directive de compilation
      <link linkend="install.configure.enable-force-cgi-redirect">--enable-force-cgi-redirect</link>
    </title>
    <simpara>
      Cette option de compilation prévient quiconque d'appeler
      directement un script avec l'url
      <filename role="php">http://my.host/cgi-bin/php/secretdir/script.php</filename>.
      Dans ce cas-là, PHP parsera le fichier uniquement s'il y a eu redirection.
    </simpara>
    <simpara>
      Habituellement, le serveur web Apache réalise une redirection
      grâce aux directives suivantes :
    </simpara>
    <programlisting role="apache-conf">
<![CDATA[
Action php-script /cgi-bin/php
AddHandler php-script .php
]]>
    </programlisting>
    <simpara>
      Cette option a uniquement été testée avec Apache et
      compte sur Apache pour affecter la variable d'environnement non-standard
      <envar>REDIRECT_STATUS</envar> pour les requêtes redirigées.
      Dans le cas où votre serveur web ne supporte pas le renseignement
      du PHP, pour savoir si la requête a été
      redirigée ou non, vous ne pouvez pas utiliser cette option de
      compilation. Vous devez alors utiliser une des autres méthodes
      d'exploitation de la version binaire CGI du PHP, comme exposé ci-dessous.
    </simpara>
   </sect2>
   <sect2 id="security.cgi-bin.doc-root">
    <title>Cas 3: Utilisation du "doc_root" ou du "user_dir"</title>
    <simpara>
      Ajouter un contenu interactif dans votre serveur web, comme des scripts
      ou des exécutables, est souvent considéré comme une
      pratique non-sécurisée. Si, par erreur, le script n'est pas
      exécuté mais affiché comme une page HTML classique,
      il peut en résulter un vol de propriété intellectuelle
      ou des problèmes de sécurité à propos des mots
      de passe notamment. Donc, la majorité des administrateurs
      préfèrent mettre en place un répertoire
      spécial pour les scripts qui soit uniquement accessible par le biais
      du binaire CGI du PHP, et donc, tous les fichiers de ce répertoire
      seront interprétés et non affichés tels quels.
    </simpara>
    <simpara>
      Aussi, si vous ne pouvez pas utiliser la méthode
      présentée ci-dessus, il est nécessaire de mettre
      en place un répertoire "doc_root" différent de votre
      répertoire "document root" de votre serveur web.
    </simpara>
    <simpara>
      Vous pouvez utiliser la directive <link linkend="ini.doc-root">doc_root</link>
      dans le <link linkend="configuration.file">fichier de configuration</link>,
      ou vous pouvez affecter la variable d'environnement
      <envar>PHP_DOCUMENT_ROOT</envar>. Si cette variable d'environnement
      est affectée, le binaire <acronym>CGI</acronym> du PHP construira
      toujours le nom de fichier à ouvrir avec <parameter>doc_root</parameter>
      et le "path information" de la requête, et donc vous serez sûr
      qu'aucun script n'est exécuté en dehors du répertoire
      prédéfini (à l'exception du répertoire
      désigné par la directive <parameter>user_dir</parameter>
      Voir ci-dessous).
    </simpara>
    <simpara>
     Une autre option possible ici est la directive
     <link linkend="ini.user-dir">user_dir</link>. Lorsque la directive n'est pas
     activée, seuls les fichiers contenus dans le répertoire
     <parameter>doc_root</parameter> peuvent être ouverts.
     Ouvrir un fichier possédant l'url
     <filename role="url">http://my.host/~user/doc.php</filename> ne correspond
     pas à l'ouverture d'un fichier sous le répertoire racine de
     l'utilisateur mais à l'ouverture du fichier
     <filename role="uri">~user/doc.php</filename> sous le repertoire
     "doc_root" (oui, un répertoire commence par un tilde
     [<literal>~</literal>]).
    </simpara>
    <simpara>
      Si la directive "user_dir" est activée à la valeur
      <filename role="dir">public_php</filename> par exemple, une requête
      du type <filename role="url">http://my.host/~user/doc.php</filename>
      ouvrira un fichier appelé <filename>doc.php</filename> sous le
      répertoire appelé <filename role="dir">public_php</filename>
      sous le répertoire racine de l'utilisateur.
      Si le répertoire racine des utilisateurs est
      <filename role="dir">/home/user</filename>, le fichier exécuté
      sera <filename>/home/user/public_php/doc.php</filename>.
    </simpara>
    <simpara>
      <parameter>user_dir</parameter> et <parameter>doc_root</parameter> sont
      deux directives totalement indépendantes et donc vous pouvez
      contrôler l'accès au répertoire "document root"
      séparément des répertoires "user directory".
    </simpara>
   </sect2>
   <sect2 id="security.cgi-bin.shell">
    <title>
     Cas 4: L'exécutable PHP à l'extérieur de l'arborescence du serveur
    </title>
    <para>
      Une solution extrêmement sécurisée consiste à
      mettre l'exécutable PHP à l'extérieur de l'arborescence
      du serveur web. Dans le répertoire
      <filename role="dir">/usr/local/bin</filename>, par exemple.
      Le problème de cette méthode est que vous aurez à
      rajouter la ligne suivante :
     <informalexample>
      <programlisting role="cgi">
<![CDATA[
#!/usr/local/bin/php
]]>
      </programlisting>
     </informalexample>
     dans tous les fichiers contenant des tags PHP. Vous devrez aussi rendre le
     binaire PHP exécutable. Dans ce cas-là, traitez le fichier
     exactement comme si vous aviez un autre script écrit en Perl ou en
     sh ou en un autre langage de script qui utilise <literal>#!</literal> comme
     mécanisme pour lancer l'interpréteur lui-même.
    </para>
    <para>
      Pour que l'exécutable PHP prenne en compte les variables
      d'environnement <envar>PATH_INFO</envar> et
      <envar>PATH_TRANSLATED</envar> correctement avec cette configuration,
      vous devez utiliser l'option de compilation
      <link linkend="install.configure.enable-discard-path">--enable-discard-path</link>.
    </para>
   </sect2>
  </sect1>
  <sect1 id="security.apache">
   <title>Module Apache</title>
   <simpara>
     Lorsque le PHP est compilé en tant que module Apache, ce module
     hérite des permissions accordées à l'utilisateur
     faisant tourner Apache ( par défaut, l'utilisateur "nobody").
     Par exemple, si vous utilisez PHP pour accéder à une
     base de données, à moins que la base n'ait un
     système de droits d'accès interne, vous devrez rendre
     la base accessible à l'utilisateur "nobody". Cela signifie
     qu'un script mal intentionné peut accéder à la base,
     la modifier sans authentification. Il est aussi possible qu'un
     robot accède à la page d'administration, et
     détruise toutes les pages. Vous devez aussi protéger
     vos bases de données avec les autorisations Apache, ou
     définir votre propre modèle d'accès avec
     LDAP, .htaccess, etc... et inclure ce code dans tous vos scripts
     PHP.
   </simpara>
   <simpara>
    Souvent, lorsqu'on a établi les droits de l'utilisateur
    PHP (ici, l'utilisateur Apache) pour minimiser les risques, on
    s'aperçoit que PHP ne peut plus écrire de virus dans
    les fichiers des utilisateurs. Ou encore, modifier une base
    de données privée. Il est aussi incapable de modifier
    des fichiers qu'il devrait pouvoir modifier, ou effectuer
    certaines transactions.
   </simpara>
   <simpara>
    Une erreur fréquente de sécurité est de donner
    à l'utilisateur Apache les droits de superadministrateur.
   </simpara>
   <simpara>
    Donner de telles permissions à l'utilisateur Apache est extrêmement
    dangereux, et peut compromettre tout le système, telle que l'utilisation
    des <literal>sudo</literal> ou du <literal>chroot</literal>.
    Pour les professionnels de la sécurité, une telle utilisation
    est à exclure d'office.
   </simpara>
   <simpara>
    Il existe des solutions plus simples. En utilisant
    <function>open_basedir</function> vous pouvez contrôler et restreindre
    l'accès à certains dossiers qui pourront être utilisés par PHP. Vous pouvez
    aussi créer des aires de restriction Apache, pour restreindre les activités
    anonymes liées aux internautes.
   </simpara>
  </sect1>
    <sect1 id="security.filesystem">
   <title>Sécurité des fichiers</title>
   <simpara>
    PHP est soumis aux règles de sécurité
    intrinsèques de la plupart des systèmes serveurs :
    il respecte notamment les droits des fichiers et des dossiers.
    Une attention particulière doit être portée aux
    fichiers ou dossiers qui sont accessibles à tout le monde, afin de
    s'assurer qu'ils ne divulguent pas d'informations critiques.
   </simpara>
   <simpara>
    Puisque PHP a été fait pour permettre aux utilisateurs
    d'accéder aux fichiers, il est possible de créer un
    script qui vous permet de lire des fichiers tels que /etc/password,
    de modifier les connexions ethernet, lancer des impressions de documents,
    etc... Cela implique notamment que vous devez vous assurer que les fichiers
    accédés par les scripts sont bien ceux qu'il faut.
   </simpara>
   <simpara>
    Considérez le script suivant, où l'utilisateur indique
    qu'il souhaite effacer un fichier dans son dossier racine. Nous
    supposons que PHP est utilisé comme interface web pour
    gérer les fichiers, et que l'utilisateur Apache est
    autorisé à effacer les fichiers dans le dossier racine des
    utilisateurs.
   </simpara>
   <para>
    <example>
     <title>Une erreur de vérification de variable conduit à ...</title>
     <programlisting role="php">
<![CDATA[
<?php
// Efface un fichier dans un dossier racine
$username = $_POST['user_submitted_name'];
$homedir = "/home/$username";
$file_to_delete = "$userfile";
unlink ($homedir/$userfile);
echo "$file_to_delete a été effacé!";
?>
]]>
     </programlisting>
    </example>
    Etant donné que le nom de l'utilisateur est à fournir, des intrus peuvent
    envoyer un nom d'utilisateur autre que le leur, et effacer des
    documents dans les comptes des autres utilisateurs.
    Dans ce cas, vous souhaiterez utiliser une autre forme d'authentification.
    Considérez ce qui pourrait se passer si les utilisateurs passent
    "../etc/" et "passwd" comme arguments! Le code serait exécuté
    tel que :
    <example>
     <title>Une attaque du système de fichiers!</title>
     <programlisting role="php">
<![CDATA[
<?php
// efface un fichier n'importe où sur le disque dur,
// où l'utilisateur PHP a accès. Si PHP a un accès root :
$username = "../etc/";
$homedir = "/home/../etc/";
$file_to_delete = "passwd";
unlink ("/home/../etc/passwd");
echo "/home/../etc/passwd a été effacé!";
?>
]]>
     </programlisting>
    </example>
    Il y a deux mesures primordiales à prendre pour éviter
    ces manoeuvres :
    <itemizedlist>
     <listitem>
      <simpara>
       Limiter les permissions du l'utilisateur web PHP.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Vérifier toutes les variables liées aux chemins et aux fichiers
       qui sont fournis.
      </simpara>
     </listitem>
    </itemizedlist>
    Voici un script renforcé :
    <example>
     <title>Une vérification renforcée</title>
     <programlisting role="php">
<![CDATA[
<?php
// Efface un fichier sur le disque où l'utilisateur à le droit d'aller
  $username = $_SERVER['REMOTE_USER'];
// utilise un mécanisme d'authentification
  $homedir = "/home/$username";
  $file_to_delete = basename("$userfile");
// supprime le chemin excédentaire
  unlink ($homedir/$file_to_delete);
  $fp = fopen("/home/logging/filedelete.log","+a"); //note l'effacement
  $logstring = "$username $homedir $file_to_delete";
  fputs ($fp, $logstring);
  fclose($fp);
  echo "$file_to_delete a été éffacé!";
?>
]]>
     </programlisting>
    </example>
    Cependant, même cette technique n'est pas sans faille.
    Si votre système d'identification permet aux utilisateurs
    de créer leur propre login, et qu'un utilisateur choisi
    le login "../etc/", le système est de nouveau exposé. Pour cette
    raison, vous pouvez essayez d'écrire un script renforcé :
    <example>
     <title>Vérification de noms de fichiers sécurisée</title>
     <programlisting role="php">
<![CDATA[
<?php
  $username = $_SERVER['REMOTE_USER'];;
  $homedir = "/home/$username";
  if (!ereg('^[^./][^/]*$', $username))
    die('Erreur de nom de fichier');
    //meurt, ne SURTOUT pas traiter!
//etc...
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Suivant votre système d'exploitation, vous devrez protéger
    un grand nombre de fichiers, notamment les entrées de périphériques,
    (/dev/ ou COM1), les fichiers de configuration (fichiers /etc/ et .ini),
    les lieux de stockage d'informations (/home/, My Documents), etc.
    Pour cette raison, il est généralement plus sûr d'établir une
    politique qui interdit TOUT sauf ce que vous autorisez.
   </para>
  </sect1>
  <sect1 id="security.database">
   <title>Sécurité des bases de données</title>
   <simpara>
    De nos jours, les bases de données sont des composants incontournables
    des serveurs web et des applications en ligne, qui fournissent du contenu
    dynamique. Des données secrètes ou critiques peuvent être stockées dans les
    bases de données : il est donc important de les protéger efficacement.
   </simpara>
   <simpara>
    Pour lire ou stocker des informations, vous devez vous connecter au serveur
    de bases de données, envoyer une requête valide, lire le résultat et 
    refermer la connexion. De nos jours, le langage le plus courant pour ce
    type de communication est le langage SQL (Structured Query Language). Voyez comment
    un pirate peut 
    <link linkend="security.database.sql-injection">s'introduire dans une requête SQL</link>.
   </simpara>
   <simpara>
    Comme vous pouvez le réaliser, &php; ne peut pas protéger vos bases de données
    pour vous. La section suivante vous introduira aux notions de base pour protéger
    vos bases de données, lors de la programmation de vos scripts.
   </simpara>
   <simpara>
    Gardez bien cette règle simple en tête : la défense se fait par couches.
    Plus vous ajouterez de tests pour protéger votre base, plus faible sera la
    probabilité de réussite d'un pirate. Ajoutez à cela un bon schéma de base
    de données, et vous aurez une application réussie.
   </simpara>

   <sect2 id="security.database.design">
    <title>Schéma de base de données</title>
     <simpara>
      La première étape est de créer une base de données, à moins que vous ne
      souhaitiez utiliser une base de données déjà créée. Lorsque la base
      de données est créée, un utilisateur propriétaire en est responsable. 
      Généralement, seul le propriétaire (et le super utilisateur) peuvent
      intervenir avec les tables de cette base, et il faut que ce dernier 
      donne des droits à tous les intervenants qui auront à travailler sur cette
      base.
     </simpara>
     <simpara>
      Les applications ne doivent jamais se connecter au serveur de
      bases de données sous le nom du propriétaire ou de l'administrateur,
      car ces utilisateurs ont des droits très importants, et pourront
      exécuter n'importe quelle requête, comme par exemple la
      modification de tables, l'effacement de lignes ou même encore,
      la destruction de la base.
     </simpara>
     <simpara>
      Vous pouvez créer différents utilisateurs de bases de données pour
      chaque aspect de votre application, avec des droits limités aux
      seules actions planifiées. Il faut alors éviter que le même utilisateur
      dispose des droits de plusieurs cas d'utilisation. Cela permet que
      si des intrus obtiennent l'accès à la base avec l'un de ces jeux
      de droits, ils ne pourront pas affecter toute l'application.
     </simpara>
     <simpara>
      Il est recommandé de ne pas implémenter toute la logique fonctionnelle
      dans l'application web (c'est-à-dire dans vos scripts), mais d'en
      reporter une partie dans la base en utilisant les triggers, vues et
      règles. Si le système évolue, les nouvelles versions vous feront réécrire
      toute la logique et donc tous vos scripts. De plus, l'utilisation de
      trigger permet de gérer de manière transparente des données, et 
      fournit des indications pour déboguer votre application.
     </simpara>
   </sect2>

   <sect2 id="security.database.connection">
    <title>Connexions au serveur de base de données</title>
    <simpara>
     Il est recommandé d'établir des connexions au serveur avec le
     protocole SSL, pour chiffrer les échanges clients/serveur, afin
     d'améliorer la sécurité. Vous pouvez aussi utiliser un client
     SSH pour chiffrer la connexion entre les clients et le serveur
     de bases de données. Si l'une de ces deux protections est 
     mise en place, il sera difficile de surveiller votre trafic et
     de comprendre les informations échangées.
    </simpara>
    <!--simpara>
     If your database server native SSL support, consider to use <link
     linkend="ref.openssl">OpenSSL functions</link> in communication between
     PHP and database via SSL.
    </simpara-->
   </sect2>

   <sect2 id="security.database.storage">
    <title>Modèle de stockage avec chiffrement</title>
    <simpara>
     Les protocoles SSL/SSH protègent les données qui circulent entre
     le serveur et le client, mais SSL/SSH ne protègent pas les données
     une fois dans la base. SSL est un protocole en ligne.
    </simpara>
    <simpara>
     Une fois que le pirate a obtenu l'accès direct à votre base de données 
     (en contournant le serveur web), les données sensibles, stockées dans votre
     base sont accessibles directement, à moins que les données de la base
     ne soient protégées par la base. Chiffrer les données est une bonne
     solution pour réduire cette menace, mais très peut de bases de données
     offrent ce type de chiffrement.
    </simpara>
    <simpara>
     Le moyen le plus simple pour contourner ce problème est de créer votre
     propre logiciel de chiffrement, et de l'utiliser dans vos scripts &php;.
     &php; peut vous aider dans cette tâche grâce aux nombreuses extensions
     dont il dispose, comme par exemple 
     <link linkend="ref.mcrypt">Mcrypt</link> et 
     <link linkend="ref.mhash">Mhash</link>, qui connaissent un large éventail
     de méthodes de chiffrement. Le script &php; va chiffrer les données qui seront
     stockées, et les déchiffrer losrqu'elles seront relues. Voyez la suite
     pour des exemples d'utilisation de ce chiffrement.
    </simpara>
    <simpara>
     Dans le cas de données vraiment sensibles, si la représentation originale
     n'est pas nécessaire (pour affichage, ou comparaison), utiliser un
     hash est une bonne solution. L'exemple classique est le stockage de
     mots de passe dans les bases de données, après les avoir passé au 
     MD5. Voyez les fonctions <function>crypt</function> et <function>md5</function>.
    </simpara>
    <example>
     <title>Utiliser un mot de passe et MD5</title>
     <programlisting role="php">
<![CDATA[
// Stockage du mot de passe hashé
$query  = sprintf("INSERT INTO users(name,pwd) VALUES('%s','%s');",
            addslashes($username), md5($password));
$result = pg_exec($connection, $query);

// interroger le serveur pour comparer le mot de passe soumis
$query = sprintf("SELECT 1 FROM users WHERE name='%s' AND pwd='%s';",
            addslashes($username), md5($password));
$result = pg_exec($connection, $query);

if (pg_numrows($result) > 0) {
    echo "Bienvenue, $username!";
}
else {
    echo "Identification échouée pour $username.";
}
]]>
     </programlisting>
    </example>
   </sect2>

   <sect2 id="security.database.sql-injection">
    <title>Injection SQL</title>
    <simpara>
     De nombreux développeurs web ne sont pas conscients des possibilités
     de manipulation des requêtes SQL, et supposent que les requêtes SQL
     sont des commandes sûres. Cela signifie qu'une requête SQL est 
     capable de contourner les contrôles et vérifications, comme par
     exemple les identifications et authentifications, et parfois, les requêtes
     SQL ont accès aux commandes d'administration.
    </simpara>
    <simpara>
     L'injection SQL directe est une technique où un pirate modifie une requête
     SQL existante pour afficher des données cachées, ou pour écraser des
     valeurs importantes, ou encore exécuter des commandes dangereuses pour la
     base. Cela se fait lorsque l'application prend les données envoyées par
     l'internaute, et l'utilise directement pour contruire une requête SQL. Les
     exemples ci-dessous sont basés sur une histoire vraie, malheureusement.
    </simpara>
    <para>
     Avec le manque de vérification des données de l'internaute et la connexion
     au serveur avec des droits de super utilisateur, le pirate peut créer des
     utilisateurs, et créer un autre super utilisateur.
     <example>
      <title>
       Séparation des résultats en pages, et créer des administrateurs 
       (PostgreSQL et MySQL)
      </title>
      <programlisting role="php">
<![CDATA[
$offset = argv[0]; // Attention, aucune validation!
$query  = "SELECT id, name FROM products ORDER BY name LIMIT 20 OFFSET $offset;";
// avec PostgreSQL 
$result = pg_exec($conn, $query);
// avec MySQL
$result = mysql_query($query);
]]>
      </programlisting>
     </example>
      Un utilisateur normal clique sur les boutons 'suivant' et 'précédent',
      qui sont alors placés dans la variable <varname>$offset</varname>,
      encodée dans l'URL. Le script s'attend à ce que la variable 
      <varname>$offset</varname> soit alors un nombre décimal. Cependant,
      il est possible de modifier l'URL en ajoutant une nouvelle valeur,
      au format URL, comme ceci : 
      <informalexample>
       <programlisting>
<![CDATA[
// cas de PostgreSQL
0;
insert into pg_shadow(usename,usesysid,usesuper,usecatupd,passwd)
    select 'crack', usesysid, 't','t','crack'
    from pg_shadow where usename='postgres';
--

// cas de MySQL
0;
UPDATE user SET Password=PASSWORD('crack') WHERE user='root';
FLUSH PRIVILEGES;
]]>
       </programlisting>
      </informalexample>
      Si cela arrive, le script va créer un nouveau super utilisateur.
      Notez que la valeur <literal>0;</literal> sert à terminer la requête
      originale et la terminer correctement.
    </para>
    <note>
     <para>
      C'est une techinque répandue que de forcer l'analyseur SQL d'ignorer le
      reste de la requête, en utilisant les symboles <literal>--</literal> pour
      mettre en commentaire.
     </para>
    </note>
    <para>
     Un moyen possible pour accéder aux mots de passe est de contourner 
     la recherche de page. Ce que le pirate doit faire, c'est simplement 
     voir si une variable du formulaire est utilisée dans la requête, et 
     si elle est mal gérée. Ces variables peuvent avoir été configurées
     dans une page précédente pour être utilisées dans les clauses 
     <literal>WHERE, ORDER BY, LIMIT</literal> et <literal>OFFSET</literal> des
     requêtes <literal>SELECT</literal>. Si votre base de données supporte
     les commandes <literal>UNION</literal>, le pirate peut essayer d'ajouter
     une requête entière pour lister les mots de passe dans n'importe quelle
     table. Utiliser la technique des mots de passe chiffrés est fortement
     recommandé.
     <example>
      <title>
       Liste d'articles ... et ajout de mot de passe
      </title>
      <programlisting role="php">
<![CDATA[
$query  = "SELECT id, name, inserted, size FROM products
                  WHERE size = '$size'
                  ORDER BY $order LIMIT $limit, $offset;";
$result = odbc_exec($conn, $query);
]]>
      </programlisting>
     </example>
     La partie statique de la requête, combinée avec une autre
     requête <literal>SELECT</literal>, va révéler les mots de passe : 
     <example>
      <title>Révélation des mots de passe</title>
      <programlisting>
<![CDATA[
'
union select '1', concat(uname||'-'||passwd) as name, '1971-01-01', '0' from usertable;
--
]]>
      </programlisting>
     </example>
     Si cette requête (exploitant les <literal>'</literal> et <literal>--</literal>) 
     est affectée à une variable utilisée dans 
     <varname>$query</varname>, l'injection SQL va arriver.
    </para>
    <para>
     Les commandes <literal>UPDATE</literal> sont aussi sujettes à des
     attaques de votre base de données. Ces requêtes peuvent aussi introduire
     toute une nouvelle requête dans votre commande initiale. Mais en plus,
     le pirate peut jouer sur la commande <literal>SET</literal>. Dans ce cas,
     il doit connaitre un peu votre base de données. Cela peut se deviner
     en examinant les noms de variables dans les formulaires, ou simplement,
     en testant les cas les plus classiques. Il n'y a pas beaucoup de conventions
     de nommination pour stocker des noms d'utilisateurs et des mots de passe.
     <example>
     <title>Modifier un mot de passe ... et gain de droits!</title>
      <programlisting role="php">
<![CDATA[
$query = "UPDATE usertable SET pwd='$pwd' WHERE uid='$uid';";
]]>
      </programlisting>
     </example>
     Mais un internaute fourbe peut envoyer une valeur telle que
     <literal>' or uid like '%admin%'; --</literal> dans <varname>$uid</varname>
     pour modifier le mot de passe utilisateur, ou simplement, utiliser la variable
     <varname>$pwd</varname> avec la valeur 
     <literal>"hehehe', admin='yes', trusted=100 "</literal> (avec l'espace final) pour
     obtenir des droits supplémentaires. La requête sera alors devenue : 
     <example>
     <title>Une requête et son injection</title>
      <programlisting role="php">
<![CDATA[
// $uid == ' or uid like'%admin%'; --
$query = "UPDATE usertable SET pwd='...' WHERE uid='' or uid like '%admin%'; --";

// $pwd == "hehehe', admin='yes', trusted=100 "
$query = "UPDATE usertable SET pwd='hehehe', admin='yes', trusted=100 WHERE ...;"
]]>
      </programlisting>
     </example>
    </para>
    <para>
     C'est un exemple terrible d'acquisition de droits d'administrateur sur un
     serveur de base de données.
     <example>
     <title>Attaque d'un serveur de bases de données (MSSQL Server)</title>
      <programlisting role="php">
<![CDATA[
$query  = "SELECT * FROM products WHERE id LIKE '%$prod%'";
$result = mssql_query($query);
]]>
      </programlisting>
     </example>
     Si le pirate injecte la valeur 
     <literal>a%' exec master..xp_cmdshell 'net user test testpass /ADD' --</literal>
     dans la variable <varname>$prod</varname>, alors la requête <varname>$query</varname> 
     devient : 
     <example>
     <title>Attaque d'un serveur de base de données (MSSQL Server) - 2</title>
      <programlisting role="php">
<![CDATA[
$query  = "SELECT * FROM products
                    WHERE id LIKE '%a%'
                    exec master..xp_cmdshell 'net user test testpass /ADD'--";
$result = mssql_query($query);
]]>
      </programlisting>
     </example>
     MSSQL Server exécute les requêtes SQL en lot, y compris la commande 
     d'ajout d'un nouvel utilisateur à la base de données locale. Si cette
     application fonctionnait en tant que <literal>sa</literal> et que le service
     MSSQLSERVER disposait de niveau de droits suffisant, le pirate dispose désormais
     d'un compte avec accès au serveur.
    </para>
    <note>
     <para>
      Certains des exemples ci-dessus sont spécifiques à certains serveurs de
      bases de données. Cela n'empêche pas des attaques similaires d'être possibles
      sur d'autres produits. Votre base de données sera alors vulnérable d'une autre
      manière.
     </para>
    </note>

    <sect3 id="security.database.avoiding">
     <title>Techniques de contournement</title>
     <simpara>
      Vous pouvez prétendre que le pirate doit d'abord obtenir des informations
      sur le schéma de la base de données, dans la plupart des cas d'injections.
      C'est vrai, mais vous ne saurez jamais comment ni quand ces informations
      auront filtré, et si cela arrive, votre base de données sera en grand
      danger. Si vous utilisez une base de données Open Srouce, ou une 
      base qui est du domaine public, ou encore un schéma qui appartient
      à un système de gestion de contenu ou d'un forum, le pirate peut facilement
      se procurer une copie du code que vous utilisez. Cela peut être un
      risque potentiel si la base a été mal conçue.
     </simpara>
     <simpara>
      Ces attaques sont généralement basées sur l'exploitation de code qui
      n'est pas écrit de manière sécuritaire. N'ayez aucune confiance dans
      les données qui proviennent de l'utilisateur, même si cela provient d'un
      menu déroulant, d'un champ caché ou d'un cookie. Le premier exemple montre
      comment une requête peut causer un désastre.
     </simpara>
     <itemizedlist>
      <listitem>
       <simpara>
        Ne nous connectez jamais sur une base de données en tant que super utilisateur
        ou propriétaire de la base. Utilisez toujours un utilisateur adapté, avec
        des droits très limités.
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        Vérifiez que les données ont bien le type attendu. &php; dispose
        d'un éventail de fonction de validation large, depuis les plus
        simples, de la section <link linkend="ref.variables">Variables</link> et
        la section <link linkend="ref.ctype">Caractères</link>
        (e.g. <function>is_numeric</function>, <function>ctype_digit</function>
        respectivement) aux fonctions avancées de
        <link linkend="ref.pcre">Expression régulière Perl</link>.
       </simpara>
      </listitem>
      <listitem>
       <para>
        Si l'application attend une entrée numérique, vérifiez vos données
        avec la fonction <function>is_numeric</function>, ou bien modifiez
        automatiquement le type avec la fonction <function>settype</function>, 
        ou encore avec <function>sprintf</function>.
        <example>
         <title>Une navigation de fiches plus sécuritaire</title>
         <programlisting role="php">
<![CDATA[
<?php
settype($offset, 'integer');
$query = "SELECT id, name FROM products ORDER BY name LIMIT 20 OFFSET $offset;";

// notez que %d dans la chaîne de format : %s serait inutile
$query = sprintf("SELECT id, name FROM products ORDER BY name LIMIT 20 OFFSET %d;",
                 $offset);
?>
]]>
         </programlisting>
        </example>
       </para>
      </listitem>
      <listitem>
       <simpara>
        Mettez entre guillemet toutes les valeurs non numériques qui sont
        passées à la base de données, et protégez-vous des guillemets dans
        les valeurs avec la fonction <function>addslashes</function> ou 
        <function>addcslashes</function>. Voyez 
        <link linkend="security.database.storage">le premier exemple</link>.
        Comme les exemples l'on montré, les guillemets statiques peuvent
        être facilement contournés.
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        N'affichez jamais d'informations spécifiques à la base, et notamment
        des informations concernant le schéma. Voyez aussi la section
        <link linkend="security.errors">Rapport d'erreur</link> et le chapitre
        <link linkend="ref.errorfunc">Gestion des erreurs</link>.
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        Vous pouvez avoir des procédures stockées et des curseurs prédéfinis qui
        font que les utilisateurs n'ont pas un accès direct aux tables ou vues,
        mais cette solution a d'autres impacts.
       </simpara>
      </listitem>
     </itemizedlist>

     <simpara>
      A coté de ces conseils, il est recommandé d'enregistrer vos requêtes soit dans
      vos scripts soit dans la base elle-même, si elle le supporte. Evidemment,
      cet enregistrement ne sera pas capable d'empêcher une attaque, mais vous
      permettra de retrouver la requête qui a fauté. L'historique n'est pas très utile 
      par lui-même, mais au niveau des informations qu'il contient. Plus vous
      avez de détails, mieux c'est.
     </simpara>
    </sect3>
   </sect2>
  </sect1>
  <sect1 id="security.errors">
   <title>Rapport d'erreurs</title>
   <para>
     En termes de sécurité, il y a deux conséquences au rapport d'erreur.
     D'un coté, cela améliore la sécurité, 
     mais d'un autre, cela la réduit aussi.
   </para>
   <para>
    Une tactique d'attaque standard consiste à faire faire des erreurs
    au système, et lire les variables d'environnement et de contexte qui
    sont retournées. Cela permet au pirate de lire de nombreuses
    informations sur le serveur, et de détecter des faiblesses du serveur.
    Par exemple, si un intrus a glané des informations sur votre page, avec
    une première utilisation de votre site, il peut essayer de remplacer les
    variables par ses propres valeurs :
    <example>
     <title>Attaque de site avec une page HTML personnalisée</title>
     <programlisting role="php">
<![CDATA[
<form method="post" action="http://www.site.cible.com/?username=badfoo&password=badfoo">
<input type="hidden" name="username" value="badfoo">
<input type="hidden" name="password" value="badfoo">
</form>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Les erreurs PHP qui sont normalement retournées peuvent être
    très pratiques pour un développeur qui essaie de déboger un
    script, car elles donnent de précieux renseignements tels que
    quelle fonction a échoué, quel fichier n'a pas été
    trouvé, quel script PHP a bogé, et quelle ligne est en faute. Toutes
    ces informations sont exploitables. Il est commun aux développeurs PHP
    d'utiliser les fonctions <function>show_source</function>,
    <function>highlight_string</function>, ou <function>highlight_file</function>
    comme outils de débogage, mais sur un site en production, cela expose
    des variables cachées, des syntaxes non vérifiées
    ou d'autres informations critiques. Il est particulièrement dangeureux
    d'exécuter du code de sources connues, avec les gestionnaires de
    débogage. Si l'intrus peut comprendre votre technique habituelle
    d'utilisation, il peut tenter une attaque frontale sur une page, en
    envoyant des chaînes de débogage :
    <example>
     <title>Exploiter des variables classiques de débogage</title>
     <programlisting role="php">
<![CDATA[
<form method="post" action="http://www.site.cible.com/?errors=Y&showerrors=1"&debug=1">
<input type="hidden" name="errors" value="Y">
<input type="hidden" name="showerrors" value="1">
<input type="hidden" name="debug" value="1">
</form>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Indépendamment de la gestion des erreurs, la possibilité de tester
    la gestion des erreurs d'un système conduit à un trou de sécurité,
    et la diffusion de plus d'informations sur votre système.
   </para>
   <para>
    Si un pirate affiche une page <acronym>html</acronym>, et essaye de la tester (pour
    rechercher des faiblesses du système), il peut déterminer sur quel
    système PHP a été compilé.
   </para>
   <para>
    Une erreur de fonction indique si un système supporte une base de
    données spécifique, ou bien indique comment la page a
    été générée. Cela peut orienter l'intrus
    vers les ports de cette base de données ou bien vers une attaque
    liée à cette application. En envoyant des données
    erronées, par exemple, un pirate peut déterminer l'ordre
    d'authentification dans un script (à partir des lignes d'erreurs),
    et essayer de les exploiter ailleurs, dans le script.
   </para>
   <para>
    Une erreur de fichier, ou une erreur générale PHP peut indiquer
    quelles sont les permissions du serveur web, ainsi que la structure
    et l'organisation des fichiers. Les gestionnaires d'erreurs utilisateurs
    peuvent aussi aggraver ce problème, en permettant l'exploitation facile
    d'informations préalablement cachées.
   </para>
   <para>
    Il y a trois solutions majeures à ces problèmes : la première
    est de scruter toutes les fonctions, et d'essayer de traiter toutes les
    erreurs. La deuxième est de désactiver le rapport d'erreur, dès
    que le script est en production. La troisième est d'utiliser les
    fonctions de gestion des erreurs. Suivant votre politique de
    sécurité, vous pouvez utiliser un panachage savant des
    trois méthodes.
   </para>
   <para>
    Une méthode pour gagner du temps est d'utiliser la fonction
    <function>error_reporting</function>, pour vous aider à
    sécuriser le code, et détecter les utilisations dangeureuses de variables.
    Vous testez votre code en béta-test avec la valeur <constant>E_ALL</constant>,
    et vous pouvez rapidement repérer les variables qui ne sont pas
    protégées. Une fois que le code est prêt à être déployé,
    utilisez la constante <constant>E_NONE</constant>, pour isoler
    votre code.
    <example>
     <title>Détecter des variables non protégées avec E_ALL</title>
     <programlisting role="php">
<![CDATA[
<?php
  if ($username) {
// Non initialisée, ou vérifée avant utilisation
    $good_login = 1;
  }
  if ($good_login == 1) {
// Si le test ci-dessus échoue, les valeurs n'ont pas été testées
    fpassthru ("/données/très/très/sensibles/index.html");
  }
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect1>
  <sect1 id="security.registerglobals">
   <title>Utilisation des variables super-globales</title>
   <para>
    Une fonctionnalité de PHP qui peut être utilisée pour
    améliorer la sécurité est de configurer PHP en désactivant l'option
    <link linkend="ini.register-globals">register_globals</link>.
    En supprimant la possibilité que les variables envoyées
    par les internautes soient injectées automatiquement dans
    le script PHP, vous pouvez restreindre la quantité de
    variables non-protégées.  Les intrus devront prendre beaucoup plus
    de temps pour corrompre les mécanismes d'envoi de données,
    et vos variables internes seront nettement mieux protégées.
   </para>
   <para>
    Bien que cela augmente d'autant les efforts à fournir pour
    écrire un script PHP, les bénéfices peuvent en être
    nettement plus interessants.
    <example>
     <title>Travailler avec register_globals = on</title>
     <programlisting role="php">
<![CDATA[
<?php
  if ($username) {
// attention, cette valeur peut être parasitée via GET/POST/COOKIES
    $good_login = 1;
  }
if ($good_login == 1) {
// attention, cette valeur peut être parasitée via GET/POST/COOKIES
    fpassthru ("/données/très/très/sensibles/index.html");
}
?>
]]>
     </programlisting>
    </example>
    <example>
     <title>Travailler avec register_globals = off</title>
     <programlisting role="php">
<![CDATA[
<?php
  if($_COOKIE["username"]){
// ne peut provenir que d'un cookie, corrompu ou pas
    $good_login = 1;
// Impossible à parasiter
    fpassthru ("/données/très/très/sensibles/index.html");
  }
?>
]]>
     </programlisting>
    </example>
    En utilisant intelligemment ceci, il est même possible
    de détecter les tentatives de corruption. Si vous savez à l'avance
    d'où la variable doit venir (GET ou POST ou COOKIE), vous pouvez
    tester les données. Même si cela ne vous garantit pas contre
    la corruption de ces données, cela impose aux pirates de bien
    savoir comment corrompre les données.
    <example>
     <title>Détection de corruption de variables</title>
     <programlisting role="php">
<![CDATA[
<?php
  if ($_COOKIE['username'] &&
      !$_POST['username'] &&
      !$_GET['username'] ) {
    // D'autres vérifications pour vérifier l'origine du nom d'utilisateur fourni
    $good_login = 1;
    fpassthru ("/données/très/très/sensibles/index.html");
  } else {
   mail("admin@example.com", "Tentative de piratage", $_SERVER['REMOTE_ADDR']);
   echo "Problème de sécurité, l'administrateur est alerté.";
   exit;
  }
?>
]]>
     </programlisting>
    </example>
    Bien entendu, désactiver l'option register_globals ne signifie pas
    que votre code devient ouvert à tous. Mais il faut aussi
    vérifier toutes les données qui vous sont fournies par les
    utilisateurs, et plutôt deux fois qu'une.
   </para>
  </sect1>
  <sect1 id="security.variables">
   <title>Données transmises par les internautes</title>
   <para>
    Les plus grandes faiblesses de nombreux programmes PHP ne viennent pas
    du langage lui-même, mais de son utilisation en omettant les
    caractéristiques de sécurité. Pour cette raison,
    vous devez toujours prendre le temps de prendre en compte les implications
    d'une fonction, et de cerner toutes les applications d'une utilisation exotiques
    des paramètres.
    <example>
     <title>Utilisation dangereuse de variables</title>
     <programlisting role="php">
<![CDATA[
<?php
// efface un fichier à la racine d'un utilisateur... ou peut être
// de quelqu'un d'autre?
  unlink($evil_var);
// Note l'accès de ce fichier ... ou pas?
  fputs($fp, $evil_var);
// Exécute une commande triviale... ou ajoute une entrée dans /etc/password ?
  system($evil_var);
  exec($evil_var);
?>
]]>
     </programlisting>
    </example>
    Il est vivement recommandé d'examiner minutieusement votre code
    pour vous assurer qu'il n'y a pas de variables envoyées par le
    client web, et qui ne sont pas suffisamment vérifiées avant utilisation.
    <itemizedlist>
     <listitem>
      <simpara>
       Est-ce que ce script n'affectera que les fichiers prévus?
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Est-il possible que des valeurs incohérentes soient exploitées ici?
      </simpara>
     </listitem>
     <listitem>
     <simpara>
       Est-ce que ce script peut être utilisé dans un but différent?
       </simpara>
     </listitem>
     <listitem>
      <simpara>
       Est-ce que ce script peut être utilisé malicieusement,
       en conjonction avec d'autres?
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Est-ce que toutes les actions seront notées?
      </simpara>
     </listitem>
    </itemizedlist>
    En répondant de manière adéquate à ces questions
    lors de l'écriture de vos scripts (plutôt qu'après), vous
    éviterez une réécriture inopportune pour raison de
    sécurité. En commençant vos projets avec ces recommandations
    en tête, vous ne garantirez pas la sécurité de votre
    système, mais vous contribuerez à l'améliorer.
   </para>
   <para>
    Vous pouvez aussi envisager de supprimer l'acquisition automatique des
    variables d'environnement, les guillemets magiques (magic_quotes),
    ou encore toute option qui pourrait vous conduire à mésévaluer
    la validité, la source ou la valeur d'une variable. En travaillant avec
    error_reporting(E_ALL), vous pouvez être averti que certaines variables
    sont utilisées avant d'être exploitées, ou
    vérifiées (et donc, vous pourrez traiter des valeurs exotiques
    à la source).
   </para>
  </sect1>
  <sect1 id="security.hiding">
   <title>Masquer PHP</title>
   <para>
    Quelques astuces permettent de masquer PHP, et cela entrave les
    pirates qui recherchent des faiblesses dans votre système. En
    désactivant l'option expose_php dans votre fichier &php.ini;,
    vous pouvez réduire la quantité d'informations disponible.
   </para>
   <para>
    Une autre astuce est de configurer le serveur web, comme Apache,
    pour qu'il utilise plusieurs types de fichiers différents avec PHP,
    soit localement avec le fichier &htaccess;, soit
    dans le fichier de configuration lui-même. Vous pouvez utiliser des
    informations déroutantes comme ceci :
    <example>
     <title>Masquer PHP avec un autre langage</title>
     <programlisting role="apache-conf">
<![CDATA[
# Faire que le code PHP ressemble à un autre langage
AddType application/x-httpd-php .asp .py .pl
]]>
     </programlisting>
    </example>
    Ou masquez le complètement :
    <example>
     <title>Masquer PHP avec des types inconnus</title>
     <programlisting role="apache-conf">
<![CDATA[
# Faire que le code PHP ressemble à un autre langage qui n'existe pas
AddType application/x-httpd-php .bop .foo .133t
]]>
     </programlisting>
    </example>
    Ou encore, cachez-le sous forme de html. Cela a un léger impact négatif
    sur les performances générales, car tous les fichiers HTML seront aussi
    analysés et traités par le moteur PHP :
    <example>
     <title>Utiliser le type html pour les extensions PHP</title>
     <programlisting role="apache-conf">
<![CDATA[
# Faire que le code PHP ressemble à du html
AddType application/x-httpd-php .htm .html
]]>
     </programlisting>
    </example>
    Pour que cela fonctionne efficacement, pensez à renommer tous vos
    fichiers avec les extensions ci-dessus. Même si c'est une forme
    de sécurité du non-dit, c'est une mesure de prévention mineure,
    avec peu d'inconvénients.
    </para>
   </sect1>
  <sect1 id="security.current">
   <title>Etre à jour</title>
   <simpara>
    PHP, comme de nombreux systèmes de grande taille, est constamment
    testé et amélioré. Chaque nouvelle version rassemble
    des modifications majeures et mineures, aussi bien pour renforcer la
    sécurité, que pour réparer les problèmes de conceptions
    de configuration, et d'autres points qui peuvent affecter la sécurité
    globale et la stabilité de votre système.
   </simpara>
   <simpara>
    Comme les autres langages de scripts systèmes, la meilleure approche
    est de mettre à jour souvent PHP, et de rester à l'écoute
    des dernières versions et des modifications qu'elles apportent.
   </simpara>
  </sect1>
 </chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
