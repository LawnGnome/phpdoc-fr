 <chapter id="security">
  <title>S&eacute;curit&eacute;</title>
  <simpara>
	PHP est un langage puissant et l'interpr&eacute;teur, qu'il soit inclus dans le
	serveur web ou bien compil&eacute; en version CGI, est capable d'acc&eacute;der
	aux fichiers, d'ex&eacute;cuter des commandes et d'ouvrir des connexions
	r&eacute;seaux.  Toutes ces propri&eacute;t&eacute;s rendent fragile la
	s&eacute;curit&eacute; d'un serveur web. Le langage PHP a &eacute;t&eacute;
	pens&eacute; afin d'&ecirc;tre un langage beaucoup plus s&eacute;curis&eacute;
	pour &eacute;crire des <acronym>CGI</acronym> que le Perl ou le langage C. De
	plus une s&eacute;lection rigoureuse des options de compilation et
	d'ex&eacute;cution vous permettront d'obtenir un &eacute;quilibre
	parfait entre libert&eacute; et s&eacute;curit&eacute;.
  </simpara>
  <simpara>
	Etant donn&eacute; qu'il y a de nombreux moyens d'utiliser le langage PHP,
	il y a de nombreuses directives de configuration afin d'en contr&ocirc;ler
	le comportement. Un grand nombre d'options permettent d'utiliser le PHP
	dans de nombreuses situations, mais cela signifie aussi qu'il y a certaines
	combinaisons d'options de compilation et d'ex&eacute;cution qui fragilise
	la s&eacute;curit&eacute; du serveur. Ce chapitre explique comme les
	diff&eacute;rentes options de configurations peuvent &ecirc;tre
	combin&eacute;es, tout en conservant une s&eacute;curit&eacute; maximum.
  </simpara>
  <simpara>
   La flexibilit&eacute; de configuration de PHP est &eacute;paul&eacute;e par
   la flexibilit&eacute; du code. PHP peut &ecirc;tre compil&eacute; pour
   constituer une application serveur compl&egrave;te, avec toutes
   les fonctionnalit&eacute;s d'un shell, ou il peut encore
   &ecirc;tre utilis&eacute; comple simple SSI (server side include)
   avec peu de risque, dans un environnement &agrave; s&eacute;curit&eacute;
   renforc&eacute;e. Comment cr&eacute;er cet environnement et le
   s&eacute;curis&eacute; est largement &agrave; la charge du
   d&eacute;veloppeur PHP.
  </simpara>
  <simpara>
   Ce chapitre commence par expliquer les diff&eacute;rentes options de configuration
   et les situations o&ugrave; elles peuvent &ecirc;tre utilis&eacute;es en
   toute s&eacute;curit&eacute;. Puis, viennent les consid&eacute;rations de 
   niveaux de s&eacute;curit&eacute;, et les conseils g&eacute;n&eacute;raux.
  </simpara>
  <sect1 id="security.cgi">
   <title>Binaires CGI</title>
   <sect2 id="security.cgi.attacks">
    <title>Faiblesses connues</title>
    <simpara>
   	  Utiliser le PHP comme un <acronym>CGI</acronym> ex&eacute;cutable vient
	  la plupart du temps du fait que l'on ne veut pas l'utiliser comme un module
	  du serveur web, (comme Apache), ou bien que l'on souhaite l'utiliser en
	  combinaison d'un <acronym>CGI</acronym> compl&eacute;mentaire, afin de
	  cr&eacute;er un environnement de script s&eacute;curis&eacute; (en utilisant
	  des techniques de chroot ou setuid). Une telle d&eacute;cision signifie
	  habituellement que vous installez votre ex&eacute;cutable dans le
	  r&eacute;pertoire cgi-bin de votre serveur web.
	<ulink url="&url.cert;">CERT CA-96.11</ulink> recommande effectivement de
	placer l'interpr&eacute;teur &agrave; l'int&eacute;rieur du r&eacute;pertoire
	cgi-bin. M&ecirc;me si le binaire PHP peut &ecirc;tre utilis&eacute; comme
	interpr&eacute;teur ind&eacute;pendant, PHP a &eacute;t&eacute;
	pens&eacute; afin de rendre impossible les attaques que ce type
	d'installation induit.
    </simpara>
    <itemizedlist>
     <listitem>
      <simpara>
       Acc&egrave;s au syst&egrave;me de fichier:
       <filename role="url">http://ma.machine/cgi-bin/php?/etc/passwd</filename>
      </simpara>
      <simpara>
	   Lorsque la requ&ecirc;te est pass&eacute;e dans une url, apr&egrave;s le point
	   d'interrogation (?), elle est envoy&eacute;e &agrave; l'interpr&eacute;teur
	   comme une ligne de commande par l'interface CGI. Habituellement,
	   l'interpr&eacute;teur ouvre le fichier sp&eacute;cifi&eacute; et
	   l'ex&eacute;cute.
      </simpara>
      <simpara>
	   Lorsqu'il est invoqu&eacute; comme ex&eacute;cutable CGI, le PHP refuse
   	   d'interpr&eacute;ter les arguments de la ligne de commande.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Acc&egrave;s d'un document web sur le serveur :
       <filename role="url">http://my.host/cgi-bin/php/secret/doc.html</filename>
      </simpara>
      <simpara>
   	    Le "path information" dans l'url, situ&eacute; juste apr&egrave;s le nom
   	    du binaire PHP, <filename role="uri">/secret/doc.html</filename> est
   	    utilis&eacute; par convention pour sp&eacute;cifier le nom du fichier
   	    qui doit &ecirc;tre ouvert et interpr&eacute;t&eacute; par le programe
   	    <acronym>CGI</acronym>. Habituellement, des directives de configuration
   	    du serveur web (pour le serveur Apache: Action) sont utilis&eacute;es pour
   	    rediriger les requ&ecirc;tes pour obtenir un document
   	    <filename role="url">http://my.host/secret/script.php</filename> par
   	    l'interpr&eacute;teur PHP. Dans une telle configuration, le serveur web
   	    v&eacute;rifie d'abord si il a acc&egrave;s au r&eacute;pertoire
   	    <filename role="uri">/secret</filename>, et apr&egrave;s cette
   	    v&eacute;rification redirige la requ&ecirc;te vers
   	    <filename role="url">http://my.host/cgi-bin/php/secret/script.php</filename>.
   	    Malheureusement, si la requ&ecirc;te est faite directement sous cette forme,
   	    aucune v&eacute;rification d'acc&egrave;s n'est faite par le serveur web
   	    pour le fichier <filename role="uri">/secret/script.php</filename>,
   	    mais uniquement pour le fichier <filename role="uri">/cgi-bin/php</filename>.
   	    De cette mani&egrave;re, n'importe quel utilisateur qui peut acc&eacute;der
   	    au fichier <filename role="uri">/cgi-bin/php</filename> peut aussi
   	    acc&eacute;der au document prot&eacute;g&eacute;s sur le serveur web.
      </simpara>
      <simpara>
       Avec le PHP, l'option de compilation
       <link linkend="install.configure.enable-force-cgi-redirect">--enable-force-cgi-redirect</link>
       et les options d'ex&eacute;cution <link linkend="ini.doc-root">doc_root</link>
       et <link linkend="ini.user-dir">user_dir</link> peuvent &ecirc;tre
       utilis&eacute;es pour pr&eacute;venir ce genre d'attaques, si des restrictions
       d'acc&egrave;s sont appliqu&eacute;es sur les documents du serveur. Voir
       ci-dessous pour des explications plus compl&egrave;tes sur les
       diff&eacute;rentes combinaisons.
      </simpara>
     </listitem>
    </itemizedlist>
   </sect2>
   <sect2 id="security.cgi.default">
    <title>Cas 1: Tous les fichiers sont publics</title>
    <simpara>
      Si votre serveur n'a aucun document dont l'acc&egrave;s est restreint
      par un mot de passe ou un syst&egrave;me de v&eacute;rification de l'adresse
      IP, vous n'avez aucun besoin de ce type de configuration. Si votre serveur web
      ne permet pas les redirections, ou si votre serveur web n'a aucun besoin de
      communiquer avec le binaire PHP de mani&egrave;re s&eacute;curis&eacute;e,
      vous pouvez utiliser l'option de compilation
      <link linkend="install.configure.enable-force-cgi-redirect">--disable-force-cgi-redirect</link>.
      Vous devez quand m&ecirc;me v&eacute;rifier qu'aucun script ne fait appel
      au PHP, de mani&egrave;re directe,
      <filename role="php">http://my.host/cgi-bin/php/dir/script.php</filename>
      ou bien de mani&egrave;re indirecte, par redirection,
      <filename role="php">http://my.host/dir/script.php</filename>.
    </simpara>
    <simpara>
      Les redirections peuvent &ecirc;tre configur&eacute;es dans les fichiers
      de configuration d'Apache en utilisant les directives "AddHandler" et
      "Action" (voir ci-dessous).
    </simpara>
   </sect2>
   <sect2 id="security.cgi.force-redirect">
    <title>
      Cas 2: Utilisation de la directive de compilation --enable-force-cgi-redirect
    </title>
    <simpara>
      Cette option de compilation pr&eacute;vient quiconque d'appeler
      directement un script avec l'url
      <filename role="php">http://my.host/cgi-bin/php/secretdir/script.php</filename>.
      Dans ce cas l&agrave;, PHP parsera le fichier uniquement si il y a eu redirection.
    </simpara>
    <simpara>
      Habituellement, le serveur web Apache r&eacute;alise une redirection
      gr&acirc;ce aux directives suivantes :
    </simpara>
    <programlisting role="apache-conf">
Action.php-script /cgi-bin/php
AddHandler.php-script .php
    </programlisting>
    <simpara>
      Cette option a uniquement &eacute;t&eacute; test&eacute;e avec Apache et
      compte sur Apache pour affecter la variable d'environnement non-standart
      <envar>REDIRECT_STATUS</envar> pour les requ&ecirc;tes redirig&eacute;es.
      Dans le cas o&uacute; votre serveur web ne supporte pas le renseignement
      du PHP, pour savoir si la requ&ecirc;te a &eacute;t&eacute;
      redirig&eacute;e ou non, vous ne pouvez pas utiliser cette option de
      compilation. Vous devez alors utiliser une des autres mani&egrave;res
      pour utiliser la version binaire CGI du PHP, comme expos&eacute; ci-dessous.
    </simpara>
   </sect2>
   <sect2 id="security.cgi.doc-root">
    <title>Cas 3: Utilisation du "doc_root" ou du "user_dir"</title>
    <simpara>
      Ajouter un contenu interactif dans votre serveur web, comme des scripts
      ou des ex&eacute;cutables, est souvent consid&eacute;r&eacute; comme une
      pratique non-s&eacute;curis&eacute;e. Si, par erreur, le script n'est pas
      ex&eacute;cut&eacute; mais affich&eacute; comme une page HTML classique,
      il peut en r&eacute;sulter un vol de propri&eacute;t&eacute; intellectuelle
      ou des probl&egrave;mes de s&eacute;curit&eacute; &agrave; propos des mots
      de passe notamment. Donc, la plupart des administrateurs
      pr&eacute;f&egrave;rent mettre en place un r&eacute;pertoire
      sp&eacute;cial pour les scripts qui est uniquement accessible par le biais
      du binaire CGI du PHP, et donc, tous les fichiers de ce r&eacute;pertoire
      seront interpr&eacute;t&eacute;s et non affich&eacute;s tels quel.
    </simpara>
    <simpara>
      Aussi, si vous ne pouvez pas utiliser la m&eacute;thode
      pr&eacute;sent&eacute;e ci-dessus, il est n&eacute;cessaire de mettre
      en place un r&eacute;pertoire "doc_root" diff&eacute;rent de votre
      r&eacute;pertoire "document root" de votre serveur web.
    </simpara>
    <simpara>
      Vous pouvez utiliser la directive <link linkend="ini.doc-root">doc_root</link>
      dans le <link linkend="configuration.file">fichier de configuration</link>,
      ou vous pouvez affecter la variable d'environnement
      <envar>PHP_DOCUMENT_ROOT</envar>. Si cette variable d'environnement
      est affect&eacute;e, le binaire <acronym>CGI</acronym> du PHP construira
      toujours le nom de fichier &agrave; ouvrir avec <parameter>doc_root</parameter>
      et le "path information" de la requ&ecirc;te, et donc vous serez s&ucirc;r
      qu'aucun script n'est ex&eacute;cut&eacute; en dehors du r&eacute;pertoire
      pr&eacute;d&eacute;finit. (&agrave; l'exception du r&eacute;pertoire
      d&eacute;sign&eacute; par la directive <parameter>user_dir</parameter>
      Voir ci-dessous).
    </simpara>
    <simpara>
     Une autre option possible ici est la directive
     <link linkend="ini.user-dir">user_dir</link>. Lorsque la directive n'est pas
     activ&eacute;e, seulement les fichiers contenues dans le r&eacute;pertoire
     <parameter>doc_root</parameter> peuvent &ecirc;tre ouverts.
     Ouvrir un fichier poss&eacute;dant l'url
     <filename role="url">http://my.host/~user/doc.php</filename> ne correspond
     pas &agrave; l'ouverture d'un fichier sous le r&eacute;pertoire racine de
     l'utilisateur mais &agrave; l'ouverture du fichier
     <filename role="uri">~user/doc.php</filename> sous le repertoire
     "doc_root" (oui, un r&eacute;pertoire commence par un tilde
     [<literal>~</literal>]).
    </simpara>
    <simpara>
      Si la directive "user_dir" est activ&eacute;e &agrave; la valeur
      <filename role="dir">public_php</filename> par exemple, une requ&ecirc;te
      du type <filename role="url">http://my.host/~user/doc.php</filename>
      ouvrira un fichier appel&eacute; <filename>doc.php</filename> sous le
      r&eacute;pertoire appel&eacute; <filename role="dir">public_php</filename>
      sous le r&eacute;pertoire racine de l'utilisateur.
      Si le r&eacute;pertoire racine des utilisateurs est
      <filename role="dir">/home/user</filename>, le fichier ex&eacute;cut&eacute;
      sera <filename>/home/user/public_php/doc.php</filename>.
    </simpara>
    <simpara>
      <parameter>user_dir</parameter> et <parameter>doc_root</parameter> sont
      deux directives totalement ind&eacute;pendantes et donc vous pouvez
      contr&ocirc;ler l'acc&egrave;s au r&eacute;pertoire "document root"
      s&eacute;par&eacute;ment des r&eacute;pertoires "user directory".
    </simpara>
   </sect2>
   <sect2 id="security.cgi.shell">
    <title>
     Cas 4: L'ex&eacute;cutable PHP &agrave; l'ext&eacute;rieur de l'arborescence du serveur
    </title>
    <para>
      Une solution extr&ecirc;mement s&eacute;curis&eacute;e consiste &agrave;
      mettre l'ex&eacute;cutable PHP &agrave; l'ext&eacute;rieur de l'arborescence
      du serveur web. Dans le r&eacute;pertoire
      <filename role="dir">/usr/local/bin</filename>, par exemple.
      Le probl&egrave;me de cette m&eacute;thode est que vous aurez &agrave;
      rajouter la ligne suivante :
     <informalexample>
      <programlisting role="cgi">
#!/usr/local/bin/php
      </programlisting>
     </informalexample>
     dans tous les fichiers contenant des tags PHP. Vous devrez aussi rendre le
     binaire PHP ex&eacute;cutable. Dans ce cas-l&agrave;, traitez le fichier
     exactement comme si vous aviez un autre script &eacute;crit en Perl ou en
     sh ou en un autre langage de script qui utilise <literal>#!</literal> comme
     m&eacute;canisme pour lancer l'interpr&eacute;teur lui-m&ecirc;me.
    </para>
    <para>
      Pour que l'ex&eacute;cutable PHP prenne en compte les variables
      d'environnement <envar>PATH_INFO</envar> et
      <envar>PATH_TRANSLATED</envar> correctement avec cette configuration,
      vous devez utiliser l'option de compilation
      <link linkend="install.configure.enable-discard-path">--enable-discard-path</link>.
    </para>
   </sect2>
  </sect1>
  <sect1 id="security.apache">
   <title>Module Apache</title>
   <simpara>
     Lorsque le PHP est compil&eacute; en tant que module Apache, ce module
     h&eacute;rite des permissions accord&eacute;es &agrave; l'utilisateur
     faisant tourner Apache ( par d&eacute;faut, l'utilisateur "noboby").
     Par exemple, si vous utilisez PHP pour acc&eacute;der &agrave; une
     base de donn&eacute;es &agrave; moins que la base n'ai un
     syst&egrave;me de droits d'acc&egrave;s interne, vous devrez rendre
     la base accessible &agrave; l'utilisateur "nobody". Cela signifie
     qu'un script malintentionn&eacute; peut acc&eacute;der &agrave; la base,
     la modifier sans authentification. Il est aussi possible qu'un
     robot acc&eacute;de &agrave; la page d'administration, et
     d&eacute;truise toutes les pages. Vous devez ainsi prot&eacute;ger
     vos bases de donn&eacute;es avec les autorisations Apache, ou
     d&eacute;finir votre propre mod&egrave;le d'acc&egrave;s avec
     LDAP, .htaccess, etc... et include ce code dans tous vos scripts
     PHP.
   </simpara>
   <simpara>
    Souvent, lorsqu'on a &eacute;tablit les droits pour que l'utilisateur
    PHP (ici, l'utilisateur Apache) pour minimiser les risques, on
    s'aper&ccedil;oit que PHP ne peut plus &eacute;crire des virus dans
    les fichiers des utilisateurs. Ou encore, de modifier une base
    de donn&eacute;es priv&eacute;e. Il est aussi incapable de modifier
    des fichiers qu'il devrait pouvoir modifier, ou effectuer
    certaines transactions.
   </simpara>
   <simpara>
    Une erreur fr&eacute;quente de s&eacute;curit&eacute; est de donner
    &agrave; l'utilisateur Apache les droits de superadministrateur.
   </simpara>
   <simpara>
    Donner de telles permissions &agrave; l'utilisateur Apache est extr&ecirc;mement
    dangereux, et peut compromettre tout le syst&egrave;me, tell que l'utilisation
    des sudo ou du chroot. Une telle utilisation est &agrave; exclure pour les
    profesionnels de la s&eacute;curit&eacute;.
   </simpara>
  </sect1>
    <sect1 id="security.filesystem">
   <title>S&eacute;curit&eacute; des fichiers</title>
   <simpara>
     PHP est soumis aux r&egrave;gles de s&eacute;curit&eacute;
     intrins&egrave;ques de la plus part des syst&egrave;mes serveurs :
     il respecte notamment les droits des fichiers, et des dossiers.
     Une attention particuli&egrave;re doit &ecirc;tre port&eacute;e aux
     fichiers qui sont accessible &agrave; tout le monde, afin de
     s'assurer qu'ils ne divulguent pas d'informations critiques.
   </simpara>
   <simpara>
    Puisque PHP a &eacute;t&eacute; fait pour permettre aux utilisateurs
    d'acc&eacute;der aux fichiers, il est possible de cr&eacute;er un
    script qui vous permet de lire des fichiers tels que /etc/password,
    de modifier les connexions ethernet, lancer des impressions de documents,
    etc... Cela implique notamment que vous devez vous assurer que les fichiers
    acc&eacute;d&eacute;s par les scripts sont bien ceux qu'il faut.
   </simpara>
   <simpara>
    Consid&eacute;rez le script suivant, o&ugrave; l'utilisateur indique
    qu'il souhaite effacer un fichier dans son dossier racine. Nous
    supposons que PHP est utilis&eacute; comme interface web pour
    g&eacute;rer les fichiers, et que l'utilisateur Apache est
    autoris&eacute; &agrave; effacer les fichiers dans le dossier racine des
    utilisateurs.
   </simpara>
   <para>
    <example>
     <title>Une erreur de v&eacute;rification de variable conduit &agrave; ....</title>
     <programlisting role="php">
&lt;?php
// efface un fichier dans un dossier racine
$username = $user_submitted_name;
$homedir = "/home/$username";
$file_to_delete = "$userfile";
unlink ($homedir/$userfile);
echo "$file_to_delete a &eacute;t&eacute; effac&eacute;!";
?&gt;
     </programlisting>
    </example>
   Etant donn&eacute; que le nom de l'utilisateur est &agrave; fournir, ils peuvent
   envoyer un nom d'utilisateur autre que le leur, et effacer des
   documents dans les comptes des autres utilisateurs.
   Dans ce cas, vous souhaiterez utiliser une autre forme d'authentification.
   Consid&eacute;rez ce qui pourrait se passer si les utilisateurs passer
   "../etc/" et "passwd" comme arguments!. Le code serait &eacute;x&eacute;cut&eacute; 
   tel que :
    <example>
     <title>Une attaque du syst&egrave;me de fichier!</title>
     <programlisting role="php">
&lt;?php
// efface un fichier n'importe o&ugrave; sur le disque dur,
// o&ugrave; l'utilisateur PHP a acc&egrave;s. Si PHP a un acc&egrave;s root :
$username = "../etc/";
$homedir = "/home/../etc/";
$file_to_delete = "passwd";
unlink ("/home/../etc/passwd");
echo "/home/../etc/passwd" has been deleted!";
?&gt;
     </programlisting>
    </example>
    Il y a deux mesures primordiales &agrave; prendre pour &eacute;viter
    ces manoeuvres :
    <itemizedlist>
     <listitem>
      <simpara>
       Limiter les permissions du l'utilisateur web PHP.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       V&eacute;rifier toutes les variables li&eacute;es aux chemins et aux fichiers
       qui sont fournies.
      </simpara>
     </listitem>
    </itemizedlist>
    Voici le script renforc&eacute; :
    <example>
     <title>Une v&eacute;rification renforc&eacute;e</title>
     <programlisting role="php">
&lt;?php
// Efface un fichier sur le disque o&ugrave; l'utilisateur &agrave; le droit
$username = get_env("REMOTE_USER");
// utilise un m&eacute;canisme d'authentification
$homedir = "/home/$username";
$file_to_delete = basename("$userfile");
// supprime le chemin exc&eacute;dentaire
unlink ($homedir/$file_to_delete);
$fp = fopen("/home/logging/filedelete.log","+a"); //note l'effacement
$logstring = "$HTTP_REMOTE_USER $homedir $file_to_delete";
fputs ($fp, $logstring);
fclose($fp);
echo "$file_to_delete a &eacute;t&eacute; &eacute;ffac&eacute;!";
?&gt;
     </programlisting>
    </example>
    Vous pouvez vous prot&eacute;ger avec une v&eacute;rification telle que :
    <example>
     <title>V&eacute;rfication de noms de fichier s&eacute;curis&eacute;e</title>
     <programlisting role="php">
&lt;?php
$username = $HTTP_REMOTE_USER;
$homedir = "/home/$username";
if (!ereg('^[^./][^/]*$', $userfile))
    die('Erreur de nom de fichier'); //meurt, ne pas traiter!
//etc...
?&gt;
     </programlisting>
    </example>
    Suivant votre syst&egrave;me d'exploitation, vous devrez prot&eacute;ger
    un grand nombre de fichiers, notamment les entr&eacute;es de p&eacute;riph&eacute;riques,
    (/dev/ ou COM1), les fichiers de configuration (fichiers /etc/ et .ini),
    les lieux de stockages d'informations (/home/, My Documents), etc.
    Pour cette raison, il est g&eacute;n&eacute;ralement plus s&ucirc;r d'&eacute;tablir une
    politique qui interdit TOUT sauf ce que vous autorisez.
   </para>
  </sect1>
  <sect1 id="security.errors">
   <title>Rapport d'erreur</title>
   <simpara>
    Une tactique d'attaque standard consiste &agrave; faire faire des erreurs
    au syst&egrave;me, et lire les variables d'environnement et de contexte qui
    sont retourn&eacute;es. Cela permet au hacker de lire de nombreuses
    informations sur le serveur, et d&eacute;tecter des faiblesses du serveur.
   </simpara>
   <simpara>
    Les erreurs PHP qui sont normalement retourn&eacute;es peuvent &ecirc;tre
    tr&egrave;s pratiques pour un d&eacute;veloppeur qui essaie de d&eacute;bugger un
    scripts, car elles donnent de pr&eacute;cieux renseignements tels que
    quelle fonction a &eacute;chou&eacute;, quel fichier n'a pas &eacute;t&eacute; 
    trouv&eacute;, quel script PHP a bugg&eacute;, et quelle ligne est en faute. Toutes
    ces informations sont exploitables. Il est commun aux d&eacute;veloppeurs PHP
    d'utiliser les fonctions <function>show_source</function>,
    <function>highlight_string</function>, ou <function>highlight_file</function>
    comme outils de d&eacute;buggage, mais sur un site en production,  cela expose
    des variables cach&eacute;es, des syntaxes non v&eacute;rifi&eacute;es 
    ou d'autres informations dangeureuses.
   </simpara>
   <simpara>
    Par exemple, le style d'erreur indique sur quel syst&egrave;me PHP fonctionne.
    Si un pirate affiche une page <acronym>html</acronym>, et essaye de la tester (pour
    rechercher des faiblesses du syst&egrave;me), il peut d&eacute;terminer sur quel
    syst&egrave;me PHP a &eacute;t&eacute; compil&eacute;.
   </simpara>
   <simpara>
    Une erreur de fonction indique si un syst&egrave;me supporte une base de
    donn&eacute;es sp&eacute;cifique, ou bien indique comment la page a
    &eacute;t&eacute; g&eacute;n&eacute;r&eacute;e. Cela peut orienter l'intrus
    vers les ports de cette base de donn&eacute;es ou bien vers une attaque
    li&eacute;e &agrave; cette application. En envoyant des donn&eacute;es
    &eacute;rron&eacute;es, par exemple, un pirate peut determiner l'ordre
    d'authentification dans un script (&agrave; partir des lignes d'erreurs),
    et essayer de les exploiter ailleurs, dans le script.
   </simpara>
   <simpara>
    Une erreur de fichier, ou une erreur g&eacute;n&eacute;rale PHP peut indiquer
    quelles sont les permissions du serveur web, ainsi que la structure
    et l'organisation des fichiers. Les gestionnaires d'erreurs utilisateurs
    peuvent aussi aggraver ce probl&egrave;me, en permettant l'exploitation facile
    d'informations pr&eacute;alablement cach&eacute;es.
   </simpara>
   <simpara>
    Il y a trois solutions majeures &agrave; ces probl&egrave;mes : la premi&egrave;re est
    de scruter toutes les fonctions, et essayer de traiter toutes les
    erreurs. La deuxi&egrave;me est d'inactiver le rapport d'erreur, d&egrave;s
    que le script est en production. La troisi&egrave;me est d'utiliser les
    fonctions de gestions des erreurs. Suivant votre politique de
    s&eacute;curit&eacute;, vous pouvez utiliser un panachage savant des 
    trois m&eacute;thodes.
   </simpara>
  </sect1>
  <sect1 id="security.variables">
   <title>User Submitted Data</title>
   <para>
    Les plus grandes faiblesses de nombreux programmes PHP ne viennent pas
    du langage lui-m&ecirc;me, mais de son utilisation en omettant les 
    caract&eacute;ristiques de s&eacute;curit&eacute;. Pour cette raison, 
    vous devez toujours prendre le temps de prendre en compte les implications 
    d'une fonction, et de cerner toutes les applications d'une utilisation exotiques 
    des param&egrave;tres.
    <example>
     <title>Utilisation dangereuse de variables</title>
     <programlisting role="php">
&lt;?php
// efface un fichier &agrave; la racine d'un utilisateur... ou peut &ecirc;tre
// de quelqu'un d'autre?
unlink ($evil_var);
// Note l'acc&egrave;s de ce fichier ... ou pas?
fputs ($fp, $evil_var);
// Ex&eacute;cute une commande triviale... ou pas?
system ($evil_var);
exec ($evil_var);
?&gt;
     </programlisting>
    </example>
    Il est vivement recommand&eacute; d'&eacute;xaminer minutieusement votre code
    pour vous assurer qu'il n'y a pas de variables envoy&eacute;es par le
    client web, et qui ne sont pas suffisament v&eacute;rifi&eacute;e avant utilisation.
    <itemizedlist>
     <listitem>
      <simpara>
       Est ce que ce script n'affectera que les fichiers pr&eacute;vus?
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Est il possible que des valeurs incoh&eacute;rentes soient exploit&eacute;es ici?
      </simpara>
     </listitem>
     <listitem>
     <simpara>
       Est ce que ce script peut &ecirc;tre utilis&eacute; dans un but diff&eacute;rents?
       </simpara>
     </listitem>
     <listitem>
      <simpara>
       Est ce que ce script peut &ecirc;tre utilis&eacute; malicieusement,
       en conjonction avec d'autres?
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Est ce que toutes les actions seront not&eacute;es?
      </simpara>
     </listitem>
    </itemizedlist>
    En r&eacute;pondant de mani&egrave;re ad&eacute;quate &agrave; ces questions 
    lors de l'&eacute;criture de vos scripts (plut&ocirc;t qu'apr&egrave;s), vous 
    &eacute;viterez une r&eacute;&eacute;criture inopportune pour raison de 
    s&eacute;curit&eacute;. En commencant vos projets avec ces recommandations 
    en t&ecirc;tes, vous garantirez pas la s&eacute;curit&eacute; de votre 
    syst&egrave;me, mais vous contribuerez &agrave; l'am&eacute;liorer.
   </para>
   <para>
    Vous pouvez aussi envisager de supprimer l'acquisition automatique des
    variables d'environnement, les guillemets magiques (magic_quotes),
    ou encore toute option qui pourrait vous conduire &agrave; m&eacute;s&eacute;valuer
    la validit&eacute;, la source ou la valeur d'une variable. En travaillant avec
    error_reporting(E_ALL), vous pouvez &ecirc;tre averti que certaines variables
    sont utilis&eacute;es avant d'&ecirc;tre exploit&eacute;es, ou 
    v&eacute;rifi&eacute;es (et donc, vous pourrez traiter des valeurs exotiques 
    &agrave; la source).
   </para>
  </sect1>
  <sect1 id="security.general">
   <title>Consid&eacute;rations g&eacute;n&eacute;rales</title>
   <simpara>
    Un syst&egrave;me compl&egrave;tement s&eacute;curis&eacute; est
    virtuellement impossible. De ce fait, une approche qui
    &eacute;quilibre les risques et l'ergonomie est souvent retenue.
    Si toutes les variables envoy&eacute;es par l'utilisateur
    n&eacute;cessitaient deux formes d'identification biom&eacute;triques
    (comme par exemple un scanner de la r&eacute;tine, et une
    empreinte digitale), vous pourriez avoir un niveau de
    s&eacute;curit&eacute; &eacute;lev&eacute;. Cela prendrai aussi
    une demi-heure pour remplir les conditions de s&eacute;curit&eacute;,
    ce qui pousserait les utilisateurs &agrave; &eacute;viter d'utiliser
    votre syst&egrave;me.
   </simpara>
   <simpara>
    La meilleure s&eacute;curit&eacute; est celle qui prot&egrave;ge
    votre syst&egrave;me, sans emp&ecirc;cher les utilisateurs de faire
    leur travail. En g&eacute;n&eacute;ral, les attaques exploitent
    des trous de s&eacute;curit&eacute; entre diverses couches d'identification : cet
    empilement devient trop complexe, et finalement, peu fiable.
   </simpara>
   <simpara>
    Une phrase qui vaut la peine d'&ecirc;tre retenue : un syst&egrave;me est
    aussi fiable que son maillon le plus faible. Si toutes les
    transactions sont exhaustivement not&eacute; (heure, lieu, type, etc...)
    mais que l'utilisateur n'est authentifi&eacute; que par un cookie,
    la validit&eacute; de votre syst&egrave;me de surveillance est intimement
    li&eacute; &agrave; la validit&eacute; du cookie (et donc,
    s&eacute;v&egrave;rement r&eacute;duite).
   </simpara>
   <simpara>
    Lors de vos tests, gardez &agrave; l'esprit que vous ne pourrez pas
    tester toutes les configurations, mais probablement les plus
    simples. Les donn&eacute;es en entr&eacute;es auxquelles vous pouvez vous
    attendre ne seront rien compar&eacute;es aux donn&eacute;es
    incoh&eacute;rentes qu'un employ&eacute; n&eacute;gligent, un
    hacker disposant d'autant de temps qu'il veut, ou du chat de la
    maison marchant sur le clavier. Il est donc bon de regarder le
    code logiquement, de voir d'o&ugrave; des donn&eacute;es incoh&eacute;rentes
    peuvent &ecirc;tre introduites, modifi&eacute;es, r&eacute;duites ou
    amplifi&eacute;es.
   </simpara>
   <simpara>
    L'Internet est rempli de personnes qui tentent de se faire une renomm&eacute;e
    en piratant vos programmes, bloquant votre site, envoyant des contenus
    inappropri&eacute;s, qui rendent vos journ&eacute;es si &quot;sp&eacute;ciales&quot;.
    Peut importe que vous ayez un grand portail ou un petit web, vous pouvez
    &ecirc;tre la cible pour tout quidam avec une connexion. Vous &ecirc;tes une
    cible potentielle d&egrave;s que vous &ecirc;tes connect&eacute; vous m&ecirc;me.
    Certains programmes de piratage ne font pas dans la demi-mesure, et
    testent syst&eacute;matiquement des millions d'IP, &agrave; la recherche
    de victimes : ne soyez pas la prochaine.
   </simpara>
  </sect1>
  <sect1 id="security.current">
   <title>Etre &agrave; jour</title>
   <simpara>
    PHP, comme de nombreux syst&egrave;mes de grandes tailles, est constamment
    test&eacute; et am&eacute;lior&eacute;. Chaque nouvelle version rassemble 
    des modifications majeures et mineures, aussi bien pour renforcer la 
    s&eacute;curit&eacute;, r&eacute;parer les probl&egrave;mes de conceptions 
    de configuration, et d'autres points qui peuvent affecter la s&eacute;curit&eacute; 
    globale et la stabilit&eacute; de votre syst&egrave;me.
   </simpara>
   <simpara>
    Comme les autres langages de scripts syst&egrave;mes, la meilleure approche 
    est de mettre &agrave; jour souvent PHP, et de rester &agrave; l'&eacute;coute 
    des derni&egrave;res versions et des modifications qu'elles apportent.
   </simpara>
  </sect1>
 </chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
