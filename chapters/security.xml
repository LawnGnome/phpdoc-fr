<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.20 $ -->
 <chapter id="security">
  <title>S&eacute;curit&eacute;</title>
  <simpara>
    PHP est un langage puissant et l'interpr&eacute;teur, qu'il soit inclus dans le
    serveur web ou bien compil&eacute; en version CGI, est capable d'acc&eacute;der
    aux fichiers, d'ex&eacute;cuter des commandes et d'ouvrir des connexions
    r&eacute;seaux.  Toutes ces propri&eacute;t&eacute;s rendent fragile la
    s&eacute;curit&eacute; d'un serveur web. Le langage PHP a &eacute;t&eacute;
    pens&eacute; afin d'&ecirc;tre un langage beaucoup plus s&eacute;curis&eacute;
    pour &eacute;crire des <acronym>CGI</acronym> que le Perl ou le langage C. De
    plus, une s&eacute;lection rigoureuse des options de compilation et
    d'ex&eacute;cution vous permettra d'obtenir un &eacute;quilibre
    parfait entre libert&eacute; et s&eacute;curit&eacute;.
  </simpara>
  <simpara>
    Etant donn&eacute; qu'il y a de nombreux moyens d'utiliser le langage PHP,
    il y a de nombreuses directives de configuration afin d'en contr&ocirc;ler
    le comportement. Un grand nombre d'options permettent d'utiliser le PHP
    dans de nombreuses situations, mais cela signifie aussi qu'il y a certaines
    combinaisons d'options de compilation et d'ex&eacute;cution qui fragilisent
    la s&eacute;curit&eacute; du serveur. Ce chapitre explique comme les
    diff&eacute;rentes options de configurations peuvent &ecirc;tre
    combin&eacute;es, tout en conservant une s&eacute;curit&eacute; maximum.
  </simpara>
  <simpara>
   La flexibilit&eacute; de configuration de PHP est &eacute;paul&eacute;e par
   la flexibilit&eacute; du code. PHP peut &ecirc;tre compil&eacute; pour
   constituer une application serveur compl&egrave;te, avec toutes
   les fonctionnalit&eacute;s d'un shell, ou il peut encore
   &ecirc;tre utilis&eacute; comme simple SSI (server side include)
   avec peu de risque, dans un environnement &agrave; s&eacute;curit&eacute;
   renforc&eacute;e. Comment cr&eacute;er cet environnement et le
   s&eacute;curiser est largement &agrave; la charge du
   d&eacute;veloppeur PHP.
  </simpara>
  <simpara>
   Ce chapitre commence par expliquer les diff&eacute;rentes options de configuration
   et les situations dans lesquelles elles peuvent &ecirc;tre utilis&eacute;es en
   toute s&eacute;curit&eacute;. Puis, viennent les consid&eacute;rations de
   niveaux de s&eacute;curit&eacute;, et les conseils g&eacute;n&eacute;raux.
  </simpara>
  <sect1 id="security.general">
   <title>Consid&eacute;rations g&eacute;n&eacute;rales</title>
   <simpara>
    Un syst&egrave;me compl&egrave;tement s&ucirc;r est une impossiblit&eacute; virtuelle. 
    L'approche souvent utilis&eacute;e par les professionnels de la
    s&eacute;curit&eacute; est d'&eacute;quilibrer les risques et l'ergonomie.
    Si chaque variable fournie par l'utilisateur demandaient deux
    formes de validation biom&eacute;trique (un scan de la r&eacute;tine et
    une empreinte digitale), on obtiendrait un syst&egrave;me avec
    un niveau de s&eacute;curit&eacute; d'un bon niveau. Il faudrait aussi une
    bonne heure pour remplir un formulaire simple, ce qui encouragerait
    les utilisateurs &agrave; trouver un moyen de contourner cette s&eacute;curit&eacute;.
   </simpara>
   <simpara>
    La meilleure s&eacute;curit&eacute; est suffisamment discr&egrave;te pour assurer
    un maximum de s&eacute;curit&eacute; sans ajouter de contraintes insurmontables
    pour l'utilisateur ou de syst&egrave;mes complexes de programmation.
    Souvent, les attaques sur un script sont des exploitations 
    des sys&egrave;mes de s&eacute;curit&eacute; trop complexes, qui s'&eacute;rodent au cour
    du temps.
   </simpara>
   <simpara>
    Un principe qu'il est bon de retenir : Un syst&egrave;me est aussi sur
    que son maillon le plus faible. Si toutes les transactions sont
    bien not&eacute;es dans une base, avec confirmation mais que l'utilisateur
    n'est authentifi&eacute;e que par un cookie, la robustesse de votre
    syst&egrave;me est s&eacute;v&egrave;rement r&eacute;duite.
   </simpara>
   <simpara>
    Lorsque vous testez votre site, gardez en t&ecirc;te que vous ne pourrez
    jamais tester toutes les situations, m&ecirc;me pour les pages les plus
    simples. Les valeurs que vous attendez seront toujours compl&eacute;tement
    diff&eacute;rentes des valeurs qu'un employ&eacute; n&eacute;gligent, un hacker qui a toute
    la nuit devant lui ou encore le chat de la maison qui marche sur le clavier.
    C'est pourquoi il est pr&eacute;f&eacute;rable de regarder le code d'un point de vue
    logique, pour rep&eacute;rer les points d'entr&eacute;e des donn&eacute;es inattendues,
    puis de voir comment elles pourront &ecirc;tre modifi&eacute;es, 
    amplifi&eacute;es ou r&eacute;duites.
   </simpara>
   <simpara>
    L'Internet est rempli d'individu qui tentent de se faire une renomm&eacute;e
    en piratant vos programmes, en bloquant votre site, en envoyant des contenus
    inappropri&eacute;s, qui rendent vos journ&eacute;es si &quot;sp&eacute;ciales&quot;.
    Peut importe que vous ayez un grand portail ou un petit web, vous pouvez
    &ecirc;tre la cible pour tout quidam avec une connexion. Vous &ecirc;tes une
    cible potentielle d&egrave;s que vous &ecirc;tes connect&eacute; vous-m&ecirc;me.
    Certains programmes de piratage ne font pas dans la demi-mesure, et
    testent syst&eacute;matiquement des millions d'IP, &agrave; la recherche
    de victimes : ne soyez pas la prochaine.
   </simpara>
  </sect1>
  <sect1 id="security.cgi-bin">
   <title>Binaires CGI</title>
   <sect2 id="security.cgi-bin.attacks">
    <title>Faiblesses connues</title>
    <simpara>
         Utiliser le PHP comme un <acronym>CGI</acronym> ex&eacute;cutable vient
      la majorit&eacute; du temps du fait que l'on ne veut pas l'utiliser comme un module
      du serveur web, (comme Apache), ou bien que l'on souhaite l'utiliser en
      combinaison d'un <acronym>CGI</acronym> compl&eacute;mentaire, afin de
      cr&eacute;er un environnement de script s&eacute;curis&eacute; (en utilisant
      des techniques de chroot ou setuid). Une telle d&eacute;cision signifie
      habituellement que vous installez votre ex&eacute;cutable dans le
      r&eacute;pertoire cgi-bin de votre serveur web.
    <ulink url="&url.cert;">CERT CA-96.11</ulink> recommande effectivement de
    placer l'interpr&eacute;teur &agrave; l'int&eacute;rieur du r&eacute;pertoire
    cgi-bin. M&ecirc;me si le binaire PHP peut &ecirc;tre utilis&eacute; comme
    interpr&eacute;teur ind&eacute;pendant, PHP a &eacute;t&eacute;
    pens&eacute; afin de rendre impossible les attaques que ce type
    d'installation induit.
    </simpara>
    <itemizedlist>
     <listitem>
      <simpara>
       Acc&egrave;s au syst&egrave;me de fichier:
       <filename role="url">http://ma.machine/cgi-bin/php?/etc/passwd</filename>
      </simpara>
      <simpara>
       Lorsque la requ&ecirc;te est pass&eacute;e dans une url, apr&egrave;s le point
       d'interrogation (?), elle est envoy&eacute;e &agrave; l'interpr&eacute;teur
       comme une ligne de commande par l'interface CGI. Habituellement,
       l'interpr&eacute;teur ouvre le fichier sp&eacute;cifi&eacute; et
       l'ex&eacute;cute.
      </simpara>
      <simpara>
       Lorsqu'il est invoqu&eacute; comme ex&eacute;cutable CGI, le PHP refuse
          d'interpr&eacute;ter les arguments de la ligne de commande.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Acc&egrave;s d'un document web sur le serveur :
       <filename role="url">http://my.host/cgi-bin/php/secret/doc.html</filename>
      </simpara>
      <simpara>
           Le "path information" dans l'url, situ&eacute; juste apr&egrave;s le nom
           de l'ex&eacute;cutable PHP, <filename role="uri">/secret/doc.html</filename> est
           utilis&eacute; par convention pour sp&eacute;cifier le nom du fichier
           qui doit &ecirc;tre ouvert et interpr&eacute;t&eacute; par le programe
           <acronym>CGI</acronym>. Habituellement, des directives de configuration
           du serveur web (pour le serveur Apache: Action) sont utilis&eacute;es pour
           rediriger les requ&ecirc;tes afin d'obtenir un document
           <filename role="url">http://my.host/secret/script.php</filename> par
           l'interpr&eacute;teur PHP. Dans une telle configuration, le serveur web
           v&eacute;rifie d'abord s'il a acc&egrave;s au r&eacute;pertoire
           <filename role="uri">/secret</filename>, et apr&egrave;s cette
           v&eacute;rification redirige la requ&ecirc;te vers
           <filename role="url">http://my.host/cgi-bin/php/secret/script.php</filename>.
           Malheureusement, si la requ&ecirc;te est faite directement sous cette forme,
           aucune v&eacute;rification d'acc&egrave;s n'est faite par le serveur web
           pour le fichier <filename role="uri">/secret/script.php</filename>,
           mais uniquement pour le fichier <filename role="uri">/cgi-bin/php</filename>.
           De cette mani&egrave;re, n'importe quel utilisateur qui peut acc&eacute;der
           au fichier <filename role="uri">/cgi-bin/php</filename> peut aussi
           acc&eacute;der aux documents prot&eacute;g&eacute;s sur le serveur web.
      </simpara>
      <simpara>
       Avec le PHP, l'option de compilation
       <link linkend="install.configure.enable-force-cgi-redirect">--enable-force-cgi-redirect</link>
       et les options d'ex&eacute;cution <link linkend="ini.doc-root">doc_root</link>
       et <link linkend="ini.user-dir">user_dir</link> peuvent &ecirc;tre
       utilis&eacute;es pour pr&eacute;venir ce genre d'attaques, si des restrictions
       d'acc&egrave;s sont appliqu&eacute;es sur les documents du serveur. Voir
       ci-dessous pour des explications plus compl&egrave;tes sur les
       diff&eacute;rentes combinaisons.
      </simpara>
     </listitem>
    </itemizedlist>
   </sect2>
   <sect2 id="security.cgi-bin.default">
    <title>Cas 1: Tous les fichiers sont publics</title>
    <simpara>
      Si votre serveur n'a aucun document dont l'acc&egrave;s est restreint
      par un mot de passe ou un syst&egrave;me de v&eacute;rification de l'adresse
      IP, vous n'avez aucun besoin de ce type de configuration. Si votre serveur web
      ne permet pas les redirections, ou si votre serveur web n'a aucun besoin de
      communiquer avec le binaire PHP de mani&egrave;re s&eacute;curis&eacute;e,
      vous pouvez utiliser l'option de compilation
      <link linkend="install.configure.enable-force-cgi-redirect">--disable-force-cgi-redirect</link>.
      Vous devez quand m&ecirc;me v&eacute;rifier qu'aucun script ne fait appel
      au PHP, de mani&egrave;re directe,
      <filename role="php">http://my.host/cgi-bin/php/dir/script.php</filename>
      ou bien de mani&egrave;re indirecte, par redirection,
      <filename role="php">http://my.host/dir/script.php</filename>.
    </simpara>
    <simpara>
      Les redirections peuvent &ecirc;tre configur&eacute;es dans les fichiers
      de configuration d'Apache en utilisant les directives "AddHandler" et
      "Action" (voir ci-dessous).
    </simpara>
   </sect2>
   <sect2 id="security.cgi-bin.force-redirect">
    <title>
      Cas 2: Utilisation de la directive de compilation
      <link linkend="install.configure.enable-force-cgi-redirect">--enable-force-cgi-redirect</link>
    </title>
    <simpara>
      Cette option de compilation pr&eacute;vient quiconque d'appeler
      directement un script avec l'url
      <filename role="php">http://my.host/cgi-bin/php/secretdir/script.php</filename>.
      Dans ce cas l&agrave;, PHP parsera le fichier uniquement s'il y a eu redirection.
    </simpara>
    <simpara>
      Habituellement, le serveur web Apache r&eacute;alise une redirection
      gr&acirc;ce aux directives suivantes :
    </simpara>
    <programlisting role="apache-conf">
Action.php-script /cgi-bin/php
AddHandler.php-script .php
    </programlisting>
    <simpara>
      Cette option a uniquement &eacute;t&eacute; test&eacute;e avec Apache et
      compte sur Apache pour affecter la variable d'environnement non-standart
      <envar>REDIRECT_STATUS</envar> pour les requ&ecirc;tes redirig&eacute;es.
      Dans le cas o&ugrave; votre serveur web ne supporte pas le renseignement
      du PHP, pour savoir si la requ&ecirc;te a &eacute;t&eacute;
      redirig&eacute;e ou non, vous ne pouvez pas utiliser cette option de
      compilation. Vous devez alors utiliser une des autres m&eacute;thodes
      d'exploitation de la version binaire CGI du PHP, comme expos&eacute; ci-dessous.
    </simpara>
   </sect2>
   <sect2 id="security.cgi-bin.doc-root">
    <title>Cas 3: Utilisation du "doc_root" ou du "user_dir"</title>
    <simpara>
      Ajouter un contenu interactif dans votre serveur web, comme des scripts
      ou des ex&eacute;cutables, est souvent consid&eacute;r&eacute; comme une
      pratique non-s&eacute;curis&eacute;e. Si, par erreur, le script n'est pas
      ex&eacute;cut&eacute; mais affich&eacute; comme une page HTML classique,
      il peut en r&eacute;sulter un vol de propri&eacute;t&eacute; intellectuelle
      ou des probl&egrave;mes de s&eacute;curit&eacute; &agrave; propos des mots
      de passe notamment. Donc, la majorit&eacute; des administrateurs
      pr&eacute;f&egrave;rent mettre en place un r&eacute;pertoire
      sp&eacute;cial pour les scripts qui soit uniquement accessible par le biais
      du binaire CGI du PHP, et donc, tous les fichiers de ce r&eacute;pertoire
      seront interpr&eacute;t&eacute;s et non affich&eacute;s tels quels.
    </simpara>
    <simpara>
      Aussi, si vous ne pouvez pas utiliser la m&eacute;thode
      pr&eacute;sent&eacute;e ci-dessus, il est n&eacute;cessaire de mettre
      en place un r&eacute;pertoire "doc_root" diff&eacute;rent de votre
      r&eacute;pertoire "document root" de votre serveur web.
    </simpara>
    <simpara>
      Vous pouvez utiliser la directive <link linkend="ini.doc-root">doc_root</link>
      dans le <link linkend="configuration.file">fichier de configuration</link>,
      ou vous pouvez affecter la variable d'environnement
      <envar>PHP_DOCUMENT_ROOT</envar>. Si cette variable d'environnement
      est affect&eacute;e, le binaire <acronym>CGI</acronym> du PHP construira
      toujours le nom de fichier &agrave; ouvrir avec <parameter>doc_root</parameter>
      et le "path information" de la requ&ecirc;te, et donc vous serez s&ucirc;r
      qu'aucun script n'est ex&eacute;cut&eacute; en dehors du r&eacute;pertoire
      pr&eacute;d&eacute;fini (&agrave; l'exception du r&eacute;pertoire
      d&eacute;sign&eacute; par la directive <parameter>user_dir</parameter>
      Voir ci-dessous).
    </simpara>
    <simpara>
     Une autre option possible ici est la directive
     <link linkend="ini.user-dir">user_dir</link>. Lorsque la directive n'est pas
     activ&eacute;e, seuls les fichiers contenus dans le r&eacute;pertoire
     <parameter>doc_root</parameter> peuvent &ecirc;tre ouverts.
     Ouvrir un fichier poss&eacute;dant l'url
     <filename role="url">http://my.host/~user/doc.php</filename> ne correspond
     pas &agrave; l'ouverture d'un fichier sous le r&eacute;pertoire racine de
     l'utilisateur mais &agrave; l'ouverture du fichier
     <filename role="uri">~user/doc.php</filename> sous le repertoire
     "doc_root" (oui, un r&eacute;pertoire commence par un tilde
     [<literal>~</literal>]).
    </simpara>
    <simpara>
      Si la directive "user_dir" est activ&eacute;e &agrave; la valeur
      <filename role="dir">public_php</filename> par exemple, une requ&ecirc;te
      du type <filename role="url">http://my.host/~user/doc.php</filename>
      ouvrira un fichier appel&eacute; <filename>doc.php</filename> sous le
      r&eacute;pertoire appel&eacute; <filename role="dir">public_php</filename>
      sous le r&eacute;pertoire racine de l'utilisateur.
      Si le r&eacute;pertoire racine des utilisateurs est
      <filename role="dir">/home/user</filename>, le fichier ex&eacute;cut&eacute;
      sera <filename>/home/user/public_php/doc.php</filename>.
    </simpara>
    <simpara>
      <parameter>user_dir</parameter> et <parameter>doc_root</parameter> sont
      deux directives totalement ind&eacute;pendantes et donc vous pouvez
      contr&ocirc;ler l'acc&egrave;s au r&eacute;pertoire "document root"
      s&eacute;par&eacute;ment des r&eacute;pertoires "user directory".
    </simpara>
   </sect2>
   <sect2 id="security.cgi-bin.shell">
    <title>
     Cas 4: L'ex&eacute;cutable PHP &agrave; l'ext&eacute;rieur de l'arborescence du serveur
    </title>
    <para>
      Une solution extr&ecirc;mement s&eacute;curis&eacute;e consiste &agrave;
      mettre l'ex&eacute;cutable PHP &agrave; l'ext&eacute;rieur de l'arborescence
      du serveur web. Dans le r&eacute;pertoire
      <filename role="dir">/usr/local/bin</filename>, par exemple.
      Le probl&egrave;me de cette m&eacute;thode est que vous aurez &agrave;
      rajouter la ligne suivante :
     <informalexample>
      <programlisting role="cgi">
#!/usr/local/bin/php
      </programlisting>
     </informalexample>
     dans tous les fichiers contenant des tags PHP. Vous devrez aussi rendre le
     binaire PHP ex&eacute;cutable. Dans ce cas-l&agrave;, traitez le fichier
     exactement comme si vous aviez un autre script &eacute;crit en Perl ou en
     sh ou en un autre langage de script qui utilise <literal>#!</literal> comme
     m&eacute;canisme pour lancer l'interpr&eacute;teur lui-m&ecirc;me.
    </para>
    <para>
      Pour que l'ex&eacute;cutable PHP prenne en compte les variables
      d'environnement <envar>PATH_INFO</envar> et
      <envar>PATH_TRANSLATED</envar> correctement avec cette configuration,
      vous devez utiliser l'option de compilation
      <link linkend="install.configure.enable-discard-path">--enable-discard-path</link>.
    </para>
   </sect2>
  </sect1>
  <sect1 id="security.apache">
   <title>Module Apache</title>
   <simpara>
     Lorsque le PHP est compil&eacute; en tant que module Apache, ce module
     h&eacute;rite des permissions accord&eacute;es &agrave; l'utilisateur
     faisant tourner Apache ( par d&eacute;faut, l'utilisateur "nobody").
     Par exemple, si vous utilisez PHP pour acc&eacute;der &agrave; une
     base de donn&eacute;es, &agrave; moins que la base n'ait un
     syst&egrave;me de droits d'acc&egrave;s interne, vous devrez rendre
     la base accessible &agrave; l'utilisateur "nobody". Cela signifie
     qu'un script mal intentionn&eacute; peut acc&eacute;der &agrave; la base,
     la modifier sans authentification. Il est aussi possible qu'un
     robot acc&egrave;de &agrave; la page d'administration, et
     d&eacute;truise toutes les pages. Vous devez aussi prot&eacute;ger
     vos bases de donn&eacute;es avec les autorisations Apache, ou
     d&eacute;finir votre propre mod&egrave;le d'acc&egrave;s avec
     LDAP, .htaccess, etc... et inclure ce code dans tous vos scripts
     PHP.
   </simpara>
   <simpara>
    Souvent, lorsqu'on a &eacute;tabli les droits de l'utilisateur
    PHP (ici, l'utilisateur Apache) pour minimiser les risques, on
    s'aper&ccedil;oit que PHP ne peut plus &eacute;crire des virus dans
    les fichiers des utilisateurs. Ou encore, de modifier une base
    de donn&eacute;es priv&eacute;e. Il est aussi incapable de modifier
    des fichiers qu'il devrait pouvoir modifier, ou effectuer
    certaines transactions.
   </simpara>
   <simpara>
    Une erreur fr&eacute;quente de s&eacute;curit&eacute; est de donner
    &agrave; l'utilisateur Apache les droits de superadministrateur.
   </simpara>
   <simpara>
    Donner de telles permissions &agrave; l'utilisateur Apache est extr&ecirc;mement
    dangereux, et peut compromettre tout le syst&egrave;me, telle que l'utilisation
    des <literal>sudo</literal> ou du <literal>chroot</literal>.
    Pour les professionnels de la s&eacute;curit&eacute;, une telle utilisation
    est &agrave; exclure d'office.
   </simpara>
   <simpara>
    Il existe des solutions plus simples. En utilisant
    <function>open_basedir</function> vous pouvez contr&ocirc;ler et restraindre
    l'acc&egrave;s &agrave; certains dossiers qui pourront &ecirc;tre utilis&eacute;s par PHP. Vous pouvez
    aussi des aires de restrictions Apache, pour restraindre les activit&eacute;s
    anonymes li&eacute;es aux internautes.
   </simpara>
  </sect1>
    <sect1 id="security.filesystem">
   <title>S&eacute;curit&eacute; des fichiers</title>
   <simpara>
    PHP est soumis aux r&egrave;gles de s&eacute;curit&eacute;
    intrins&egrave;ques de la plupart des syst&egrave;mes serveurs :
    il respecte notamment les droits des fichiers et des dossiers.
    Une attention particuli&egrave;re doit &ecirc;tre port&eacute;e aux
    fichiers ou dossiers qui sont accessibles &agrave; tout le monde, afin de
    s'assurer qu'ils ne divulguent pas d'informations critiques.
   </simpara>
   <simpara>
    Puisque PHP a &eacute;t&eacute; fait pour permettre aux utilisateurs
    d'acc&eacute;der aux fichiers, il est possible de cr&eacute;er un
    script qui vous permet de lire des fichiers tels que /etc/password,
    de modifier les connexions ethernet, lancer des impressions de documents,
    etc... Cela implique notamment que vous devez-vous assurer que les fichiers
    acc&eacute;d&eacute;s par les scripts sont bien ceux qu'il faut.
   </simpara>
   <simpara>
    Consid&eacute;rez le script suivant, o&ugrave; l'utilisateur indique
    qu'il souhaite effacer un fichier dans son dossier racine. Nous
    supposons que PHP est utilis&eacute; comme interface web pour
    g&eacute;rer les fichiers, et que l'utilisateur Apache est
    autoris&eacute; &agrave; effacer les fichiers dans le dossier racine des
    utilisateurs.
   </simpara>
   <para>
    <example>
     <title>Une erreur de v&eacute;rification de variable conduit &agrave; ...</title>
     <programlisting role="php">
<![CDATA[
<?php
// efface un fichier dans un dossier racine
$username = $HTTP_POST_VARS['user_submitted_name'];
$homedir = "/home/$username";
$file_to_delete = "$userfile";
unlink ($homedir/$userfile);
echo "$file_to_delete a &eacute;t&eacute; effac&eacute;!";
?>
]]>
     </programlisting>
    </example>
    Etant donn&eacute; que le nom de l'utilisateur est &agrave; fournir, des intrus peuvent
    envoyer un nom d'utilisateur autre que le leur, et effacer des
    documents dans les comptes des autres utilisateurs.
    Dans ce cas, vous souhaiterez utiliser une autre forme d'authentification.
    Consid&eacute;rez ce qui pourrait se passer si les utilisateurs passent
    "../etc/" et "passwd" comme arguments! Le code serait &eacute;x&eacute;cut&eacute;
    tel que :
    <example>
     <title>Une attaque du syst&egrave;me de fichiers!</title>
     <programlisting role="php">
<![CDATA[
<?php
// efface un fichier n'importe o&ugrave; sur le disque dur,
// o&ugrave; l'utilisateur PHP a acc&egrave;s. Si PHP a un acc&egrave;s root :
$username = "../etc/";
$homedir = "/home/../etc/";
$file_to_delete = "passwd";
unlink ("/home/../etc/passwd");
echo "/home/../etc/passwd a &eacute;t&eacute; effac&eacute;!";
?>
]]>
     </programlisting>
    </example>
    Il y a deux mesures primordiales &agrave; prendre pour &eacute;viter
    ces manoeuvres :
    <itemizedlist>
     <listitem>
      <simpara>
       Limiter les permissions du l'utilisateur web PHP.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       V&eacute;rifier toutes les variables li&eacute;es aux chemins et aux fichiers
       qui sont fournie.
      </simpara>
     </listitem>
    </itemizedlist>
    Voici un script renforc&eacute; :
    <example>
     <title>Une v&eacute;rification renforc&eacute;e</title>
     <programlisting role="php">
<![CDATA[
<?php
// Efface un fichier sur le disque o&ugrave; l'utilisateur &agrave; le droit d'aller
  $username = $HTTP_SERVER_VARS['REMOTE_USER'];
// utilise un m&eacute;canisme d'authentification
  $homedir = "/home/$username";
  $file_to_delete = basename("$userfile");
// supprime le chemin exc&eacute;dentaire
  unlink ($homedir/$file_to_delete);
  $fp = fopen("/home/logging/filedelete.log","+a"); //note l'effacement
  $logstring = "$username $homedir $file_to_delete";
  fputs ($fp, $logstring);
  fclose($fp);
  echo "$file_to_delete a &eacute;t&eacute; &eacute;ffac&eacute;!";
?>
]]>
     </programlisting>
    </example>
    Cependant, m&ecirc;me cette technique n'est pas sans faille.
    Si votre syst&egrave;me d'identification permet aux utilisateurs
    de cr&eacute;er leur propre login, et qu'un utilisateur choisi
    le login "../etc/", le syst&egrave;me est de nouveau expos&eacute;. Pour cette
    raison, vous pouvez essayez d'&eacute;crire un script renforc&eacute; :
    <example>
     <title>V&eacute;rification de noms de fichier s&eacute;curis&eacute;e</title>
     <programlisting role="php">
<![CDATA[
<?php
  $username = $HTTP_SERVER_VARS['REMOTE_USER'];;
  $homedir = "/home/$username";
  if (!ereg('^[^./][^/]*$', $username))
    die('Erreur de nom de fichier');
    //meurt, ne SURTOUT pas traiter!
//etc...
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Suivant votre syst&egrave;me d'exploitation, vous devrez prot&eacute;ger
    un grand nombre de fichiers, notamment les entr&eacute;es de p&eacute;riph&eacute;riques,
    (/dev/ ou COM1), les fichiers de configuration (fichiers /etc/ et .ini),
    les lieux de stockages d'informations (/home/, My Documents), etc.
    Pour cette raison, il est g&eacute;n&eacute;ralement plus s&ucirc;r d'&eacute;tablir une
    politique qui interdit TOUT sauf ce que vous autorisez.
   </para>
  </sect1>
  <sect1 id="security.database">
   <title>S&eacute;curit&eacute; des bases de donn&eacute;es</title>
   <simpara>
    De nos jours, les bases de donn&eacute;es sont des composants incontournables
    des serveurs web et des applications en ligne, qui fournissent du contenu
    dynamique. Des donn&eacute;es secr&egrave;tes ou critiques peuvent &ecirc;tre stock&eacute;es dans les
    bases de donn&eacute;es : il est donc important de les prot&eacute;ger efficacement.
   </simpara>
   <simpara>
    Pour lire ou stocker des informations, vous devez vous connecter au serveur
    de base de donn&eacute;es, envoyer une requ&ecirc;te valide, lire le r&eacute;sultat et 
    refermer la connexion. De nos jours, le langage le plus courant pour ce
    type de communication est le langage SQL (Structured Query Language). Voyez comment
    un pirate peut 
    <link linkend="security.database.sql-injection">s'introduire dans une requ&ecirc;te SQL</link>.
   </simpara>
   <simpara>
    Comme vous pouvez le r&eacute;aliser, &php; ne peut pas prot&eacute;ger vos bases de donn&eacute;es
    pour vous. La section suivante vous introduira aux notions de base pour prot&eacute;ger
    vos bases de donn&eacute;es, lors de la programmation de vos scripts.
   </simpara>
   <simpara>
    Gardez bien cette r&egrave;gle simple en t&ecirc;te : la d&eacute;fense se fait par couches.
    Plus vous ajouterez de tests pour prot&eacute;ger votre base, plus faible sera la
    probabilit&eacute; de r&eacute;ussite d'un pirate. Ajoutez &agrave; cela une bon sch&eacute;ma de base
    de donn&eacute;es, et vous aurez une application r&eacute;ussie.
   </simpara>

   <sect2 id="security.database.design">
    <title>Sch&eacute;ma de base de donn&eacute;es</title>
     <simpara>
      La premi&egrave;re &eacute;tape est de cr&eacute;er une base de donn&eacute;es, &agrave; moins que vous ne
      souhaitiez utiliser une base de donn&eacute;es d&eacute;j&agrave; cr&eacute;&eacute;e. Lorsque la base
      de donn&eacute;es est cr&eacute;&eacute;e, un utilisateur propri&eacute;taire en est responsable. 
      G&eacute;n&eacute;ralement, seul le propri&eacute;taire (et le super utilisateur) peuvent
      intervenir avec les tables de cette base, et il faut que ce dernier 
      donne des droits &agrave; tous les intervenants qui auront &agrave; faire dans cette
      base.
     </simpara>
     <simpara>
      Les applications ne doivent jamais se connecter au serveur de
      base de donn&eacute;es sous le nom du propri&eacute;taire ou de l'administrateur,
      car ces utilisateurs ont des droits tr&egrave;s importants, et pourront
      ex&eacute;cuter n'importe quelle requ&ecirc;te, comme par exemple la
      modification de tables, l'effacement de lignes ou m&ecirc;me encore,
      la destruction de la base.
     </simpara>
     <simpara>
      Vous pouvez cr&eacute;er diff&eacute;rents utilisateurs de base de donn&eacute;es pour
      chaque aspect de votre application, avec des droits limit&eacute;s aux
      seules actions planifi&eacute;es. Il faut alors &eacute;viter que le m&ecirc;me utilisateur
      dispose des droits de plusieurs cas d'utilisation. Cela permet que
      si des intrus obtiennent l'acc&egrave;s &agrave; la base avec l'un de ces jeux
      de droits, il ne pourra pas affecter toute l'application.
     </simpara>
     <simpara>
      Il est recommand&eacute; de ne pas impl&eacute;menter toute la logique fonctionnelle
      dans l'application web (c'est &agrave; dire dans vos scripts), mais d'en
      reporter une partie dans la base en utilisant les triggers, vues et
      r&egrave;gles. Si le syst&egrave;me &eacute;volue, les nouvelles versions vous feront r&eacute;&eacute;crire
      toute la logique et donc tous vos scripts. De plus, l'utilisation de
      trigger permet de g&eacute;rer de mani&egrave;re transparente des donn&eacute;es, et 
      fournit des indications pour d&eacute;boguer votre application.
     </simpara>
   </sect2>

   <sect2 id="security.database.connection">
    <title>Connexions au serveur de base de donn&eacute;es</title>
    <simpara>
     Il est recommand&eacute; d'&eacute;tablit des connexions au serveur avec le
     protocole SSL, pour chiffrer les &eacute;changes clients/serveur, afin
     d'am&eacute;liorer la s&eacute;curit&eacute;. Vous pouvez aussi utiliser un client
     SSH pour chiffrer la connexion entre les clients et le serveur
     de base de donn&eacute;es. Si l'une de ces deux protections est 
     mise en place, il sera difficile de surveiller votre trafic et
     de comprendre les informations &eacute;chang&eacute;es.
    </simpara>
    <!--simpara>
     If your database server native SSL support, consider to use <link
     linkend="ref.openssl">OpenSSL functions</link> in communication between
     PHP and database via SSL.
    </simpara-->
   </sect2>

   <sect2 id="security.database.storage">
    <title>Mod&egrave;le de stockage avec chiffrement</title>
    <simpara>
     Les protocoles SSL/SSH prot&egrave;gent les donn&eacute;es qui circulent entre
     le serveur et le client, mais SSL/SSH ne prot&egrave;gent pas les donn&eacute;es
     une fois dans la base. SSL est un protocole en ligne.
    </simpara>
    <simpara>
     Une fois que le pirate a obtenu l'acc&egrave;s direct &agrave; votre base de donn&eacute;es 
     (en contournant le serveur web), les donn&eacute;es sensibles, stock&eacute;es dans votre
     base sont accessibles directement, &agrave; moins que les donn&eacute;es de la base
     ne soient prot&eacute;g&eacute;es par la base. Chiffrer les donn&eacute;es est une bonne
     solution pour r&eacute;duire cette menace, mais tr&egrave;s peut de bases de donn&eacute;es
     offrent ce type de chiffrement.
    </simpara>
    <simpara>
     Le moyen le plus simple pour contourner ce probl&egrave;me est de cr&eacute;er votre
     propre logiciel de chiffrement, et de l'utiliser dans vos scripts &php;.
     &php; peut vous aider dans cette t&acirc;che gr&acirc;ce aux nombreuses extensions
     dont il dispose, comme par exemple 
     <link linkend="ref.mcrypt">Mcrypt</link> et 
     <link linkend="ref.mhash">Mhash</link>, qui connaissent un large &eacute;ventail
     de m&eacute;thodes de chiffrement. Le script &php; va chiffrer les donn&eacute;es qui seront
     stock&eacute;es, et les d&eacute;chiffrer losrqu'elles seront relues. Voyez la suite
     pour des exemples d'utilisation de ce chiffrement.
    </simpara>
    <simpara>
     Dans le cas de donn&eacute;es vraiment sensibles, si la repr&eacute;sentation originale
     n'est pas n&eacute;cessaire (pour affichage, ou comparaison), utiliser un
     hash est une bonne solution. L'exemple classique est le stockage de
     mots de passe dans les bases de donn&eacute;es, apr&egrave;s les avoir pass&eacute; au 
     MD5. Voyez les fonctions <function>crypt</function> et <function>md5</function>.
    </simpara>
    <example>
     <title>Utiliser un mot de passe et MD5</title>
     <programlisting role="php">
<![CDATA[
// Stockage du mot de passe hash&eacute;
$query  = sprintf("INSERT INTO users(name,pwd) VALUES('%s','%s');",
            addslashes($username), md5($password));
$result = pg_exec($connection, $query);

// interroger le serveur pour comparer le mot de passe soumis
$query = sprintf("SELECT 1 FROM users WHERE name='%s' AND pwd='%s';",
            addslashes($username), md5($password));
$result = pg_exec($connection, $query);

if (pg_numrows($result) > 0) {
    echo "Bienvenue, $username!";
}
else {
    echo "Identification &eacute;chou&eacute;e pour $username.";
}
]]>
     </programlisting>
    </example>
   </sect2>

   <sect2 id="security.database.sql-injection">
    <title>Injection SQL</title>
    <simpara>
     De nombreux d&eacute;veloppeurs web ne sont pas conscients des possibilit&eacute;s
     de manipulation des requ&ecirc;tes SQL, et supposent que les requ&ecirc;tes SQL
     sont des commandes s&ucirc;res. Cela signifie qu'une requ&ecirc;te SQL est 
     capable de contourner les contr&ocirc;les et v&eacute;rifications, comme par
     exemple les identifications et authentifications, et parfois, les requ&ecirc;tes
     SQL ont acc&egrave;s aux commandes d'administration.
    </simpara>
    <simpara>
     L'injection SQL directe est une technique o&ugrave; un pirate modifie une requ&ecirc;te
     SQL existante pour afficher des donn&eacute;es cach&eacute;es, ou pour &eacute;craser des
     valeurs importantes, ou encore ex&eacute;cuter des commandes dangeureuses pour la
     base. Cela se fait lorsque l'appliaction prend les donn&eacute;es envoy&eacute;es par
     l'internaute, et l'utilise directement pour contruire une requ&ecirc;te SQL. Les
     exemples ci-dessous sont bas&eacute;s sur une histoire vraie, malheureusement.
    </simpara>
    <para>
     Avec le manque de v&eacute;rification des donn&eacute;es de l'internaute et la connexion
     au serveur avec des droits de super utilisateur, le pirate peut cr&eacute;er des
     utilisateurs, et cr&eacute;er un autre super utilisateur.
     <example>
      <title>
       S&eacute;paration des r&eacute;sultats en pages, et cr&eacute;er des administrateurs 
       (PostgreSQL et MySQL)
      </title>
      <programlisting role="php">
<![CDATA[
$offset = argv[0]; // Attention, aucune validation!
$query  = "SELECT id, name FROM products ORDER BY name LIMIT 20 OFFSET $offset;";
// avec PostgreSQL 
$result = pg_exec($conn, $query);
// avec MySQL
$result = mysql_query($query);
]]>
      </programlisting>
     </example>
      Un utilisateur normale clique sur les boutons 'suivant' et 'pr&eacute;c&eacute;dent',
      qui sont alors plac&eacute;s dans la variable <varname>$offset</varname>,
      encod&eacute; dans l'URL. Le script s'attend &agrave; ce que la variable 
      <varname>$offset</varname> est alors un nombre d&eacute;cimal. Cependant,
      il est possible de modifier l'URL en ajoutant une nouvelle valeur,
      au format URL, comme ceci : 
      <informalexample>
       <programlisting>
<![CDATA[
// cas de PostgreSQL
0;
insert into pg_shadow(usename,usesysid,usesuper,usecatupd,passwd)
    select 'crack', usesysid, 't','t','crack'
    from pg_shadow where usename='postgres';
--

// cas de MySQL
0;
UPDATE user SET Password=PASSWORD('crack') WHERE user='root';
FLUSH PRIVILEGES;
]]>
       </programlisting>
      </informalexample>
      Si cela arrive, le script va cr&eacute;er un nouveau super utilisateur.
      Notez que la valeur <literal>0;</literal> qui sert &agrave; terminer la requ&ecirc;te
      originale et la terminer correctement.
    </para>
    <note>
     <para>
      C'est une techinque r&eacute;pandue que de forcer l'analyseur SQL d'ignorer le
      reste de la requ&ecirc;te, en utilisant les symboles <literal>--</literal> pour
      mettre en commentaire.
     </para>
    </note>
    <para>
     Un moyen possible pour acc&eacute;der aux mots de passe est de contourner 
     la recherche de page. Ce que le pirate doit faire, c'est simplement 
     voir si une variable du formulaire est utilis&eacute;e dans la requ&ecirc;te, et 
     si elle est mal g&eacute;r&eacute;e. Ces variables peuvent avoir &eacute;t&eacute; configur&eacute;es
     dans une page pr&eacute;c&eacute;dente pour &ecirc;tre utilis&eacute;e dans les clauses 
     <literal>WHERE, ORDER BY, LIMIT</literal> et <literal>OFFSET</literal> des
     requ&ecirc;tes <literal>SELECT</literal>. Si votre base de donn&eacute;es supporte
     les commandes <literal>UNION</literal>, le pirate peut essayer d'ajouter
     une requ&ecirc;te enti&egrave;re pour lister les mots de passe dans n'importe quelle
     table. Utiliser la technique des mots de passe chiffr&eacute;s est fortement
     recommand&eacute;e.
     <example>
      <title>
       Liste d'articles ... et ajout de mot de passe
      </title>
      <programlisting role="php">
<![CDATA[
$query  = "SELECT id, name, inserted, size FROM products
                  WHERE size = '$size'
                  ORDER BY $order LIMIT $limit, $offset;";
$result = odbc_exec($conn, $query);
]]>
      </programlisting>
     </example>
     La partie statique de la requ&ecirc;te, combin&eacute;e avec une autre
     requ&ecirc;te <literal>SELECT</literal>, va r&eacute;v&eacute;ler les mots de passe : 
     <example>
      <title>R&eacute;v&eacute;lation des mots de passe</title>
      <programlisting>
<![CDATA[
'
union select '1', concat(uname||'-'||passwd) as name, '1971-01-01', '0' from usertable;
--
]]>
      </programlisting>
     </example>
     Si cette requ&ecirc;te (exploitant les <literal>'</literal> et <literal>--</literal>) 
     est affect&eacute;e &agrave; une variable utilis&eacute;e dans 
     <varname>$query</varname>, l'injection SQL va arriver.
    </para>
    <para>
     Les commandes <literal>UPDATE</literal> sont aussi sujettes &agrave; des
     attaques de votre base de donn&eacute;es. Ces requ&ecirc;tes peuvent aussi introduite
     toute une nouvelle requ&ecirc;te dans votre commande initiale. Mais en plus,
     le pirate peut jouer sur la commande <literal>SET</literal>. Dans ce cas,
     il doit connaitre un peu votre base de donn&eacute;es. Cela peut se deviner
     en examinant les noms de variables dans les formulaires, ou simplement,
     en testant les cas les plus classiques. Il n'y a pas beaucoup de conventions
     de nommage pour stocker des noms d'utilisateur et des mots de passe.
     <example>
     <title>Modifier un mot de passe ... et gain de droits!</title>
      <programlisting role="php">
<![CDATA[
$query = "UPDATE usertable SET pwd='$pwd' WHERE uid='$uid';";
]]>
      </programlisting>
     </example>
     Mais un internaute fourbe peut envoyer une valeur telle que
     <literal>' or uid like'%admin%'; --</literal> dans <varname>$uid</varname>
     pour modifier le mot de passe utilisateur, ou simplement, utiliser la variable
     <varname>$pwd</varname> avec la valeur 
     <literal>"hehehe', admin='yes', trusted=100 "</literal> (avec l'espace final) pour
     obtenir des droist suppl&eacute;mentaires. La requ&ecirc;te sera alors devenue : 
     <example>
     <title>Une requ&ecirc;te et son injection</title>
      <programlisting role="php">
<![CDATA[
// $uid == ' or uid like'%admin%'; --
$query = "UPDATE usertable SET pwd='...' WHERE uid='' or uid like '%admin%'; --";

// $pwd == "hehehe', admin='yes', trusted=100 "
$query = "UPDATE usertable SET pwd='hehehe', admin='yes', trusted=100 WHERE ...;"
]]>
      </programlisting>
     </example>
    </para>
    <para>
     C'est un exemple terrible d'acquisition de droits d'administrateur sur un
     serveur de base de donn&eacute;es.
     <example>
     <title>Attaque d'un serveur de base de donn&eacute;es (MSSQL Server)</title>
      <programlisting role="php">
<![CDATA[
$query  = "SELECT * FROM products WHERE id LIKE '%$prod%'";
$result = mssql_query($query);
]]>
      </programlisting>
     </example>
     Si le pirate injecte la valeur 
     <literal>a%' exec master..xp_cmdshell 'net user test testpass /ADD' --</literal>
     dans la variable <varname>$prod</varname>, alors la requ&ecirc;te <varname>$query</varname> 
     devient : 
     <example>
     <title>Attaque d'un serveur de base de donn&eacute;es (MSSQL Server) - 2</title>
      <programlisting role="php">
<![CDATA[
$query  = "SELECT * FROM products
                    WHERE id LIKE '%a%'
                    exec master..xp_cmdshell 'net user test testpass /ADD'--";
$result = mssql_query($query);
]]>
      </programlisting>
     </example>
     MSSQL Server ex&eacute;cute les requ&ecirc;tes SQL en lot, y compris la commande 
     d'ajout d'un nouvel utilisateur &agrave; la base de donn&eacute;es locale. Si cette
     application fonctionnait en tant que <literal>sa</literal> et que le service
     MSSQLSERVER disposait de niveau de droits suffisant, le pirate dispose d&eacute;sormais
     d'un compte avec acc&egrave;s au serveur.
    </para>
    <note>
     <para>
      Certains des exemples ci-dessus sont sp&eacute;cifiques &agrave; certains serveurs de
      bbase de donn&eacute;es. Cela n'emp&ecirc;che pas des attaques similaires d'&ecirc;tre possibles
      sur d'autres produites. Votre base de donn&eacute;es sera alors vuln&eacute;rable d'une autre
      mani&egrave;re.
     </para>
    </note>

    <sect3 id="security.database.avoiding">
     <title>Techniques de contournement</title>
     <simpara>
      Vous pouvez pr&eacute;tendre que le pirate doit d'abord obtenir des informations
      sur le sch&eacute;ma de la base de donn&eacute;es, dans la plus part des cas d'injections.
      C'est vrai, mais vous ne saurez jamais comment ni quand ces informations
      auront filtr&eacute;s, et si cela arrive, votre base de donn&eacute;es sera en grand
      danger. Si vous utilisez une base de donn&eacute;es Open Srouce, ou une 
      base qui est du domaine publique, ou encore un sch&eacute;ma qui appartient
      &agrave; un syst&egrave;me de gestion de contenu ou d'un forum, le pirate peut facilement
      se procurer une copie du code que vous utilisez. Cela peut &ecirc;tre un
      risque potentiel si la base a &eacute;t&eacute; mal con&ccedil;ue.
     </simpara>
     <simpara>
      Ces attaques sont g&eacute;n&eacute;ralement bas&eacute;es sur l'exploitation de code qui
      n'est pas &eacute;crit de mani&egrave;re s&eacute;curitaire. N'ayez aucune confiance dans
      les donn&eacute;es qui proviennent de l'utilisateur, m&ecirc;me si cela provient d'un
      menu d&eacute;roulant, d'un champs cach&eacute; ou d'un cookie. Le premier exemple montre
      comment une requ&ecirc;te peut causer un d&eacute;sastre.
     </simpara>
     <itemizedlist>
      <listitem>
       <simpara>
        Ne nous connectez jamais sur une ase de donn&eacute;es en tant que super utilisateur
        ou propri&eacute;taire de la base. Utilisez toujours un utilisateur adapt&eacute;, avec
        des droits tr&egrave;s limit&eacute;s.
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        V&eacute;rifiez que les donn&eacute;es ont bien le type attendu. &php; dispose
        d'un &eacute;ventail de fonction de validation large, depuis les plus
        simples, de la section <link linkend="ref.variables">Variables</link> et
        la section <link linkend="ref.ctype">Caract&egrave;res</link>
        (e.g. <function>is_numeric</function>, <function>ctype_digit</function>
        respectivement) aux fonctions avanc&eacute;es de
        <link linkend="ref.pcre">Expression r&eacute;guli&egrave;re Perl</link>.
       </simpara>
      </listitem>
      <listitem>
       <para>
        Si l'application attend une entr&eacute;e num&eacute;rique, v&eacute;rifiez vos donn&eacute;es
        avec la fonction <function>is_numeric</function>, ou bien modifiez
        automatiquement le type avec la fonction <function>settype</function>, 
        ou encore avec <function>sprintf</function>.
        <example>
         <title>Une navigation de fiches plus s&eacute;curitaire</title>
         <programlisting role="php">
<![CDATA[
settype($offset, 'integer');
$query = "SELECT id, name FROM products ORDER BY name LIMIT 20 OFFSET $offset;";

// notez que %d dans la cha&icirc;ne de format : %s serait inutile
$query = sprintf("SELECT id, name FROM products ORDER BY name LIMIT 20 OFFSET %d;",
                 $offset);
]]>
         </programlisting>
        </example>
       </para>
      </listitem>
      <listitem>
       <simpara>
        Mettez entre guillemet toutes les valeurs non num&eacute;riques qui sont
        pass&eacute;es &agrave; la base de donn&eacute;es, et prot&eacute;gez-vous des guillemets dans
        les valeurs avec la fonction <function>addslashes</function> ou 
        <function>addcslashes</function>. Voyez 
        <link linkend="security.database.storage">le premier exemple</link>.
        Comme les exemples l'on montr&eacute;, les guillemets statiques peuvent
        &ecirc;tre facilement contourn&eacute;s.
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        N'affichez jamais d'information sp&eacute;cifique &agrave; la base, et notamment
        des informations concernant le sch&eacute;ma. Voyez aussi la section
        <link linkend="security.errors">Rapport d'erreur</link> et le chapitre
        <link linkend="ref.errorfunc">Gestion des erreurs</link>.
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        Vous pouvez avoir des proc&eacute;dures stock&eacute;es et des curseurs pr&eacute;d&eacute;finis qui
        font que les utilisateurs n'ont pas un acc&egrave;s direct aux tables ou vues,
        mais cette solution a d'autres impacts.
       </simpara>
      </listitem>
     </itemizedlist>

     <simpara>
      A cot&eacute; de ces conseils, il est recommand&eacute; d'enregistrer vos requ&ecirc;tes soit dans
      vos scripts soit dans la base elle m&ecirc;me, si elle le supporte. Evidemment,
      cet enregistrement ne sera pas capable d'emp&ecirc;cher une attaque, mais vous
      permettra de retrouver la requ&ecirc;te qui a faut&eacute;. L'historique n'est pas tr&egrave;s utile 
      par lui m&ecirc;me, mais au niveau des informations qu'il contient. Plus vous
      avez de d&eacute;tails, mieux c'est.
     </simpara>
    </sect3>
   </sect2>
  </sect1>
  <sect1 id="security.errors">
   <title>Rapport d'erreurs</title>
   <para>
     En terme de s&eacute;curit&eacute;, il y a deux cons&eacute;quence au rapport d'erreur.
     D'un cot&eacute;, cela am&eacute;liore la s&eacute;curit&eacute;, 
     mais d'un autre, cela la r&eacute;duit aussi.
   </para>
   <para>
    Une tactique d'attaque standard consiste &agrave; faire faire des erreurs
    au syst&egrave;me, et lire les variables d'environnement et de contexte qui
    sont retourn&eacute;es. Cela permet au pirate de lire de nombreuses
    informations sur le serveur, et de d&eacute;tecter des faiblesses du serveur.
    Par exemple, si un intrus a glan&eacute; des informations sur votre page, avec
    une premi&egrave;re utilisation de votre site, il peut essayer de remplacer les
    variables par ses propres valeurs :
    <example>
     <title>Attacque de site avec une page HTML personnalis&eacute;e</title>
     <programlisting role="php">
<![CDATA[
<form method="post" action="http://www.site.cible.com/?username=badfoo&amp;password=badfoo">
<input type="hidden" name="username" value="badfoo">
<input type="hidden" name="password" value="badfoo">
</form>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Les erreurs PHP qui sont normalement retourn&eacute;es peuvent &ecirc;tre
    tr&egrave;s pratiques pour un d&eacute;veloppeur qui essaie de d&eacute;bugger un
    script, car elles donnent de pr&eacute;cieux renseignements tels que
    quelle fonction a &eacute;chou&eacute;, quel fichier n'a pas &eacute;t&eacute;
    trouv&eacute;, quel script PHP a bugg&eacute;, et quelle ligne est en faute. Toutes
    ces informations sont exploitables. Il est commun aux d&eacute;veloppeurs PHP
    d'utiliser les fonctions <function>show_source</function>,
    <function>highlight_string</function>, ou <function>highlight_file</function>
    comme outils de d&eacute;buggage, mais sur un site en production, cela expose
    des variables cach&eacute;es, des syntaxes non v&eacute;rifi&eacute;es
    ou d'autres informations critiques. Il est particuli&egrave;rement dangeureux
    d'ex&eacute;cuter du code de sources connues, avec les gestionnaires de
    d&eacute;buggage. Si l'intrus peut comprendre votre technique habituelle
    d'utilisation, il peut tenter une attaque frontale sur une page, en
    envoyant des cha&icirc;nes de d&eacute;buggage :
    <example>
     <title>Exploiter des variables classiques de d&eacute;buggage</title>
     <programlisting role="php">
<![CDATA[
<form method="post" action="http://www.site.cible.com/?errors=Y&amp;showerrors=1"&amp;debug=1">
<input type="hidden" name="errors" value="Y">
<input type="hidden" name="showerrors" value="1">
<input type="hidden" name="debug" value="1">
</form>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Ind&eacute;pendamment de la gestion des erreurs, la possibilit&eacute; de tester
    la gestion des erreurs d'un syst&egrave;me conduit &agrave; un trou de s&eacute;curit&eacute;,
    et la diffusion de plus d'informations sur votre syst&egrave;me.
   </para>
   <para>
    Si un pirate affiche une page <acronym>html</acronym>, et essaye de la tester (pour
    rechercher des faiblesses du syst&egrave;me), il peut d&eacute;terminer sur quel
    syst&egrave;me PHP a &eacute;t&eacute; compil&eacute;.
   </para>
   <para>
    Une erreur de fonction indique si un syst&egrave;me supporte une base de
    donn&eacute;es sp&eacute;cifique, ou bien indique comment la page a
    &eacute;t&eacute; g&eacute;n&eacute;r&eacute;e. Cela peut orienter l'intrus
    vers les ports de cette base de donn&eacute;es ou bien vers une attaque
    li&eacute;e &agrave; cette application. En envoyant des donn&eacute;es
    erron&eacute;es, par exemple, un pirate peut d&eacute;terminer l'ordre
    d'authentification dans un script (&agrave; partir des lignes d'erreurs),
    et d'essayer de les exploiter ailleurs, dans le script.
   </para>
   <para>
    Une erreur de fichier, ou une erreur g&eacute;n&eacute;rale PHP peut indiquer
    quelles sont les permissions du serveur web, ainsi que la structure
    et l'organisation des fichiers. Les gestionnaires d'erreurs utilisateurs
    peuvent aussi aggraver ce probl&egrave;me, en permettant l'exploitation facile
    d'informations pr&eacute;alablement cach&eacute;es.
   </para>
   <para>
    Il y a trois solutions majeures &agrave; ces probl&egrave;mes : la premi&egrave;re
    est de scruter toutes les fonctions, et d'essayer de traiter toutes les
    erreurs. La deuxi&egrave;me est d'inactiver le rapport d'erreur, d&egrave;s
    que le script est en production. La troisi&egrave;me est d'utiliser les
    fonctions de gestions des erreurs. Suivant votre politique de
    s&eacute;curit&eacute;, vous pouvez utiliser un panachage savant des
    trois m&eacute;thodes.
   </para>
   <para>
    Une m&eacute;thode pour gagner du temps est d'utiliser la fonction
    <function>error_reporting</function>, pour vous aider &agrave;
    s&eacute;curiser le code, et d&eacute;tecter les utilisations dangeureuses de variables.
    Vous testez votre code en b&eacute;ta-test avec la valeur <constant>E_ALL</constant>,
    et vous pouvez rapidement rep&eacute;rer les variables qui ne sont pas
    prot&eacute;g&eacute;es. Une fois que le code est pr&ecirc;t &agrave; &ecirc;tre d&eacute;ploy&eacute;,
    utilisez la constante <constant>E_NONE</constant>, pour isoler
    votre code.
    <example>
     <title>D&eacute;tecter des variables non prot&eacute;g&eacute;es avec E_ALL</title>
     <programlisting role="php">
<![CDATA[
<?php
  if ($username) {
// Non initialis&eacute;e, ou v&eacute;rif&eacute;e avant utilisation
    $good_login = 1;
  }
  if ($good_login == 1) {
// Si le test ci-dessus &eacute;choue, les valeurs n'ont pas &eacute;t&eacute; test&eacute;es
    fpassthru ("/donn&eacute;es/tr&egrave;s/tr&egrave;s/sensibles/index.html");
  }
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect1>
  <sect1 id="security.registerglobals">
   <title>Utilisation des variables super-globales</title>
   <para>
    Une fonctionnalit&eacute; de PHP qui peut &ecirc;tre utilis&eacute;e pour
    am&eacute;liorer la s&eacute;curit&eacute; est de configurer PHP en inactivant l'option
    <link linkend="ini.register-globals">register_globals</link>.
    En supprimant la possibilit&eacute; que les variables envoy&eacute;es
    par les internautes soient inject&eacute;es automatiquement dans
    le script PHP, vous pouvez restreindre la quantit&eacute; de
    variables non-prot&eacute;g&eacute;es.  Les intrus devront prendre beaucoup plus
    de temps pour corrompre les m&eacute;canismes d'envoi de donn&eacute;es,
    et vos variables internes seront nettement mieux prot&eacute;g&eacute;es.
   </para>
   <para>
    Bien que cela augmente d'autant les efforts &agrave; fournir pour
    &eacute;crire un script PHP, les b&eacute;n&eacute;fices peuvent en &ecirc;tre
    nettement plus interessants.
    <example>
     <title>Travailler avec register_globals actif</title>
     <programlisting role="php">
<![CDATA[
<?php
  if ($username) {
// attention, cette valeur peut &ecirc;tre parasit&eacute;e via GET/POST/COOKIES
    $good_login = 1;
  }
if ($good_login == 1) {
// attention, cette valeur peut &ecirc;tre parasit&eacute;e via GET/POST/COOKIES
    fpassthru ("/donn&eacute;es/tr&egrave;s/tr&egrave;s/sensibles/index.html");
}
?>
]]>
     </programlisting>
    </example>
    <example>
     <title>Travailler avec register_globals actif</title>
     <programlisting role="php">
<![CDATA[
<?php
  if($HTTP_COOKIE_VARS["username"]){
// ne peut provenir que d'un cookie, corrompu ou pas
    $good_login = 1;
// Impossible &agrave; parasiter
    fpassthru ("/donn&eacute;es/tr&egrave;s/tr&egrave;s/sensibles/index.html");
  }
?>
]]>
     </programlisting>
    </example>
    En utilisant intelligemment ceci, il est m&ecirc;me possible
    de d&eacute;tecter les tentatives de corruption. Si vous savez &agrave; l'avance
    d'o&ugrave; la variable doit venir (GET ou POST ou COOKIE), vous pouvez
    tester les donn&eacute;es. M&ecirc;me si cela ne vous garantit pas contre
    la corruption de ces donn&eacute;es, cela impose aux pirates de bien
    savoir comment corrompre les donn&eacute;es.
    <example>
     <title>D&eacute;tection de corruption de variables</title>
     <programlisting role="php">
<![CDATA[
<?php
  if ($HTTP_COOKIE_VARS['username'] &amp;&amp;
      !$HTTP_POST_VARS['username'] &amp;&amp;
      !$HTTP_GET_VARS['username'] ) {
    // D'autres v&eacute;rifications pour v&eacute;rifier l'origine du nom d'utilisateur fourni
    $good_login = 1;
    fpassthru ("/donn&eacute;es/tr&egrave;s/tr&egrave;s/sensibles/index.html");
  } else {
   mail("admin@example.com", "Tentative de piratage", $HTTP_SERVER_VARS['REMOTE_ADDR']);
   echo "Probl&egrave;me de s&eacute;curit&eacute;, l'administrateur est alert&eacute;.";
   exit;
  }
?>
]]>
     </programlisting>
    </example>
    Bien entendu, inactiver l'option register_globals ne signifie pas
    que votre code devient ouvert &agrave; tous. Mais il faut aussi
    v&eacute;rifier toutes les donn&eacute;es qui vous sont fournies par les
    utilisateurs, et plut&ocirc;t deux fois qu'une.
   </para>
  </sect1>
  <sect1 id="security.variables">
   <title>Donn&eacute;es transmises par les internautes</title>
   <para>
    Les plus grandes faiblesses de nombreux programmes PHP ne viennent pas
    du langage lui-m&ecirc;me, mais de son utilisation en omettant les
    caract&eacute;ristiques de s&eacute;curit&eacute;. Pour cette raison,
    vous devez toujours prendre le temps de prendre en compte les implications
    d'une fonction, et de cerner toutes les applications d'une utilisation exotiques
    des param&egrave;tres.
    <example>
     <title>Utilisation dangereuse de variables</title>
     <programlisting role="php">
<![CDATA[
<?php
// efface un fichier &agrave; la racine d'un utilisateur... ou peut &ecirc;tre
// de quelqu'un d'autre?
  unlink($evil_var);
// Note l'acc&egrave;s de ce fichier ... ou pas?
  fputs($fp, $evil_var);
// Ex&eacute;cute une commande triviale... ou ajoute une entr&eacute;e dans /etc/password ?
  system($evil_var);
  exec($evil_var);
?>
]]>
     </programlisting>
    </example>
    Il est vivement recommand&eacute; d'examiner minutieusement votre code
    pour vous assurer qu'il n'y a pas de variables envoy&eacute;es par le
    client web, et qui ne sont pas suffisamment v&eacute;rifi&eacute;es avant utilisation.
    <itemizedlist>
     <listitem>
      <simpara>
       Est-ce que ce script n'affectera que les fichiers pr&eacute;vus?
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Est-il possible que des valeurs incoh&eacute;rentes soient exploit&eacute;es ici?
      </simpara>
     </listitem>
     <listitem>
     <simpara>
       Est-ce que ce script peut &ecirc;tre utilis&eacute; dans un but diff&eacute;rent?
       </simpara>
     </listitem>
     <listitem>
      <simpara>
       Est-ce que ce script peut &ecirc;tre utilis&eacute; malicieusement,
       en conjonction avec d'autres?
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Est-ce que toutes les actions seront not&eacute;es?
      </simpara>
     </listitem>
    </itemizedlist>
    En r&eacute;pondant de mani&egrave;re ad&eacute;quate &agrave; ces questions
    lors de l'&eacute;criture de vos scripts (plut&ocirc;t qu'apr&egrave;s), vous
    &eacute;viterez une r&eacute;&eacute;criture inopportune pour raison de
    s&eacute;curit&eacute;. En commen&ccedil;ant vos projets avec ces recommandations
    en t&ecirc;te, vous ne garantirez pas la s&eacute;curit&eacute; de votre
    syst&egrave;me, mais vous contribuerez &agrave; l'am&eacute;liorer.
   </para>
   <para>
    Vous pouvez aussi envisager de supprimer l'acquisition automatique des
    variables d'environnement, les guillemets magiques (magic_quotes),
    ou encore toute option qui pourrait vous conduire &agrave; m&eacute;s&eacute;valuer
    la validit&eacute;, la source ou la valeur d'une variable. En travaillant avec
    error_reporting(E_ALL), vous pouvez &ecirc;tre averti que certaines variables
    sont utilis&eacute;es avant d'&ecirc;tre exploit&eacute;es, ou
    v&eacute;rifi&eacute;es (et donc, vous pourrez traiter des valeurs exotiques
    &agrave; la source).
   </para>
  </sect1>
  <sect1 id="security.hiding">
   <title>Masquer PHP</title>
   <para>
    Quelques astuces permettent de masquer PHP, et cela entrave les
    pirates qui recherchent des faiblesses dans votre syst&egrave;me. En
    inactivant l'option expose_php dans votre fichier &php.ini;,
    vous pouvez r&eacute;duire la quantit&eacute; d'informations disponible.
   </para>
   <para>
    Une autre astuce est de configurer le serveur web, comme Apache,
    pour qu'il utilise plusieurs types de fichiers diff&eacute;rents avec PHP,
    soit localement avec le fichier <filename>.htaccess</filename>, soit
    dans le fichier de configuration lui-m&ecirc;me. Vous pouvez utiliser des
    informations d&eacute;routantes comme ceci :
    <example>
     <title>Masquer PHP avec un autre langage</title>
     <programlisting role="php">
// Faire que le code PHP ressemble &agrave; un autre type
AddType application/x-httpd-php .asp .py .pl
     </programlisting>
    </example>
    Ou masquez le compl&egrave;tement :
    <example>
     <title>Masquer PHP avec des types inconnus</title>
     <programlisting role="php">
// Faire que le code PHP ressemble &agrave; un autre langage qui n'existe pas
AddType application/x-httpd-php .bop .foo .133t
     </programlisting>
    </example>
    Ou encore, cachez le sous forme de html. Cela a un l&eacute;g&egrave;r impact n&eacute;gatif
    sur les performances g&eacute;n&eacute;rales, car tous les fichiers HTML seront aussi
    analys&eacute;s et trait&eacute;s par le moteur PHP :
    <example>
     <title>Utiliser le type html pour les extensions PHP</title>
     <programlisting role="php">
// Faire que le code PHP ressemble &agrave; du html
AddType application/x-httpd-php .htm .html
     </programlisting>
    </example>
    Pour que cela fonctionne efficacement, pensez &agrave; renommer tous vos
    fichiers avec les extensions ci-dessus. M&ecirc;me si c'est une forme
    de s&eacute;curit&eacute; du non-dit, c'est une mesure de pr&eacute;vention mineure,
    avec peu d'inconv&eacute;nients.
    </para>
   </sect1>
  <sect1 id="security.current">
   <title>Etre &agrave; jour</title>
   <simpara>
    PHP, comme de nombreux syst&egrave;mes de grande taille, est constamment
    test&eacute; et am&eacute;lior&eacute;. Chaque nouvelle version rassemble
    des modifications majeures et mineures, aussi bien pour renforcer la
    s&eacute;curit&eacute;, que pour r&eacute;parer les probl&egrave;mes de conceptions
    de configuration, et d'autres points qui peuvent affecter la s&eacute;curit&eacute;
    globale et la stabilit&eacute; de votre syst&egrave;me.
   </simpara>
   <simpara>
    Comme les autres langages de scripts syst&egrave;mes, la meilleure approche
    est de mettre &agrave; jour souvent PHP, et de rester &agrave; l'&eacute;coute
    des derni&egrave;res versions et des modifications qu'elles apportent.
   </simpara>
  </sect1>
 </chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
